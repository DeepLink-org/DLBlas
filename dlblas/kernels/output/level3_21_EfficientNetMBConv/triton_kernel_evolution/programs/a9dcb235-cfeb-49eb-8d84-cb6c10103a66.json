{"id": "a9dcb235-cfeb-49eb-8d84-cb6c10103a66", "code": "# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef depthwise_conv2d_kernel(\n    input_ptr, weight_ptr, output_ptr,\n    H, W, stride, padding, kernel_size,\n    hidden_dim, out_H, out_W, batch,\n    input_batch_stride, input_channel_stride, input_height_stride, input_width_stride,\n    weight_channel_stride, weight_height_stride, weight_width_stride,\n    output_batch_stride, output_channel_stride, output_height_stride, output_width_stride,\n    BLOCK_SIZE: tl.constexpr,\n):\n    pid = tl.program_id(0)\n    num_outputs = batch * hidden_dim * out_H * out_W\n    if pid >= num_outputs:\n        return\n\n    # Calculate output indices\n    idx = pid\n    j = idx % out_W\n    idx //= out_W\n    i = idx % out_H\n    idx //= out_H\n    c = idx % hidden_dim\n    b = idx // hidden_dim\n\n    # Initialize accumulator\n    acc = 0.0\n    # Compute convolution\n    for kh in range(kernel_size):\n        for kw in range(kernel_size):\n            in_i = i * stride + kh - padding\n            in_j = j * stride + kw - padding\n            if in_i >= 0 and in_i < H and in_j >= 0 and in_j < W:\n                input_offset = (b * input_batch_stride + \n                               c * input_channel_stride + \n                               in_i * input_height_stride + \n                               in_j * input_width_stride)\n                weight_offset = (c * weight_channel_stride + \n                                kh * weight_height_stride + \n                                kw * weight_width_stride)\n                x = tl.load(input_ptr + input_offset)\n                w = tl.load(weight_ptr + weight_offset)\n                acc += x * w\n\n    # Store result\n    output_offset = (b * output_batch_stride + \n                    c * output_channel_stride + \n                    i * output_height_stride + \n                    j * output_width_stride)\n    tl.store(output_ptr + output_offset, acc)\n\ndef depthwise_conv2d_triton(input, weight, stride, padding, kernel_size):\n    batch, hidden_dim, H, W = input.shape\n    out_H = (H + 2 * padding - kernel_size) // stride + 1\n    out_W = (W + 2 * padding - kernel_size) // stride + 1\n    output = torch.empty((batch, hidden_dim, out_H, out_W), \n                         device=input.device, dtype=input.dtype)\n\n    # Get strides\n    input_strides = (input.stride(0), input.stride(1), input.stride(2), input.stride(3))\n    weight_strides = (weight.stride(0), weight.stride(1), weight.stride(2))\n    output_strides = (output.stride(0), output.stride(1), output.stride(2), output.stride(3))\n\n    # Launch kernel\n    total_ops = batch * hidden_dim * out_H * out_W\n    grid = lambda meta: (triton.cdiv(total_ops, meta['BLOCK_SIZE']),)\n    depthwise_conv2d_kernel[grid](\n        input, weight, output,\n        H, W, stride, padding, kernel_size,\n        hidden_dim, out_H, out_W, batch,\n        *input_strides,\n        *weight_strides,\n        *output_strides,\n        BLOCK_SIZE=1024\n    )\n    return output\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_channels, out_channels, kernel_size, stride, expand_ratio):\n        super(ModelNew, self).__init__()\n        self.use_residual = (stride == 1 and in_channels == out_channels)\n        hidden_dim = in_channels * expand_ratio\n        self.stride = stride\n        self.padding = (kernel_size - 1) // 2\n        self.kernel_size = kernel_size\n        \n        if expand_ratio != 1:\n            self.expand_conv = nn.Sequential(\n                nn.Conv2d(in_channels, hidden_dim, kernel_size=1, stride=1, padding=0, bias=False),\n                nn.BatchNorm2d(hidden_dim),\n                nn.ReLU6(inplace=True)\n            )\n        \n        # Depthwise components\n        self.depthwise_weight = nn.Parameter(\n            torch.empty(hidden_dim, 1, kernel_size, kernel_size)\n        )\n        self.depthwise_bn = nn.BatchNorm2d(hidden_dim)\n        self.depthwise_relu = nn.ReLU6(inplace=True)\n        \n        self.project_conv = nn.Sequential(\n            nn.Conv2d(hidden_dim, out_channels, kernel_size=1, stride=1, padding=0, bias=False),\n            nn.BatchNorm2d(out_channels)\n        )\n    \n    def forward(self, x):\n        identity = x\n        \n        if hasattr(self, 'expand_conv'):\n            x = self.expand_conv(x)\n        \n        # Triton depthwise convolution\n        x = depthwise_conv2d_triton(\n            x, self.depthwise_weight, \n            self.stride, self.padding, self.kernel_size\n        )\n        x = self.depthwise_bn(x)\n        x = self.depthwise_relu(x)\n        \n        x = self.project_conv(x)\n        \n        if self.use_residual:\n            x += identity\n        \n        return x\n\n# Test code\nbatch_size = 10\nin_channels = 112\nout_channels = 192\nkernel_size = 5\nstride = 2\nexpand_ratio = 6\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_channels, 224, 224)]\n\ndef get_init_inputs():\n    return [in_channels, out_channels, kernel_size, stride, expand_ratio]\n# =================== EVOLVE-BLOCK-END ===================", "language": "python", "parent_id": "47d7b57d-9383-485d-a57c-572cb8c6e790", "generation": 1, "timestamp": 1754586269.3958628, "iteration_found": 0, "metrics": {"compiled": true, "correctness": false, "score": 10, "stage": "wrong_answer", "verify_payload": {"id": "level3_21_EfficientNetMBConv", "result": {"compiled": true, "correctness": false, "metadata": {"hardware": "NVIDIA L20Y", "device": "cuda:1", "max_difference": ["8.624508", "10.053205", "9.901541", "8.273981", "9.627108"], "avg_difference": ["1.111688", "1.091982", "1.095623", "1.127319", "1.091670"], "correctness_issue": "Output mismatch", "correctness_trials": "(0 / 5)", "reference_timing_ms": 0.223, "speed_up": -1.0, "custom_timing": -1.0}, "runtime": -1.0, "runtime_stats": {}}}}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": true, "correctness": true, "stage": "reference code", "passed": false, "score": 0.0, "speed_up": 1.0, "runtime_ms": 6.58, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:5", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.223, "speed_up": 0.034, "custom_timing": 6.58}}, "island": 1}, "artifacts_json": null, "artifact_dir": null}