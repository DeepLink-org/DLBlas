{"id": "a1fa0261-9718-4ea1-89e7-12d4ede372af", "code": "# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport math\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef _fused_attention_kernel(\n    Q, K, V, O,\n    stride_qz, stride_qh, stride_qm, stride_qk,\n    stride_kz, stride_kh, stride_kn, stride_kk,\n    stride_vz, stride_vh, stride_vn, stride_vk,\n    stride_oz, stride_oh, stride_om, stride_ok,\n    scale,\n    seq_len_q, seq_len_k, head_size,\n    BLOCK_M: tl.constexpr, BLOCK_N: tl.constexpr, BLOCK_HEAD: tl.constexpr,\n):\n    pid_m = tl.program_id(0)\n    pid_batch_head = tl.program_id(1)\n    \n    start_m = pid_m * BLOCK_M\n    offs_m = start_m + tl.arange(0, BLOCK_M)\n    offs_n = tl.arange(0, BLOCK_N)\n    offs_d = tl.arange(0, BLOCK_HEAD)\n    \n    q_ptrs = Q + pid_batch_head * stride_qz + (offs_m[:, None] * stride_qm + offs_d[None, :] * stride_qk)\n    k_ptrs = K + pid_batch_head * stride_kz + (offs_n[:, None] * stride_kn + offs_d[None, :] * stride_kk)\n    v_ptrs = V + pid_batch_head * stride_vz + (offs_n[:, None] * stride_vn + offs_d[None, :] * stride_vk)\n    o_ptrs = O + pid_batch_head * stride_oz + (offs_m[:, None] * stride_om + offs_d[None, :] * stride_ok)\n    \n    mask_m = offs_m < seq_len_q\n    mask_n = offs_n < seq_len_k\n    \n    q = tl.load(q_ptrs, mask=mask_m[:, None] & (offs_d[None, :] < head_size), other=0.0)\n    q = (q * scale).to(q.dtype)\n    \n    m_i = tl.zeros([BLOCK_M], dtype=tl.float32) - float(\"inf\")\n    l_i = tl.zeros([BLOCK_M], dtype=tl.float32)\n    acc = tl.zeros([BLOCK_M, BLOCK_HEAD], dtype=tl.float32)\n    \n    for start_n in range(0, seq_len_k, BLOCK_N):\n        start_n = tl.multiple_of(start_n, BLOCK_N)\n        \n        k = tl.load(k_ptrs + start_n * stride_kn, mask=(start_n + offs_n)[:, None] < seq_len_k, other=0.0)\n        s = tl.dot(q, tl.trans(k))\n        \n        if start_n + BLOCK_N > start_m:\n            causal_mask = (start_m + offs_m[:, None]) >= (start_n + offs_n[None, :])\n            s = tl.where(causal_mask, s, float(\"-inf\"))\n        \n        m_ij = tl.max(s, 1)\n        p = tl.exp(s - m_ij[:, None])\n        l_ij = tl.sum(p, 1)\n        \n        alpha = tl.exp(m_i - m_ij)\n        l_i = l_i * alpha + l_ij\n        \n        p = p.to(q.dtype)\n        v = tl.load(v_ptrs + start_n * stride_vn, mask=(start_n + offs_n)[:, None] < seq_len_k, other=0.0)\n        pv = tl.dot(p, v)\n        \n        acc = acc * alpha[:, None] + pv\n        m_i = m_ij\n    \n    acc = acc / l_i[:, None]\n    tl.store(o_ptrs, acc.to(O.dtype.element_ty), mask=mask_m[:, None] & (offs_d[None, :] < head_size))\n\nclass NewGELU(nn.Module):\n    def __init__(self):\n        super(NewGELU, self).__init__()\n    \n    def forward(self, x):\n        return 0.5 * x * (1.0 + torch.tanh(math.sqrt(2.0 / math.pi) * (x + 0.044715 * torch.pow(x, 3.0))))\n\nclass CausalSelfAttention(nn.Module):\n    def __init__(self, n_embd, n_head, attn_pdrop, resid_pdrop, max_seqlen):\n        super().__init__()\n        assert n_embd % n_head == 0\n        self.c_attn = nn.Linear(n_embd, 3 * n_embd)\n        self.c_proj = nn.Linear(n_embd, n_embd)\n        self.attn_dropout = nn.Dropout(attn_pdrop)\n        self.resid_dropout = nn.Dropout(resid_pdrop)\n        self.n_head = n_head\n        self.n_embd = n_embd\n        self.head_size = n_embd // n_head\n\n    def forward(self, x):\n        B, T, C = x.size()\n        hs = self.head_size\n\n        q, k, v = self.c_attn(x).split(self.n_embd, dim=2)\n        q = q.view(B, T, self.n_head, hs).transpose(1, 2)\n        k = k.view(B, T, self.n_head, hs).transpose(1, 2)\n        v = v.view(B, T, self.n_head, hs).transpose(1, 2)\n\n        scale = 1.0 / math.sqrt(k.size(-1))\n        q_flat = q.contiguous().view(B * self.n_head, T, hs)\n        k_flat = k.contiguous().view(B * self.n_head, T, hs)\n        v_flat = v.contiguous().view(B * self.n_head, T, hs)\n        output_flat = torch.empty_like(q_flat)\n\n        BLOCK_M, BLOCK_N, BLOCK_HEAD = 64, 64, 128\n        grid = (triton.cdiv(T, BLOCK_M), B * self.n_head)\n        _fused_attention_kernel[grid](\n            q_flat, k_flat, v_flat, output_flat,\n            q_flat.stride(0), q_flat.stride(1), q_flat.stride(2), 1,\n            k_flat.stride(0), k_flat.stride(1), k_flat.stride(2), 1,\n            v_flat.stride(0), v_flat.stride(1), v_flat.stride(2), 1,\n            output_flat.stride(0), output_flat.stride(1), output_flat.stride(2), 1,\n            scale,\n            T, T, hs,\n            BLOCK_M, BLOCK_N, BLOCK_HEAD\n        )\n\n        y = output_flat.view(B, self.n_head, T, hs).transpose(1, 2).contiguous().view(B, T, C)\n        y = self.resid_dropout(self.c_proj(y))\n        return y\n    \nclass ModelNew(nn.Module):\n    def __init__(self, n_embd, n_head, attn_pdrop, resid_pdrop, max_seqlen):\n        super().__init__()\n        self.ln_1 = nn.LayerNorm(n_embd)\n        self.attn = CausalSelfAttention(n_embd, n_head, attn_pdrop, resid_pdrop, max_seqlen)\n        self.ln_2 = nn.LayerNorm(n_embd)\n        self.mlp = nn.ModuleDict(dict(\n            c_fc    = nn.Linear(n_embd, 4 * n_embd),\n            c_proj  = nn.Linear(4 * n_embd, n_embd),\n            act     = NewGELU(),\n            dropout = nn.Dropout(resid_pdrop),\n        ))\n        m = self.mlp\n        self.mlpf = lambda x: m.dropout(m.c_proj(m.act(m.c_fc(x)))\n\n    def forward(self, x):\n        x = x + self.attn(self.ln_1(x))\n        x = x + self.mlpf(self.ln_2(x))\n        return x\n\nbatch_size = 128\nmax_seqlen = 1024\nseq_len = 512\nn_embd = 768\nn_head = 8\nattn_pdrop = 0.0\nresid_pdrop = 0.0\n\ndef get_inputs():\n    return [torch.randn(batch_size, seq_len, n_embd)]\n\ndef get_init_inputs():\n    return [n_embd, n_head, attn_pdrop, resid_pdrop, max_seqlen]\n# =================== EVOLVE-BLOCK-END ===================", "language": "python", "parent_id": "fd5efd91-7f23-4b3f-a72a-a7fbff68729e", "generation": 2, "timestamp": 1754590395.909313, "iteration_found": 9, "metrics": {"compiled": false, "correctness": false, "score": 1, "stage": "compile_error", "compile_log": "", "exec_log": "[Child] \u7ed1\u5b9a GPU 4, torch sees 1 device(s)\n\n[Exception]\nTraceback (most recent call last):\n  File \"/cpfs01/shared/llm_kernel/hujiakai/KernelLLM/validation_api_server/code_executor.py\", line 71, in _exec_worker\n    exec(textwrap.dedent(code_src), mod.__dict__)\n  File \"<string>\", line 134\n    self.mlpf = lambda x: m.dropout(m.c_proj(m.act(m.c_fc(x)))\n                                   ^\nSyntaxError: '(' was never closed\n", "exit_code": "1"}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": false, "correctness": false, "score": -100.0, "stage": "no_valid_triton_code", "feedback": "You need to generate real and valid triton code for the core function. The key word '@triton.jit' is not found."}, "island": 1}, "artifacts_json": null, "artifact_dir": null}