{"id": "7b7cefc5-d1dc-432d-88f9-3f57787f92fe", "code": "# ================== EVOLVE-BLOCK-START ==================\nimport math\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_C': 64, 'VEC_SIZE': 4}, num_warps=4),\n        triton.Config({'BLOCK_C': 128, 'VEC_SIZE': 4}, num_warps=4),\n        triton.Config({'BLOCK_C': 64, 'VEC_SIZE': 8}, num_warps=8),\n        triton.Config({'BLOCK_C': 128, 'VEC_SIZE': 8}, num_warps=8),\n    ],\n    key=['in_channels', 'out_channels', 'kernel_volume'],\n)\n@triton.jit\ndef conv3d_kernel(\n    input_ptr, weight_ptr, bias_ptr, output_ptr,\n    in_d, in_h, in_w, out_d, out_h, out_w,\n    stride_d, stride_h, stride_w,\n    pad_d, pad_h, pad_w,\n    dil_d, dil_h, dil_w,\n    groups,\n    in_channels, out_channels, kernel_d, kernel_h, kernel_w,\n    input_bs, input_cs, input_ds, input_hs, input_ws,\n    weight_ocs, weight_ics, weight_ds, weight_hs, weight_ws,\n    output_bs, output_cs, output_ds, output_hs, output_ws,\n    kernel_volume,\n    BLOCK_C: tl.constexpr,\n    VEC_SIZE: tl.constexpr,\n):\n    pid_b = tl.program_id(0)\n    pid_spatial = tl.program_id(1)\n    batch_idx = pid_b\n    spatial_idx = pid_spatial\n\n    ow = spatial_idx % out_w\n    spatial_idx //= out_w\n    oh = spatial_idx % out_h\n    od = spatial_idx // out_h\n\n    group_idx = tl.program_id(2)\n    group_channels = out_channels // groups\n    oc_start = group_idx * group_channels\n    oc_end = oc_start + group_channels\n    ic_start = group_idx * (in_channels // groups)\n    ic_end = ic_start + (in_channels // groups)\n\n    acc_ptrs = tl.arange(0, BLOCK_C) * VEC_SIZE\n    acc = tl.zeros((BLOCK_C,), dtype=tl.float32)\n\n    for k_idx in range(0, kernel_volume, VEC_SIZE):\n        k_offsets = k_idx + tl.arange(0, VEC_SIZE)\n        k_mask = k_offsets < kernel_volume\n        kd = k_offsets // (kernel_h * kernel_w)\n        kh = (k_offsets % (kernel_h * kernel_w)) // kernel_w\n        kw = k_offsets % kernel_w\n\n        id = od * stride_d - pad_d + kd * dil_d\n        ih = oh * stride_h - pad_h + kh * dil_h\n        iw = ow * stride_w - pad_w + kw * dil_w\n\n        in_bounds = (id >= 0) & (id < in_d) & (ih >= 0) & (ih < in_h) & (iw >= 0) & (iw < in_w)\n        k_mask = k_mask & in_bounds\n\n        for ic_block in range(ic_start, ic_end, BLOCK_C):\n            ic_offsets = ic_block + tl.arange(0, BLOCK_C)\n            ic_mask = ic_offsets < ic_end\n            ic_offsets = tl.where(ic_mask, ic_offsets, 0)\n\n            input_ptrs = (\n                batch_idx * input_bs +\n                ic_offsets[:, None] * input_cs +\n                id[None, :] * input_ds +\n                ih[None, :] * input_hs +\n                iw[None, :] * input_ws\n            )\n            weight_ptrs = (\n                oc_start * weight_ocs +\n                ic_offsets[:, None] * weight_ics +\n                kd[None, :] * weight_ds +\n                kh[None, :] * weight_hs +\n                kw[None, :] * weight_ws\n            )\n\n            input_vals = tl.load(input_ptr + input_ptrs, mask=ic_mask[:, None] & k_mask[None, :], other=0.0)\n            weight_vals = tl.load(weight_ptr + weight_ptrs, mask=ic_mask[:, None] & k_mask[None, :], other=0.0)\n\n            acc += tl.sum(input_vals * weight_vals, axis=1)\n\n    if bias_ptr != 0:\n        bias_vals = tl.load(bias_ptr + oc_start + acc_ptrs, mask=oc_start + acc_ptrs < oc_end, other=0.0)\n        acc += bias_vals\n\n    output_ptrs = (\n        batch_idx * output_bs +\n        (oc_start + acc_ptrs) * output_cs +\n        od * output_ds +\n        oh * output_hs +\n        ow * output_ws\n    )\n    tl.store(output_ptr + output_ptrs, acc, mask=oc_start + acc_ptrs < oc_end)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_channels: int, out_channels: int, kernel_size: tuple, \n                 stride: tuple = (1, 1, 1), padding: tuple = (0, 0, 0), \n                 dilation: tuple = (1, 1, 1), groups: int = 1, bias: bool = False):\n        super(ModelNew, self).__init__()\n        self.in_channels = in_channels\n        self.out_channels = out_channels\n        self.kernel_size = kernel_size\n        self.stride = stride\n        self.padding = padding\n        self.dilation = dilation\n        self.groups = groups\n        \n        self.weight = nn.Parameter(torch.empty(\n            out_channels, in_channels // groups, *kernel_size\n        ))\n        if bias:\n            self.bias = nn.Parameter(torch.empty(out_channels))\n        else:\n            self.register_parameter('bias', None)\n        \n        self.reset_parameters()\n    \n    def reset_parameters(self):\n        nn.init.kaiming_uniform_(self.weight, a=math.sqrt(5))\n        if self.bias is not None:\n            fan_in, _ = nn.init._calculate_fan_in_and_fan_out(self.weight)\n            bound = 1 / math.sqrt(fan_in)\n            nn.init.uniform_(self.bias, -bound, bound)\n    \n    def forward(self, x: torch.Tensor) -> torch.Tensor:\n        B, C, D, H, W = x.shape\n        Kd, Kh, Kw = self.kernel_size\n        s_d, s_h, s_w = self.stride\n        pad_d, pad_h, pad_w = self.padding\n        dil_d, dil_h, dil_w = self.dilation\n        \n        out_d = (D + 2 * pad_d - dil_d * (Kd - 1) - 1) // s_d + 1\n        out_h = (H + 2 * pad_h - dil_h * (Kh - 1) - 1) // s_h + 1\n        out_w = (W + 2 * pad_w - dil_w * (Kw - 1) - 1) // s_w + 1\n        \n        output = torch.empty(B, self.out_channels, out_d, out_h, out_w, \n                             device=x.device, dtype=x.dtype)\n        \n        kernel_volume = Kd * Kh * Kw\n        bias_ptr = self.bias.data_ptr() if self.bias is not None else 0\n        \n        grid = (\n            B, \n            out_d * out_h * out_w,\n            self.groups\n        )\n        \n        conv3d_kernel[grid](\n            x, self.weight, bias_ptr, output,\n            D, H, W, out_d, out_h, out_w,\n            s_d, s_h, s_w,\n            pad_d, pad_h, pad_w,\n            dil_d, dil_h, dil_w,\n            self.groups,\n            self.in_channels, self.out_channels, Kd, Kh, Kw,\n            x.stride(0), x.stride(1), x.stride(2), x.stride(3), x.stride(4),\n            self.weight.stride(0), self.weight.stride(1), \n            self.weight.stride(2), self.weight.stride(3), self.weight.stride(4),\n            output.stride(0), output.stride(1), \n            output.stride(2), output.stride(3), output.stride(4),\n            kernel_volume,\n            BLOCK_C=triton.next_power_of_2(self.out_channels // self.groups),\n            VEC_SIZE=4\n        )\n        \n        return output\n\n# Test code\nbatch_size = 16\nin_channels = 3\nout_channels = 64\nkernel_size = (3, 5, 7)  # Asymmetric kernel size\ndepth = 16\nheight = 256\nwidth = 256\n\ndef get_inputs():\n    x = torch.randn(batch_size, in_channels, depth, height, width)\n    return [x]\n\ndef get_init_inputs():\n    return [in_channels, out_channels, kernel_size]  # Provide in_channels, out_channels, kernel_size for initialization\n# =================== EVOLVE-BLOCK-END ===================", "language": "python", "parent_id": "7fd8670a-6cb4-40b4-8983-36021e861d29", "generation": 1, "timestamp": 1754648177.9510007, "iteration_found": 3, "metrics": {"compiled": true, "correctness": false, "score": 10, "stage": "wrong_answer", "verify_payload": {"id": "level1_66_conv_standard_3D__asymmetric_input__asymmetric_kernel", "result": {"compiled": true, "correctness": false, "metadata": {"hardware": "NVIDIA L20Y", "device": "cuda:7", "runtime_error": "Traceback (most recent call last):\n  File \"/cpfs01/shared/llm_kernel/hujiakai/KernelLLM/validation_api_server/helpers/evaluations.py\", line 720, in run_and_check_correctness\n    output_new = model_new(*inputs)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1773, in _wrapped_call_impl\n    return self._call_impl(*args, **kwargs)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1784, in _call_impl\n    return forward_call(*args, **kwargs)\n  File \"/tmp/tmp596f3wc5.py\", line 158, in forward\n    conv3d_kernel[grid](\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 390, in <lambda>\n    return lambda *args, **kwargs: self.run(grid=grid, warmup=False, *args, **kwargs)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 239, in run\n    benchmark()\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 228, in benchmark\n    timings = {config: self._bench(*args, config=config, **kwargs) for config in pruned_configs}\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 228, in <dictcomp>\n    timings = {config: self._bench(*args, config=config, **kwargs) for config in pruned_configs}\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 135, in _bench\n    raise ValueError(f\"Conflicting meta-parameters: {', '.join(conflicts)}.\"\nValueError: Conflicting meta-parameters: VEC_SIZE, BLOCK_C. Make sure that you don't re-define auto-tuned symbols.\n", "runtime_error_name": "builtins.ValueError", "reference_timing_ms": 0.0443, "speed_up": -1.0, "custom_timing": -1.0}, "runtime": -1.0, "runtime_stats": {}}}}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": true, "correctness": true, "stage": "reference code", "passed": false, "score": 0.0, "speed_up": 1.0, "runtime_ms": 31.2, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:6", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.0443, "speed_up": 0.001, "custom_timing": 31.2}}, "island": 1}, "artifacts_json": null, "artifact_dir": null}