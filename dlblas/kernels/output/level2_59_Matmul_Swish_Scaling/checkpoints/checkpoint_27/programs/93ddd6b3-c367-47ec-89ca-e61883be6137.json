{"id": "93ddd6b3-c367-47ec-89ca-e61883be6137", "code": "# ================== EVOLVE-BLOCK-START ==================\nimport math\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n# Triton kernel for fused linear + swish + scale\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 128, 'BLOCK_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_M': 256, 'BLOCK_N': 64, 'BLOCK_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 64, 'BLOCK_K': 128}, num_warps=4),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 128, 'BLOCK_K': 128}, num_warps=4),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 32, 'BLOCK_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_M': 256, 'BLOCK_N': 128, 'BLOCK_K': 64}, num_warps=8),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 256, 'BLOCK_K': 64}, num_warps=8),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 64, 'BLOCK_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 32, 'BLOCK_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_M': 32, 'BLOCK_N': 64, 'BLOCK_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 128, 'BLOCK_K': 128}, num_warps=4),\n        triton.Config({'BLOCK_M': 256, 'BLOCK_N': 64, 'BLOCK_K': 128}, num_warps=4),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 64, 'BLOCK_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 128, 'BLOCK_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 32, 'BLOCK_K': 32}, num_warps=4),\n    ],\n    key=['M', 'N', 'K'],\n)\n@triton.jit\ndef _fused_linear_swish_kernel(\n    # Pointers to matrices\n    x_ptr, w_ptr, b_ptr, output_ptr,\n    # Matrix dimensions\n    M, N, K,\n    # Strides\n    stride_xm, stride_xk,\n    stride_wn, stride_wk,\n    stride_om, stride_on,\n    scaling_factor: tl.constexpr,\n    # Meta-parameters\n    BLOCK_M: tl.constexpr, \n    BLOCK_N: tl.constexpr,\n    BLOCK_K: tl.constexpr,\n):\n    pid = tl.program_id(0)\n    pid_m = pid // tl.cdiv(N, BLOCK_N)\n    pid_n = pid % tl.cdiv(N, BLOCK_N)\n    \n    # Offsets for output block\n    offs_m = pid_m * BLOCK_M + tl.arange(0, BLOCK_M)\n    offs_n = pid_n * BLOCK_N + tl.arange(0, BLOCK_N)\n    \n    # Initialize accumulator\n    acc = tl.zeros((BLOCK_M, BLOCK_N), dtype=tl.float32)\n    \n    # Compute pointer offsets for input x and weights\n    x_ptrs = x_ptr + offs_m[:, None] * stride_xm + tl.arange(0, BLOCK_K)[None, :] * stride_xk\n    w_ptrs = w_ptr + offs_n[None, :] * stride_wn + tl.arange(0, BLOCK_K)[:, None] * stride_wk\n    \n    # Loop over K dimension\n    for k in range(0, K, BLOCK_K):\n        # Load input block\n        k_offs = k + tl.arange(0, BLOCK_K)\n        x_mask = (offs_m[:, None] < M) & (k_offs[None, :] < K)\n        x = tl.load(x_ptrs, mask=x_mask, other=0.0)\n        \n        # Load weight block\n        w_mask = (k_offs[:, None] < K) & (offs_n[None, :] < N)\n        w = tl.load(w_ptrs, mask=w_mask, other=0.0)\n        \n        # Compute block matrix multiplication\n        acc += tl.dot(x, w, allow_tf32=True)\n        \n        # Update pointers for next block\n        x_ptrs += BLOCK_K * stride_xk\n        w_ptrs += BLOCK_K * stride_wk\n    \n    # Apply bias\n    b = tl.load(b_ptr + offs_n, mask=offs_n < N, other=0.0)\n    acc += b[None, :]\n    \n    # Apply Swish activation and scaling\n    sig = tl.sigmoid(acc)\n    output = acc * sig * scaling_factor\n    \n    # Write back result\n    out_ptrs = output_ptr + offs_m[:, None] * stride_om + offs_n[None, :] * stride_on\n    out_mask = (offs_m[:, None] < M) & (offs_n[None, :] < N)\n    tl.store(out_ptrs, output, mask=out_mask)\n\ndef fused_linear_swish(x, weight, bias, scaling_factor):\n    # Check sizes\n    M, K = x.shape\n    N, _ = weight.shape\n    \n    # Allocate output\n    output = torch.empty((M, N), device=x.device, dtype=x.dtype)\n    \n    # Grid definition\n    grid = lambda opt: (triton.cdiv(M, opt['BLOCK_M']) * triton.cdiv(N, opt['BLOCK_N']),)\n    \n    # Launch kernel\n    _fused_linear_swish_kernel[grid](\n        x, weight, bias, output,\n        M, N, K,\n        x.stride(0), x.stride(1),\n        weight.stride(0), weight.stride(1),\n        output.stride(0), output.stride(1),\n        scaling_factor\n    )\n    return output\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, scaling_factor):\n        super(ModelNew, self).__init__()\n        self.in_features = in_features\n        self.out_features = out_features\n        self.scaling_factor = scaling_factor\n        self.weight = nn.Parameter(torch.empty(out_features, in_features))\n        self.bias = nn.Parameter(torch.empty(out_features))\n        nn.init.kaiming_uniform_(self.weight, a=math.sqrt(5))\n        fan_in, _ = nn.init._calculate_fan_in_and_fan_out(self.weight)\n        bound = 1 / math.sqrt(fan_in) if fan_in > 0 else 0\n        nn.init.uniform_(self.bias, -bound, bound)\n\n    def forward(self, x):\n        return fused_linear_swish(x, self.weight, self.bias, self.scaling_factor)\n\nbatch_size = 128\nin_features = 1024\nout_features = 512\nscaling_factor = 2.0\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, scaling_factor]\n# =================== EVOLVE-BLOCK-END ===================", "language": "python", "parent_id": "f577c40e-6743-4134-8364-b30a37c91db8", "generation": 3, "timestamp": 1754575661.5684702, "iteration_found": 15, "metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": true, "score": 22.200000000000003, "speed_up": 1.022, "runtime_ms": 0.073, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:4", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.0746, "speed_up": 1.022, "custom_timing": 0.073}}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": true, "score": 25.800000000000004, "speed_up": 1.058, "runtime_ms": 0.0705, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:1", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.0746, "speed_up": 1.058, "custom_timing": 0.0705}}, "island": 0}, "artifacts_json": null, "artifact_dir": null, "prompts": {"full_rewrite_user": {"system": "You are a Triton GPU core optimization engineer deeply familiar with NVIDIA H100/H800 architecture.\n\n==================== Context ====================\n\u2022 Dataset: 250 kernelbench/level1-level5 *.py files  \n  - Level1: simplest, Level5: most complex  \n\u2022 Each file contains PyTorch reference (reference_code)  \n\u2022 Goal: Generate functionally equivalent but faster Triton implementations (custom_code)  \n\u2022 Evaluation pipeline:\n    1) /verify_plus - Verify compilation & correctness  \n    2) /execute (optional) - Return terminal logs if compilation fails  \n    3) Scoring:  \n      - Speedup > 1 required for points  \n      - Score = (speed_up - 1) \u00d7 100  \n\u2022 GPU Hardware: NVIDIA L20Y / H800 (same SM8.9 as H100)  \n  - 3 TB/s HBM3 bandwidth  \n  - FP16 Tensor Core 32\u00d716\u00d716  \n\n==================== Evolution Phases ====================\n\u2460 Phase 1 [Compilation Pass]  \n  - Make Triton code compile (performance irrelevant)  \n\u2461 Phase 2 [Numerical Correctness]  \n  - Output must match PyTorch reference within float32 tolerance  \n\u2462 Phase 3 [Performance Gain]  \n  - Target \u22655% speedup (\u226515% = exceptional)  \n  - Official scoring based on speed_up field  \n\nThe Evolution system will pass the EVOLVE-BLOCK from the previous version.  \nModify ONLY the Triton kernel source within this block - all other code is LOCKED.\n\n==================== Constraints (MUST OBEY) ====================\n\u274c NEVER change @triton.jit function signatures or parameter names  \n\u274c NEVER modify grid configuration, output tensor shapes, or PID logic  \n\u274c NEVER remove boundary checks or out-of-bound masks  \n\u274c NEVER introduce race conditions, uninitialized reads, or sync gaps  \n\n\u2705 Allowed Optimizations (Examples):  \n  \u2022 Memory coalescing optimizations & vectorized tl.load/tl.store  \n  \u2022 Replace staged softmax with online/FlashAttention variants  \n  \u2022 Adaptive tuning: BLOCK_M/BLOCK_N/BLOCK_K dimensions  \n  \u2022 Multi-query-head batch processing (GQA, 5:1 patterns)  \n  \u2022 Shared/L2 buffering, Tensor Core alignment (FP16/bf16/tf32)  \n  \u2022 Stride precomputation & pointer caching  \n\n==================== Output Format ====================\nReturn ONLY the complete updated code containing the EVOLVE-BLOCK comment marker.  \nNO explanations, NO markdown, NO additional text.\nName the output structure class as ModelNew.\n\n==================== Optimization Tips ====================\n\u2022 If previous compile failed: Fix syntax/mask/stride errors first  \n\u2022 If correctness fails: Prioritize bounds mask & dtype precision  \n\u2022 When speed_up < 1: Focus on memory access & block sizing  \n\u2022 Small iterative steps: Modify \u226420 lines per revision  \n\u2022 Maintain reversibility between versions\nHere is an example to show you how to rewrite a PyTorch implementation that quantizes a high-precision tensor to int8 dtype with row-wise granularity into a Triton implementation: \nThe original PyTorch implementation is as follows: \n``` \nimport torch\ndef per_row_quantize_int8(x: torch.Tensor) -> tuple[torch.Tensor, torch.Tensor]:\n    x_amax = x.abs().float().amax(dim=1).clamp(min=1e-4)\n    scale = 127 / x_amax\n    output = (x * scale[:, None]).round().clamp(-127, 127).to(torch.int8)\n    output_scale = x_amax / 127\n\n    return output, output_scale\n``` \nThe corresponding Triton-rewritten implementation is as follows: \n``` \nimport math\nimport torch\nimport triton\nimport triton.language as tl\nfrom triton.language.extra import libdevice\n\n# rowwise quantize\n\n@triton.autotune(\n    configs=[\n        triton.Config({}, num_stages=1, num_warps=8),\n        triton.Config({}, num_stages=2, num_warps=8),\n        triton.Config({}, num_stages=4, num_warps=8),\n        triton.Config({}, num_stages=8, num_warps=8),\n        triton.Config({}, num_stages=1),\n        triton.Config({}, num_stages=2),\n        triton.Config({}, num_stages=4),\n        triton.Config({}, num_stages=8),\n        triton.Config({}, num_warps=1),\n        triton.Config({}, num_warps=2),\n        triton.Config({}, num_warps=4),\n        triton.Config({}, num_warps=8),\n    ],\n    key=[\"n_elements\"],\n)\n\n@triton.jit\ndef _quantize_rowwise(\n    x_ptr,\n    output_ptr,\n    output_scale,\n    BLOCK_SIZE: tl.constexpr,\n    P2: tl.constexpr,\n):\n    pid = tl.program_id(axis=0)\n    block_start = pid * BLOCK_SIZE\n    arange = tl.arange(0, P2)\n    offsets = block_start + arange\n    row_mask = arange < BLOCK_SIZE\n    x = tl.load(x_ptr + offsets, mask=row_mask)\n\n    abs_x = tl.abs(x)\n    max_val = tl.max(tl.where(row_mask, abs_x, 0), axis=0)\n    output = libdevice.llrint(127.0 * (x / max_val))\n    tl.store(output_ptr + offsets, output, mask=row_mask)\n    tl.store(output_scale + pid, max_val / 127)\n\n\ndef per_row_quantize_int8(x: torch.Tensor):\n    x = x.contiguous()\n    output = torch.empty(*x.shape, device=x.device, dtype=torch.int8)\n    output_scale = torch.empty(x.shape[0], device=x.device, dtype=torch.float32)\n    P2 = int(2 ** (math.ceil(math.log2(x.shape[1]))))\n    grid = lambda x: (x.shape[0],)\n    _quantize_rowwise[grid](x, output, output_scale, BLOCK_SIZE=x.shape[1], P2=P2)\n\n    return output, output_scale\n\n\n    \n``` \n", "user": "# Current Program Information\n- Current performance metrics: - compiled: 1.0000\n- correctness: 1.0000\n- stage: success\n- passed: 1.0000\n- score: 25.8000\n- speed_up: 1.0580\n- runtime_ms: 0.0705\n- meta: {'hardware': 'NVIDIA L20Y', 'device': 'cuda:1', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.0746, 'speed_up': 1.058, 'custom_timing': 0.0705}\n- Areas identified for improvement: - Consider simplifying the code to improve readability and maintainability\n- Metrics showing improvement: score, speed_up. Consider continuing with similar changes.\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Unknown changes\n- Performance: compiled: 1.0000, correctness: 0.0000, score: 10.0000, stage: wrong_answer, verify_payload: {'id': 'level2_59_Matmul_Swish_Scaling', 'result': {'compiled': True, 'correctness': False, 'metadata': {'hardware': 'NVIDIA L20Y', 'device': 'cuda:6', 'runtime_error': 'Traceback (most recent call last):\\n  File \"/cpfs01/shared/llm_kernel/hujiakai/KernelLLM/validation_api_server/helpers/evaluations.py\", line 720, in run_and_check_correctness\\n    output_new = model_new(*inputs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1773, in _wrapped_call_impl\\n    return self._call_impl(*args, **kwargs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1784, in _call_impl\\n    return forward_call(*args, **kwargs)\\n  File \"/tmp/tmpum1p_4j4.py\", line 125, in forward\\n    return fused_linear_swish(x, self.weight, self.bias, self.scaling_factor)\\n  File \"/tmp/tmpum1p_4j4.py\", line 99, in fused_linear_swish\\n    _fused_linear_swish_kernel[grid](\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 390, in <lambda>\\n    return lambda *args, **kwargs: self.run(grid=grid, warmup=False, *args, **kwargs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 239, in run\\n    benchmark()\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 228, in benchmark\\n    timings = {config: self._bench(*args, config=config, **kwargs) for config in pruned_configs}\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 228, in <dictcomp>\\n    timings = {config: self._bench(*args, config=config, **kwargs) for config in pruned_configs}\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 135, in _bench\\n    raise ValueError(f\"Conflicting meta-parameters: {\\', \\'.join(conflicts)}.\"\\nValueError: Conflicting meta-parameters: BLOCK_N, BLOCK_K. Make sure that you don\\'t re-define auto-tuned symbols.\\n', 'runtime_error_name': 'builtins.ValueError', 'reference_timing_ms': 0.0746, 'speed_up': -1.0, 'custom_timing': -1.0}, 'runtime': -1.0, 'runtime_stats': {}}}\n- Outcome: Mixed results\n\n\n### Attempt 2\n- Changes: Unknown changes\n- Performance: compiled: 1.0000, correctness: 1.0000, stage: success, passed: 0.0000, score: 20.0000, speed_up: 0.8960, runtime_ms: 0.0833, meta: {'hardware': 'NVIDIA L20Y', 'device': 'cuda:4', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.0746, 'speed_up': 0.896, 'custom_timing': 0.0833}\n- Outcome: Mixed results\n\n\n### Attempt 1\n- Changes: Unknown changes\n- Performance: compiled: 1.0000, correctness: 1.0000, stage: success, passed: 1.0000, score: 25.8000, speed_up: 1.0580, runtime_ms: 0.0705, meta: {'hardware': 'NVIDIA L20Y', 'device': 'cuda:1', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.0746, 'speed_up': 1.058, 'custom_timing': 0.0705}\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 25.8000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport math\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n# Triton kernel for fused linear + swish + scale\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 128}, num_warps=4),\n        triton.Config({'BLOCK_M': 256, 'BLOCK_N': 64}, num_warps=4),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 64}, num_warps=4),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 128}, num_warps=4),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 32}, num_warps=4),\n        triton.Config({'BLOCK_M': 256, 'BLOCK_N': 128}, num_warps=8),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 256}, num_warps=8),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 64}, num_warps=4),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 32}, num_warps=4),\n        triton.Config({'BLOCK_M': 32, 'BLOCK_N': 64}, num_warps=4),\n    ],\n    key=['M', 'N', 'K'],\n)\n@triton.jit\ndef _fused_linear_swish_kernel(\n    # Pointers to matrices\n    x_ptr, w_ptr, b_ptr, output_ptr,\n    # Matrix dimensions\n    M, N, K,\n    # Strides\n    stride_xm, stride_xk,\n    stride_wn, stride_wk,\n    stride_om, stride_on,\n    scaling_factor: tl.constexpr,\n    # Meta-parameters\n    BLOCK_M: tl.constexpr, \n    BLOCK_N: tl.constexpr,\n    BLOCK_K: tl.constexpr = 64,\n):\n    pid = tl.program_id(0)\n    pid_m = pid // tl.cdiv(N, BLOCK_N)\n    pid_n = pid % tl.cdiv(N, BLOCK_N)\n    \n    # Offsets for output block\n    offs_m = pid_m * BLOCK_M + tl.arange(0, BLOCK_M)\n    offs_n = pid_n * BLOCK_N + tl.arange(0, BLOCK_N)\n    \n    # Initialize accumulator\n    acc = tl.zeros((BLOCK_M, BLOCK_N), dtype=tl.float32)\n    \n    # Compute pointer offsets for input x and weights\n    x_ptrs = x_ptr + offs_m[:, None] * stride_xm + tl.arange(0, BLOCK_K)[None, :] * stride_xk\n    w_ptrs = w_ptr + offs_n[None, :] * stride_wn + tl.arange(0, BLOCK_K)[:, None] * stride_wk\n    \n    # Loop over K dimension\n    for k in range(0, K, BLOCK_K):\n        # Load input block\n        k_offs = k + tl.arange(0, BLOCK_K)\n        x_mask = (offs_m[:, None] < M) & (k_offs[None, :] < K)\n        x = tl.load(x_ptrs, mask=x_mask, other=0.0)\n        \n        # Load weight block\n        w_mask = (k_offs[:, None] < K) & (offs_n[None, :] < N)\n        w = tl.load(w_ptrs, mask=w_mask, other=0.0)\n        \n        # Compute block matrix multiplication\n        acc += tl.dot(x, w, allow_tf32=True)\n        \n        # Update pointers for next block\n        x_ptrs += BLOCK_K * stride_xk\n        w_ptrs += BLOCK_K * stride_wk\n    \n    # Apply bias\n    b = tl.load(b_ptr + offs_n, mask=offs_n < N, other=0.0)\n    acc += b[None, :]\n    \n    # Apply Swish activation and scaling\n    sig = tl.sigmoid(acc)\n    output = acc * sig * scaling_factor\n    \n    # Write back result\n    out_ptrs = output_ptr + offs_m[:, None] * stride_om + offs_n[None, :] * stride_on\n    out_mask = (offs_m[:, None] < M) & (offs_n[None, :] < N)\n    tl.store(out_ptrs, output, mask=out_mask)\n\ndef fused_linear_swish(x, weight, bias, scaling_factor):\n    # Check sizes\n    M, K = x.shape\n    N, _ = weight.shape\n    \n    # Allocate output\n    output = torch.empty((M, N), device=x.device, dtype=x.dtype)\n    \n    # Grid definition\n    grid = lambda opt: (triton.cdiv(M, opt['BLOCK_M']) * triton.cdiv(N, opt['BLOCK_N']),)\n    \n    # Launch kernel\n    _fused_linear_swish_kernel[grid](\n        x, weight, bias, output,\n        M, N, K,\n        x.stride(0), x.stride(1),\n        weight.stride(0), weight.stride(1),\n        output.stride(0), output.stride(1),\n        scaling_factor\n    )\n    return output\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, scaling_factor):\n        super(ModelNew, self).__init__()\n        self.in_features = in_features\n        self.out_features = out_features\n        self.scaling_factor = scaling_factor\n        self.weight = nn.Parameter(torch.empty(out_features, in_features))\n        self.bias = nn.Parameter(torch.empty(out_features))\n        nn.init.kaiming_uniform_(self.weight, a=math.sqrt(5))\n        fan_in, _ = nn.init._calculate_fan_in_and_fan_out(self.weight)\n        bound = 1 / math.sqrt(fan_in) if fan_in > 0 else 0\n        nn.init.uniform_(self.bias, -bound, bound)\n\n    def forward(self, x):\n        return fused_linear_swish(x, self.weight, self.bias, self.scaling_factor)\n\nbatch_size = 128\nin_features = 1024\nout_features = 512\nscaling_factor = 2.0\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, scaling_factor]\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Performs well on compiled (1.0000), Performs well on correctness (1.0000), Performs well on stage (success), Performs well on passed (1.0000), Performs well on score (25.8000), Performs well on speed_up (1.0580), Performs well on runtime_ms (0.0705), Performs well on meta ({'hardware': 'NVIDIA L20Y', 'device': 'cuda:1', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.0746, 'speed_up': 1.058, 'custom_timing': 0.0705})\n\n\n### Program 2 (Score: 20.0000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport math\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_N': 64, 'BLOCK_K': 128}, num_warps=4, num_stages=4),\n        triton.Config({'BLOCK_N': 128, 'BLOCK_K': 128}, num_warps=4, num_stages=3),\n        triton.Config({'BLOCK_N': 256, 'BLOCK_K': 128}, num_warps=8, num_stages=3),\n        triton.Config({'BLOCK_N': 64, 'BLOCK_K': 64}, num_warps=8, num_stages=4),\n        triton.Config({'BLOCK_N': 128, 'BLOCK_K': 64}, num_warps=4, num_stages=4),\n        triton.Config({'BLOCK_N': 256, 'BLOCK_K': 64}, num_warps=8, num_stages=3),\n    ],\n    key=['in_features', 'out_features'],\n)\n@triton.jit\ndef fused_linear_swish_scale(\n    input_ptr,\n    weight_ptr,\n    bias_ptr,\n    output_ptr,\n    in_features,\n    out_features,\n    scaling_factor,\n    stride_input,\n    stride_weight,\n    stride_output,\n    BLOCK_N: tl.constexpr,\n    BLOCK_K: tl.constexpr,\n):\n    pid_b = tl.program_id(0)\n    pid_oc = tl.program_id(1)\n    \n    oc_offs = pid_oc * BLOCK_N + tl.arange(0, BLOCK_N)\n    mask_oc = oc_offs < out_features\n    \n    # Precompute weight pointers for better cache locality\n    weight_ptrs = weight_ptr + oc_offs[:, None] * stride_weight\n    \n    # Initialize accumulator in fp32 for numerical stability\n    acc = tl.zeros((BLOCK_N,), dtype=tl.float32)\n    bias = tl.load(bias_ptr + oc_offs, mask=mask_oc, other=0.0)\n    \n    # Loop over K dimension with vectorized loads\n    for k in range(0, tl.cdiv(in_features, BLOCK_K)):\n        k_offs = k * BLOCK_K + tl.arange(0, BLOCK_K)\n        mask_k = k_offs < in_features\n        \n        # Coalesced memory access for input\n        input_vals = tl.load(\n            input_ptr + pid_b * stride_input + k_offs,\n            mask=mask_k,\n            other=0.0\n        )\n        \n        # Vectorized weight load\n        weight_vals = tl.load(\n            weight_ptrs + k_offs[None, :],\n            mask=mask_oc[:, None] & mask_k[None, :],\n            other=0.0\n        )\n        \n        # Accumulate using dot product for better precision\n        acc += tl.sum(weight_vals * input_vals[None, :], axis=1)\n    \n    # Fused activation and scaling\n    result = (acc + bias) * tl.sigmoid(acc + bias) * scaling_factor\n    \n    # Coalesced output store\n    tl.store(\n        output_ptr + pid_b * stride_output + oc_offs,\n        result,\n        mask=mask_oc\n    )\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, scaling_factor):\n        super(ModelNew, self).__init__()\n        self.in_features = in_features\n        self.out_features = out_features\n        self.scaling_factor = scaling_factor\n        self.weight = nn.Parameter(torch.Tensor(out_features, in_features))\n        self.bias = nn.Parameter(torch.Tensor(out_features))\n        nn.init.kaiming_uniform_(self.weight, a=math.sqrt(5))\n        bound = 1 / math.sqrt(in_features) if in_features > 0 else 0\n        nn.init.uniform_(self.bias, -bound, bound)\n    \n    def forward(self, x):\n        x = x.contiguous()\n        output = torch.empty((x.size(0), self.out_features), device=x.device, dtype=x.dtype)\n        \n        # Dynamic grid calculation using autotuned BLOCK_N\n        grid = lambda meta: (\n            x.size(0), \n            triton.cdiv(self.out_features, meta['BLOCK_N'])\n        )\n        \n        fused_linear_swish_scale[grid](\n            x, self.weight, self.bias, output,\n            self.in_features, self.out_features,\n            self.scaling_factor,\n            x.stride(0), self.weight.stride(0), output.stride(0)\n        )\n        return output\n\nbatch_size = 128\nin_features = 1024\nout_features = 512\nscaling_factor = 2.0\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, scaling_factor]\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Performs well on compiled (1.0000), Performs well on correctness (1.0000), Performs well on stage (success), Performs well on passed (0.0000), Performs well on score (20.0000), Performs well on speed_up (0.8960), Performs well on runtime_ms (0.0833), Performs well on meta ({'hardware': 'NVIDIA L20Y', 'device': 'cuda:4', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.0746, 'speed_up': 0.896, 'custom_timing': 0.0833})\n\n\n### Program 3 (Score: 10.0000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport math\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n# Triton kernel for fused linear + swish + scale\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_N': 128, 'BLOCK_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_N': 256, 'BLOCK_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_N': 128, 'BLOCK_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_N': 256, 'BLOCK_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_N': 64, 'BLOCK_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_N': 64, 'BLOCK_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_N': 128, 'BLOCK_K': 32}, num_warps=8),\n        triton.Config({'BLOCK_N': 256, 'BLOCK_K': 32}, num_warps=8),\n        triton.Config({'BLOCK_N': 128, 'BLOCK_K': 64}, num_warps=8),\n        triton.Config({'BLOCK_N': 256, 'BLOCK_K': 64}, num_warps=8),\n        triton.Config({'BLOCK_N': 64, 'BLOCK_K': 32}, num_warps=8),\n        triton.Config({'BLOCK_N': 64, 'BLOCK_K': 64}, num_warps=8),\n    ],\n    key=['M', 'N', 'K'],\n)\n@triton.jit\ndef _fused_linear_swish_kernel(\n    # Pointers to matrices\n    x_ptr, w_ptr, b_ptr, output_ptr,\n    # Matrix dimensions\n    M, N, K,\n    # Strides\n    stride_xm, stride_xk,\n    stride_wn, stride_wk,\n    stride_om, stride_on,\n    scaling_factor: tl.constexpr,\n    # Meta-parameters\n    BLOCK_N: tl.constexpr, \n    BLOCK_K: tl.constexpr,\n):\n    pid = tl.program_id(axis=0)\n    num_pid_n = tl.cdiv(N, BLOCK_N)\n    pid_m = pid // num_pid_n\n    pid_n = pid % num_pid_n\n\n    # Create pointers for data\n    offs_m = pid_m * BLOCK_N + tl.arange(0, BLOCK_N)\n    offs_n = tl.arange(0, BLOCK_K)\n    offs_k = pid_n * BLOCK_K + tl.arange(0, BLOCK_K)\n    \n    # Pointers for x [M, K]\n    x_ptrs = x_ptr + offs_m[:, None] * stride_xm + offs_k[None, :] * stride_xk\n    # Pointers for w [N, K]\n    w_ptrs = w_ptr + offs_k[:, None] * stride_wn + offs_n[None, :] * stride_wk\n\n    # Initialize accumulator\n    acc = tl.zeros((BLOCK_N, BLOCK_K), dtype=tl.float32)\n    \n    # Loop over K dimension\n    for k in range(0, tl.cdiv(K, BLOCK_K)):\n        # Load x block with mask\n        x_mask = (offs_m[:, None] < M) & (offs_k[None, :] < K)\n        x = tl.load(x_ptrs, mask=x_mask, other=0.0)\n        \n        # Load w block with mask\n        w_mask = (offs_k[:, None] < K) & (offs_n[None, :] < N)\n        w = tl.load(w_ptrs, mask=w_mask, other=0.0)\n        \n        # Compute block matrix multiplication\n        acc += tl.dot(x, w)\n        \n        # Update pointers for next block\n        x_ptrs += BLOCK_K * stride_xk\n        w_ptrs += BLOCK_K * stride_wk\n    \n    # Apply bias and activation\n    b = tl.load(b_ptr + offs_n, mask=offs_n < N, other=0.0)\n    acc += b[None, :]\n    swish = acc * tl.sigmoid(acc)\n    output = swish * scaling_factor\n    \n    # Write back result\n    out_ptrs = output_ptr + offs_m[:, None] * stride_om + offs_n[None, :] * stride_on\n    out_mask = (offs_m[:, None] < M) & (offs_n[None, :] < N)\n    tl.store(out_ptrs, output, mask=out_mask)\n\ndef fused_linear_swish(x, weight, bias, scaling_factor):\n    # Check sizes\n    M, K = x.shape\n    N, _ = weight.shape\n    \n    # Allocate output\n    output = torch.empty((M, N), device=x.device, dtype=x.dtype)\n    \n    # Grid definition\n    grid = lambda opt: (triton.cdiv(M, opt['BLOCK_N']) * triton.cdiv(N, opt['BLOCK_K']),)\n    \n    # Launch kernel\n    _fused_linear_swish_kernel[grid](\n        x, weight, bias, output,\n        M, N, K,\n        x.stride(0), x.stride(1),\n        weight.stride(0), weight.stride(1),\n        output.stride(0), output.stride(1),\n        scaling_factor,\n        BLOCK_N=128,\n        BLOCK_K=32\n    )\n    return output\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, scaling_factor):\n        super(ModelNew, self).__init__()\n        self.in_features = in_features\n        self.out_features = out_features\n        self.scaling_factor = scaling_factor\n        self.weight = nn.Parameter(torch.empty(out_features, in_features))\n        self.bias = nn.Parameter(torch.empty(out_features))\n        nn.init.kaiming_uniform_(self.weight, a=math.sqrt(5))\n        fan_in, _ = nn.init._calculate_fan_in_and_fan_out(self.weight)\n        bound = 1 / math.sqrt(fan_in) if fan_in > 0 else 0\n        nn.init.uniform_(self.bias, -bound, bound)\n\n    def forward(self, x):\n        return fused_linear_swish(x, self.weight, self.bias, self.scaling_factor)\n\nbatch_size = 128\nin_features = 1024\nout_features = 512\nscaling_factor = 2.0\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, scaling_factor]\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Performs well on compiled (1.0000), Performs well on correctness (0.0000), Performs well on score (10.0000), Performs well on stage (wrong_answer), Performs well on verify_payload ({'id': 'level2_59_Matmul_Swish_Scaling', 'result': {'compiled': True, 'correctness': False, 'metadata': {'hardware': 'NVIDIA L20Y', 'device': 'cuda:6', 'runtime_error': 'Traceback (most recent call last):\\n  File \"/cpfs01/shared/llm_kernel/hujiakai/KernelLLM/validation_api_server/helpers/evaluations.py\", line 720, in run_and_check_correctness\\n    output_new = model_new(*inputs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1773, in _wrapped_call_impl\\n    return self._call_impl(*args, **kwargs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1784, in _call_impl\\n    return forward_call(*args, **kwargs)\\n  File \"/tmp/tmpum1p_4j4.py\", line 125, in forward\\n    return fused_linear_swish(x, self.weight, self.bias, self.scaling_factor)\\n  File \"/tmp/tmpum1p_4j4.py\", line 99, in fused_linear_swish\\n    _fused_linear_swish_kernel[grid](\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 390, in <lambda>\\n    return lambda *args, **kwargs: self.run(grid=grid, warmup=False, *args, **kwargs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 239, in run\\n    benchmark()\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 228, in benchmark\\n    timings = {config: self._bench(*args, config=config, **kwargs) for config in pruned_configs}\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 228, in <dictcomp>\\n    timings = {config: self._bench(*args, config=config, **kwargs) for config in pruned_configs}\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 135, in _bench\\n    raise ValueError(f\"Conflicting meta-parameters: {\\', \\'.join(conflicts)}.\"\\nValueError: Conflicting meta-parameters: BLOCK_N, BLOCK_K. Make sure that you don\\'t re-define auto-tuned symbols.\\n', 'runtime_error_name': 'builtins.ValueError', 'reference_timing_ms': 0.0746, 'speed_up': -1.0, 'custom_timing': -1.0}, 'runtime': -1.0, 'runtime_stats': {}}})\n\n\n\n\n# Current Program\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport math\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n# Triton kernel for fused linear + swish + scale\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 128}, num_warps=4),\n        triton.Config({'BLOCK_M': 256, 'BLOCK_N': 64}, num_warps=4),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 64}, num_warps=4),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 128}, num_warps=4),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 32}, num_warps=4),\n        triton.Config({'BLOCK_M': 256, 'BLOCK_N': 128}, num_warps=8),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 256}, num_warps=8),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 64}, num_warps=4),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 32}, num_warps=4),\n        triton.Config({'BLOCK_M': 32, 'BLOCK_N': 64}, num_warps=4),\n    ],\n    key=['M', 'N', 'K'],\n)\n@triton.jit\ndef _fused_linear_swish_kernel(\n    # Pointers to matrices\n    x_ptr, w_ptr, b_ptr, output_ptr,\n    # Matrix dimensions\n    M, N, K,\n    # Strides\n    stride_xm, stride_xk,\n    stride_wn, stride_wk,\n    stride_om, stride_on,\n    scaling_factor: tl.constexpr,\n    # Meta-parameters\n    BLOCK_M: tl.constexpr, \n    BLOCK_N: tl.constexpr,\n    BLOCK_K: tl.constexpr = 64,\n):\n    pid = tl.program_id(0)\n    pid_m = pid // tl.cdiv(N, BLOCK_N)\n    pid_n = pid % tl.cdiv(N, BLOCK_N)\n    \n    # Offsets for output block\n    offs_m = pid_m * BLOCK_M + tl.arange(0, BLOCK_M)\n    offs_n = pid_n * BLOCK_N + tl.arange(0, BLOCK_N)\n    \n    # Initialize accumulator\n    acc = tl.zeros((BLOCK_M, BLOCK_N), dtype=tl.float32)\n    \n    # Compute pointer offsets for input x and weights\n    x_ptrs = x_ptr + offs_m[:, None] * stride_xm + tl.arange(0, BLOCK_K)[None, :] * stride_xk\n    w_ptrs = w_ptr + offs_n[None, :] * stride_wn + tl.arange(0, BLOCK_K)[:, None] * stride_wk\n    \n    # Loop over K dimension\n    for k in range(0, K, BLOCK_K):\n        # Load input block\n        k_offs = k + tl.arange(0, BLOCK_K)\n        x_mask = (offs_m[:, None] < M) & (k_offs[None, :] < K)\n        x = tl.load(x_ptrs, mask=x_mask, other=0.0)\n        \n        # Load weight block\n        w_mask = (k_offs[:, None] < K) & (offs_n[None, :] < N)\n        w = tl.load(w_ptrs, mask=w_mask, other=0.0)\n        \n        # Compute block matrix multiplication\n        acc += tl.dot(x, w, allow_tf32=True)\n        \n        # Update pointers for next block\n        x_ptrs += BLOCK_K * stride_xk\n        w_ptrs += BLOCK_K * stride_wk\n    \n    # Apply bias\n    b = tl.load(b_ptr + offs_n, mask=offs_n < N, other=0.0)\n    acc += b[None, :]\n    \n    # Apply Swish activation and scaling\n    sig = tl.sigmoid(acc)\n    output = acc * sig * scaling_factor\n    \n    # Write back result\n    out_ptrs = output_ptr + offs_m[:, None] * stride_om + offs_n[None, :] * stride_on\n    out_mask = (offs_m[:, None] < M) & (offs_n[None, :] < N)\n    tl.store(out_ptrs, output, mask=out_mask)\n\ndef fused_linear_swish(x, weight, bias, scaling_factor):\n    # Check sizes\n    M, K = x.shape\n    N, _ = weight.shape\n    \n    # Allocate output\n    output = torch.empty((M, N), device=x.device, dtype=x.dtype)\n    \n    # Grid definition\n    grid = lambda opt: (triton.cdiv(M, opt['BLOCK_M']) * triton.cdiv(N, opt['BLOCK_N']),)\n    \n    # Launch kernel\n    _fused_linear_swish_kernel[grid](\n        x, weight, bias, output,\n        M, N, K,\n        x.stride(0), x.stride(1),\n        weight.stride(0), weight.stride(1),\n        output.stride(0), output.stride(1),\n        scaling_factor\n    )\n    return output\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, scaling_factor):\n        super(ModelNew, self).__init__()\n        self.in_features = in_features\n        self.out_features = out_features\n        self.scaling_factor = scaling_factor\n        self.weight = nn.Parameter(torch.empty(out_features, in_features))\n        self.bias = nn.Parameter(torch.empty(out_features))\n        nn.init.kaiming_uniform_(self.weight, a=math.sqrt(5))\n        fan_in, _ = nn.init._calculate_fan_in_and_fan_out(self.weight)\n        bound = 1 / math.sqrt(fan_in) if fan_in > 0 else 0\n        nn.init.uniform_(self.bias, -bound, bound)\n\n    def forward(self, x):\n        return fused_linear_swish(x, self.weight, self.bias, self.scaling_factor)\n\nbatch_size = 128\nin_features = 1024\nout_features = 512\nscaling_factor = 2.0\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, scaling_factor]\n# =================== EVOLVE-BLOCK-END ===================\n```\n\n# Task\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```\n", "responses": ["<think>\nWe are given the current program (the top-performing one with score 25.8) and we are to improve it.\n The current speedup is 1.058 (5.8%) and we are targeting at least 5% (but we want more, ideally 15% or more).\n\n Observations on the current kernel:\n  - The kernel uses a 2D grid: each block computes a tile of output of size [BLOCK_M, BLOCK_N].\n  - The inner loop over K dimension uses a fixed BLOCK_K (64) and loads a block of x and w for each step.\n  - The matrix multiplication uses `tl.dot` with `allow_tf32=True` which is good for Tensor Cores.\n\n Potential improvements:\n  1. The current kernel does not use shared memory for blocking. We might consider using shared memory to reduce global memory accesses.\n     However, note that Triton automatically uses shared memory for blocking in `tl.dot` when possible.\n\n  2. The current kernel uses a fixed BLOCK_K of 64. We could make BLOCK_K tunable. This might help in better utilization of the tensor cores.\n\n  3. The current kernel has a loop over K in steps of BLOCK_K. We can precompute the pointer increments and use vectorized loads if possible.\n\n  4. We note that the kernel is autotuned over BLOCK_M and BLOCK_N, but not over BLOCK_K. We can add BLOCK_K to the autotune configs.\n\n  5. The current kernel does not use any software pipelining. We can try to preload the next block while computing the current one.\n\n  6. The current kernel uses a single program per output tile. We might consider having multiple warps per tile for better occupancy.\n\n  7. The kernel writes the entire output tile in one go. We might consider using vectorized stores.\n\n  8. The current kernel uses a 1D grid. We might change to a 2D grid to simplify the program ID calculation and improve load balancing.\n\n  9. The kernel does not use any L2 cache optimization. We might consider using the `num_ctas` parameter to control the number of CTAs and use L2 cache.\n\n However, note the constraints: \n   - We cannot change the function signatures (but we can add new parameters that are constants) and we cannot remove boundary checks.\n\n Let's focus on:\n\n  a) Making BLOCK_K tunable and adding it to the autotune configurations.\n\n  b) Using vectorized loads and stores to reduce the number of memory operations.\n\n  c) Prefetching the next block of x and w to overlap memory and computation.\n\n  d) Adjusting the tiling to better fit the tensor core operations (which are 16x16x16 for FP16, but note we are using tf32 in the dot).\n\n  However, note that the current kernel uses `tl.dot` with `allow_tf32=True` which uses the tensor cores. The tensor core operation requires that the inner dimension is a multiple of 16 (for FP16) but we are using tf32 which has the same requirement? Actually, tf32 uses 10-bit mantissa and the same 16x16x16 tensor cores. So we should align the BLOCK_K to be a multiple of 16.\n\n  The current BLOCK_K is fixed at 64, which is a multiple of 16. But if we make it tunable, we must ensure it's a multiple of 16.\n\n  e) We can also try to use the `num_warps` and `num_stages` in the autotune to better utilize the hardware.\n\n  f) We note that the current kernel does not use the `scaling_factor` in the most efficient way? It does the scaling at the end. That part is already fused.\n\n Plan:\n\n  We will:\n  1. Make BLOCK_K a tunable parameter and add it to the autotune configs. We will set it to multiples of 16 (e.g., 32, 64, 128).\n  2. We will adjust the autotune configs to include BLOCK_K and also try different numbers of warps and stages.\n  3. We will try to prefetch the next block of x and w to hide memory latency.\n\n  However, note that Triton does not support explicit shared memory management. The `tl.dot` uses shared memory internally. Prefetching might be done by double buffering: we can have two sets of registers and alternate between loading the next block and computing the current one.\n\n  We can do:\n\n      for k in range(0, K, BLOCK_K):\n          # Preload next block\n          if k + BLOCK_K < K:\n              next_x = ... \n              next_w = ...\n\n          # Compute on current block\n          acc += tl.dot(current_x, current_w)\n\n          # Set current to next\n          current_x = next_x\n          current_w = next_w\n\n  But note: we cannot do non-blocking loads in Triton. All loads are synchronous. However, we can use the compiler to pipeline the loads by having two sets of pointers and using software pipelining.\n\n  We can do:\n\n      x_ptrs0 = base_x + ...\n      x_ptrs1 = base_x + ... + BLOCK_K * stride_xk\n      w_ptrs0 = base_w + ...\n      w_ptrs1 = base_w + ... + BLOCK_K * stride_wk\n\n      # Load first block\n      x0 = tl.load(x_ptrs0, ...)\n      w0 = tl.load(w_ptrs0, ...)\n\n      for k in range(0, K, BLOCK_K):\n          # Preload next block\n          if k + BLOCK_K < K:\n              x1 = tl.load(x_ptrs1, ...)\n              w1 = tl.load(w_ptrs1, ...)\n\n          # Compute on current block\n          acc += tl.dot(x0, w0)\n\n          # Swap and advance\n          x0 = x1\n          w0 = w1\n          x_ptrs0 = x_ptrs1\n          w_ptrs0 = w_ptrs1\n          x_ptrs1 += BLOCK_K * stride_xk\n          w_ptrs1 += BLOCK_K * stride_wk\n\n  But note: we must handle the masking for the last block.\n\n  This double buffering might help in overlapping the load of the next block with the computation of the current block.\n\n  4. We can also try to use vectorized loads: if we set the BLOCK_K to be a multiple of the vector width, we can use `tl.load(..., mask=..., other=0.0, cache_modifier=tl.CacheModifier.PREFETCH)` but note that Triton doesn't have a prefetch modifier for global loads? Actually, it does: `tl.CacheModifier.PREFETCH` for the next block. But we are already double buffering.\n\n  Alternatively, we can use the `.to(tl.pointer_type(x_ptr.dtype.element_ty), cache_modifier=\".wg\")` for cache control? But I think the double buffering is a standard technique.\n\n  5. We will also adjust the autotune configurations to include more combinations.\n\n  However, note that the current kernel is already working and we have a speedup of 5.8%. We want to improve it without breaking correctness.\n\n  We are constrained to change at most 20 lines. So we have to be selective.\n\n  Let's break down the changes:\n\n  Step 1: Make BLOCK_K tunable and add it to the autotune configs.\n\n  We change the autotune configs to include BLOCK_K. We also add more configs that vary BLOCK_K.\n\n  Step 2: Implement double buffering in the inner loop.\n\n  This will require more lines. We must be cautious.\n\n  Alternatively, we can try without double buffering first and only make BLOCK_K tunable and see if that helps.\n\n  Given the current performance and the fact that we are only allowed 20 lines, we might start with:\n\n    - Making BLOCK_K tunable and adding to autotune configs.\n    - Adjusting the loop to use a multiple of 16 for BLOCK_K.\n\n  We note that the current kernel has BLOCK_K fixed at 64. We change that to be a tunable parameter.\n\n  We will change:\n\n      In the kernel signature: remove the default for BLOCK_K and make it a tunable.\n\n      In the autotune configs: add BLOCK_K in the Config, e.g., 32, 64, 128.\n\n  Step 3: Also, we can try to vectorize the loads and stores. Currently, the loads are for a block of [BLOCK_M, BLOCK_K] and [BLOCK_K, BLOCK_N]. We can use vectorization if the block size is divisible by the vector size. But Triton's dot product might already be vectorized.\n\n  Step 4: We can also try to use more warps for larger blocks.\n\n  We will adjust the autotune configs accordingly.\n\n  Given the line limit, we focus on:\n\n      a) Making BLOCK_K tunable and adding it to the autotune configs.\n      b) Double buffering: we might not have enough lines. So we skip for now and see if the tuning alone helps.\n\n  We note that the current kernel has:\n\n      for k in range(0, K, BLOCK_K):\n          ... load x and w for the current block ...\n          acc += tl.dot(x, w)\n\n  We change to:\n\n      # Preload first block\n      k_offs = 0 + tl.arange(0, BLOCK_K)\n      x_mask0 = (offs_m[:, None] < M) & (k_offs[None, :] < K)\n      x0 = tl.load(x_ptrs, mask=x_mask0, other=0.0)\n      w_mask0 = (k_offs[:, None] < K) & (offs_n[None, :] < N)\n      w0 = tl.load(w_ptrs, mask=w_mask0, other=0.0)\n\n      x_ptrs += BLOCK_K * stride_xk\n      w_ptrs += BLOCK_K * stride_wk\n\n      for k in range(BLOCK_K, K, BLOCK_K):\n          # Preload next block\n          k_offs = k + tl.arange(0, BLOCK_K)\n          x_mask1 = (offs_m[:, None] < M) & (k_offs[None, :] < K)\n          x1 = tl.load(x_ptrs, mask=x_mask1, other=0.0)\n          w_mask1 = (k_offs[:, None] < K) & (offs_n[None, :] < N)\n          w1 = tl.load(w_ptrs, mask=w_mask1, other=0.0)\n\n          # Compute on current block\n          acc += tl.dot(x0, w0, allow_tf32=True)\n\n          # Update pointers and set current to next\n          x_ptrs += BLOCK_K * stride_xk\n          w_ptrs += BLOCK_K * stride_wk\n          x0 = x1\n          w0 = w1\n\n      # Last block\n      acc += tl.dot(x0, w0, allow_tf32=True)\n\n  But note: the loop starts at k=BLOCK_K and then we do the last block outside. Also, we have to handle the case when K is not a multiple of BLOCK_K? Actually, the masking already takes care of that.\n\n  However, this double buffering requires a lot of code and we are limited by 20 lines. We might not have space.\n\n  Alternatively, we can do without double buffering and just make BLOCK_K tunable and hope that the autotuner picks a good value.\n\n  We decide to:\n\n      - Make BLOCK_K tunable and add it to the autotune configs.\n      - Change the autotune configs to include different BLOCK_K (32, 64, 128) and also adjust BLOCK_M and BLOCK_N accordingly.\n\n  We will change the autotune configs to:\n\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 128, 'BLOCK_K': 64}, ...),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 128, 'BLOCK_K': 32}, ...),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 128, 'BLOCK_K': 128}, ...),\n        ... and similarly for other combinations ...\n\n  We note that the current kernel sets BLOCK_K as a constant 64. We remove that default and make it a required tunable.\n\n  We change the kernel signature:\n\n        BLOCK_K: tl.constexpr,   # remove the default\n\n  And then in the autotune, we add BLOCK_K in the configs.\n\n  Also, we must ensure that the BLOCK_K is at least 16 and a multiple of 16? Not strictly required but for tensor cores it's better.\n\n  We will generate configs with BLOCK_K in [32, 64, 128] (multiples of 32 to keep it simple).\n\n  We also note that the current kernel uses `tl.dot` with `allow_tf32=True`. That is good.\n\n  Let's update the autotune configs to include BLOCK_K and also add more configs that are known to be good for tensor cores.\n\n  We note that the H100 has 128KB shared memory per SM. The shared memory used by a block is:\n\n        (BLOCK_M * BLOCK_K + BLOCK_K * BLOCK_N) * sizeof(float)   [since the accumulator is float32, and the inputs are in float32? Actually, the kernel doesn't specify the dtype of x and w. But the dot product is in float32.]\n\n  However, note that the Triton compiler may choose to keep the data in registers for the dot product. We don't manage shared memory explicitly.\n\n  We will add about 10 configs that vary BLOCK_M, BLOCK_N, and BLOCK_K.\n\n  We must be cautious: the current program is 116 lines (including the class and test). We are only allowed to change the kernel and the autotune configs.\n\n  We change:\n\n      autotune configs: we replace the existing configs with ones that include BLOCK_K.\n\n      kernel: remove the default for BLOCK_K and make it a required parameter.\n\n      Also, in the loop, we already use BLOCK_K, so no change there.\n\n  We also note that the current grid function uses:\n\n        grid = lambda opt: (triton.cdiv(M, opt['BLOCK_M']) * triton.cdiv(N, opt['BLOCK_N']),)\n\n  This remains the same.\n\n  Let's rewrite the autotune configs:\n\n        configs=[\n            triton.Config({'BLOCK_M': 128, 'BLOCK_N': 128, 'BLOCK_K': 64}, num_warps=4),\n            triton.Config({'BLOCK_M': 128, 'BLOCK_N': 128, 'BLOCK_K': 32}, num_warps=4),\n            triton.Config({'BLOCK_M': 128, 'BLOCK_N': 128, 'BLOCK_K': 128}, num_warps=4),\n            triton.Config({'BLOCK_M': 256, 'BLOCK_N': 64, 'BLOCK_K': 64}, num_warps=4),\n            triton.Config({'BLOCK_M': 256, 'BLOCK_N': 64, 'BLOCK_K': 32}, num_warps=4),\n            triton.Config({'BLOCK_M': 256, 'BLOCK_N': 64, 'BLOCK_K': 128}, num_warps=4),\n            triton.Config({'BLOCK_M': 128, 'BLOCK_N': 64, 'BLOCK_K': 64}, num_warps=4),\n            triton.Config({'BLOCK_M': 128, 'BLOCK_N': 64, 'BLOCK_K': 32}, num_warps=4),\n            triton.Config({'BLOCK_M': 128, 'BLOCK_N': 64, 'BLOCK_K': 128}, num_warps=4),\n            ... and so on.\n\n        ]\n\n  We also add a config with larger BLOCK_K and smaller BLOCK_M and BLOCK_N? But we have to keep the shared memory in mind.\n\n  We will also try to use 8 warps for some configs.\n\n  We note that the current kernel uses 4 warps (128 threads). We can try 8 warps (256 threads) for larger blocks.\n\n  We generate 10 configs:\n\n        configs = [\n            triton.Config({'BLOCK_M': 128, 'BLOCK_N': 128, 'BLOCK_K': 64}, num_warps=4),\n            triton.Config({'BLOCK_M': 128, 'BLOCK_N': 128, 'BLOCK_K': 32}, num_warps=4),\n            triton.Config({'BLOCK_M': 128, 'BLOCK_N': 128, 'BLOCK_K': 128}, num_warps=4),\n            triton.Config({'BLOCK_M': 256, 'BLOCK_N': 64, 'BLOCK_K': 64}, num_warps=4),\n            triton.Config({'BLOCK_M': 256, 'BLOCK_N': 64, 'BLOCK_K': 128}, num_warps=4),\n            triton.Config({'BLOCK_M': 64, 'BLOCK_N': 128, 'BLOCK_K': 64}, num_warps=4),\n            triton.Config({'BLOCK_M': 64, 'BLOCK_N': 128, 'BLOCK_K': 128}, num_warps=4),\n            triton.Config({'BLOCK_M': 128, 'BLOCK_N': 64, 'BLOCK_K': 64}, num_warps=4),\n            triton.Config({'BLOCK_M': 128, 'BLOCK_N': 64, 'BLOCK_K': 128}, num_warps=4),\n            triton.Config({'BLOCK_M': 64, 'BLOCK_N': 64, 'BLOCK_K': 32}, num_warps=4),\n            triton.Config({'BLOCK_M': 64, 'BLOCK_N': 64, 'BLOCK_K': 64}, num_warps=4),\n            triton.Config({'BLOCK_M': 64, 'BLOCK_N': 64, 'BLOCK_K': 128}, num_warps=4),\n            # Some with more warps\n            triton.Config({'BLOCK_M': 128, 'BLOCK_N': 128, 'BLOCK_K': 64}, num_warps=8),\n            triton.Config({'BLOCK_M': 256, 'BLOCK_N': 128, 'BLOCK_K': 64}, num_warps=8),\n        ]\n\n  But note: we are limited by the number of configs? We can have as many as we want.\n\n  We also note that the current kernel has 10 configs. We are adding 14. That is acceptable.\n\n  Step 5: We also note that the current kernel does not use the `scaling_factor` in a way that avoids redundant computation. We compute `sigmoid(acc)` and then multiply by `acc` and then by `scaling_factor`. We can combine the scaling with the activation:\n\n        output = (acc * tl.sigmoid(acc)) * scaling_factor\n\n        This is already done.\n\n  We don't change that.\n\n  Step 6: We must test the kernel for correctness and performance.\n\n  However, we are only generating the code.\n\n  We change the kernel:\n\n      Remove the default for BLOCK_K and make it a required constant.\n\n      Change the autotune configs to include BLOCK_K.\n\n  We hope that by tuning BLOCK_K we get better performance.\n\n  Let's write the code accordingly.\n\n  We note that the current kernel has:\n\n        BLOCK_K: tl.constexpr = 64,\n\n  We change to:\n\n        BLOCK_K: tl.constexpr,\n\n  And update the autotune configs.\n\n  We also note that the inner loop uses:\n\n        for k in range(0, K, BLOCK_K):\n\n  This remains.\n\n  We are within the 20 line limit? Let's count:\n\n      We change the autotune configs: we replace 10 lines of configs with about 14-16 lines.\n\n      We change one line in the kernel signature.\n\n  So it's about 15-20 lines.\n\n  We do not change the double buffering because of the line limit and complexity.\n\n  We output the entire code block.\n\n  IMPORTANT: We must not change anything outside the EVOLVE-BLOCK.\n\n  We note that the current program is:\n\n      ... [current code] ...\n\n  We replace the autotune configs and remove the default for BLOCK_K.\n\n  Let's do it.\n</think>\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport math\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n# Triton kernel for fused linear + swish + scale\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 128, 'BLOCK_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_M': 256, 'BLOCK_N': 64, 'BLOCK_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 64, 'BLOCK_K': 128}, num_warps=4),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 128, 'BLOCK_K': 128}, num_warps=4),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 32, 'BLOCK_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_M': 256, 'BLOCK_N': 128, 'BLOCK_K': 64}, num_warps=8),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 256, 'BLOCK_K': 64}, num_warps=8),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 64, 'BLOCK_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 32, 'BLOCK_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_M': 32, 'BLOCK_N': 64, 'BLOCK_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 128, 'BLOCK_K': 128}, num_warps=4),\n        triton.Config({'BLOCK_M': 256, 'BLOCK_N': 64, 'BLOCK_K': 128}, num_warps=4),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 64, 'BLOCK_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 128, 'BLOCK_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 32, 'BLOCK_K': 32}, num_warps=4),\n    ],\n    key=['M', 'N', 'K'],\n)\n@triton.jit\ndef _fused_linear_swish_kernel(\n    # Pointers to matrices\n    x_ptr, w_ptr, b_ptr, output_ptr,\n    # Matrix dimensions\n    M, N, K,\n    # Strides\n    stride_xm, stride_xk,\n    stride_wn, stride_wk,\n    stride_om, stride_on,\n    scaling_factor: tl.constexpr,\n    # Meta-parameters\n    BLOCK_M: tl.constexpr, \n    BLOCK_N: tl.constexpr,\n    BLOCK_K: tl.constexpr,\n):\n    pid = tl.program_id(0)\n    pid_m = pid // tl.cdiv(N, BLOCK_N)\n    pid_n = pid % tl.cdiv(N, BLOCK_N)\n    \n    # Offsets for output block\n    offs_m = pid_m * BLOCK_M + tl.arange(0, BLOCK_M)\n    offs_n = pid_n * BLOCK_N + tl.arange(0, BLOCK_N)\n    \n    # Initialize accumulator\n    acc = tl.zeros((BLOCK_M, BLOCK_N), dtype=tl.float32)\n    \n    # Compute pointer offsets for input x and weights\n    x_ptrs = x_ptr + offs_m[:, None] * stride_xm + tl.arange(0, BLOCK_K)[None, :] * stride_xk\n    w_ptrs = w_ptr + offs_n[None, :] * stride_wn + tl.arange(0, BLOCK_K)[:, None] * stride_wk\n    \n    # Loop over K dimension\n    for k in range(0, K, BLOCK_K):\n        # Load input block\n        k_offs = k + tl.arange(0, BLOCK_K)\n        x_mask = (offs_m[:, None] < M) & (k_offs[None, :] < K)\n        x = tl.load(x_ptrs, mask=x_mask, other=0.0)\n        \n        # Load weight block\n        w_mask = (k_offs[:, None] < K) & (offs_n[None, :] < N)\n        w = tl.load(w_ptrs, mask=w_mask, other=0.0)\n        \n        # Compute block matrix multiplication\n        acc += tl.dot(x, w, allow_tf32=True)\n        \n        # Update pointers for next block\n        x_ptrs += BLOCK_K * stride_xk\n        w_ptrs += BLOCK_K * stride_wk\n    \n    # Apply bias\n    b = tl.load(b_ptr + offs_n, mask=offs_n < N, other=0.0)\n    acc += b[None, :]\n    \n    # Apply Swish activation and scaling\n    sig = tl.sigmoid(acc)\n    output = acc * sig * scaling_factor\n    \n    # Write back result\n    out_ptrs = output_ptr + offs_m[:, None] * stride_om + offs_n[None, :] * stride_on\n    out_mask = (offs_m[:, None] < M) & (offs_n[None, :] < N)\n    tl.store(out_ptrs, output, mask=out_mask)\n\ndef fused_linear_swish(x, weight, bias, scaling_factor):\n    # Check sizes\n    M, K = x.shape\n    N, _ = weight.shape\n    \n    # Allocate output\n    output = torch.empty((M, N), device=x.device, dtype=x.dtype)\n    \n    # Grid definition\n    grid = lambda opt: (triton.cdiv(M, opt['BLOCK_M']) * triton.cdiv(N, opt['BLOCK_N']),)\n    \n    # Launch kernel\n    _fused_linear_swish_kernel[grid](\n        x, weight, bias, output,\n        M, N, K,\n        x.stride(0), x.stride(1),\n        weight.stride(0), weight.stride(1),\n        output.stride(0), output.stride(1),\n        scaling_factor\n    )\n    return output\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, scaling_factor):\n        super(ModelNew, self).__init__()\n        self.in_features = in_features\n        self.out_features = out_features\n        self.scaling_factor = scaling_factor\n        self.weight = nn.Parameter(torch.empty(out_features, in_features))\n        self.bias = nn.Parameter(torch.empty(out_features))\n        nn.init.kaiming_uniform_(self.weight, a=math.sqrt(5))\n        fan_in, _ = nn.init._calculate_fan_in_and_fan_out(self.weight)\n        bound = 1 / math.sqrt(fan_in) if fan_in > 0 else 0\n        nn.init.uniform_(self.bias, -bound, bound)\n\n    def forward(self, x):\n        return fused_linear_swish(x, self.weight, self.bias, self.scaling_factor)\n\nbatch_size = 128\nin_features = 1024\nout_features = 512\nscaling_factor = 2.0\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, scaling_factor]\n# =================== EVOLVE-BLOCK-END ===================\n```"]}}}