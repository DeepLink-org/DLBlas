{"id": "52e5b5c2-6a92-40f2-a9af-96b4ddaa1993", "code": "# ================== EVOLVE-BLOCK-START ==================\nimport math\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n# Triton kernel for fused linear + swish + scale\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 128, 'BLOCK_K': 32}, num_warps=4, num_stages=3),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 128, 'BLOCK_K': 64}, num_warps=4, num_stages=3),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 128, 'BLOCK_K': 128}, num_warps=4, num_stages=3),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 128, 'BLOCK_K': 32}, num_warps=4, num_stages=3),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 128, 'BLOCK_K': 64}, num_warps=4, num_stages=3),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 64, 'BLOCK_K': 32}, num_warps=4, num_stages=3),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 64, 'BLOCK_K': 64}, num_warps=4, num_stages=3),\n        triton.Config({'BLOCK_M': 256, 'BLOCK_N': 64, 'BLOCK_K': 32}, num_warps=4, num_stages=3),\n        triton.Config({'BLOCK_M': 256, 'BLOCK_N': 64, 'BLOCK_K': 64}, num_warps=4, num_stages=3),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 256, 'BLOCK_K': 32}, num_warps=8, num_stages=3),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 256, 'BLOCK_K': 64}, num_warps=8, num_stages=3),\n        triton.Config({'BLOCK_M': 256, 'BLOCK_N': 128, 'BLOCK_K': 32}, num_warps=8, num_stages=3),\n        triton.Config({'BLOCK_M': 256, 'BLOCK_N': 128, 'BLOCK_K': 64}, num_warps=8, num_stages=3),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 256, 'BLOCK_K': 32}, num_warps=8, num_stages=3),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 256, 'BLOCK_K': 64}, num_warps=8, num_stages=3),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 64, 'BLOCK_K': 32}, num_warps=4, num_stages=4),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 64, 'BLOCK_K': 64}, num_warps=4, num_stages=4),\n        triton.Config({'BLOCK_M': 32, 'BLOCK_N': 64, 'BLOCK_K': 32}, num_warps=4, num_stages=4),\n        triton.Config({'BLOCK_M': 32, 'BLOCK_N': 64, 'BLOCK_K': 64}, num_warps=4, num_stages=4),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 32, 'BLOCK_K': 32}, num_warps=4, num_stages=4),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 32, 'BLOCK_K': 64}, num_warps=4, num_stages=4),\n    ],\n    key=['M', 'N', 'K'],\n)\n@triton.jit\ndef _fused_linear_swish_kernel(\n    # Pointers to matrices\n    x_ptr, w_ptr, b_ptr, output_ptr,\n    # Matrix dimensions\n    M, N, K,\n    # Strides\n    stride_xm, stride_xk,\n    stride_wn, stride_wk,\n    stride_om, stride_on,\n    scaling_factor: tl.constexpr,\n    # Meta-parameters\n    BLOCK_M: tl.constexpr, \n    BLOCK_N: tl.constexpr,\n    BLOCK_K: tl.constexpr,\n):\n    pid = tl.program_id(0)\n    pid_m = pid // tl.cdiv(N, BLOCK_N)\n    pid_n = pid % tl.cdiv(N, BLOCK_N)\n    \n    # Offsets for output block\n    offs_m = pid_m * BLOCK_M + tl.arange(0, BLOCK_M)\n    offs_n = pid_n * BLOCK_N + tl.arange(0, BLOCK_N)\n    \n    # Initialize accumulator\n    acc = tl.zeros((BLOCK_M, BLOCK_N), dtype=tl.float32)\n    \n    # Compute pointer offsets for input x and weights\n    x_ptrs = x_ptr + offs_m[:, None] * stride_xm + tl.arange(0, BLOCK_K)[None, :] * stride_xk\n    w_ptrs = w_ptr + offs_n[None, :] * stride_wn + tl.arange(0, BLOCK_K)[:, None] * stride_wk\n    \n    # Loop over K dimension\n    for k in range(0, K, BLOCK_K):\n        # Load input block\n        k_offs = k + tl.arange(0, BLOCK_K)\n        x_mask = (offs_m[:, None] < M) & (k_offs[None, :] < K)\n        x = tl.load(x_ptrs, mask=x_mask, other=0.0)\n        \n        # Load weight block\n        w_mask = (k_offs[:, None] < K) & (offs_n[None, :] < N)\n        w = tl.load(w_ptrs, mask=w_mask, other=0.0)\n        \n        # Compute block matrix multiplication\n        acc += tl.dot(x, w, allow_tf32=True)\n        \n        # Update pointers for next block\n        x_ptrs += BLOCK_K * stride_xk\n        w_ptrs += BLOCK_K * stride_wk\n    \n    # Apply bias\n    b = tl.load(b_ptr + offs_n, mask=offs_n < N, other=0.0)\n    acc += b[None, :]\n    \n    # Apply Swish activation and scaling\n    sig = tl.sigmoid(acc)\n    output = acc * sig * scaling_factor\n    \n    # Write back result\n    out_ptrs = output_ptr + offs_m[:, None] * stride_om + offs_n[None, :] * stride_on\n    out_mask = (offs_m[:, None] < M) & (offs_n[None, :] < N)\n    tl.store(out_ptrs, output, mask=out_mask)\n\ndef fused_linear_swish(x, weight, bias, scaling_factor):\n    # Check sizes\n    M, K = x.shape\n    N, _ = weight.shape\n    \n    # Allocate output\n    output = torch.empty((M, N), device=x.device, dtype=x.dtype)\n    \n    # Grid definition\n    grid = lambda opt: (triton.cdiv(M, opt['BLOCK_M']) * triton.cdiv(N, opt['BLOCK_N']),)\n    \n    # Launch kernel\n    _fused_linear_swish_kernel[grid](\n        x, weight, bias, output,\n        M, N, K,\n        x.stride(0), x.stride(1),\n        weight.stride(0), weight.stride(1),\n        output.stride(0), output.stride(1),\n        scaling_factor\n    )\n    return output\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, scaling_factor):\n        super(ModelNew, self).__init__()\n        self.in_features = in_features\n        self.out_features = out_features\n        self.scaling_factor = scaling_factor\n        self.weight = nn.Parameter(torch.empty(out_features, in_features))\n        self.bias = nn.Parameter(torch.empty(out_features))\n        nn.init.kaiming_uniform_(self.weight, a=math.sqrt(5))\n        fan_in, _ = nn.init._calculate_fan_in_and_fan_out(self.weight)\n        bound = 1 / math.sqrt(fan_in) if fan_in > 0 else 0\n        nn.init.uniform_(self.bias, -bound, bound)\n\n    def forward(self, x):\n        return fused_linear_swish(x, self.weight, self.bias, self.scaling_factor)\n\nbatch_size = 128\nin_features = 1024\nout_features = 512\nscaling_factor = 2.0\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, scaling_factor]\n# =================== EVOLVE-BLOCK-END ===================", "language": "python", "parent_id": "f577c40e-6743-4134-8364-b30a37c91db8", "generation": 3, "timestamp": 1754578265.6014318, "iteration_found": 27, "metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": true, "score": 22.200000000000003, "speed_up": 1.022, "runtime_ms": 0.073, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:2", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.0746, "speed_up": 1.022, "custom_timing": 0.073}}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": true, "score": 25.800000000000004, "speed_up": 1.058, "runtime_ms": 0.0705, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:1", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.0746, "speed_up": 1.058, "custom_timing": 0.0705}}, "island": 2}, "artifacts_json": null, "artifact_dir": null, "prompts": {"full_rewrite_user": {"system": "You are a Triton GPU core optimization engineer deeply familiar with NVIDIA H100/H800 architecture.\n\n==================== Context ====================\n\u2022 Dataset: 250 kernelbench/level1-level5 *.py files  \n  - Level1: simplest, Level5: most complex  \n\u2022 Each file contains PyTorch reference (reference_code)  \n\u2022 Goal: Generate functionally equivalent but faster Triton implementations (custom_code)  \n\u2022 Evaluation pipeline:\n    1) /verify_plus - Verify compilation & correctness  \n    2) /execute (optional) - Return terminal logs if compilation fails  \n    3) Scoring:  \n      - Speedup > 1 required for points  \n      - Score = (speed_up - 1) \u00d7 100  \n\u2022 GPU Hardware: NVIDIA L20Y / H800 (same SM8.9 as H100)  \n  - 3 TB/s HBM3 bandwidth  \n  - FP16 Tensor Core 32\u00d716\u00d716  \n\n==================== Evolution Phases ====================\n\u2460 Phase 1 [Compilation Pass]  \n  - Make Triton code compile (performance irrelevant)  \n\u2461 Phase 2 [Numerical Correctness]  \n  - Output must match PyTorch reference within float32 tolerance  \n\u2462 Phase 3 [Performance Gain]  \n  - Target \u22655% speedup (\u226515% = exceptional)  \n  - Official scoring based on speed_up field  \n\nThe Evolution system will pass the EVOLVE-BLOCK from the previous version.  \nModify ONLY the Triton kernel source within this block - all other code is LOCKED.\n\n==================== Constraints (MUST OBEY) ====================\n\u274c NEVER change @triton.jit function signatures or parameter names  \n\u274c NEVER modify grid configuration, output tensor shapes, or PID logic  \n\u274c NEVER remove boundary checks or out-of-bound masks  \n\u274c NEVER introduce race conditions, uninitialized reads, or sync gaps  \n\n\u2705 Allowed Optimizations (Examples):  \n  \u2022 Memory coalescing optimizations & vectorized tl.load/tl.store  \n  \u2022 Replace staged softmax with online/FlashAttention variants  \n  \u2022 Adaptive tuning: BLOCK_M/BLOCK_N/BLOCK_K dimensions  \n  \u2022 Multi-query-head batch processing (GQA, 5:1 patterns)  \n  \u2022 Shared/L2 buffering, Tensor Core alignment (FP16/bf16/tf32)  \n  \u2022 Stride precomputation & pointer caching  \n\n==================== Output Format ====================\nReturn ONLY the complete updated code containing the EVOLVE-BLOCK comment marker.  \nNO explanations, NO markdown, NO additional text.\nName the output structure class as ModelNew.\n\n==================== Optimization Tips ====================\n\u2022 If previous compile failed: Fix syntax/mask/stride errors first  \n\u2022 If correctness fails: Prioritize bounds mask & dtype precision  \n\u2022 When speed_up < 1: Focus on memory access & block sizing  \n\u2022 Small iterative steps: Modify \u226420 lines per revision  \n\u2022 Maintain reversibility between versions\nHere is an example to show you how to rewrite a PyTorch implementation that quantizes a high-precision tensor to int8 dtype with row-wise granularity into a Triton implementation: \nThe original PyTorch implementation is as follows: \n``` \nimport torch\ndef per_row_quantize_int8(x: torch.Tensor) -> tuple[torch.Tensor, torch.Tensor]:\n    x_amax = x.abs().float().amax(dim=1).clamp(min=1e-4)\n    scale = 127 / x_amax\n    output = (x * scale[:, None]).round().clamp(-127, 127).to(torch.int8)\n    output_scale = x_amax / 127\n\n    return output, output_scale\n``` \nThe corresponding Triton-rewritten implementation is as follows: \n``` \nimport math\nimport torch\nimport triton\nimport triton.language as tl\nfrom triton.language.extra import libdevice\n\n# rowwise quantize\n\n@triton.autotune(\n    configs=[\n        triton.Config({}, num_stages=1, num_warps=8),\n        triton.Config({}, num_stages=2, num_warps=8),\n        triton.Config({}, num_stages=4, num_warps=8),\n        triton.Config({}, num_stages=8, num_warps=8),\n        triton.Config({}, num_stages=1),\n        triton.Config({}, num_stages=2),\n        triton.Config({}, num_stages=4),\n        triton.Config({}, num_stages=8),\n        triton.Config({}, num_warps=1),\n        triton.Config({}, num_warps=2),\n        triton.Config({}, num_warps=4),\n        triton.Config({}, num_warps=8),\n    ],\n    key=[\"n_elements\"],\n)\n\n@triton.jit\ndef _quantize_rowwise(\n    x_ptr,\n    output_ptr,\n    output_scale,\n    BLOCK_SIZE: tl.constexpr,\n    P2: tl.constexpr,\n):\n    pid = tl.program_id(axis=0)\n    block_start = pid * BLOCK_SIZE\n    arange = tl.arange(0, P2)\n    offsets = block_start + arange\n    row_mask = arange < BLOCK_SIZE\n    x = tl.load(x_ptr + offsets, mask=row_mask)\n\n    abs_x = tl.abs(x)\n    max_val = tl.max(tl.where(row_mask, abs_x, 0), axis=0)\n    output = libdevice.llrint(127.0 * (x / max_val))\n    tl.store(output_ptr + offsets, output, mask=row_mask)\n    tl.store(output_scale + pid, max_val / 127)\n\n\ndef per_row_quantize_int8(x: torch.Tensor):\n    x = x.contiguous()\n    output = torch.empty(*x.shape, device=x.device, dtype=torch.int8)\n    output_scale = torch.empty(x.shape[0], device=x.device, dtype=torch.float32)\n    P2 = int(2 ** (math.ceil(math.log2(x.shape[1]))))\n    grid = lambda x: (x.shape[0],)\n    _quantize_rowwise[grid](x, output, output_scale, BLOCK_SIZE=x.shape[1], P2=P2)\n\n    return output, output_scale\n\n\n    \n``` \n", "user": "# Current Program Information\n- Current performance metrics: - compiled: 1.0000\n- correctness: 1.0000\n- stage: success\n- passed: 1.0000\n- score: 25.8000\n- speed_up: 1.0580\n- runtime_ms: 0.0705\n- meta: {'hardware': 'NVIDIA L20Y', 'device': 'cuda:1', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.0746, 'speed_up': 1.058, 'custom_timing': 0.0705}\n- Areas identified for improvement: - Consider simplifying the code to improve readability and maintainability\n- Metrics showing improvement: score, speed_up. Consider continuing with similar changes.\n- Metrics showing regression: runtime_ms. Consider reverting or revising recent changes in these areas.\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Unknown changes\n- Performance: compiled: 1.0000, correctness: 1.0000, stage: success, passed: 0.0000, score: 20.0000, speed_up: 0.9920, runtime_ms: 0.0752, meta: {'hardware': 'NVIDIA L20Y', 'device': 'cuda:4', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.0746, 'speed_up': 0.992, 'custom_timing': 0.0752}\n- Outcome: Mixed results\n\n\n### Attempt 2\n- Changes: Unknown changes\n- Performance: compiled: 1.0000, correctness: 1.0000, stage: success, passed: 0.0000, score: 20.0000, speed_up: 0.8960, runtime_ms: 0.0833, meta: {'hardware': 'NVIDIA L20Y', 'device': 'cuda:4', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.0746, 'speed_up': 0.896, 'custom_timing': 0.0833}\n- Outcome: Mixed results\n\n\n### Attempt 1\n- Changes: Unknown changes\n- Performance: compiled: 1.0000, correctness: 1.0000, stage: success, passed: 1.0000, score: 25.8000, speed_up: 1.0580, runtime_ms: 0.0705, meta: {'hardware': 'NVIDIA L20Y', 'device': 'cuda:1', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.0746, 'speed_up': 1.058, 'custom_timing': 0.0705}\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 25.8000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport math\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n# Triton kernel for fused linear + swish + scale\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 128}, num_warps=4),\n        triton.Config({'BLOCK_M': 256, 'BLOCK_N': 64}, num_warps=4),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 64}, num_warps=4),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 128}, num_warps=4),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 32}, num_warps=4),\n        triton.Config({'BLOCK_M': 256, 'BLOCK_N': 128}, num_warps=8),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 256}, num_warps=8),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 64}, num_warps=4),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 32}, num_warps=4),\n        triton.Config({'BLOCK_M': 32, 'BLOCK_N': 64}, num_warps=4),\n    ],\n    key=['M', 'N', 'K'],\n)\n@triton.jit\ndef _fused_linear_swish_kernel(\n    # Pointers to matrices\n    x_ptr, w_ptr, b_ptr, output_ptr,\n    # Matrix dimensions\n    M, N, K,\n    # Strides\n    stride_xm, stride_xk,\n    stride_wn, stride_wk,\n    stride_om, stride_on,\n    scaling_factor: tl.constexpr,\n    # Meta-parameters\n    BLOCK_M: tl.constexpr, \n    BLOCK_N: tl.constexpr,\n    BLOCK_K: tl.constexpr = 64,\n):\n    pid = tl.program_id(0)\n    pid_m = pid // tl.cdiv(N, BLOCK_N)\n    pid_n = pid % tl.cdiv(N, BLOCK_N)\n    \n    # Offsets for output block\n    offs_m = pid_m * BLOCK_M + tl.arange(0, BLOCK_M)\n    offs_n = pid_n * BLOCK_N + tl.arange(0, BLOCK_N)\n    \n    # Initialize accumulator\n    acc = tl.zeros((BLOCK_M, BLOCK_N), dtype=tl.float32)\n    \n    # Compute pointer offsets for input x and weights\n    x_ptrs = x_ptr + offs_m[:, None] * stride_xm + tl.arange(0, BLOCK_K)[None, :] * stride_xk\n    w_ptrs = w_ptr + offs_n[None, :] * stride_wn + tl.arange(0, BLOCK_K)[:, None] * stride_wk\n    \n    # Loop over K dimension\n    for k in range(0, K, BLOCK_K):\n        # Load input block\n        k_offs = k + tl.arange(0, BLOCK_K)\n        x_mask = (offs_m[:, None] < M) & (k_offs[None, :] < K)\n        x = tl.load(x_ptrs, mask=x_mask, other=0.0)\n        \n        # Load weight block\n        w_mask = (k_offs[:, None] < K) & (offs_n[None, :] < N)\n        w = tl.load(w_ptrs, mask=w_mask, other=0.0)\n        \n        # Compute block matrix multiplication\n        acc += tl.dot(x, w, allow_tf32=True)\n        \n        # Update pointers for next block\n        x_ptrs += BLOCK_K * stride_xk\n        w_ptrs += BLOCK_K * stride_wk\n    \n    # Apply bias\n    b = tl.load(b_ptr + offs_n, mask=offs_n < N, other=0.0)\n    acc += b[None, :]\n    \n    # Apply Swish activation and scaling\n    sig = tl.sigmoid(acc)\n    output = acc * sig * scaling_factor\n    \n    # Write back result\n    out_ptrs = output_ptr + offs_m[:, None] * stride_om + offs_n[None, :] * stride_on\n    out_mask = (offs_m[:, None] < M) & (offs_n[None, :] < N)\n    tl.store(out_ptrs, output, mask=out_mask)\n\ndef fused_linear_swish(x, weight, bias, scaling_factor):\n    # Check sizes\n    M, K = x.shape\n    N, _ = weight.shape\n    \n    # Allocate output\n    output = torch.empty((M, N), device=x.device, dtype=x.dtype)\n    \n    # Grid definition\n    grid = lambda opt: (triton.cdiv(M, opt['BLOCK_M']) * triton.cdiv(N, opt['BLOCK_N']),)\n    \n    # Launch kernel\n    _fused_linear_swish_kernel[grid](\n        x, weight, bias, output,\n        M, N, K,\n        x.stride(0), x.stride(1),\n        weight.stride(0), weight.stride(1),\n        output.stride(0), output.stride(1),\n        scaling_factor\n    )\n    return output\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, scaling_factor):\n        super(ModelNew, self).__init__()\n        self.in_features = in_features\n        self.out_features = out_features\n        self.scaling_factor = scaling_factor\n        self.weight = nn.Parameter(torch.empty(out_features, in_features))\n        self.bias = nn.Parameter(torch.empty(out_features))\n        nn.init.kaiming_uniform_(self.weight, a=math.sqrt(5))\n        fan_in, _ = nn.init._calculate_fan_in_and_fan_out(self.weight)\n        bound = 1 / math.sqrt(fan_in) if fan_in > 0 else 0\n        nn.init.uniform_(self.bias, -bound, bound)\n\n    def forward(self, x):\n        return fused_linear_swish(x, self.weight, self.bias, self.scaling_factor)\n\nbatch_size = 128\nin_features = 1024\nout_features = 512\nscaling_factor = 2.0\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, scaling_factor]\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Performs well on compiled (1.0000), Performs well on correctness (1.0000), Performs well on stage (success), Performs well on passed (1.0000), Performs well on score (25.8000), Performs well on speed_up (1.0580), Performs well on runtime_ms (0.0705), Performs well on meta ({'hardware': 'NVIDIA L20Y', 'device': 'cuda:1', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.0746, 'speed_up': 1.058, 'custom_timing': 0.0705})\n\n\n### Program 2 (Score: 20.0000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport math\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_N': 64, 'BLOCK_K': 128}, num_warps=4, num_stages=4),\n        triton.Config({'BLOCK_N': 128, 'BLOCK_K': 128}, num_warps=4, num_stages=3),\n        triton.Config({'BLOCK_N': 256, 'BLOCK_K': 128}, num_warps=8, num_stages=3),\n        triton.Config({'BLOCK_N': 64, 'BLOCK_K': 64}, num_warps=8, num_stages=4),\n        triton.Config({'BLOCK_N': 128, 'BLOCK_K': 64}, num_warps=4, num_stages=4),\n        triton.Config({'BLOCK_N': 256, 'BLOCK_K': 64}, num_warps=8, num_stages=3),\n    ],\n    key=['in_features', 'out_features'],\n)\n@triton.jit\ndef fused_linear_swish_scale(\n    input_ptr,\n    weight_ptr,\n    bias_ptr,\n    output_ptr,\n    in_features,\n    out_features,\n    scaling_factor,\n    stride_input,\n    stride_weight,\n    stride_output,\n    BLOCK_N: tl.constexpr,\n    BLOCK_K: tl.constexpr,\n):\n    pid_b = tl.program_id(0)\n    pid_oc = tl.program_id(1)\n    \n    oc_offs = pid_oc * BLOCK_N + tl.arange(0, BLOCK_N)\n    mask_oc = oc_offs < out_features\n    \n    # Precompute weight pointers for better cache locality\n    weight_ptrs = weight_ptr + oc_offs[:, None] * stride_weight\n    \n    # Initialize accumulator in fp32 for numerical stability\n    acc = tl.zeros((BLOCK_N,), dtype=tl.float32)\n    bias = tl.load(bias_ptr + oc_offs, mask=mask_oc, other=0.0)\n    \n    # Loop over K dimension with vectorized loads\n    for k in range(0, tl.cdiv(in_features, BLOCK_K)):\n        k_offs = k * BLOCK_K + tl.arange(0, BLOCK_K)\n        mask_k = k_offs < in_features\n        \n        # Coalesced memory access for input\n        input_vals = tl.load(\n            input_ptr + pid_b * stride_input + k_offs,\n            mask=mask_k,\n            other=0.0\n        )\n        \n        # Vectorized weight load\n        weight_vals = tl.load(\n            weight_ptrs + k_offs[None, :],\n            mask=mask_oc[:, None] & mask_k[None, :],\n            other=0.0\n        )\n        \n        # Accumulate using dot product for better precision\n        acc += tl.sum(weight_vals * input_vals[None, :], axis=1)\n    \n    # Fused activation and scaling\n    result = (acc + bias) * tl.sigmoid(acc + bias) * scaling_factor\n    \n    # Coalesced output store\n    tl.store(\n        output_ptr + pid_b * stride_output + oc_offs,\n        result,\n        mask=mask_oc\n    )\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, scaling_factor):\n        super(ModelNew, self).__init__()\n        self.in_features = in_features\n        self.out_features = out_features\n        self.scaling_factor = scaling_factor\n        self.weight = nn.Parameter(torch.Tensor(out_features, in_features))\n        self.bias = nn.Parameter(torch.Tensor(out_features))\n        nn.init.kaiming_uniform_(self.weight, a=math.sqrt(5))\n        bound = 1 / math.sqrt(in_features) if in_features > 0 else 0\n        nn.init.uniform_(self.bias, -bound, bound)\n    \n    def forward(self, x):\n        x = x.contiguous()\n        output = torch.empty((x.size(0), self.out_features), device=x.device, dtype=x.dtype)\n        \n        # Dynamic grid calculation using autotuned BLOCK_N\n        grid = lambda meta: (\n            x.size(0), \n            triton.cdiv(self.out_features, meta['BLOCK_N'])\n        )\n        \n        fused_linear_swish_scale[grid](\n            x, self.weight, self.bias, output,\n            self.in_features, self.out_features,\n            self.scaling_factor,\n            x.stride(0), self.weight.stride(0), output.stride(0)\n        )\n        return output\n\nbatch_size = 128\nin_features = 1024\nout_features = 512\nscaling_factor = 2.0\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, scaling_factor]\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Performs well on compiled (1.0000), Performs well on correctness (1.0000), Performs well on stage (success), Performs well on passed (0.0000), Performs well on score (20.0000), Performs well on speed_up (0.8960), Performs well on runtime_ms (0.0833), Performs well on meta ({'hardware': 'NVIDIA L20Y', 'device': 'cuda:4', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.0746, 'speed_up': 0.896, 'custom_timing': 0.0833})\n\n\n### Program 3 (Score: 20.0000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport math\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n# Triton kernel for fused linear + swish + scale\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 128, 'BLOCK_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_M': 256, 'BLOCK_N': 64, 'BLOCK_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 64, 'BLOCK_K': 128}, num_warps=4),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 128, 'BLOCK_K': 128}, num_warps=4),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 32, 'BLOCK_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_M': 256, 'BLOCK_N': 128, 'BLOCK_K': 64}, num_warps=8),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 256, 'BLOCK_K': 64}, num_warps=8),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 64, 'BLOCK_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 32, 'BLOCK_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_M': 32, 'BLOCK_N': 64, 'BLOCK_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 128, 'BLOCK_K': 128}, num_warps=4),\n        triton.Config({'BLOCK_M': 256, 'BLOCK_N': 64, 'BLOCK_K': 128}, num_warps=4),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 64, 'BLOCK_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 128, 'BLOCK_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 32, 'BLOCK_K': 32}, num_warps=4),\n        # New configurations optimized for problem dimensions\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 512, 'BLOCK_K': 64}, num_warps=8),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 256, 'BLOCK_K': 128}, num_warps=8),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 512, 'BLOCK_K': 128}, num_warps=8),\n    ],\n    key=['M', 'N', 'K'],\n)\n@triton.jit\ndef _fused_linear_swish_kernel(\n    # Pointers to matrices\n    x_ptr, w_ptr, b_ptr, output_ptr,\n    # Matrix dimensions\n    M, N, K,\n    # Strides\n    stride_xm, stride_xk,\n    stride_wn, stride_wk,\n    stride_om, stride_on,\n    scaling_factor: tl.constexpr,\n    # Meta-parameters\n    BLOCK_M: tl.constexpr, \n    BLOCK_N: tl.constexpr,\n    BLOCK_K: tl.constexpr,\n):\n    pid = tl.program_id(0)\n    pid_m = pid // tl.cdiv(N, BLOCK_N)\n    pid_n = pid % tl.cdiv(N, BLOCK_N)\n    \n    # Offsets for output block\n    offs_m = pid_m * BLOCK_M + tl.arange(0, BLOCK_M)\n    offs_n = pid_n * BLOCK_N + tl.arange(0, BLOCK_N)\n    \n    # Initialize accumulator\n    acc = tl.zeros((BLOCK_M, BLOCK_N), dtype=tl.float32)\n    \n    # Compute pointer offsets for input x and weights\n    x_ptrs = x_ptr + offs_m[:, None] * stride_xm + tl.arange(0, BLOCK_K)[None, :] * stride_xk\n    w_ptrs = w_ptr + offs_n[None, :] * stride_wn + tl.arange(0, BLOCK_K)[:, None] * stride_wk\n    \n    # Loop over K dimension\n    for k in range(0, K, BLOCK_K):\n        # Load input block\n        k_offs = k + tl.arange(0, BLOCK_K)\n        x_mask = (offs_m[:, None] < M) & (k_offs[None, :] < K)\n        x = tl.load(x_ptrs, mask=x_mask, other=0.0)\n        \n        # Load weight block\n        w_mask = (k_offs[:, None] < K) & (offs_n[None, :] < N)\n        w = tl.load(w_ptrs, mask=w_mask, other=0.0)\n        \n        # Compute block matrix multiplication\n        acc += tl.dot(x, w, allow_tf32=True)\n        \n        # Update pointers for next block\n        x_ptrs += BLOCK_K * stride_xk\n        w_ptrs += BLOCK_K * stride_wk\n    \n    # Apply bias\n    b = tl.load(b_ptr + offs_n, mask=offs_n < N, other=0.0)\n    acc += b[None, :]\n    \n    # Apply Swish activation and scaling\n    sig = tl.sigmoid(acc)\n    output = acc * sig * scaling_factor\n    \n    # Write back result\n    out_ptrs = output_ptr + offs_m[:, None] * stride_om + offs_n[None, :] * stride_on\n    out_mask = (offs_m[:, None] < M) & (offs_n[None, :] < N)\n    tl.store(out_ptrs, output, mask=out_mask)\n\ndef fused_linear_swish(x, weight, bias, scaling_factor):\n    # Check sizes\n    M, K = x.shape\n    N, _ = weight.shape\n    \n    # Allocate output\n    output = torch.empty((M, N), device=x.device, dtype=x.dtype)\n    \n    # Grid definition\n    grid = lambda opt: (triton.cdiv(M, opt['BLOCK_M']) * triton.cdiv(N, opt['BLOCK_N']),)\n    \n    # Launch kernel\n    _fused_linear_swish_kernel[grid](\n        x, weight, bias, output,\n        M, N, K,\n        x.stride(0), x.stride(1),\n        weight.stride(0), weight.stride(1),\n        output.stride(0), output.stride(1),\n        scaling_factor\n    )\n    return output\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, scaling_factor):\n        super(ModelNew, self).__init__()\n        self.in_features = in_features\n        self.out_features = out_features\n        self.scaling_factor = scaling_factor\n        self.weight = nn.Parameter(torch.empty(out_features, in_features))\n        self.bias = nn.Parameter(torch.empty(out_features))\n        nn.init.kaiming_uniform_(self.weight, a=math.sqrt(5))\n        fan_in, _ = nn.init._calculate_fan_in_and_fan_out(self.weight)\n        bound = 1 / math.sqrt(fan_in) if fan_in > 0 else 0\n        nn.init.uniform_(self.bias, -bound, bound)\n\n    def forward(self, x):\n        return fused_linear_swish(x, self.weight, self.bias, self.scaling_factor)\n\nbatch_size = 128\nin_features = 1024\nout_features = 512\nscaling_factor = 2.0\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, scaling_factor]\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Performs well on compiled (1.0000), Performs well on correctness (1.0000), Performs well on stage (success), Performs well on passed (0.0000), Performs well on score (20.0000), Performs well on speed_up (0.9920), Performs well on runtime_ms (0.0752), Performs well on meta ({'hardware': 'NVIDIA L20Y', 'device': 'cuda:4', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.0746, 'speed_up': 0.992, 'custom_timing': 0.0752})\n\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 20.0000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport math\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_N': 64, 'BLOCK_K': 128}, num_warps=4, num_stages=4),\n        triton.Config({'BLOCK_N': 128, 'BLOCK_K': 128}, num_warps=4, num_stages=3),\n        triton.Config({'BLOCK_N': 256, 'BLOCK_K': 128}, num_warps=8, num_stages=3),\n        triton.Config({'BLOCK_N': 64, 'BLOCK_K': 64}, num_warps=8, num_stages=4),\n        triton.Config({'BLOCK_N': 128, 'BLOCK_K': 64}, num_warps=4, num_stages=4),\n        triton.Config({'BLOCK_N': 256, 'BLOCK_K': 64}, num_warps=8, num_stages=3),\n    ],\n    key=['in_features', 'out_features'],\n)\n@triton.jit\ndef fused_linear_swish_scale(\n    input_ptr,\n    weight_ptr,\n    bias_ptr,\n    output_ptr,\n    in_features,\n    out_features,\n    scaling_factor,\n    stride_input,\n    stride_weight,\n    stride_output,\n    BLOCK_N: tl.constexpr,\n    BLOCK_K: tl.constexpr,\n):\n    pid_b = tl.program_id(0)\n    pid_oc = tl.program_id(1)\n    \n    oc_offs = pid_oc * BLOCK_N + tl.arange(0, BLOCK_N)\n    mask_oc = oc_offs < out_features\n    \n    # Vectorized accumulator initialization\n    acc = tl.zeros((BLOCK_N,), dtype=tl.float32)\n    bias = tl.load(bias_ptr + oc_offs, mask=mask_oc, other=0.0)\n    \n    # Optimized memory access with vectorization\n    for k in range(0, tl.cdiv(in_features, BLOCK_K)):\n        k_offs = k * BLOCK_K\n        cols = k_offs + tl.arange(0, BLOCK_K)\n        mask_k = cols < in_features\n        \n        # Coalesced memory access\n        input_vals = tl.load(\n            input_ptr + pid_b * stride_input + cols,\n            mask=mask_k,\n            other=0.0\n        )\n        \n        weight_vals = tl.load(\n            weight_ptr + (oc_offs[:, None] * stride_weight + cols[None, :]),\n            mask=mask_oc[:, None] & mask_k[None, :],\n            other=0.0\n        )\n        \n        # Efficient matrix multiplication\n        acc += tl.sum(weight_vals * input_vals[None, :], axis=1)\n    \n    # Fused activation and scaling\n    acc += bias\n    sig = 1.0 / (1.0 + tl.exp(-acc))\n    result = acc * sig * scaling_factor\n    \n    # Vectorized store\n    tl.store(\n        output_ptr + pid_b * stride_output + oc_offs,\n        result,\n        mask=mask_oc\n    )\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, scaling_factor):\n        super(ModelNew, self).__init__()\n        self.in_features = in_features\n        self.out_features = out_features\n        self.scaling_factor = scaling_factor\n        self.weight = nn.Parameter(torch.Tensor(out_features, in_features))\n        self.bias = nn.Parameter(torch.Tensor(out_features))\n        nn.init.kaiming_uniform_(self.weight, a=math.sqrt(5))\n        bound = 1 / math.sqrt(in_features) if in_features > 0 else 0\n        nn.init.uniform_(self.bias, -bound, bound)\n    \n    def forward(self, x):\n        x = x.contiguous()\n        output = torch.empty((x.size(0), self.out_features), device=x.device, dtype=x.dtype)\n        \n        # Use base block size for grid calculation\n        grid = (x.size(0), triton.cdiv(self.out_features, 64))\n        \n        # Launch kernel without explicit block parameters\n        fused_linear_swish_scale[grid](\n            x, self.weight, self.bias, output,\n            self.in_features, self.out_features,\n            self.scaling_factor,\n            x.stride(0), self.weight.stride(0), output.stride(0)\n        )\n        return output\n\nbatch_size = 128\nin_features = 1024\nout_features = 512\nscaling_factor = 2.0\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, scaling_factor]\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Alternative approach to compiled, Alternative approach to correctness\n\n\n### Program D2 (Score: 20.0000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport math\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n# Triton kernel for fused linear + swish + scale\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_N': 256, 'BLOCK_SIZE_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_N': 256, 'BLOCK_SIZE_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 32}, num_warps=8),\n        triton.Config({'BLOCK_SIZE_N': 256, 'BLOCK_SIZE_K': 32}, num_warps=8),\n        triton.Config({'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 64}, num_warps=8),\n        triton.Config({'BLOCK_SIZE_N': 256, 'BLOCK_SIZE_K': 64}, num_warps=8),\n        triton.Config({'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 32}, num_warps=8),\n        triton.Config({'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 64}, num_warps=8),\n    ],\n    key=['out_features', 'in_features'],\n)\n@triton.jit\ndef _fused_linear_swish_kernel(\n    # Pointers to matrices\n    x_ptr, w_ptr, b_ptr, output_ptr,\n    # Matrix dimensions\n    batch_size, in_features, out_features,\n    # Strides\n    stride_x0, stride_x1,\n    stride_w0, stride_w1,\n    stride_out0, stride_out1,\n    scaling_factor: tl.constexpr,\n    # Meta-parameters\n    BLOCK_SIZE_N: tl.constexpr, BLOCK_SIZE_K: tl.constexpr,\n):\n    # Map program ids to the block of the output they should compute.\n    pid = tl.program_id(0)\n    num_out_blocks = tl.cdiv(out_features, BLOCK_SIZE_N)\n    batch_idx = pid // num_out_blocks\n    out_block_idx = pid % num_out_blocks\n\n    # This program will compute a block of the output for the given batch index and a block of the out_features.\n    offs_out = out_block_idx * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n    offs_k = tl.arange(0, BLOCK_SIZE_K)\n\n    # Create pointers for the weight block: [BLOCK_SIZE_N, BLOCK_SIZE_K]\n    w_ptrs = w_ptr + offs_out[:, None] * stride_w0 + offs_k[None, :] * stride_w1\n\n    # Accumulator for the output block\n    acc = tl.zeros((BLOCK_SIZE_N,), dtype=tl.float32)\n\n    # Loop over the in_features dimension in blocks of BLOCK_SIZE_K\n    num_k_blocks = tl.cdiv(in_features, BLOCK_SIZE_K)\n    for k in range(0, num_k_blocks):\n        k_offs = k * BLOCK_SIZE_K\n        # Load a block of x for the current batch and the current K block.\n        x_ptrs = x_ptr + batch_idx * stride_x0 + (k_offs + offs_k) * stride_x1\n        mask_x = (k_offs + offs_k) < in_features\n        x_block = tl.load(x_ptrs, mask=mask_x, other=0.0)\n\n        # Load a block of weights for the current K block and the current out block.\n        mask_w = (offs_out[:, None] < out_features) & ((k_offs + offs_k)[None, :] < in_features)\n        w_block = tl.load(w_ptrs + k_offs * stride_w1, mask=mask_w, other=0.0)\n\n        # Compute the dot product for this block\n        acc += tl.sum(w_block * x_block[None, :], axis=1)\n\n    # Load bias for the current out block\n    b_ptrs = b_ptr + offs_out\n    mask_bias = offs_out < out_features\n    bias = tl.load(b_ptrs, mask=mask_bias, other=0.0)\n    acc += bias\n\n    # Apply Swish: acc * sigmoid(acc)\n    swish_output = acc * tl.sigmoid(acc)\n    # Scale\n    swish_output = swish_output * scaling_factor\n\n    # Write back the result\n    out_ptrs = output_ptr + batch_idx * stride_out0 + offs_out * stride_out1\n    tl.store(out_ptrs, swish_output, mask=mask_bias)\n\ndef fused_linear_swish(x, weight, bias, scaling_factor):\n    # Check sizes\n    batch, in_features = x.shape\n    out_features, _ = weight.shape\n    # Allocate output\n    output = torch.empty((batch, out_features), device=x.device, dtype=x.dtype)\n    # The grid is batch * ceil(out_features / BLOCK_SIZE_N)\n    grid = lambda meta: (batch * triton.cdiv(out_features, meta['BLOCK_SIZE_N']),)\n    # Launch kernel\n    _fused_linear_swish_kernel[grid](\n        x, weight, bias, output,\n        batch, in_features, out_features,\n        x.stride(0), x.stride(1),\n        weight.stride(0), weight.stride(1),\n        output.stride(0), output.stride(1),\n        scaling_factor\n    )\n    return output\n\nclass ModelNew(nn.Module):\n    \"\"\"\n    Simple model that performs a matrix multiplication, applies Swish activation, and scales the result.\n    Uses a fused Triton kernel for the operation.\n    \"\"\"\n    def __init__(self, in_features, out_features, scaling_factor):\n        super(ModelNew, self).__init__()\n        self.in_features = in_features\n        self.out_features = out_features\n        self.scaling_factor = scaling_factor\n        self.weight = nn.Parameter(torch.empty(out_features, in_features))\n        self.bias = nn.Parameter(torch.empty(out_features))\n        # initialize the parameters\n        nn.init.kaiming_uniform_(self.weight, a=math.sqrt(5))\n        fan_in, _ = nn.init._calculate_fan_in_and_fan_out(self.weight)\n        bound = 1 / math.sqrt(fan_in) if fan_in > 0 else 0\n        nn.init.uniform_(self.bias, -bound, bound)\n\n    def forward(self, x):\n        # We use the fused kernel\n        return fused_linear_swish(x, self.weight, self.bias, self.scaling_factor)\n\nbatch_size = 128\nin_features = 1024\nout_features = 512\nscaling_factor = 2.0\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, scaling_factor]\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Alternative approach to compiled, Alternative approach to correctness\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 20.0000, Type: High-Performer)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport math\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n# Triton kernel for fused linear + swish + scale\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_N': 256, 'BLOCK_SIZE_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_N': 256, 'BLOCK_SIZE_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 32}, num_warps=8),\n        triton.Config({'BLOCK_SIZE_N': 256, 'BLOCK_SIZE_K': 32}, num_warps=8),\n        triton.Config({'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 64}, num_warps=8),\n        triton.Config({'BLOCK_SIZE_N': 256, 'BLOCK_SIZE_K': 64}, num_warps=8),\n        triton.Config({'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 32}, num_warps=8),\n        triton.Config({'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 64}, num_warps=8),\n    ],\n    key=['out_features', 'in_features'],\n)\n@triton.jit\ndef _fused_linear_swish_kernel(\n    # Pointers to matrices\n    x_ptr, w_ptr, b_ptr, output_ptr,\n    # Matrix dimensions\n    batch_size, in_features, out_features,\n    # Strides\n    stride_x0, stride_x1,\n    stride_w0, stride_w1,\n    stride_out0, stride_out1,\n    scaling_factor: tl.constexpr,\n    # Meta-parameters\n    BLOCK_SIZE_N: tl.constexpr, BLOCK_SIZE_K: tl.constexpr,\n):\n    # Map program ids to the block of the output they should compute.\n    pid = tl.program_id(0)\n    num_out_blocks = tl.cdiv(out_features, BLOCK_SIZE_N)\n    batch_idx = pid // num_out_blocks\n    out_block_idx = pid % num_out_blocks\n\n    # This program will compute a block of the output for the given batch index and a block of the out_features.\n    offs_out = out_block_idx * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n    offs_k = tl.arange(0, BLOCK_SIZE_K)\n\n    # Create pointers for the weight block: [BLOCK_SIZE_N, BLOCK_SIZE_K]\n    w_ptrs = w_ptr + offs_out[:, None] * stride_w0 + offs_k[None, :] * stride_w1\n\n    # Accumulator for the output block\n    acc = tl.zeros((BLOCK_SIZE_N,), dtype=tl.float32)\n\n    # Loop over the in_features dimension in blocks of BLOCK_SIZE_K\n    num_k_blocks = tl.cdiv(in_features, BLOCK_SIZE_K)\n    for k in range(0, num_k_blocks):\n        k_offs = k * BLOCK_SIZE_K\n        # Load a block of x for the current batch and the current K block.\n        x_ptrs = x_ptr + batch_idx * stride_x0 + (k_offs + offs_k) * stride_x1\n        mask_x = (k_offs + offs_k) < in_features\n        x_block = tl.load(x_ptrs, mask=mask_x, other=0.0)\n\n        # Load a block of weights for the current K block and the current out block.\n        mask_w = (offs_out[:, None] < out_features) & ((k_offs + offs_k)[None, :] < in_features)\n        w_block = tl.load(w_ptrs + k_offs * stride_w1, mask=mask_w, other=0.0)\n\n        # Compute the dot product for this block\n        acc += tl.sum(w_block * x_block[None, :], axis=1)\n\n    # Load bias for the current out block\n    b_ptrs = b_ptr + offs_out\n    mask_bias = offs_out < out_features\n    bias = tl.load(b_ptrs, mask=mask_bias, other=0.0)\n    acc += bias\n\n    # Apply Swish: acc * sigmoid(acc)\n    swish_output = acc * tl.sigmoid(acc)\n    # Scale\n    swish_output = swish_output * scaling_factor\n\n    # Write back the result\n    out_ptrs = output_ptr + batch_idx * stride_out0 + offs_out * stride_out1\n    tl.store(out_ptrs, swish_output, mask=mask_bias)\n\ndef fused_linear_swish(x, weight, bias, scaling_factor):\n    # Check sizes\n    batch, in_features = x.shape\n    out_features, _ = weight.shape\n    # Allocate output\n    output = torch.empty((batch, out_features), device=x.device, dtype=x.dtype)\n    # The grid is batch * ceil(out_features / BLOCK_SIZE_N)\n    grid = lambda meta: (batch * triton.cdiv(out_features, meta['BLOCK_SIZE_N']),)\n    # Launch kernel\n    _fused_linear_swish_kernel[grid](\n        x, weight, bias, output,\n        batch, in_features, out_features,\n        x.stride(0), x.stride(1),\n        weight.stride(0), weight.stride(1),\n        output.stride(0), output.stride(1),\n        scaling_factor\n    )\n    return output\n\nclass ModelNew(nn.Module):\n    \"\"\"\n    Simple model that performs a matrix multiplication, applies Swish activation, and scales the result.\n    Uses a fused Triton kernel for the operation.\n    \"\"\"\n    def __init__(self, in_features, out_features, scaling_factor):\n        super(ModelNew, self).__init__()\n        self.in_features = in_features\n        self.out_features = out_features\n        self.scaling_factor = scaling_factor\n        self.weight = nn.Parameter(torch.empty(out_features, in_features))\n        self.bias = nn.Parameter(torch.empty(out_features))\n        # initialize the parameters\n        nn.init.kaiming_uniform_(self.weight, a=math.sqrt(5))\n        fan_in, _ = nn.init._calculate_fan_in_and_fan_out(self.weight)\n        bound = 1 / math.sqrt(fan_in) if fan_in > 0 else 0\n        nn.init.uniform_(self.bias, -bound, bound)\n\n    def forward(self, x):\n        # We use the fused kernel\n        return fused_linear_swish(x, self.weight, self.bias, self.scaling_factor)\n\nbatch_size = 128\nin_features = 1024\nout_features = 512\nscaling_factor = 2.0\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, scaling_factor]\n# =================== EVOLVE-BLOCK-END ===================\n```\nUnique approach: Modification: Full rewrite, Excellent compiled (1.000), Excellent correctness (1.000)\n\n\n### Inspiration 2 (Score: 10.0000, Type: High-Performer)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport math\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n# Triton kernel for fused linear + swish + scale\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_N': 128, 'BLOCK_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_N': 256, 'BLOCK_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_N': 128, 'BLOCK_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_N': 256, 'BLOCK_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_N': 64, 'BLOCK_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_N': 64, 'BLOCK_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_N': 128, 'BLOCK_K': 32}, num_warps=8),\n        triton.Config({'BLOCK_N': 256, 'BLOCK_K': 32}, num_warps=8),\n        triton.Config({'BLOCK_N': 128, 'BLOCK_K': 64}, num_warps=8),\n        triton.Config({'BLOCK_N': 256, 'BLOCK_K': 64}, num_warps=8),\n        triton.Config({'BLOCK_N': 64, 'BLOCK_K': 32}, num_warps=8),\n        triton.Config({'BLOCK_N': 64, 'BLOCK_K': 64}, num_warps=8),\n    ],\n    key=['M', 'N', 'K'],\n)\n@triton.jit\ndef _fused_linear_swish_kernel(\n    # Pointers to matrices\n    x_ptr, w_ptr, b_ptr, output_ptr,\n    # Matrix dimensions\n    M, N, K,\n    # Strides\n    stride_xm, stride_xk,\n    stride_wn, stride_wk,\n    stride_om, stride_on,\n    scaling_factor: tl.constexpr,\n    # Meta-parameters\n    BLOCK_N: tl.constexpr, \n    BLOCK_K: tl.constexpr,\n):\n    pid = tl.program_id(axis=0)\n    num_pid_n = tl.cdiv(N, BLOCK_N)\n    pid_m = pid // num_pid_n\n    pid_n = pid % num_pid_n\n\n    # Create pointers for data\n    offs_m = pid_m * BLOCK_N + tl.arange(0, BLOCK_N)\n    offs_n = tl.arange(0, BLOCK_K)\n    offs_k = pid_n * BLOCK_K + tl.arange(0, BLOCK_K)\n    \n    # Pointers for x [M, K]\n    x_ptrs = x_ptr + offs_m[:, None] * stride_xm + offs_k[None, :] * stride_xk\n    # Pointers for w [N, K]\n    w_ptrs = w_ptr + offs_k[:, None] * stride_wn + offs_n[None, :] * stride_wk\n\n    # Initialize accumulator\n    acc = tl.zeros((BLOCK_N, BLOCK_K), dtype=tl.float32)\n    \n    # Loop over K dimension\n    for k in range(0, tl.cdiv(K, BLOCK_K)):\n        # Load x block with mask\n        x_mask = (offs_m[:, None] < M) & (offs_k[None, :] < K)\n        x = tl.load(x_ptrs, mask=x_mask, other=0.0)\n        \n        # Load w block with mask\n        w_mask = (offs_k[:, None] < K) & (offs_n[None, :] < N)\n        w = tl.load(w_ptrs, mask=w_mask, other=0.0)\n        \n        # Compute block matrix multiplication\n        acc += tl.dot(x, w)\n        \n        # Update pointers for next block\n        x_ptrs += BLOCK_K * stride_xk\n        w_ptrs += BLOCK_K * stride_wk\n    \n    # Apply bias and activation\n    b = tl.load(b_ptr + offs_n, mask=offs_n < N, other=0.0)\n    acc += b[None, :]\n    swish = acc * tl.sigmoid(acc)\n    output = swish * scaling_factor\n    \n    # Write back result\n    out_ptrs = output_ptr + offs_m[:, None] * stride_om + offs_n[None, :] * stride_on\n    out_mask = (offs_m[:, None] < M) & (offs_n[None, :] < N)\n    tl.store(out_ptrs, output, mask=out_mask)\n\ndef fused_linear_swish(x, weight, bias, scaling_factor):\n    # Check sizes\n    M, K = x.shape\n    N, _ = weight.shape\n    \n    # Allocate output\n    output = torch.empty((M, N), device=x.device, dtype=x.dtype)\n    \n    # Grid definition\n    grid = lambda opt: (triton.cdiv(M, opt['BLOCK_N']) * triton.cdiv(N, opt['BLOCK_K']),)\n    \n    # Launch kernel\n    _fused_linear_swish_kernel[grid](\n        x, weight, bias, output,\n        M, N, K,\n        x.stride(0), x.stride(1),\n        weight.stride(0), weight.stride(1),\n        output.stride(0), output.stride(1),\n        scaling_factor,\n        BLOCK_N=128,\n        BLOCK_K=32\n    )\n    return output\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, scaling_factor):\n        super(ModelNew, self).__init__()\n        self.in_features = in_features\n        self.out_features = out_features\n        self.scaling_factor = scaling_factor\n        self.weight = nn.Parameter(torch.empty(out_features, in_features))\n        self.bias = nn.Parameter(torch.empty(out_features))\n        nn.init.kaiming_uniform_(self.weight, a=math.sqrt(5))\n        fan_in, _ = nn.init._calculate_fan_in_and_fan_out(self.weight)\n        bound = 1 / math.sqrt(fan_in) if fan_in > 0 else 0\n        nn.init.uniform_(self.bias, -bound, bound)\n\n    def forward(self, x):\n        return fused_linear_swish(x, self.weight, self.bias, self.scaling_factor)\n\nbatch_size = 128\nin_features = 1024\nout_features = 512\nscaling_factor = 2.0\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, scaling_factor]\n# =================== EVOLVE-BLOCK-END ===================\n```\nUnique approach: Modification: Full rewrite, Excellent compiled (1.000), Alternative correctness approach\n\n\n### Inspiration 3 (Score: 20.0000, Type: High-Performer)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport math\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_N': 64, 'BLOCK_K': 128}, num_warps=4, num_stages=4),\n        triton.Config({'BLOCK_N': 128, 'BLOCK_K': 128}, num_warps=4, num_stages=3),\n        triton.Config({'BLOCK_N': 256, 'BLOCK_K': 128}, num_warps=8, num_stages=3),\n        triton.Config({'BLOCK_N': 64, 'BLOCK_K': 64}, num_warps=8, num_stages=4),\n        triton.Config({'BLOCK_N': 128, 'BLOCK_K': 64}, num_warps=4, num_stages=4),\n        triton.Config({'BLOCK_N': 256, 'BLOCK_K': 64}, num_warps=8, num_stages=3),\n    ],\n    key=['in_features', 'out_features'],\n)\n@triton.jit\ndef fused_linear_swish_scale(\n    input_ptr,\n    weight_ptr,\n    bias_ptr,\n    output_ptr,\n    in_features,\n    out_features,\n    scaling_factor,\n    stride_input,\n    stride_weight,\n    stride_output,\n    BLOCK_N: tl.constexpr,\n    BLOCK_K: tl.constexpr,\n):\n    pid_b = tl.program_id(0)\n    pid_oc = tl.program_id(1)\n    \n    oc_offs = pid_oc * BLOCK_N + tl.arange(0, BLOCK_N)\n    mask_oc = oc_offs < out_features\n    \n    # Vectorized accumulator initialization\n    acc = tl.zeros((BLOCK_N,), dtype=tl.float32)\n    bias = tl.load(bias_ptr + oc_offs, mask=mask_oc, other=0.0)\n    \n    # Optimized memory access with vectorization\n    for k in range(0, tl.cdiv(in_features, BLOCK_K)):\n        k_offs = k * BLOCK_K\n        cols = k_offs + tl.arange(0, BLOCK_K)\n        mask_k = cols < in_features\n        \n        # Coalesced memory access\n        input_vals = tl.load(\n            input_ptr + pid_b * stride_input + cols,\n            mask=mask_k,\n            other=0.0\n        )\n        \n        weight_vals = tl.load(\n            weight_ptr + (oc_offs[:, None] * stride_weight + cols[None, :]),\n            mask=mask_oc[:, None] & mask_k[None, :],\n            other=0.0\n        )\n        \n        # Efficient matrix multiplication\n        acc += tl.sum(weight_vals * input_vals[None, :], axis=1)\n    \n    # Fused activation and scaling\n    acc += bias\n    sig = 1.0 / (1.0 + tl.exp(-acc))\n    result = acc * sig * scaling_factor\n    \n    # Vectorized store\n    tl.store(\n        output_ptr + pid_b * stride_output + oc_offs,\n        result,\n        mask=mask_oc\n    )\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, scaling_factor):\n        super(ModelNew, self).__init__()\n        self.in_features = in_features\n        self.out_features = out_features\n        self.scaling_factor = scaling_factor\n        self.weight = nn.Parameter(torch.Tensor(out_features, in_features))\n        self.bias = nn.Parameter(torch.Tensor(out_features))\n        nn.init.kaiming_uniform_(self.weight, a=math.sqrt(5))\n        bound = 1 / math.sqrt(in_features) if in_features > 0 else 0\n        nn.init.uniform_(self.bias, -bound, bound)\n    \n    def forward(self, x):\n        x = x.contiguous()\n        output = torch.empty((x.size(0), self.out_features), device=x.device, dtype=x.dtype)\n        \n        # Use base block size for grid calculation\n        grid = (x.size(0), triton.cdiv(self.out_features, 64))\n        \n        # Launch kernel without explicit block parameters\n        fused_linear_swish_scale[grid](\n            x, self.weight, self.bias, output,\n            self.in_features, self.out_features,\n            self.scaling_factor,\n            x.stride(0), self.weight.stride(0), output.stride(0)\n        )\n        return output\n\nbatch_size = 128\nin_features = 1024\nout_features = 512\nscaling_factor = 2.0\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, scaling_factor]\n# =================== EVOLVE-BLOCK-END ===================\n```\nUnique approach: Modification: Full rewrite, Excellent compiled (1.000), Excellent correctness (1.000)\n\n\n### Inspiration 4 (Score: 20.0000, Type: High-Performer)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport math\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_N': 64, 'BLOCK_K': 128}, num_warps=4, num_stages=4),\n        triton.Config({'BLOCK_N': 128, 'BLOCK_K': 128}, num_warps=4, num_stages=3),\n        triton.Config({'BLOCK_N': 256, 'BLOCK_K': 128}, num_warps=8, num_stages=3),\n        triton.Config({'BLOCK_N': 64, 'BLOCK_K': 64}, num_warps=8, num_stages=4),\n        triton.Config({'BLOCK_N': 128, 'BLOCK_K': 64}, num_warps=4, num_stages=4),\n        triton.Config({'BLOCK_N': 256, 'BLOCK_K': 64}, num_warps=8, num_stages=3),\n    ],\n    key=['in_features', 'out_features'],\n)\n@triton.jit\ndef fused_linear_swish_scale(\n    input_ptr,\n    weight_ptr,\n    bias_ptr,\n    output_ptr,\n    in_features,\n    out_features,\n    scaling_factor,\n    stride_input,\n    stride_weight,\n    stride_output,\n    BLOCK_N: tl.constexpr,\n    BLOCK_K: tl.constexpr,\n):\n    pid_b = tl.program_id(0)\n    pid_oc = tl.program_id(1)\n    \n    oc_offs = pid_oc * BLOCK_N + tl.arange(0, BLOCK_N)\n    mask_oc = oc_offs < out_features\n    \n    # Precompute weight pointers for better cache locality\n    weight_ptrs = weight_ptr + oc_offs[:, None] * stride_weight\n    \n    # Initialize accumulator in fp32 for numerical stability\n    acc = tl.zeros((BLOCK_N,), dtype=tl.float32)\n    bias = tl.load(bias_ptr + oc_offs, mask=mask_oc, other=0.0)\n    \n    # Loop over K dimension with vectorized loads\n    for k in range(0, tl.cdiv(in_features, BLOCK_K)):\n        k_offs = k * BLOCK_K + tl.arange(0, BLOCK_K)\n        mask_k = k_offs < in_features\n        \n        # Coalesced memory access for input\n        input_vals = tl.load(\n            input_ptr + pid_b * stride_input + k_offs,\n            mask=mask_k,\n            other=0.0\n        )\n        \n        # Vectorized weight load\n        weight_vals = tl.load(\n            weight_ptrs + k_offs[None, :],\n            mask=mask_oc[:, None] & mask_k[None, :],\n            other=0.0\n        )\n        \n        # Accumulate using dot product for better precision\n        acc += tl.sum(weight_vals * input_vals[None, :], axis=1)\n    \n    # Fused activation and scaling\n    result = (acc + bias) * tl.sigmoid(acc + bias) * scaling_factor\n    \n    # Coalesced output store\n    tl.store(\n        output_ptr + pid_b * stride_output + oc_offs,\n        result,\n        mask=mask_oc\n    )\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, scaling_factor):\n        super(ModelNew, self).__init__()\n        self.in_features = in_features\n        self.out_features = out_features\n        self.scaling_factor = scaling_factor\n        self.weight = nn.Parameter(torch.Tensor(out_features, in_features))\n        self.bias = nn.Parameter(torch.Tensor(out_features))\n        nn.init.kaiming_uniform_(self.weight, a=math.sqrt(5))\n        bound = 1 / math.sqrt(in_features) if in_features > 0 else 0\n        nn.init.uniform_(self.bias, -bound, bound)\n    \n    def forward(self, x):\n        x = x.contiguous()\n        output = torch.empty((x.size(0), self.out_features), device=x.device, dtype=x.dtype)\n        \n        # Dynamic grid calculation using autotuned BLOCK_N\n        grid = lambda meta: (\n            x.size(0), \n            triton.cdiv(self.out_features, meta['BLOCK_N'])\n        )\n        \n        fused_linear_swish_scale[grid](\n            x, self.weight, self.bias, output,\n            self.in_features, self.out_features,\n            self.scaling_factor,\n            x.stride(0), self.weight.stride(0), output.stride(0)\n        )\n        return output\n\nbatch_size = 128\nin_features = 1024\nout_features = 512\nscaling_factor = 2.0\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, scaling_factor]\n# =================== EVOLVE-BLOCK-END ===================\n```\nUnique approach: Modification: Full rewrite, Excellent compiled (1.000), Excellent correctness (1.000)\n\n\n### Inspiration 5 (Score: 10.0000, Type: High-Performer)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport math\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_N': 64, 'BLOCK_K': 128}, num_warps=4, num_stages=4),\n        triton.Config({'BLOCK_N': 128, 'BLOCK_K': 128}, num_warps=4, num_stages=3),\n        triton.Config({'BLOCK_N': 256, 'BLOCK_K': 128}, num_warps=8, num_stages=3),\n        triton.Config({'BLOCK_N': 64, 'BLOCK_K': 64}, num_warps=8, num_stages=4),\n        triton.Config({'BLOCK_N': 128, 'BLOCK_K': 64}, num_warps=4, num_stages=4),\n        triton.Config({'BLOCK_N': 256, 'BLOCK_K': 64}, num_warps=8, num_stages=3),\n    ],\n    key=['in_features', 'out_features'],\n)\n@triton.jit\ndef fused_linear_swish_scale(\n    input_ptr,\n    weight_ptr,\n    bias_ptr,\n    output_ptr,\n    in_features,\n    out_features,\n    scaling_factor,\n    stride_input,\n    stride_weight,\n    stride_output,\n    BLOCK_N: tl.constexpr,\n    BLOCK_K: tl.constexpr,\n):\n    pid_b = tl.program_id(0)\n    pid_oc = tl.program_id(1)\n    \n    oc_offs = pid_oc * BLOCK_N + tl.arange(0, BLOCK_N)\n    mask_oc = oc_offs < out_features\n    \n    # Precompute weight pointers for better cache locality\n    weight_ptrs = weight_ptr + oc_offs[:, None] * stride_weight\n    \n    # Initialize accumulator in fp32 for numerical stability\n    acc = tl.zeros((BLOCK_N,), dtype=tl.float32)\n    bias = tl.load(bias_ptr + oc_offs, mask=mask_oc, other=0.0)\n    \n    # Loop over K dimension with vectorized loads\n    for k in range(0, tl.cdiv(in_features, BLOCK_K)):\n        k_offs = k * BLOCK_K + tl.arange(0, BLOCK_K)\n        mask_k = k_offs < in_features\n        \n        # Coalesced memory access for input\n        input_vals = tl.load(\n            input_ptr + pid_b * stride_input + k_offs,\n            mask=mask_k,\n            other=0.0\n        )\n        \n        # Vectorized weight load\n        weight_vals = tl.load(\n            weight_ptrs + k_offs[None, :],\n            mask=mask_oc[:, None] & mask_k[None, :],\n            other=0.0\n        )\n        \n        # Optimized: Transpose weights & use tensor-core dot product\n        weight_vals_trans = tl.trans(weight_vals)\n        product = tl.dot(input_vals[None, :], weight_vals_trans, allow_tf32=True)\n        acc += product[0, :]\n    \n    # Fused activation and scaling\n    result = (acc + bias) * tl.sigmoid(acc + bias) * scaling_factor\n    \n    # Coalesced output store\n    tl.store(\n        output_ptr + pid_b * stride_output + oc_offs,\n        result,\n        mask=mask_oc\n    )\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, scaling_factor):\n        super(ModelNew, self).__init__()\n        self.in_features = in_features\n        self.out_features = out_features\n        self.scaling_factor = scaling_factor\n        self.weight = nn.Parameter(torch.Tensor(out_features, in_features))\n        self.bias = nn.Parameter(torch.Tensor(out_features))\n        nn.init.kaiming_uniform_(self.weight, a=math.sqrt(5))\n        bound = 1 / math.sqrt(in_features) if in_features > 0 else 0\n        nn.init.uniform_(self.bias, -bound, bound)\n    \n    def forward(self, x):\n        x = x.contiguous()\n        output = torch.empty((x.size(0), self.out_features), device=x.device, dtype=x.dtype)\n        \n        # Dynamic grid calculation using autotuned BLOCK_N\n        grid = lambda meta: (\n            x.size(0), \n            triton.cdiv(self.out_features, meta['BLOCK_N'])\n        )\n        \n        fused_linear_swish_scale[grid](\n            x, self.weight, self.bias, output,\n            self.in_features, self.out_features,\n            self.scaling_factor,\n            x.stride(0), self.weight.stride(0), output.stride(0)\n        )\n        return output\n\nbatch_size = 128\nin_features = 1024\nout_features = 512\nscaling_factor = 2.0\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, scaling_factor]\n# =================== EVOLVE-BLOCK-END ===================\n```\nUnique approach: Modification: Full rewrite, Excellent compiled (1.000), Alternative correctness approach\n\n\n\n# Current Program\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport math\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n# Triton kernel for fused linear + swish + scale\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 128}, num_warps=4),\n        triton.Config({'BLOCK_M': 256, 'BLOCK_N': 64}, num_warps=4),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 64}, num_warps=4),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 128}, num_warps=4),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 32}, num_warps=4),\n        triton.Config({'BLOCK_M': 256, 'BLOCK_N': 128}, num_warps=8),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 256}, num_warps=8),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 64}, num_warps=4),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 32}, num_warps=4),\n        triton.Config({'BLOCK_M': 32, 'BLOCK_N': 64}, num_warps=4),\n    ],\n    key=['M', 'N', 'K'],\n)\n@triton.jit\ndef _fused_linear_swish_kernel(\n    # Pointers to matrices\n    x_ptr, w_ptr, b_ptr, output_ptr,\n    # Matrix dimensions\n    M, N, K,\n    # Strides\n    stride_xm, stride_xk,\n    stride_wn, stride_wk,\n    stride_om, stride_on,\n    scaling_factor: tl.constexpr,\n    # Meta-parameters\n    BLOCK_M: tl.constexpr, \n    BLOCK_N: tl.constexpr,\n    BLOCK_K: tl.constexpr = 64,\n):\n    pid = tl.program_id(0)\n    pid_m = pid // tl.cdiv(N, BLOCK_N)\n    pid_n = pid % tl.cdiv(N, BLOCK_N)\n    \n    # Offsets for output block\n    offs_m = pid_m * BLOCK_M + tl.arange(0, BLOCK_M)\n    offs_n = pid_n * BLOCK_N + tl.arange(0, BLOCK_N)\n    \n    # Initialize accumulator\n    acc = tl.zeros((BLOCK_M, BLOCK_N), dtype=tl.float32)\n    \n    # Compute pointer offsets for input x and weights\n    x_ptrs = x_ptr + offs_m[:, None] * stride_xm + tl.arange(0, BLOCK_K)[None, :] * stride_xk\n    w_ptrs = w_ptr + offs_n[None, :] * stride_wn + tl.arange(0, BLOCK_K)[:, None] * stride_wk\n    \n    # Loop over K dimension\n    for k in range(0, K, BLOCK_K):\n        # Load input block\n        k_offs = k + tl.arange(0, BLOCK_K)\n        x_mask = (offs_m[:, None] < M) & (k_offs[None, :] < K)\n        x = tl.load(x_ptrs, mask=x_mask, other=0.0)\n        \n        # Load weight block\n        w_mask = (k_offs[:, None] < K) & (offs_n[None, :] < N)\n        w = tl.load(w_ptrs, mask=w_mask, other=0.0)\n        \n        # Compute block matrix multiplication\n        acc += tl.dot(x, w, allow_tf32=True)\n        \n        # Update pointers for next block\n        x_ptrs += BLOCK_K * stride_xk\n        w_ptrs += BLOCK_K * stride_wk\n    \n    # Apply bias\n    b = tl.load(b_ptr + offs_n, mask=offs_n < N, other=0.0)\n    acc += b[None, :]\n    \n    # Apply Swish activation and scaling\n    sig = tl.sigmoid(acc)\n    output = acc * sig * scaling_factor\n    \n    # Write back result\n    out_ptrs = output_ptr + offs_m[:, None] * stride_om + offs_n[None, :] * stride_on\n    out_mask = (offs_m[:, None] < M) & (offs_n[None, :] < N)\n    tl.store(out_ptrs, output, mask=out_mask)\n\ndef fused_linear_swish(x, weight, bias, scaling_factor):\n    # Check sizes\n    M, K = x.shape\n    N, _ = weight.shape\n    \n    # Allocate output\n    output = torch.empty((M, N), device=x.device, dtype=x.dtype)\n    \n    # Grid definition\n    grid = lambda opt: (triton.cdiv(M, opt['BLOCK_M']) * triton.cdiv(N, opt['BLOCK_N']),)\n    \n    # Launch kernel\n    _fused_linear_swish_kernel[grid](\n        x, weight, bias, output,\n        M, N, K,\n        x.stride(0), x.stride(1),\n        weight.stride(0), weight.stride(1),\n        output.stride(0), output.stride(1),\n        scaling_factor\n    )\n    return output\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, scaling_factor):\n        super(ModelNew, self).__init__()\n        self.in_features = in_features\n        self.out_features = out_features\n        self.scaling_factor = scaling_factor\n        self.weight = nn.Parameter(torch.empty(out_features, in_features))\n        self.bias = nn.Parameter(torch.empty(out_features))\n        nn.init.kaiming_uniform_(self.weight, a=math.sqrt(5))\n        fan_in, _ = nn.init._calculate_fan_in_and_fan_out(self.weight)\n        bound = 1 / math.sqrt(fan_in) if fan_in > 0 else 0\n        nn.init.uniform_(self.bias, -bound, bound)\n\n    def forward(self, x):\n        return fused_linear_swish(x, self.weight, self.bias, self.scaling_factor)\n\nbatch_size = 128\nin_features = 1024\nout_features = 512\nscaling_factor = 2.0\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, scaling_factor]\n# =================== EVOLVE-BLOCK-END ===================\n```\n\n# Task\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```\n", "responses": ["<think>\nWe are given the current program, which has a speedup of 1.058 (score 25.8) and we are to improve it.\n The current program uses a Triton kernel that does a matrix multiplication (with bias, swish, and scaling) by tiling the output matrix.\n The autotuning is over BLOCK_M and BLOCK_N, and the inner block size for K (BLOCK_K) is fixed at 64.\n\n Areas to consider for improvement:\n 1. The current kernel uses a fixed BLOCK_K=64. We might make BLOCK_K tunable as well, and adjust the tiling accordingly.\n 2. The kernel currently uses a 2D grid: each block computes a tile of size BLOCK_M x BLOCK_N. We note that the grid is defined as (triton.cdiv(M, BLOCK_M) * triton.cdiv(N, BLOCK_N)).\n 3. We are using `tl.dot` which uses Tensor Cores (allow_tf32=True). We can try to adjust the block sizes to be multiples of 16 or 32 to better utilize Tensor Cores on H100 (which are 32x16x16 for FP16).\n\n However, note that the current kernel already achieves a speedup of 1.058. We want to increase that.\n\n Observation from the top performing programs:\n - The top program (Program 1) is the current one. The other programs have lower speedup.\n\n Inspiration:\n - We see that in some programs (like Inspiration 5) they use a different kernel structure that transposes the weight matrix and uses `tl.dot` in a different way. However, that program had a lower score.\n\n Proposed changes:\n 1. Make BLOCK_K a tunable parameter. We note that the current kernel uses BLOCK_K=64. We can try different values (like 32, 64, 128) and see which one performs better.\n 2. We can also try to adjust the block sizes to be multiples of 16 (or 32) to better match the tensor core shape.\n\n However, note the constraint: we cannot change the kernel signature arbitrarily? Actually, we are allowed to change the autotune configs and the internal kernel code as long as we don't change the function signature (parameters) in a way that breaks the call. But note: the kernel signature must remain the same. We see that the kernel currently has:\n    BLOCK_K: tl.constexpr = 64\n We can change the default and make it a tunable parameter by including it in the autotune configs.\n\n Let's restructure the autotune configs to include BLOCK_K and also adjust the block sizes to be multiples of 16 for Tensor Cores.\n\n Steps:\n  - Add BLOCK_K to the autotune configs. We'll try values like 32, 64, 128 (and maybe 256? but note K=1024, so 256 would be 4 blocks in K).\n  - We also note that the problem dimensions: M=128, N=512, K=1024.\n\n  We can set the autotune configs to:\n      triton.Config({'BLOCK_M': 128, 'BLOCK_N': 128, 'BLOCK_K': 32}, num_warps=4),\n      ... and so on.\n\n  - We must also adjust the kernel to use the BLOCK_K from the config (it already does, because we are passing it as a meta-parameter and it is a `tl.constexpr`).\n\n  - We note that the inner loop in K is over `range(0, K, BLOCK_K)`. That remains unchanged.\n\n  - We should also consider the tensor core requirements: for FP16, the ideal is that the inner dimension (BLOCK_K) is a multiple of 16 (or 32) and that BLOCK_M and BLOCK_N are multiples of 16 and 32 respectively? Actually, the Triton dot operation for tensor cores requires that the inner dimension (K) is a multiple of 16 and the other dimensions are multiples of 16 and 32? But Triton might handle that internally? However, we can set our block sizes to be multiples of 16 and 32 to be safe.\n\n  - We note that the current block sizes (like 128, 256, 64) are already multiples of 32 or 64. But we should ensure that the new BLOCK_K we try are multiples of 16.\n\n  - We also note that the kernel uses `tl.dot(x, w, allow_tf32=True)`. This is good for tensor cores.\n\n  - We might also consider increasing the number of warps? But the current configs use 4 or 8 warps.\n\n  - We can also try to use more stages? The current kernel does not set `num_stages` in the config. By default, Triton uses 1 or 2? We can try to set it explicitly to 3 or 4? But note: the autotune configs in the current program do not set `num_stages`. We can add that.\n\n  - However, note that the top program (current) does not set `num_stages` and the Inspiration 5 program does set `num_stages` (but had lower performance). So we might leave it to the autotuner to choose.\n\n  - We are going to add more configs that vary BLOCK_K and also adjust the block sizes.\n\n  - We must be cautious: the kernel must compile and be correct.\n\n  - We are going to generate a new set of configs that include BLOCK_K and also have block sizes that are multiples of 16 and 32.\n\n  - We note that the current grid function is: `grid = lambda opt: (triton.cdiv(M, opt['BLOCK_M']) * triton.cdiv(N, opt['BLOCK_N']),)`\n\n  - We are not changing the grid function.\n\n  - We are also going to keep the same kernel structure.\n\n  - We are going to change the kernel to use the BLOCK_K from the config (it already does) and then we add more configs.\n\n  - We note that the kernel already has a parameter `BLOCK_K: tl.constexpr` and it is set to 64 by default. We are going to override that in the autotune.\n\n  - We are going to change the autotune configs to include BLOCK_K and also add more configs that are known to be good for tensor cores.\n\n  - We are going to try to set the block sizes to multiples of 16 and 32. For example, we might try BLOCK_M=128, BLOCK_N=128, BLOCK_K=32; BLOCK_M=128, BLOCK_N=128, BLOCK_K=64; etc.\n\n  - We also note that the H100 has a large shared memory? So we can try larger blocks.\n\n  - We are going to generate a list of configs that cover a range of BLOCK_M, BLOCK_N, and BLOCK_K.\n\n  - We are going to keep the same number of warps? We can also make the number of warps depend on the block sizes.\n\n  - We note that the maximum number of threads per block is 1024. So the product of BLOCK_M and BLOCK_N should be <= 1024? Actually, the kernel uses a 2D block: the inner loops are over BLOCK_K, and the block is of size BLOCK_M * BLOCK_N? Not exactly: the kernel is written in a way that each program instance (block) computes a tile of BLOCK_M x BLOCK_N. The number of threads per block is the product of the two? Actually, no: the kernel uses a 1D grid, and the block in Triton is defined by the number of warps and the way we map to threads. We are using `tl.arange(0, BLOCK_M)` and `tl.arange(0, BLOCK_N)` which are independent. The total number of threads in a block is BLOCK_M * BLOCK_N? But that might be too large. Actually, the way Triton works: the kernel is executed by a block of threads that are organized in a 1D manner? And we are using two independent ranges? Then the total number of threads is the maximum of BLOCK_M and BLOCK_N? Actually, no: the kernel uses two independent loops? The dot product is done by the hardware? \n\n  - We must be cautious: the product BLOCK_M * BLOCK_N must be less than or equal to the maximum number of threads per block (1024). But note: we are using a 2D tile and the Triton compiler will map the operations to threads. We have to make sure that the tile sizes are not too large.\n\n  - Alternatively, we can set the number of warps appropriately. Each warp has 32 threads. So if we have 8 warps, that's 256 threads. We can set the number of warps to be at least ceil((BLOCK_M * BLOCK_N) / 32). But actually, Triton might handle that internally? \n\n  - We are going to set the number of warps to 4 or 8 for larger blocks.\n\n  - We are going to try the following configs (inspired by the top programs and the tensor core requirements):\n\n    configs = [\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 128, 'BLOCK_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 128, 'BLOCK_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 128, 'BLOCK_K': 128}, num_warps=4),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 128, 'BLOCK_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 128, 'BLOCK_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 64, 'BLOCK_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 64, 'BLOCK_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_M': 256, 'BLOCK_N': 64, 'BLOCK_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_M': 256, 'BLOCK_N': 64, 'BLOCK_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 256, 'BLOCK_K': 32}, num_warps=8),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 256, 'BLOCK_K': 64}, num_warps=8),\n        triton.Config({'BLOCK_M': 256, 'BLOCK_N': 128, 'BLOCK_K': 32}, num_warps=8),\n        triton.Config({'BLOCK_M': 256, 'BLOCK_N': 128, 'BLOCK_K': 64}, num_warps=8),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 256, 'BLOCK_K': 32}, num_warps=8),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 256, 'BLOCK_K': 64}, num_warps=8),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 64, 'BLOCK_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 64, 'BLOCK_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_M': 32, 'BLOCK_N': 64, 'BLOCK_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_M': 32, 'BLOCK_N': 64, 'BLOCK_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 32, 'BLOCK_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 32, 'BLOCK_K': 64}, num_warps=4),\n    ]\n\n  - We are also going to remove the fixed BLOCK_K=64 from the kernel definition and make it a required meta-parameter? Actually, we can keep the default and override it in the config.\n\n  - We note that the kernel currently has: `BLOCK_K: tl.constexpr = 64`. We can change that to `BLOCK_K: tl.constexpr` and remove the default? But that would break if we don't provide it? Actually, the autotuner will provide it. But in the kernel call, we are not passing BLOCK_K? We are passing it via the autotuner. And the grid function does not use BLOCK_K? So it's safe.\n\n  - However, the kernel call in the Python function does not pass BLOCK_K. We are only passing the autotune configs. The autotuner will pass it as a keyword argument. So we must change the kernel signature to not have a default for BLOCK_K? Actually, we can leave it as is because the autotuner will override it. But to be safe, we remove the default.\n\n  - Let's change the kernel signature to:\n        BLOCK_K: tl.constexpr,\n\n  - And then in the autotune configs, we set BLOCK_K.\n\n  - Also, note that the kernel uses `tl.arange(0, BLOCK_K)` and we are loading a block of size BLOCK_K. So we must have BLOCK_K as a constexpr.\n\n  - We are going to make these changes.\n\n  - We are also going to set the key for autotuning to include M, N, K? The current key is ['M','N','K'] which is good.\n\n  - We are going to change the autotune configs to the list above.\n\n  - We are also going to try to use 3 or 4 stages? We can set `num_stages` in the configs. But note: the current program doesn't set it. We can leave it to the compiler? Or we can try to set it. We will set it to 3 for the larger blocks and 4 for the smaller ones? Actually, we can set it in the configs. Let's set:\n\n        For num_warps=4: num_stages=3\n        For num_warps=8: num_stages=3\n\n    But we don't know the best value. We can leave it out and let Triton choose? Or we can set it to 3 for all? Actually, the Inspiration 5 program set `num_stages`. We can try setting it to 3 or 4.\n\n  - We are going to set `num_stages=3` for all configs? We can try that.\n\n  - Alternatively, we can leave it as default? The Triton documentation says that the default is 1. We can set it to 2 or 3 to allow more software pipelining.\n\n  - We are going to set `num_stages=3` for all configs.\n\n  - But note: the shared memory usage might increase with the number of stages. We have to be cautious.\n\n  - We are going to set it to 3 for now and see.\n\n  - We are going to change the kernel to remove the default for BLOCK_K.\n\n  - We are going to update the autotune configs to the new list and include BLOCK_K and num_stages.\n\n  - We are also going to change the kernel to use the new BLOCK_K.\n\n  - We are going to change the kernel's inner loop to use the new BLOCK_K (it already does).\n\n  - We are going to change the kernel's pointer updates: they are already using BLOCK_K.\n\n  - We are going to change the kernel's mask for x and w: they are already using k_offs = k + tl.arange(0, BLOCK_K) and then mask with k_offs < K.\n\n  - We are going to change the kernel to remove the default for BLOCK_K.\n\n  - We are going to change the autotune configs to the list above.\n\n  - We are going to write the new code.\n\n  - We note that the current program has 10 configs. We are replacing with 20 configs? We are going to write 20 configs.\n\n  - We are going to change the kernel signature for BLOCK_K.\n\n  - We are going to change the autotune configs to include BLOCK_K and set num_stages=3.\n\n  - We are going to run the program and hope for a speedup.\n\n  - We note that the current program is working and we are building upon it.\n\n  - We are going to change the kernel and the autotune configs.\n\n  - We are going to output the entire code.\n\n  - We are going to be cautious: the kernel must be correct.\n\n  - We are going to change only the kernel and the autotune configs.\n\n  - We are going to leave the rest of the code (the ModelNew and the fused_linear_swish function) unchanged.\n\n  - We are going to write the new code.\n\n  - IMPORTANT: We must not change the function signatures of the kernel or the fused_linear_swish function? Actually, the kernel signature is changing by removing the default for BLOCK_K. But that is a constexpr and it is passed by the autotuner. The call to the kernel in the fused_linear_swish function does not pass BLOCK_K explicitly? It is passed by the autotuner via the grid function? So it is safe.\n\n  - We are going to change the kernel signature from:\n        BLOCK_K: tl.constexpr = 64,\n    to:\n        BLOCK_K: tl.constexpr,\n\n  - And then we update the autotune configs.\n\n  - We are going to output the code.\n\n  - We note that the current program has a speedup of 1.058. We hope to get at least 1.10.\n\n  - We are going to try.\n\n  - If we cannot get a speedup, we might revert? But we are only allowed one step.\n\n  - We are going to make the change.\n\n  - We are going to write the code.\n\n  - We note that the problem dimensions: M=128, N=512, K=1024.\n\n  - We are going to try to choose block sizes that divide these dimensions? But it's not necessary because we have masks.\n\n  - We are going to output the code.\n</think>\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport math\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n# Triton kernel for fused linear + swish + scale\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 128, 'BLOCK_K': 32}, num_warps=4, num_stages=3),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 128, 'BLOCK_K': 64}, num_warps=4, num_stages=3),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 128, 'BLOCK_K': 128}, num_warps=4, num_stages=3),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 128, 'BLOCK_K': 32}, num_warps=4, num_stages=3),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 128, 'BLOCK_K': 64}, num_warps=4, num_stages=3),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 64, 'BLOCK_K': 32}, num_warps=4, num_stages=3),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 64, 'BLOCK_K': 64}, num_warps=4, num_stages=3),\n        triton.Config({'BLOCK_M': 256, 'BLOCK_N': 64, 'BLOCK_K': 32}, num_warps=4, num_stages=3),\n        triton.Config({'BLOCK_M': 256, 'BLOCK_N': 64, 'BLOCK_K': 64}, num_warps=4, num_stages=3),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 256, 'BLOCK_K': 32}, num_warps=8, num_stages=3),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 256, 'BLOCK_K': 64}, num_warps=8, num_stages=3),\n        triton.Config({'BLOCK_M': 256, 'BLOCK_N': 128, 'BLOCK_K': 32}, num_warps=8, num_stages=3),\n        triton.Config({'BLOCK_M': 256, 'BLOCK_N': 128, 'BLOCK_K': 64}, num_warps=8, num_stages=3),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 256, 'BLOCK_K': 32}, num_warps=8, num_stages=3),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 256, 'BLOCK_K': 64}, num_warps=8, num_stages=3),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 64, 'BLOCK_K': 32}, num_warps=4, num_stages=4),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 64, 'BLOCK_K': 64}, num_warps=4, num_stages=4),\n        triton.Config({'BLOCK_M': 32, 'BLOCK_N': 64, 'BLOCK_K': 32}, num_warps=4, num_stages=4),\n        triton.Config({'BLOCK_M': 32, 'BLOCK_N': 64, 'BLOCK_K': 64}, num_warps=4, num_stages=4),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 32, 'BLOCK_K': 32}, num_warps=4, num_stages=4),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 32, 'BLOCK_K': 64}, num_warps=4, num_stages=4),\n    ],\n    key=['M', 'N', 'K'],\n)\n@triton.jit\ndef _fused_linear_swish_kernel(\n    # Pointers to matrices\n    x_ptr, w_ptr, b_ptr, output_ptr,\n    # Matrix dimensions\n    M, N, K,\n    # Strides\n    stride_xm, stride_xk,\n    stride_wn, stride_wk,\n    stride_om, stride_on,\n    scaling_factor: tl.constexpr,\n    # Meta-parameters\n    BLOCK_M: tl.constexpr, \n    BLOCK_N: tl.constexpr,\n    BLOCK_K: tl.constexpr,\n):\n    pid = tl.program_id(0)\n    pid_m = pid // tl.cdiv(N, BLOCK_N)\n    pid_n = pid % tl.cdiv(N, BLOCK_N)\n    \n    # Offsets for output block\n    offs_m = pid_m * BLOCK_M + tl.arange(0, BLOCK_M)\n    offs_n = pid_n * BLOCK_N + tl.arange(0, BLOCK_N)\n    \n    # Initialize accumulator\n    acc = tl.zeros((BLOCK_M, BLOCK_N), dtype=tl.float32)\n    \n    # Compute pointer offsets for input x and weights\n    x_ptrs = x_ptr + offs_m[:, None] * stride_xm + tl.arange(0, BLOCK_K)[None, :] * stride_xk\n    w_ptrs = w_ptr + offs_n[None, :] * stride_wn + tl.arange(0, BLOCK_K)[:, None] * stride_wk\n    \n    # Loop over K dimension\n    for k in range(0, K, BLOCK_K):\n        # Load input block\n        k_offs = k + tl.arange(0, BLOCK_K)\n        x_mask = (offs_m[:, None] < M) & (k_offs[None, :] < K)\n        x = tl.load(x_ptrs, mask=x_mask, other=0.0)\n        \n        # Load weight block\n        w_mask = (k_offs[:, None] < K) & (offs_n[None, :] < N)\n        w = tl.load(w_ptrs, mask=w_mask, other=0.0)\n        \n        # Compute block matrix multiplication\n        acc += tl.dot(x, w, allow_tf32=True)\n        \n        # Update pointers for next block\n        x_ptrs += BLOCK_K * stride_xk\n        w_ptrs += BLOCK_K * stride_wk\n    \n    # Apply bias\n    b = tl.load(b_ptr + offs_n, mask=offs_n < N, other=0.0)\n    acc += b[None, :]\n    \n    # Apply Swish activation and scaling\n    sig = tl.sigmoid(acc)\n    output = acc * sig * scaling_factor\n    \n    # Write back result\n    out_ptrs = output_ptr + offs_m[:, None] * stride_om + offs_n[None, :] * stride_on\n    out_mask = (offs_m[:, None] < M) & (offs_n[None, :] < N)\n    tl.store(out_ptrs, output, mask=out_mask)\n\ndef fused_linear_swish(x, weight, bias, scaling_factor):\n    # Check sizes\n    M, K = x.shape\n    N, _ = weight.shape\n    \n    # Allocate output\n    output = torch.empty((M, N), device=x.device, dtype=x.dtype)\n    \n    # Grid definition\n    grid = lambda opt: (triton.cdiv(M, opt['BLOCK_M']) * triton.cdiv(N, opt['BLOCK_N']),)\n    \n    # Launch kernel\n    _fused_linear_swish_kernel[grid](\n        x, weight, bias, output,\n        M, N, K,\n        x.stride(0), x.stride(1),\n        weight.stride(0), weight.stride(1),\n        output.stride(0), output.stride(1),\n        scaling_factor\n    )\n    return output\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, scaling_factor):\n        super(ModelNew, self).__init__()\n        self.in_features = in_features\n        self.out_features = out_features\n        self.scaling_factor = scaling_factor\n        self.weight = nn.Parameter(torch.empty(out_features, in_features))\n        self.bias = nn.Parameter(torch.empty(out_features))\n        nn.init.kaiming_uniform_(self.weight, a=math.sqrt(5))\n        fan_in, _ = nn.init._calculate_fan_in_and_fan_out(self.weight)\n        bound = 1 / math.sqrt(fan_in) if fan_in > 0 else 0\n        nn.init.uniform_(self.bias, -bound, bound)\n\n    def forward(self, x):\n        return fused_linear_swish(x, self.weight, self.bias, self.scaling_factor)\n\nbatch_size = 128\nin_features = 1024\nout_features = 512\nscaling_factor = 2.0\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, scaling_factor]\n# =================== EVOLVE-BLOCK-END ===================\n```"]}}}