{"id": "7e208e4b-4095-4e9e-82e2-82d6162a9608", "code": "# ================== EVOLVE-BLOCK-START ==================\nimport math\nimport torch\nimport triton\nimport triton.language as tl\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_D': 4, 'BLOCK_H': 32, 'BLOCK_W': 32}, num_warps=8),\n        triton.Config({'BLOCK_D': 8, 'BLOCK_H': 16, 'BLOCK_W': 16}, num_warps=4),\n        triton.Config({'BLOCK_D': 16, 'BLOCK_H': 8, 'BLOCK_W': 8}, num_warps=8),\n        triton.Config({'BLOCK_D': 8, 'BLOCK_H': 32, 'BLOCK_W': 32}, num_warps=4),\n        triton.Config({'BLOCK_D': 16, 'BLOCK_H': 16, 'BLOCK_W': 16}, num_warps=8),\n    ],\n    key=['in_channels', 'out_channels', 'kernel_size', 'stride', 'padding', 'dilation']\n)\n@triton.jit\ndef conv_transpose3d_kernel(\n    x_ptr,\n    weight_ptr,\n    output_ptr,\n    in_channels,\n    out_channels,\n    depth,\n    height,\n    width,\n    kernel_size,\n    stride,\n    padding,\n    dilation,\n    output_depth,\n    output_height,\n    output_width,\n    stride_x_b, stride_x_c, stride_x_d, stride_x_h, stride_x_w,\n    stride_w_ic, stride_w_oc, stride_w_d, stride_w_h, stride_w_w,\n    stride_out_b, stride_out_c, stride_out_d, stride_out_h, stride_out_w,\n    BLOCK_D: tl.constexpr,\n    BLOCK_H: tl.constexpr,\n    BLOCK_W: tl.constexpr,\n):\n    pid = tl.program_id(0)\n    num_blocks_d = tl.cdiv(output_depth, BLOCK_D)\n    num_blocks_h = tl.cdiv(output_height, BLOCK_H)\n    num_blocks_w = tl.cdiv(output_width, BLOCK_W)\n    \n    b = pid // (out_channels * num_blocks_d * num_blocks_h * num_blocks_w)\n    pid_remain = pid % (out_channels * num_blocks_d * num_blocks_h * num_blocks_w)\n    oc = pid_remain // (num_blocks_d * num_blocks_h * num_blocks_w)\n    pid_spatial = pid_remain % (num_blocks_d * num_blocks_h * num_blocks_w)\n    \n    block_d = pid_spatial // (num_blocks_h * num_blocks_w)\n    block_h = (pid_spatial % (num_blocks_h * num_blocks_w)) // num_blocks_w\n    block_w = pid_spatial % num_blocks_w\n    \n    d_start = block_d * BLOCK_D\n    h_start = block_h * BLOCK_H\n    w_start = block_w * BLOCK_W\n    \n    d_offsets = d_start + tl.arange(0, BLOCK_D)\n    h_offsets = h_start + tl.arange(0, BLOCK_H)\n    w_offsets = w_start + tl.arange(0, BLOCK_W)\n    \n    acc = tl.zeros((BLOCK_D, BLOCK_H, BLOCK_W), dtype=tl.float32)\n    \n    for ic in range(0, in_channels):\n        for kd in range(0, kernel_size):\n            for kh in range(0, kernel_size):\n                for kw in range(0, kernel_size):\n                    d_base = d_offsets + padding - kd * dilation\n                    h_base = h_offsets + padding - kh * dilation\n                    w_base = w_offsets + padding - kw * dilation\n                    \n                    d_in = d_base // stride\n                    h_in = h_base // stride\n                    w_in = w_base // stride\n                    \n                    valid_d = (d_base % stride == 0) & (d_in >= 0) & (d_in < depth)\n                    valid_h = (h_base % stride == 0) & (h_in >= 0) & (h_in < height)\n                    valid_w = (w_base % stride == 0) & (w_in >= 0) & (w_in < width)\n                    \n                    valid_mask = valid_d[:, None, None] & valid_h[None, :, None] & valid_w[None, None, :]\n                    \n                    x_ptrs = x_ptr + b * stride_x_b + \\\n                             ic * stride_x_c + \\\n                             d_in[:, None, None] * stride_x_d + \\\n                             h_in[None, :, None] * stride_x_h + \\\n                             w_in[None, None, :] * stride_x_w\n                    \n                    x_val = tl.load(x_ptrs, mask=valid_mask, other=0.0)\n                    weight_val = tl.load(weight_ptr + ic * stride_w_ic + \\\n                                        oc * stride_w_oc + \\\n                                        kd * stride_w_d + \\\n                                        kh * stride_w_h + \\\n                                        kw * stride_w_w)\n                    \n                    acc += x_val * weight_val\n    \n    output_ptrs = output_ptr + b * stride_out_b + \\\n                 oc * stride_out_c + \\\n                 d_offsets[:, None, None] * stride_out_d + \\\n                 h_offsets[None, :, None] * stride_out_h + \\\n                 w_offsets[None, None, :] * stride_out_w\n                 \n    tl.store(output_ptrs, acc, mask=(\n        (d_offsets[:, None, None] < output_depth) & \n        (h_offsets[None, :, None] < output_height) & \n        (w_offsets[None, None, :] < output_width)\n    ))\n\nclass ModelNew(torch.nn.Module):\n    def __init__(self, in_channels: int, out_channels: int, kernel_size: int, \n                 stride: int = 1, padding: int = 0, dilation: int = 1, bias: bool = False):\n        super(ModelNew, self).__init__()\n        self.in_channels = in_channels\n        self.out_channels = out_channels\n        self.kernel_size = kernel_size\n        self.stride = stride\n        self.padding = padding\n        self.dilation = dilation\n        \n        self.weight = torch.nn.Parameter(\n            torch.empty(in_channels, out_channels, kernel_size, kernel_size, kernel_size)\n        )\n        if bias:\n            self.bias = torch.nn.Parameter(torch.empty(out_channels))\n        else:\n            self.register_parameter('bias', None)\n            \n        self.reset_parameters()\n\n    def reset_parameters(self):\n        torch.nn.init.kaiming_uniform_(self.weight, a=math.sqrt(5))\n        if self.bias is not None:\n            fan_in, _ = torch.nn.init._calculate_fan_in_and_fan_out(self.weight)\n            bound = 1 / math.sqrt(fan_in)\n            torch.nn.init.uniform_(self.bias, -bound, bound)\n\n    def forward(self, x: torch.Tensor) -> torch.Tensor:\n        batch_size, _, depth, height, width = x.shape\n        \n        output_depth = (depth - 1) * self.stride - 2 * self.padding + \\\n                      self.dilation * (self.kernel_size - 1) + 1\n        output_height = (height - 1) * self.stride - 2 * self.padding + \\\n                       self.dilation * (self.kernel_size - 1) + 1\n        output_width = (width - 1) * self.stride - 2 * self.padding + \\\n                      self.dilation * (self.kernel_size - 1) + 1\n        \n        output = torch.empty(\n            batch_size, \n            self.out_channels, \n            output_depth, \n            output_height, \n            output_width,\n            device=x.device, \n            dtype=x.dtype\n        )\n        \n        grid = lambda meta: (batch_size * self.out_channels * \n                            math.ceil(output_depth / meta['BLOCK_D']) * \n                            math.ceil(output_height / meta['BLOCK_H']) * \n                            math.ceil(output_width / meta['BLOCK_W']),)\n        \n        conv_transpose3d_kernel[grid](\n            x,\n            self.weight,\n            output,\n            self.in_channels,\n            self.out_channels,\n            depth,\n            height,\n            width,\n            self.kernel_size,\n            self.stride,\n            self.padding,\n            self.dilation,\n            output_depth,\n            output_height,\n            output_width,\n            x.stride(0), x.stride(1), x.stride(2), x.stride(3), x.stride(4),\n            self.weight.stride(0), self.weight.stride(1), \n            self.weight.stride(2), self.weight.stride(3), self.weight.stride(4),\n            output.stride(0), output.stride(1), \n            output.stride(2), output.stride(3), output.stride(4)\n        )\n        \n        if self.bias is not None:\n            output += self.bias.view(1, -1, 1, 1, 1)\n            \n        return output\n\n# Test code\nbatch_size = 16\nin_channels = 32\nout_channels = 64\nkernel_size = 3\ndepth = 16\nheight = 32\nwidth = 32\nstride = 2\npadding = 1\ndilation = 2\n\ndef get_inputs():\n    x = torch.randn(batch_size, in_channels, depth, height, width)\n    return [x]\n\ndef get_init_inputs():\n    return [in_channels, out_channels, kernel_size, stride, padding, dilation]\n# =================== EVOLVE-BLOCK-END ===================", "language": "python", "parent_id": "286bc68c-7587-4950-b33a-1780313ab139", "generation": 1, "timestamp": 1754645277.5259492, "iteration_found": 8, "metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": false, "score": 20, "speed_up": 0.0, "runtime_ms": 242.0, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:4", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.0534, "speed_up": 0.0, "custom_timing": 242.0}}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": true, "correctness": true, "stage": "reference code", "passed": false, "score": 0.0, "speed_up": 1.0, "runtime_ms": 1.97, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:7", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.0534, "speed_up": 0.027, "custom_timing": 1.97}}, "island": 0}, "artifacts_json": null, "artifact_dir": null}