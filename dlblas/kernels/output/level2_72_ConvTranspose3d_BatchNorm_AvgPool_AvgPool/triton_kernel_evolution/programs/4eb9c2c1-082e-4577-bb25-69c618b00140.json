{"id": "4eb9c2c1-082e-4577-bb25-69c618b00140", "code": "# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport triton\nimport triton.language as tl\n\nclass ModelNew(torch.nn.Module):\n    def __init__(self, in_channels, out_channels, kernel_size, stride, padding, bias_shape):\n        super().__init__()\n        self.conv_transpose = torch.nn.ConvTranspose3d(in_channels, out_channels, kernel_size, stride, padding)\n        self.batch_norm = torch.nn.BatchNorm3d(out_channels)\n        self.avg_pool1 = torch.nn.AvgPool3d(2)\n        self.avg_pool2 = torch.nn.AvgPool3d(2)\n        self.out_channels = out_channels\n\n    def forward(self, x):\n        if x.device.type == 'cuda':\n            return self.triton_forward(x)\n        else:\n            return self.pytorch_forward(x)\n    \n    def pytorch_forward(self, x):\n        x = self.conv_transpose(x)\n        x = self.batch_norm(x)\n        x = self.avg_pool1(x)\n        x = self.avg_pool2(x)\n        return x\n\n    def triton_forward(self, x):\n        # Get weights and parameters\n        weight = self.conv_transpose.weight\n        bias = self.conv_transpose.bias\n        gamma = self.batch_norm.weight\n        beta = self.batch_norm.bias\n        mean = self.batch_norm.running_mean\n        var = self.batch_norm.running_var\n        eps = 1e-5\n        \n        # Calculate output dimensions\n        B, C, D, H, W = x.shape\n        out_d = (D-1)*2 + 3 - 2*1\n        out_h = (H-1)*2 + 3 - 2*1\n        out_w = (W-1)*2 + 3 - 2*1\n        pool1_d, pool1_h, pool1_w = out_d//2, out_h//2, out_w//2\n        pool2_d, pool2_h, pool2_w = pool1_d//2, pool1_h//2, pool1_w//2\n        output = torch.empty((B, self.out_channels, pool2_d, pool2_h, pool2_w), \n                             device=x.device, dtype=x.dtype)\n        \n        # Launch kernel\n        grid = lambda opt: (triton.cdiv(B * self.out_channels, opt['BLOCK_SIZE_B']), \n                            triton.cdiv(pool2_d * pool2_h * pool2_w, opt['BLOCK_SIZE_ELEMS']))\n        \n        self.kernel[grid](\n            x, output, weight, bias,\n            gamma, beta, mean, var,\n            eps, C, D, H, W, \n            out_d, out_h, out_w,\n            pool1_d, pool1_h, pool1_w,\n            pool2_d, pool2_h, pool2_w,\n            x.stride(0), x.stride(1), x.stride(2), x.stride(3), x.stride(4),\n            output.stride(0), output.stride(1), output.stride(2), output.stride(3), output.stride(4),\n            BLOCK_SIZE_B=16, BLOCK_SIZE_ELEMS=128\n        )\n        return output\n\n    @triton.autotune(\n        configs=[\n            triton.Config({'BLOCK_SIZE_B': 16, 'BLOCK_SIZE_ELEMS': 128}, num_warps=4),\n            triton.Config({'BLOCK_SIZE_B': 8, 'BLOCK_SIZE_ELEMS': 256}, num_warps=4),\n            triton.Config({'BLOCK_SIZE_B': 32, 'BLOCK_SIZE_ELEMS': 64}, num_warps=8),\n            triton.Config({'BLOCK_SIZE_B': 16, 'BLOCK_SIZE_ELEMS': 256}, num_warps=8),\n        ],\n        key=['C', 'D', 'H', 'W', 'pool2_d', 'pool2_h', 'pool2_w'],\n    )\n    @triton.jit\n    def kernel(\n        x_ptr, out_ptr, weight_ptr, bias_ptr,\n        gamma_ptr, beta_ptr, mean_ptr, var_ptr,\n        eps, C, D, H, W, \n        out_d, out_h, out_w,\n        pool1_d, pool1_h, pool1_w,\n        pool2_d, pool2_h, pool2_w,\n        x_batch_stride, x_channel_stride, x_d_stride, x_h_stride, x_w_stride,\n        out_batch_stride, out_channel_stride, out_d_stride, out_h_stride, out_w_stride,\n        BLOCK_SIZE_B: tl.constexpr, BLOCK_SIZE_ELEMS: tl.constexpr\n    ):\n        # Program indices\n        pid_b = tl.program_id(0)\n        pid_e = tl.program_id(1)\n        \n        # Create ranges\n        batch_offsets = pid_b * BLOCK_SIZE_B + tl.arange(0, BLOCK_SIZE_B)\n        elem_offsets = pid_e * BLOCK_SIZE_ELEMS + tl.arange(0, BLOCK_SIZE_ELEMS)\n        \n        # Compute spatial indices\n        spatial_size = pool2_d * pool2_h * pool2_w\n        d_idx = elem_offsets // (pool2_h * pool2_w)\n        hw_idx = elem_offsets % (pool2_h * pool2_w)\n        h_idx = hw_idx // pool2_w\n        w_idx = hw_idx % pool2_w\n        \n        # Create masks\n        batch_mask = batch_offsets < B * C\n        elem_mask = elem_offsets < spatial_size\n        \n        # Initialize accumulator\n        acc = tl.zeros((BLOCK_SIZE_B, BLOCK_SIZE_ELEMS), dtype=tl.float32)\n        \n        # Precompute source spatial positions\n        src_d = d_idx * 4\n        src_h = h_idx * 4\n        src_w = w_idx * 4\n        \n        # Loop over kernel and input channels\n        for c in range(0, C):\n            for kd in range(3):\n                for kh in range(3):\n                    for kw in range(3):\n                        # Compute input indices\n                        in_d = (src_d + kd - 1) // 2\n                        in_h = (src_h + kh - 1) // 2\n                        in_w = (src_w + kw - 1) // 2\n                        \n                        # Check boundaries\n                        d_bound = (in_d >= 0) & (in_d < D)\n                        h_bound = (in_h >= 0) & (in_h < H)\n                        w_bound = (in_w >= 0) & (in_w < W)\n                        in_bounds = d_bound & h_bound & w_bound\n                        \n                        # Compute pointers\n                        x_offset = (\n                            batch_offsets[:, None] * x_batch_stride +\n                            c * x_channel_stride +\n                            in_d * x_d_stride +\n                            in_h * x_h_stride +\n                            in_w * x_w_stride\n                        )\n                        w_offset = (\n                            batch_offsets[:, None] % C * 3*3*3*C +\n                            c * 3*3*3 +\n                            kd * 3*3 +\n                            kh * 3 +\n                            kw\n                        )\n                        \n                        # Load data with masking\n                        x_val = tl.load(x_ptr + x_offset, mask=in_bounds & batch_mask[:, None] & elem_mask[None, :], other=0.0)\n                        w_val = tl.load(weight_ptr + w_offset, mask=in_bounds & batch_mask[:, None] & elem_mask[None, :], other=0.0)\n                        \n                        # Accumulate\n                        acc += x_val * w_val\n        \n        # Add bias\n        bias_offset = batch_offsets[:, None] % C\n        b_val = tl.load(bias_ptr + bias_offset, mask=batch_mask[:, None], other=0.0)\n        acc += b_val\n        \n        # Batch normalization\n        gamma_val = tl.load(gamma_ptr + bias_offset, mask=batch_mask[:, None], other=0.0)\n        beta_val = tl.load(beta_ptr + bias_offset, mask=batch_mask[:, None], other=0.0)\n        mean_val = tl.load(mean_ptr + bias_offset, mask=batch_mask[:, None], other=0.0)\n        var_val = tl.load(var_ptr + bias_offset, mask=batch_mask[:, None], other=0.0)\n        \n        norm = (acc - mean_val) / tl.sqrt(var_val + eps)\n        result = gamma_val * norm + beta_val\n        \n        # Average pooling (4x4x4 window)\n        result = result / 64.0\n        \n        # Store results\n        out_offset = (\n            (batch_offsets // C)[:, None] * out_batch_stride +\n            (batch_offsets % C)[:, None] * out_channel_stride +\n            d_idx[None, :] * out_d_stride +\n            h_idx[None, :] * out_h_stride +\n            w_idx[None, :] * out_w_stride\n        )\n        tl.store(out_ptr + out_offset, result, mask=batch_mask[:, None] & elem_mask[None, :])\n\nbatch_size = 128\nin_channels = 3\nout_channels = 16\ndepth, height, width = 32, 32, 32\nkernel_size = 3\nstride = 2\npadding = 1\nbias_shape = (out_channels, 1, 1, 1)\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_channels, depth, height, width)]\n\ndef get_init_inputs():\n    return [in_channels, out_channels, kernel_size, stride, padding, bias_shape]\n# =================== EVOLVE-BLOCK-END ===================", "language": "python", "parent_id": "24890950-ede3-417c-8a65-d2d694c72a9c", "generation": 1, "timestamp": 1754578582.3550336, "iteration_found": 0, "metrics": {"compiled": true, "correctness": false, "score": 10, "stage": "wrong_answer", "verify_payload": {"id": "level2_72_ConvTranspose3d_BatchNorm_AvgPool_AvgPool", "result": {"compiled": true, "correctness": false, "metadata": {"hardware": "NVIDIA L20Y", "device": "cuda:4", "runtime_error": "Traceback (most recent call last):\n  File \"/cpfs01/shared/llm_kernel/hujiakai/KernelLLM/validation_api_server/helpers/evaluations.py\", line 720, in run_and_check_correctness\n    output_new = model_new(*inputs)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1773, in _wrapped_call_impl\n    return self._call_impl(*args, **kwargs)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1784, in _call_impl\n    return forward_call(*args, **kwargs)\n  File \"/tmp/tmpxotb37zb.py\", line 17, in forward\n    return self.triton_forward(x)\n  File \"/tmp/tmpxotb37zb.py\", line 52, in triton_forward\n    self.kernel[grid](\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 390, in <lambda>\n    return lambda *args, **kwargs: self.run(grid=grid, warmup=False, *args, **kwargs)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 239, in run\n    benchmark()\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 228, in benchmark\n    timings = {config: self._bench(*args, config=config, **kwargs) for config in pruned_configs}\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 228, in <dictcomp>\n    timings = {config: self._bench(*args, config=config, **kwargs) for config in pruned_configs}\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 135, in _bench\n    raise ValueError(f\"Conflicting meta-parameters: {', '.join(conflicts)}.\"\nValueError: Conflicting meta-parameters: BLOCK_SIZE_ELEMS, BLOCK_SIZE_B. Make sure that you don't re-define auto-tuned symbols.\n", "runtime_error_name": "builtins.ValueError", "reference_timing_ms": 0.133, "speed_up": -1.0, "custom_timing": -1.0}, "runtime": -1.0, "runtime_stats": {}}}}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": true, "correctness": true, "stage": "reference code", "passed": false, "score": 0.0, "speed_up": 1.0, "runtime_ms": 24.4, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:7", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.133, "speed_up": 0.005, "custom_timing": 24.4}}, "island": 0}, "artifacts_json": null, "artifact_dir": null}