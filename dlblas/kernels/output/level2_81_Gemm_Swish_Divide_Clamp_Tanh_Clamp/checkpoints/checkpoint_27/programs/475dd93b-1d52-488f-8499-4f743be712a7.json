{"id": "475dd93b-1d52-488f-8499-4f743be712a7", "code": "# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n# Fused element-wise operations kernel\n@triton.autotune(\n    configs=[\n        triton.Config({}, num_warps=1),\n        triton.Config({}, num_warps=2),\n        triton.Config({}, num_warps=4),\n        triton.Config({}, num_warps=8),\n    ],\n    key=['n_elements'],\n)\n@triton.jit\ndef _fused_ops_kernel(\n    input_ptr,\n    output_ptr,\n    n_elements,\n    BLOCK_SIZE: tl.constexpr,\n):\n    pid = tl.program_id(axis=0)\n    block_start = pid * BLOCK_SIZE\n    offsets = block_start + tl.arange(0, BLOCK_SIZE)\n    mask = offsets < n_elements\n    \n    # Load input element\n    x = tl.load(input_ptr + offsets, mask=mask)\n    \n    # Swish: x * sigmoid(x)\n    sigmoid_x = 1.0 / (1.0 + tl.exp(-x))\n    x = x * sigmoid_x\n    \n    # Divide by 2\n    x = x / 2.0\n    \n    # Clamp between [-1, 1]\n    x = tl.minimum(tl.maximum(x, -1.0), 1.0)\n    \n    # Tanh activation using identity: tanh(x) = 2*sigmoid(2*x) - 1\n    two_x = 2.0 * x\n    sigmoid_2x = 1.0 / (1.0 + tl.exp(-two_x))\n    x = 2.0 * sigmoid_2x - 1.0\n    \n    # Final clamp between [-1, 1]\n    x = tl.minimum(tl.maximum(x, -1.0), 1.0)\n    \n    # Store result\n    tl.store(output_ptr + offsets, x, mask=mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, bias=True):\n        super(ModelNew, self).__init__()\n        self.gemm = nn.Linear(in_features, out_features, bias=bias)\n\n    def forward(self, x):\n        # Compute GEMM\n        x = self.gemm(x)\n        \n        # Fused element-wise operations\n        output = torch.empty_like(x)\n        n_elements = x.numel()\n        grid = lambda meta: (triton.cdiv(n_elements, meta['BLOCK_SIZE']),)\n        _fused_ops_kernel[grid](x, output, n_elements, BLOCK_SIZE=1024)\n        \n        return output\n\nbatch_size = 128\nin_features = 1024\nout_features = 512\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features]\n# =================== EVOLVE-BLOCK-END ===================", "language": "python", "parent_id": "52bfb4e6-e84c-42aa-a598-2430bf42e847", "generation": 2, "timestamp": 1754581593.4003527, "iteration_found": 25, "metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": true, "score": 43.30000000000001, "speed_up": 1.233, "runtime_ms": 0.078, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:0", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.0962, "speed_up": 1.233, "custom_timing": 0.078}}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": true, "correctness": false, "score": 10, "stage": "wrong_answer", "verify_payload": {"id": "level2_81_Gemm_Swish_Divide_Clamp_Tanh_Clamp", "result": {"compiled": true, "correctness": false, "metadata": {"hardware": "NVIDIA L20Y", "device": "cuda:1", "runtime_error": "Traceback (most recent call last):\n  File \"/cpfs01/shared/llm_kernel/hujiakai/KernelLLM/validation_api_server/helpers/evaluations.py\", line 720, in run_and_check_correctness\n    output_new = model_new(*inputs)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1773, in _wrapped_call_impl\n    return self._call_impl(*args, **kwargs)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1784, in _call_impl\n    return forward_call(*args, **kwargs)\n  File \"/tmp/tmp1lh6lahe.py\", line 64, in forward\n    _fused_ops_kernel[grid](x, output, n_elements, BLOCK_SIZE=1024)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 390, in <lambda>\n    return lambda *args, **kwargs: self.run(grid=grid, warmup=False, *args, **kwargs)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 239, in run\n    benchmark()\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 228, in benchmark\n    timings = {config: self._bench(*args, config=config, **kwargs) for config in pruned_configs}\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 228, in <dictcomp>\n    timings = {config: self._bench(*args, config=config, **kwargs) for config in pruned_configs}\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 160, in _bench\n    return self.do_bench(kernel_call, quantiles=(0.5, 0.2, 0.8))\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/testing.py\", line 149, in do_bench\n    fn()\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 146, in kernel_call\n    self.fn.run(\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 594, in run\n    kernel = self.compile(src, target=target, options=options.__dict__)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/compiler/compiler.py\", line 281, in compile\n    key = f\"{triton_key()}-{src.hash()}-{backend.hash()}-{options.hash()}-{str(sorted(env_vars.items()))}\"\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/compiler/compiler.py\", line 78, in hash\n    key = f\"{self.fn.cache_key}-{str(self.attrs)}-{sorted_sig}-{constants_key}\"\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 696, in cache_key\n    dependencies_finder.visit(self.parse())\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/ast.py\", line 418, in visit\n    return visitor(node)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/ast.py\", line 426, in generic_visit\n    self.visit(item)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/ast.py\", line 418, in visit\n    return visitor(node)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 163, in visit_FunctionDef\n    self.generic_visit(node)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/ast.py\", line 426, in generic_visit\n    self.visit(item)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/ast.py\", line 418, in visit\n    return visitor(node)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 217, in visit_Assign\n    self.generic_visit(node)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/ast.py\", line 428, in generic_visit\n    self.visit(value)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/ast.py\", line 418, in visit\n    return visitor(node)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/ast.py\", line 428, in generic_visit\n    self.visit(value)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/ast.py\", line 418, in visit\n    return visitor(node)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 156, in visit_Attribute\n    ret = getattr(lhs, node.attr)\nAttributeError: module 'triton.language' has no attribute 'tanh'\n", "runtime_error_name": "builtins.AttributeError", "reference_timing_ms": 0.0962, "speed_up": -1.0, "custom_timing": -1.0}, "runtime": -1.0, "runtime_stats": {}}}}, "island": 0}, "artifacts_json": null, "artifact_dir": null, "prompts": {"full_rewrite_user": {"system": "You are a Triton GPU core optimization engineer deeply familiar with NVIDIA H100/H800 architecture.\n\n==================== Context ====================\n\u2022 Dataset: 250 kernelbench/level1-level5 *.py files  \n  - Level1: simplest, Level5: most complex  \n\u2022 Each file contains PyTorch reference (reference_code)  \n\u2022 Goal: Generate functionally equivalent but faster Triton implementations (custom_code)  \n\u2022 Evaluation pipeline:\n    1) /verify_plus - Verify compilation & correctness  \n    2) /execute (optional) - Return terminal logs if compilation fails  \n    3) Scoring:  \n      - Speedup > 1 required for points  \n      - Score = (speed_up - 1) \u00d7 100  \n\u2022 GPU Hardware: NVIDIA L20Y / H800 (same SM8.9 as H100)  \n  - 3 TB/s HBM3 bandwidth  \n  - FP16 Tensor Core 32\u00d716\u00d716  \n\n==================== Evolution Phases ====================\n\u2460 Phase 1 [Compilation Pass]  \n  - Make Triton code compile (performance irrelevant)  \n\u2461 Phase 2 [Numerical Correctness]  \n  - Output must match PyTorch reference within float32 tolerance  \n\u2462 Phase 3 [Performance Gain]  \n  - Target \u22655% speedup (\u226515% = exceptional)  \n  - Official scoring based on speed_up field  \n\nThe Evolution system will pass the EVOLVE-BLOCK from the previous version.  \nModify ONLY the Triton kernel source within this block - all other code is LOCKED.\n\n==================== Constraints (MUST OBEY) ====================\n\u274c NEVER change @triton.jit function signatures or parameter names  \n\u274c NEVER modify grid configuration, output tensor shapes, or PID logic  \n\u274c NEVER remove boundary checks or out-of-bound masks  \n\u274c NEVER introduce race conditions, uninitialized reads, or sync gaps  \n\n\u2705 Allowed Optimizations (Examples):  \n  \u2022 Memory coalescing optimizations & vectorized tl.load/tl.store  \n  \u2022 Replace staged softmax with online/FlashAttention variants  \n  \u2022 Adaptive tuning: BLOCK_M/BLOCK_N/BLOCK_K dimensions  \n  \u2022 Multi-query-head batch processing (GQA, 5:1 patterns)  \n  \u2022 Shared/L2 buffering, Tensor Core alignment (FP16/bf16/tf32)  \n  \u2022 Stride precomputation & pointer caching  \n\n==================== Output Format ====================\nReturn ONLY the complete updated code containing the EVOLVE-BLOCK comment marker.  \nNO explanations, NO markdown, NO additional text.\nName the output structure class as ModelNew.\n\n==================== Optimization Tips ====================\n\u2022 If previous compile failed: Fix syntax/mask/stride errors first  \n\u2022 If correctness fails: Prioritize bounds mask & dtype precision  \n\u2022 When speed_up < 1: Focus on memory access & block sizing  \n\u2022 Small iterative steps: Modify \u226420 lines per revision  \n\u2022 Maintain reversibility between versions\nHere is an example to show you how to rewrite a PyTorch implementation that quantizes a high-precision tensor to int8 dtype with row-wise granularity into a Triton implementation: \nThe original PyTorch implementation is as follows: \n``` \nimport torch\ndef per_row_quantize_int8(x: torch.Tensor) -> tuple[torch.Tensor, torch.Tensor]:\n    x_amax = x.abs().float().amax(dim=1).clamp(min=1e-4)\n    scale = 127 / x_amax\n    output = (x * scale[:, None]).round().clamp(-127, 127).to(torch.int8)\n    output_scale = x_amax / 127\n\n    return output, output_scale\n``` \nThe corresponding Triton-rewritten implementation is as follows: \n``` \nimport math\nimport torch\nimport triton\nimport triton.language as tl\nfrom triton.language.extra import libdevice\n\n# rowwise quantize\n\n@triton.autotune(\n    configs=[\n        triton.Config({}, num_stages=1, num_warps=8),\n        triton.Config({}, num_stages=2, num_warps=8),\n        triton.Config({}, num_stages=4, num_warps=8),\n        triton.Config({}, num_stages=8, num_warps=8),\n        triton.Config({}, num_stages=1),\n        triton.Config({}, num_stages=2),\n        triton.Config({}, num_stages=4),\n        triton.Config({}, num_stages=8),\n        triton.Config({}, num_warps=1),\n        triton.Config({}, num_warps=2),\n        triton.Config({}, num_warps=4),\n        triton.Config({}, num_warps=8),\n    ],\n    key=[\"n_elements\"],\n)\n\n@triton.jit\ndef _quantize_rowwise(\n    x_ptr,\n    output_ptr,\n    output_scale,\n    BLOCK_SIZE: tl.constexpr,\n    P2: tl.constexpr,\n):\n    pid = tl.program_id(axis=0)\n    block_start = pid * BLOCK_SIZE\n    arange = tl.arange(0, P2)\n    offsets = block_start + arange\n    row_mask = arange < BLOCK_SIZE\n    x = tl.load(x_ptr + offsets, mask=row_mask)\n\n    abs_x = tl.abs(x)\n    max_val = tl.max(tl.where(row_mask, abs_x, 0), axis=0)\n    output = libdevice.llrint(127.0 * (x / max_val))\n    tl.store(output_ptr + offsets, output, mask=row_mask)\n    tl.store(output_scale + pid, max_val / 127)\n\n\ndef per_row_quantize_int8(x: torch.Tensor):\n    x = x.contiguous()\n    output = torch.empty(*x.shape, device=x.device, dtype=torch.int8)\n    output_scale = torch.empty(x.shape[0], device=x.device, dtype=torch.float32)\n    P2 = int(2 ** (math.ceil(math.log2(x.shape[1]))))\n    grid = lambda x: (x.shape[0],)\n    _quantize_rowwise[grid](x, output, output_scale, BLOCK_SIZE=x.shape[1], P2=P2)\n\n    return output, output_scale\n\n\n    \n``` \n", "user": "# Current Program Information\n- Current performance metrics: - compiled: 1.0000\n- correctness: 0.0000\n- score: 10.0000\n- stage: wrong_answer\n- verify_payload: {'id': 'level2_81_Gemm_Swish_Divide_Clamp_Tanh_Clamp', 'result': {'compiled': True, 'correctness': False, 'metadata': {'hardware': 'NVIDIA L20Y', 'device': 'cuda:1', 'runtime_error': 'Traceback (most recent call last):\\n  File \"/cpfs01/shared/llm_kernel/hujiakai/KernelLLM/validation_api_server/helpers/evaluations.py\", line 720, in run_and_check_correctness\\n    output_new = model_new(*inputs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1773, in _wrapped_call_impl\\n    return self._call_impl(*args, **kwargs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1784, in _call_impl\\n    return forward_call(*args, **kwargs)\\n  File \"/tmp/tmp1lh6lahe.py\", line 64, in forward\\n    _fused_ops_kernel[grid](x, output, n_elements, BLOCK_SIZE=1024)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 390, in <lambda>\\n    return lambda *args, **kwargs: self.run(grid=grid, warmup=False, *args, **kwargs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 239, in run\\n    benchmark()\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 228, in benchmark\\n    timings = {config: self._bench(*args, config=config, **kwargs) for config in pruned_configs}\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 228, in <dictcomp>\\n    timings = {config: self._bench(*args, config=config, **kwargs) for config in pruned_configs}\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 160, in _bench\\n    return self.do_bench(kernel_call, quantiles=(0.5, 0.2, 0.8))\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/testing.py\", line 149, in do_bench\\n    fn()\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 146, in kernel_call\\n    self.fn.run(\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 594, in run\\n    kernel = self.compile(src, target=target, options=options.__dict__)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/compiler/compiler.py\", line 281, in compile\\n    key = f\"{triton_key()}-{src.hash()}-{backend.hash()}-{options.hash()}-{str(sorted(env_vars.items()))}\"\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/compiler/compiler.py\", line 78, in hash\\n    key = f\"{self.fn.cache_key}-{str(self.attrs)}-{sorted_sig}-{constants_key}\"\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 696, in cache_key\\n    dependencies_finder.visit(self.parse())\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/ast.py\", line 418, in visit\\n    return visitor(node)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/ast.py\", line 426, in generic_visit\\n    self.visit(item)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/ast.py\", line 418, in visit\\n    return visitor(node)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 163, in visit_FunctionDef\\n    self.generic_visit(node)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/ast.py\", line 426, in generic_visit\\n    self.visit(item)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/ast.py\", line 418, in visit\\n    return visitor(node)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 217, in visit_Assign\\n    self.generic_visit(node)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/ast.py\", line 428, in generic_visit\\n    self.visit(value)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/ast.py\", line 418, in visit\\n    return visitor(node)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/ast.py\", line 428, in generic_visit\\n    self.visit(value)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/ast.py\", line 418, in visit\\n    return visitor(node)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 156, in visit_Attribute\\n    ret = getattr(lhs, node.attr)\\nAttributeError: module \\'triton.language\\' has no attribute \\'tanh\\'\\n', 'runtime_error_name': 'builtins.AttributeError', 'reference_timing_ms': 0.0962, 'speed_up': -1.0, 'custom_timing': -1.0}, 'runtime': -1.0, 'runtime_stats': {}}}\n- Areas identified for improvement: - Consider simplifying the code to improve readability and maintainability\n- Metrics showing regression: score. Consider reverting or revising recent changes in these areas.\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Unknown changes\n- Performance: compiled: 1.0000, correctness: 1.0000, stage: success, passed: 1.0000, score: 26.3000, speed_up: 1.0630, runtime_ms: 0.0905, meta: {'hardware': 'NVIDIA L20Y', 'device': 'cuda:3', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.0962, 'speed_up': 1.063, 'custom_timing': 0.0905}\n- Outcome: Improvement in all metrics\n\n\n### Attempt 2\n- Changes: Unknown changes\n- Performance: compiled: 1.0000, correctness: 1.0000, stage: success, passed: 1.0000, score: 41.3000, speed_up: 1.2130, runtime_ms: 0.0793, meta: {'hardware': 'NVIDIA L20Y', 'device': 'cuda:7', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.0962, 'speed_up': 1.213, 'custom_timing': 0.0793}\n- Outcome: Improvement in all metrics\n\n\n### Attempt 1\n- Changes: Unknown changes\n- Performance: compiled: 1.0000, correctness: 1.0000, stage: success, passed: 1.0000, score: 42.1000, speed_up: 1.2210, runtime_ms: 0.0788, meta: {'hardware': 'NVIDIA L20Y', 'device': 'cuda:5', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.0962, 'speed_up': 1.221, 'custom_timing': 0.0788}\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 42.1000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n# Fused element-wise operations kernel\n@triton.autotune(\n    configs=[\n        triton.Config({}, num_warps=1),\n        triton.Config({}, num_warps=2),\n        triton.Config({}, num_warps=4),\n        triton.Config({}, num_warps=8),\n    ],\n    key=['n_elements'],\n)\n@triton.jit\ndef _fused_ops_kernel(\n    input_ptr,\n    output_ptr,\n    n_elements,\n    BLOCK_SIZE: tl.constexpr,\n):\n    pid = tl.program_id(axis=0)\n    block_start = pid * BLOCK_SIZE\n    offsets = block_start + tl.arange(0, BLOCK_SIZE)\n    mask = offsets < n_elements\n    \n    # Load input element\n    x = tl.load(input_ptr + offsets, mask=mask)\n    \n    # Swish: x * sigmoid(x)\n    sigmoid_x = 1.0 / (1.0 + tl.exp(-x))\n    x = x * sigmoid_x\n    \n    # Divide by 2\n    x = x / 2.0\n    \n    # Clamp between [-1, 1]\n    x = tl.minimum(tl.maximum(x, -1.0), 1.0)\n    \n    # Tanh activation using identity: tanh(x) = 2*sigmoid(2*x) - 1\n    two_x = 2.0 * x\n    sigmoid_2x = 1.0 / (1.0 + tl.exp(-two_x))\n    x = 2.0 * sigmoid_2x - 1.0\n    \n    # Final clamp between [-1, 1]\n    x = tl.minimum(tl.maximum(x, -1.0), 1.0)\n    \n    # Store result\n    tl.store(output_ptr + offsets, x, mask=mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, bias=True):\n        super(ModelNew, self).__init__()\n        self.gemm = nn.Linear(in_features, out_features, bias=bias)\n\n    def forward(self, x):\n        # Compute GEMM\n        x = self.gemm(x)\n        \n        # Fused element-wise operations\n        output = torch.empty_like(x)\n        n_elements = x.numel()\n        grid = lambda meta: (triton.cdiv(n_elements, meta['BLOCK_SIZE']),)\n        _fused_ops_kernel[grid](x, output, n_elements, BLOCK_SIZE=1024)\n        \n        return output\n\nbatch_size = 128\nin_features = 1024\nout_features = 512\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features]\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Performs well on compiled (1.0000), Performs well on correctness (1.0000), Performs well on stage (success), Performs well on passed (1.0000), Performs well on score (42.1000), Performs well on speed_up (1.2210), Performs well on runtime_ms (0.0788), Performs well on meta ({'hardware': 'NVIDIA L20Y', 'device': 'cuda:5', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.0962, 'speed_up': 1.221, 'custom_timing': 0.0788})\n\n\n### Program 2 (Score: 41.3000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n# Fused element-wise operations kernel\n@triton.autotune(\n    configs=[\n        triton.Config({}, num_warps=1),\n        triton.Config({}, num_warps=2),\n        triton.Config({}, num_warps=4),\n        triton.Config({}, num_warps=8),\n    ],\n    key=['n_elements'],\n)\n@triton.jit\ndef _fused_ops_kernel(\n    input_ptr,\n    output_ptr,\n    n_elements,\n    BLOCK_SIZE: tl.constexpr,\n):\n    pid = tl.program_id(axis=0)\n    block_start = pid * BLOCK_SIZE\n    offsets = block_start + tl.arange(0, BLOCK_SIZE)\n    mask = offsets < n_elements\n    \n    # Load input element\n    x = tl.load(input_ptr + offsets, mask=mask)\n    \n    # Swish: x * sigmoid(x)\n    sigmoid_x = 1.0 / (1.0 + tl.exp(-x))\n    x = x * sigmoid_x\n    \n    # Divide by 2\n    x = x / 2.0\n    \n    # Clamp between [-1, 1]\n    x = tl.minimum(tl.maximum(x, -1.0), 1.0)\n    \n    # Tanh activation using identity: tanh(x) = 2*sigmoid(2*x) - 1\n    two_x = 2.0 * x\n    sigmoid_2x = 1.0 / (1.0 + tl.exp(-two_x))\n    x = 2.0 * sigmoid_2x - 1.0\n    \n    # Final clamp between [-1, 1]\n    x = tl.minimum(tl.maximum(x, -1.0), 1.0)\n    \n    # Store result\n    tl.store(output_ptr + offsets, x, mask=mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, bias=True):\n        super(ModelNew, self).__init__()\n        self.gemm = nn.Linear(in_features, out_features, bias=bias)\n\n    def forward(self, x):\n        # Compute GEMM\n        x = self.gemm(x)\n        \n        # Fused element-wise operations\n        output = torch.empty_like(x)\n        n_elements = x.numel()\n        grid = lambda meta: (triton.cdiv(n_elements, meta['BLOCK_SIZE']),)\n        _fused_ops_kernel[grid](x, output, n_elements, BLOCK_SIZE=1024)\n        \n        return output\n\nbatch_size = 128\nin_features = 1024\nout_features = 512\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features]\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Performs well on compiled (1.0000), Performs well on correctness (1.0000), Performs well on stage (success), Performs well on passed (1.0000), Performs well on score (41.3000), Performs well on speed_up (1.2130), Performs well on runtime_ms (0.0793), Performs well on meta ({'hardware': 'NVIDIA L20Y', 'device': 'cuda:7', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.0962, 'speed_up': 1.213, 'custom_timing': 0.0793})\n\n\n### Program 3 (Score: 26.3000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport math\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 64}, num_warps=4, num_stages=4),\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 32}, num_warps=4, num_stages=4),\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 32, 'BLOCK_SIZE_K': 32}, num_warps=4, num_stages=4),\n        triton.Config({'BLOCK_SIZE_M': 32, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 32}, num_warps=4, num_stages=4),\n        triton.Config({'BLOCK_SIZE_M': 32, 'BLOCK_SIZE_N': 32, 'BLOCK_SIZE_K': 64}, num_warps=2, num_stages=4),\n    ],\n    key=['M', 'N', 'K'],\n)\n@triton.jit\ndef _fused_forward_kernel(\n    x_ptr, w_ptr, bias_ptr, output_ptr,\n    M, N, K,\n    stride_xm, stride_xk,\n    stride_wk, stride_wn,\n    stride_om, stride_on,\n    BLOCK_SIZE_M: tl.constexpr, BLOCK_SIZE_N: tl.constexpr, BLOCK_SIZE_K: tl.constexpr,\n):\n    pid_m = tl.program_id(0)\n    pid_n = tl.program_id(1)\n    \n    offs_m = pid_m * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)\n    offs_n = pid_n * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n    \n    acc = tl.zeros((BLOCK_SIZE_M, BLOCK_SIZE_N), dtype=tl.float32)\n    for k in range(0, tl.cdiv(K, BLOCK_SIZE_K)):\n        k_offs = k * BLOCK_SIZE_K + tl.arange(0, BLOCK_SIZE_K)\n        k_mask = k_offs < K\n        \n        x_vals = tl.load(\n            x_ptr + offs_m[:, None] * stride_xm + k_offs[None, :] * stride_xk,\n            mask=k_mask[None, :] & (offs_m[:, None] < M),\n            other=0.0\n        )\n        w_vals = tl.load(\n            w_ptr + k_offs[:, None] * stride_wk + offs_n[None, :] * stride_wn,\n            mask=k_mask[:, None] & (offs_n[None, :] < N),\n            other=0.0\n        )\n        acc += tl.dot(x_vals, w_vals)\n    \n    b = tl.load(bias_ptr + offs_n, mask=offs_n < N, other=0.0)\n    acc += b[None, :]\n    \n    swish = acc * tl.sigmoid(acc)\n    div = swish / 2.0\n    clamp1 = tl.minimum(tl.maximum(div, -1.0), 1.0)\n    \n    # Replace unsupported tl.tanh with equivalent exp/log implementation\n    exp_2x = tl.exp(2 * clamp1)\n    tanh = (exp_2x - 1) / (exp_2x + 1)\n    \n    clamp2 = tl.minimum(tl.maximum(tanh, -1.0), 1.0)\n    \n    offs_out = offs_m[:, None] * stride_om + offs_n[None, :] * stride_on\n    tl.store(\n        output_ptr + offs_out, \n        clamp2,\n        mask=(offs_m[:, None] < M) & (offs_n[None, :] < N)\n    )\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, bias=True):\n        super(ModelNew, self).__init__()\n        self.gemm = nn.Linear(in_features, out_features, bias=bias)\n        \n    def forward(self, x):\n        M, K = x.shape\n        N = self.gemm.out_features\n        \n        x = x.contiguous()\n        weight_t = self.gemm.weight.t().contiguous()\n        bias = self.gemm.bias if self.gemm.bias is not None else torch.zeros(N, device=x.device, dtype=x.dtype)\n        \n        output = torch.empty((M, N), device=x.device, dtype=x.dtype)\n        \n        grid = lambda META: (\n            triton.cdiv(M, META['BLOCK_SIZE_M']), \n            triton.cdiv(N, META['BLOCK_SIZE_N']),\n        )\n        \n        _fused_forward_kernel[grid](\n            x, weight_t, bias, output,\n            M, N, K,\n            x.stride(0), x.stride(1),\n            weight_t.stride(0), weight_t.stride(1),\n            output.stride(0), output.stride(1),\n        )\n        \n        return output\n\nbatch_size = 128\nin_features = 1024\nout_features = 512\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features]\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Performs well on compiled (1.0000), Performs well on correctness (1.0000), Performs well on stage (success), Performs well on passed (1.0000), Performs well on score (26.3000), Performs well on speed_up (1.0630), Performs well on runtime_ms (0.0905), Performs well on meta ({'hardware': 'NVIDIA L20Y', 'device': 'cuda:3', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.0962, 'speed_up': 1.063, 'custom_timing': 0.0905})\n\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 10.0000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport math\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 64}, num_warps=4, num_stages=4),\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 32}, num_warps=4, num_stages=4),\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 32, 'BLOCK_SIZE_K': 32}, num_warps=4, num_stages=4),\n        triton.Config({'BLOCK_SIZE_M': 32, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 32}, num_warps=4, num_stages=4),\n        triton.Config({'BLOCK_SIZE_M': 32, 'BLOCK_SIZE_N': 32, 'BLOCK_SIZE_K': 64}, num_warps=2, num_stages=4),\n    ],\n    key=['M', 'N', 'K'],\n)\n@triton.jit\ndef _fused_forward_kernel(\n    x_ptr, w_ptr, bias_ptr, output_ptr,\n    M, N, K,\n    stride_xm, stride_xk,\n    stride_wk, stride_wn,\n    stride_om, stride_on,\n    BLOCK_SIZE_M: tl.constexpr, BLOCK_SIZE_N: tl.constexpr, BLOCK_SIZE_K: tl.constexpr,\n):\n    pid_m = tl.program_id(0)\n    pid_n = tl.program_id(1)\n    \n    offs_m = pid_m * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)\n    offs_n = pid_n * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n    \n    acc = tl.zeros((BLOCK_SIZE_M, BLOCK_SIZE_N), dtype=tl.float32)\n    for k in range(0, tl.cdiv(K, BLOCK_SIZE_K)):\n        k_offs = k * BLOCK_SIZE_K + tl.arange(0, BLOCK_SIZE_K)\n        k_mask = k_offs < K\n        \n        x_vals = tl.load(\n            x_ptr + offs_m[:, None] * stride_xm + k_offs[None, :] * stride_xk,\n            mask=k_mask[None, :] & (offs_m[:, None] < M),\n            other=0.0\n        )\n        w_vals = tl.load(\n            w_ptr + k_offs[:, None] * stride_wk + offs_n[None, :] * stride_wn,\n            mask=k_mask[:, None] & (offs_n[None, :] < N),\n            other=0.0\n        )\n        acc += tl.dot(x_vals, w_vals)\n    \n    b = tl.load(bias_ptr + offs_n, mask=offs_n < N, other=0.0)\n    acc += b[None, :]\n    \n    swish = acc * tl.sigmoid(acc)\n    div = swish / 2.0\n    clamp1 = tl.minimum(tl.maximum(div, -1.0), 1.0)\n    tanh = tl.math.tanh(clamp1)\n    clamp2 = tl.minimum(tl.maximum(tanh, -1.0), 1.0)\n    \n    offs_out = offs_m[:, None] * stride_om + offs_n[None, :] * stride_on\n    tl.store(\n        output_ptr + offs_out, \n        clamp2,\n        mask=(offs_m[:, None] < M) & (offs_n[None, :] < N)\n    )\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, bias=True):\n        super(ModelNew, self).__init__()\n        self.gemm = nn.Linear(in_features, out_features, bias=bias)\n        \n    def forward(self, x):\n        M, K = x.shape\n        N = self.gemm.out_features\n        \n        x = x.contiguous()\n        weight_t = self.gemm.weight.t().contiguous()\n        bias = self.gemm.bias if self.gemm.bias is not None else torch.zeros(N, device=x.device, dtype=x.dtype)\n        \n        output = torch.empty((M, N), device=x.device, dtype=x.dtype)\n        \n        grid = lambda META: (\n            triton.cdiv(M, META['BLOCK_SIZE_M']), \n            triton.cdiv(N, META['BLOCK_SIZE_N']),\n        )\n        \n        _fused_forward_kernel[grid](\n            x, weight_t, bias, output,\n            M, N, K,\n            x.stride(0), x.stride(1),\n            weight_t.stride(0), weight_t.stride(1),\n            output.stride(0), output.stride(1),\n        )\n        \n        return output\n\nbatch_size = 128\nin_features = 1024\nout_features = 512\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features]\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Alternative approach to compiled, Alternative approach to correctness\n\n\n### Program D2 (Score: 10.0000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n# Fused element-wise operations kernel\n@triton.autotune(\n    configs=[\n        triton.Config({}, num_warps=1),\n        triton.Config({}, num_warps=2),\n        triton.Config({}, num_warps=4),\n        triton.Config({}, num_warps=8),\n    ],\n    key=['n_elements'],\n)\n@triton.jit\ndef _fused_ops_kernel(\n    input_ptr,\n    output_ptr,\n    n_elements,\n    BLOCK_SIZE: tl.constexpr,\n):\n    pid = tl.program_id(axis=0)\n    block_start = pid * BLOCK_SIZE\n    offsets = block_start + tl.arange(0, BLOCK_SIZE)\n    mask = offsets < n_elements\n    \n    # Load input element\n    x = tl.load(input_ptr + offsets, mask=mask)\n    \n    # Swish: x * sigmoid(x)\n    sigmoid_x = 1.0 / (1.0 + tl.exp(-x))\n    x = x * sigmoid_x\n    \n    # Divide by 2\n    x = x / 2.0\n    \n    # Clamp between [-1, 1]\n    x = tl.minimum(tl.maximum(x, -1.0), 1.0)\n    \n    # Tanh activation\n    x = tl.tanh(x)\n    \n    # Final clamp between [-1, 1]\n    x = tl.minimum(tl.maximum(x, -1.0), 1.0)\n    \n    # Store result\n    tl.store(output_ptr + offsets, x, mask=mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, bias=True):\n        super(ModelNew, self).__init__()\n        self.gemm = nn.Linear(in_features, out_features, bias=bias)\n\n    def forward(self, x):\n        # Compute GEMM\n        x = self.gemm(x)\n        \n        # Fused element-wise operations\n        output = torch.empty_like(x)\n        n_elements = x.numel()\n        grid = lambda meta: (triton.cdiv(n_elements, meta['BLOCK_SIZE']),)\n        _fused_ops_kernel[grid](x, output, n_elements, BLOCK_SIZE=1024)\n        \n        return output\n\nbatch_size = 128\nin_features = 1024\nout_features = 512\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features]\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Alternative approach to compiled, Alternative approach to correctness\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 42.1000, Type: High-Performer)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n# Fused element-wise operations kernel\n@triton.autotune(\n    configs=[\n        triton.Config({}, num_warps=1),\n        triton.Config({}, num_warps=2),\n        triton.Config({}, num_warps=4),\n        triton.Config({}, num_warps=8),\n    ],\n    key=['n_elements'],\n)\n@triton.jit\ndef _fused_ops_kernel(\n    input_ptr,\n    output_ptr,\n    n_elements,\n    BLOCK_SIZE: tl.constexpr,\n):\n    pid = tl.program_id(axis=0)\n    block_start = pid * BLOCK_SIZE\n    offsets = block_start + tl.arange(0, BLOCK_SIZE)\n    mask = offsets < n_elements\n    \n    # Load input element\n    x = tl.load(input_ptr + offsets, mask=mask)\n    \n    # Swish: x * sigmoid(x)\n    sigmoid_x = 1.0 / (1.0 + tl.exp(-x))\n    x = x * sigmoid_x\n    \n    # Divide by 2\n    x = x / 2.0\n    \n    # Clamp between [-1, 1]\n    x = tl.minimum(tl.maximum(x, -1.0), 1.0)\n    \n    # Tanh activation using identity: tanh(x) = 2*sigmoid(2*x) - 1\n    two_x = 2.0 * x\n    sigmoid_2x = 1.0 / (1.0 + tl.exp(-two_x))\n    x = 2.0 * sigmoid_2x - 1.0\n    \n    # Final clamp between [-1, 1]\n    x = tl.minimum(tl.maximum(x, -1.0), 1.0)\n    \n    # Store result\n    tl.store(output_ptr + offsets, x, mask=mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, bias=True):\n        super(ModelNew, self).__init__()\n        self.gemm = nn.Linear(in_features, out_features, bias=bias)\n\n    def forward(self, x):\n        # Compute GEMM\n        x = self.gemm(x)\n        \n        # Fused element-wise operations\n        output = torch.empty_like(x)\n        n_elements = x.numel()\n        grid = lambda meta: (triton.cdiv(n_elements, meta['BLOCK_SIZE']),)\n        _fused_ops_kernel[grid](x, output, n_elements, BLOCK_SIZE=1024)\n        \n        return output\n\nbatch_size = 128\nin_features = 1024\nout_features = 512\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features]\n# =================== EVOLVE-BLOCK-END ===================\n```\nUnique approach: Modification: Full rewrite, Excellent compiled (1.000), Excellent correctness (1.000)\n\n\n### Inspiration 2 (Score: -100.0000, Type: Exploratory)\n```python\nclamp1 = tl.minimum(tl.maximum(div, -1.0), 1.0)\n    tanh = tl.math.tanh(clamp1)\n    clamp2 = tl.minimum(tl.maximum(tanh, -1.0), 1.0)\n```\nUnique approach: Modification: Full rewrite, Alternative compiled approach, Alternative correctness approach\n\n\n### Inspiration 3 (Score: 10.0000, Type: High-Performer)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport math\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 64}, num_warps=4, num_stages=4),\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 32}, num_warps=4, num_stages=4),\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 32, 'BLOCK_SIZE_K': 32}, num_warps=4, num_stages=4),\n        triton.Config({'BLOCK_SIZE_M': 32, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 32}, num_warps=4, num_stages=4),\n        triton.Config({'BLOCK_SIZE_M': 32, 'BLOCK_SIZE_N': 32, 'BLOCK_SIZE_K': 64}, num_warps=2, num_stages=4),\n    ],\n    key=['M', 'N', 'K'],\n)\n@triton.jit\ndef _fused_forward_kernel(\n    x_ptr, w_ptr, bias_ptr, output_ptr,\n    M, N, K,\n    stride_xm, stride_xk,\n    stride_wk, stride_wn,\n    stride_om, stride_on,\n    BLOCK_SIZE_M: tl.constexpr, BLOCK_SIZE_N: tl.constexpr, BLOCK_SIZE_K: tl.constexpr,\n):\n    pid_m = tl.program_id(0)\n    pid_n = tl.program_id(1)\n    \n    offs_m = pid_m * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)\n    offs_n = pid_n * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n    \n    acc = tl.zeros((BLOCK_SIZE_M, BLOCK_SIZE_N), dtype=tl.float32)\n    for k in range(0, tl.cdiv(K, BLOCK_SIZE_K)):\n        k_offs = k * BLOCK_SIZE_K + tl.arange(0, BLOCK_SIZE_K)\n        k_mask = k_offs < K\n        \n        x_vals = tl.load(\n            x_ptr + offs_m[:, None] * stride_xm + k_offs[None, :] * stride_xk,\n            mask=k_mask[None, :] & (offs_m[:, None] < M),\n            other=0.0\n        )\n        w_vals = tl.load(\n            w_ptr + k_offs[:, None] * stride_wk + offs_n[None, :] * stride_wn,\n            mask=k_mask[:, None] & (offs_n[None, :] < N),\n            other=0.0\n        )\n        acc += tl.dot(x_vals, w_vals)\n    \n    b = tl.load(bias_ptr + offs_n, mask=offs_n < N, other=0.0)\n    acc += b[None, :]\n    \n    swish = acc * tl.sigmoid(acc)\n    div = swish / 2.0\n    clamp1 = tl.minimum(tl.maximum(div, -1.0), 1.0)\n    tanh = tl.math.tanh(clamp1)\n    clamp2 = tl.minimum(tl.maximum(tanh, -1.0), 1.0)\n    \n    offs_out = offs_m[:, None] * stride_om + offs_n[None, :] * stride_on\n    tl.store(\n        output_ptr + offs_out, \n        clamp2,\n        mask=(offs_m[:, None] < M) & (offs_n[None, :] < N)\n    )\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, bias=True):\n        super(ModelNew, self).__init__()\n        self.gemm = nn.Linear(in_features, out_features, bias=bias)\n        \n    def forward(self, x):\n        M, K = x.shape\n        N = self.gemm.out_features\n        \n        x = x.contiguous()\n        weight_t = self.gemm.weight.t().contiguous()\n        bias = self.gemm.bias if self.gemm.bias is not None else torch.zeros(N, device=x.device, dtype=x.dtype)\n        \n        output = torch.empty((M, N), device=x.device, dtype=x.dtype)\n        \n        grid = lambda META: (\n            triton.cdiv(M, META['BLOCK_SIZE_M']), \n            triton.cdiv(N, META['BLOCK_SIZE_N']),\n        )\n        \n        _fused_forward_kernel[grid](\n            x, weight_t, bias, output,\n            M, N, K,\n            x.stride(0), x.stride(1),\n            weight_t.stride(0), weight_t.stride(1),\n            output.stride(0), output.stride(1),\n        )\n        \n        return output\n\nbatch_size = 128\nin_features = 1024\nout_features = 512\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features]\n# =================== EVOLVE-BLOCK-END ===================\n```\nUnique approach: Modification: Full rewrite, Excellent compiled (1.000), Alternative correctness approach\n\n\n### Inspiration 4 (Score: 41.3000, Type: High-Performer)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n# Fused element-wise operations kernel\n@triton.autotune(\n    configs=[\n        triton.Config({}, num_warps=1),\n        triton.Config({}, num_warps=2),\n        triton.Config({}, num_warps=4),\n        triton.Config({}, num_warps=8),\n    ],\n    key=['n_elements'],\n)\n@triton.jit\ndef _fused_ops_kernel(\n    input_ptr,\n    output_ptr,\n    n_elements,\n    BLOCK_SIZE: tl.constexpr,\n):\n    pid = tl.program_id(axis=0)\n    block_start = pid * BLOCK_SIZE\n    offsets = block_start + tl.arange(0, BLOCK_SIZE)\n    mask = offsets < n_elements\n    \n    # Load input element\n    x = tl.load(input_ptr + offsets, mask=mask)\n    \n    # Swish: x * sigmoid(x)\n    sigmoid_x = 1.0 / (1.0 + tl.exp(-x))\n    x = x * sigmoid_x\n    \n    # Divide by 2\n    x = x / 2.0\n    \n    # Clamp between [-1, 1]\n    x = tl.minimum(tl.maximum(x, -1.0), 1.0)\n    \n    # Tanh activation using identity: tanh(x) = 2*sigmoid(2*x) - 1\n    two_x = 2.0 * x\n    sigmoid_2x = 1.0 / (1.0 + tl.exp(-two_x))\n    x = 2.0 * sigmoid_2x - 1.0\n    \n    # Final clamp between [-1, 1]\n    x = tl.minimum(tl.maximum(x, -1.0), 1.0)\n    \n    # Store result\n    tl.store(output_ptr + offsets, x, mask=mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, bias=True):\n        super(ModelNew, self).__init__()\n        self.gemm = nn.Linear(in_features, out_features, bias=bias)\n\n    def forward(self, x):\n        # Compute GEMM\n        x = self.gemm(x)\n        \n        # Fused element-wise operations\n        output = torch.empty_like(x)\n        n_elements = x.numel()\n        grid = lambda meta: (triton.cdiv(n_elements, meta['BLOCK_SIZE']),)\n        _fused_ops_kernel[grid](x, output, n_elements, BLOCK_SIZE=1024)\n        \n        return output\n\nbatch_size = 128\nin_features = 1024\nout_features = 512\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features]\n# =================== EVOLVE-BLOCK-END ===================\n```\nUnique approach: Modification: Full rewrite, Excellent compiled (1.000), Excellent correctness (1.000)\n\n\n### Inspiration 5 (Score: 26.3000, Type: High-Performer)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport math\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 64}, num_warps=4, num_stages=4),\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 32}, num_warps=4, num_stages=4),\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 32, 'BLOCK_SIZE_K': 32}, num_warps=4, num_stages=4),\n        triton.Config({'BLOCK_SIZE_M': 32, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 32}, num_warps=4, num_stages=4),\n        triton.Config({'BLOCK_SIZE_M': 32, 'BLOCK_SIZE_N': 32, 'BLOCK_SIZE_K': 64}, num_warps=2, num_stages=4),\n    ],\n    key=['M', 'N', 'K'],\n)\n@triton.jit\ndef _fused_forward_kernel(\n    x_ptr, w_ptr, bias_ptr, output_ptr,\n    M, N, K,\n    stride_xm, stride_xk,\n    stride_wk, stride_wn,\n    stride_om, stride_on,\n    BLOCK_SIZE_M: tl.constexpr, BLOCK_SIZE_N: tl.constexpr, BLOCK_SIZE_K: tl.constexpr,\n):\n    pid_m = tl.program_id(0)\n    pid_n = tl.program_id(1)\n    \n    offs_m = pid_m * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)\n    offs_n = pid_n * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n    \n    acc = tl.zeros((BLOCK_SIZE_M, BLOCK_SIZE_N), dtype=tl.float32)\n    for k in range(0, tl.cdiv(K, BLOCK_SIZE_K)):\n        k_offs = k * BLOCK_SIZE_K + tl.arange(0, BLOCK_SIZE_K)\n        k_mask = k_offs < K\n        \n        x_vals = tl.load(\n            x_ptr + offs_m[:, None] * stride_xm + k_offs[None, :] * stride_xk,\n            mask=k_mask[None, :] & (offs_m[:, None] < M),\n            other=0.0\n        )\n        w_vals = tl.load(\n            w_ptr + k_offs[:, None] * stride_wk + offs_n[None, :] * stride_wn,\n            mask=k_mask[:, None] & (offs_n[None, :] < N),\n            other=0.0\n        )\n        acc += tl.dot(x_vals, w_vals)\n    \n    b = tl.load(bias_ptr + offs_n, mask=offs_n < N, other=0.0)\n    acc += b[None, :]\n    \n    swish = acc * tl.sigmoid(acc)\n    div = swish / 2.0\n    clamp1 = tl.minimum(tl.maximum(div, -1.0), 1.0)\n    \n    # Replace unsupported tl.tanh with equivalent exp/log implementation\n    exp_2x = tl.exp(2 * clamp1)\n    tanh = (exp_2x - 1) / (exp_2x + 1)\n    \n    clamp2 = tl.minimum(tl.maximum(tanh, -1.0), 1.0)\n    \n    offs_out = offs_m[:, None] * stride_om + offs_n[None, :] * stride_on\n    tl.store(\n        output_ptr + offs_out, \n        clamp2,\n        mask=(offs_m[:, None] < M) & (offs_n[None, :] < N)\n    )\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, bias=True):\n        super(ModelNew, self).__init__()\n        self.gemm = nn.Linear(in_features, out_features, bias=bias)\n        \n    def forward(self, x):\n        M, K = x.shape\n        N = self.gemm.out_features\n        \n        x = x.contiguous()\n        weight_t = self.gemm.weight.t().contiguous()\n        bias = self.gemm.bias if self.gemm.bias is not None else torch.zeros(N, device=x.device, dtype=x.dtype)\n        \n        output = torch.empty((M, N), device=x.device, dtype=x.dtype)\n        \n        grid = lambda META: (\n            triton.cdiv(M, META['BLOCK_SIZE_M']), \n            triton.cdiv(N, META['BLOCK_SIZE_N']),\n        )\n        \n        _fused_forward_kernel[grid](\n            x, weight_t, bias, output,\n            M, N, K,\n            x.stride(0), x.stride(1),\n            weight_t.stride(0), weight_t.stride(1),\n            output.stride(0), output.stride(1),\n        )\n        \n        return output\n\nbatch_size = 128\nin_features = 1024\nout_features = 512\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features]\n# =================== EVOLVE-BLOCK-END ===================\n```\nUnique approach: Modification: Full rewrite, Excellent compiled (1.000), Excellent correctness (1.000)\n\n\n\n# Current Program\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n# Fused element-wise operations kernel\n@triton.autotune(\n    configs=[\n        triton.Config({}, num_warps=1),\n        triton.Config({}, num_warps=2),\n        triton.Config({}, num_warps=4),\n        triton.Config({}, num_warps=8),\n    ],\n    key=['n_elements'],\n)\n@triton.jit\ndef _fused_ops_kernel(\n    input_ptr,\n    output_ptr,\n    n_elements,\n    BLOCK_SIZE: tl.constexpr,\n):\n    pid = tl.program_id(axis=0)\n    block_start = pid * BLOCK_SIZE\n    offsets = block_start + tl.arange(0, BLOCK_SIZE)\n    mask = offsets < n_elements\n    \n    # Load input element\n    x = tl.load(input_ptr + offsets, mask=mask)\n    \n    # Swish: x * sigmoid(x)\n    sigmoid_x = 1.0 / (1.0 + tl.exp(-x))\n    x = x * sigmoid_x\n    \n    # Divide by 2\n    x = x / 2.0\n    \n    # Clamp between [-1, 1]\n    x = tl.minimum(tl.maximum(x, -1.0), 1.0)\n    \n    # Tanh activation\n    x = tl.tanh(x)\n    \n    # Final clamp between [-1, 1]\n    x = tl.minimum(tl.maximum(x, -1.0), 1.0)\n    \n    # Store result\n    tl.store(output_ptr + offsets, x, mask=mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, bias=True):\n        super(ModelNew, self).__init__()\n        self.gemm = nn.Linear(in_features, out_features, bias=bias)\n\n    def forward(self, x):\n        # Compute GEMM\n        x = self.gemm(x)\n        \n        # Fused element-wise operations\n        output = torch.empty_like(x)\n        n_elements = x.numel()\n        grid = lambda meta: (triton.cdiv(n_elements, meta['BLOCK_SIZE']),)\n        _fused_ops_kernel[grid](x, output, n_elements, BLOCK_SIZE=1024)\n        \n        return output\n\nbatch_size = 128\nin_features = 1024\nout_features = 512\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features]\n# =================== EVOLVE-BLOCK-END ===================\n```\n\n# Task\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```\n", "responses": ["<think>\nWe are given the current program that is failing with an AttributeError because `tl.tanh` is not available.\n The error traceback indicates: \"AttributeError: module 'triton.language' has no attribute 'tanh'\"\n\n In the current program, we are using:\n     x = tl.tanh(x)\n\n However, in Triton, the `tanh` function is not directly available in `triton.language` (as of the current version).\n Instead, we can use the mathematical identity for tanh: tanh(x) = 2 * sigmoid(2*x) - 1.\n\n We note that in the top-performing programs (Program 1 and Program 2) and in the Inspiration 1 and 4, they use:\n     two_x = 2.0 * x\n     sigmoid_2x = 1.0 / (1.0 + tl.exp(-two_x))\n     x = 2.0 * sigmoid_2x - 1.0\n\n Therefore, we should replace the line `x = tl.tanh(x)` with the above computation.\n\n Additionally, we note that the current program also does a final clamp (which is also done in the top programs).\n\n Steps for the rewrite:\n  1. In the kernel, replace the line `x = tl.tanh(x)` with:\n        two_x = 2.0 * x\n        sigmoid_2x = 1.0 / (1.0 + tl.exp(-two_x))\n        x = 2.0 * sigmoid_2x - 1.0\n\n  2. We leave the rest of the kernel and the model class unchanged.\n\n We are making a small iterative change (only 3 lines replaced by 3 new lines) to fix the compilation error.\n\n Let's rewrite the kernel accordingly.\n</think>\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n# Fused element-wise operations kernel\n@triton.autotune(\n    configs=[\n        triton.Config({}, num_warps=1),\n        triton.Config({}, num_warps=2),\n        triton.Config({}, num_warps=4),\n        triton.Config({}, num_warps=8),\n    ],\n    key=['n_elements'],\n)\n@triton.jit\ndef _fused_ops_kernel(\n    input_ptr,\n    output_ptr,\n    n_elements,\n    BLOCK_SIZE: tl.constexpr,\n):\n    pid = tl.program_id(axis=0)\n    block_start = pid * BLOCK_SIZE\n    offsets = block_start + tl.arange(0, BLOCK_SIZE)\n    mask = offsets < n_elements\n    \n    # Load input element\n    x = tl.load(input_ptr + offsets, mask=mask)\n    \n    # Swish: x * sigmoid(x)\n    sigmoid_x = 1.0 / (1.0 + tl.exp(-x))\n    x = x * sigmoid_x\n    \n    # Divide by 2\n    x = x / 2.0\n    \n    # Clamp between [-1, 1]\n    x = tl.minimum(tl.maximum(x, -1.0), 1.0)\n    \n    # Tanh activation using identity: tanh(x) = 2*sigmoid(2*x) - 1\n    two_x = 2.0 * x\n    sigmoid_2x = 1.0 / (1.0 + tl.exp(-two_x))\n    x = 2.0 * sigmoid_2x - 1.0\n    \n    # Final clamp between [-1, 1]\n    x = tl.minimum(tl.maximum(x, -1.0), 1.0)\n    \n    # Store result\n    tl.store(output_ptr + offsets, x, mask=mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, bias=True):\n        super(ModelNew, self).__init__()\n        self.gemm = nn.Linear(in_features, out_features, bias=bias)\n\n    def forward(self, x):\n        # Compute GEMM\n        x = self.gemm(x)\n        \n        # Fused element-wise operations\n        output = torch.empty_like(x)\n        n_elements = x.numel()\n        grid = lambda meta: (triton.cdiv(n_elements, meta['BLOCK_SIZE']),)\n        _fused_ops_kernel[grid](x, output, n_elements, BLOCK_SIZE=1024)\n        \n        return output\n\nbatch_size = 128\nin_features = 1024\nout_features = 512\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features]\n# =================== EVOLVE-BLOCK-END ===================\n```"]}}}