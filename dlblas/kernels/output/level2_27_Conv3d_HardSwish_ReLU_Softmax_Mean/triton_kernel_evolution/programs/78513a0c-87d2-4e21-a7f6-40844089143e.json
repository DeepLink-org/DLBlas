{"id": "78513a0c-87d2-4e21-a7f6-40844089143e", "code": "# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef softmax_kernel(\n    input_ptr,\n    temp_softmax_ptr,\n    n_spatial,\n    n_channels,\n    BLOCK_SIZE_C: tl.constexpr\n):\n    # Get program IDs for batch and spatial location\n    pid_batch = tl.program_id(0)\n    pid_spatial = tl.program_id(1)\n    \n    # Calculate base pointer for current spatial location\n    base_ptr = pid_batch * n_spatial * n_channels + pid_spatial * n_channels\n    offsets = base_ptr + tl.arange(0, BLOCK_SIZE_C)\n    mask = tl.arange(0, BLOCK_SIZE_C) < n_channels\n    \n    # Load input data\n    data = tl.load(input_ptr + offsets, mask=mask, other=0.0)\n    \n    # Apply HardSwish activation\n    shifted = data + 3.0\n    clipped = tl.minimum(tl.maximum(shifted, 0.0), 6.0)\n    activated = data * clipped / 6.0\n    \n    # Apply ReLU activation\n    activated = tl.maximum(activated, 0.0)\n    \n    # Compute softmax over channels\n    max_val = tl.max(activated, axis=0)\n    exp_vals = tl.exp(activated - max_val)\n    sum_exp = tl.sum(exp_vals, axis=0)\n    softmax_vals = exp_vals / sum_exp\n    \n    # Store results\n    tl.store(temp_softmax_ptr + offsets, softmax_vals, mask=mask)\n\n@triton.jit\ndef mean_kernel(\n    temp_softmax_ptr,\n    output_ptr,\n    n_spatial,\n    n_channels,\n    BLOCK_SIZE: tl.constexpr\n):\n    # Get program IDs for batch and channel\n    pid_batch = tl.program_id(0)\n    pid_channel = tl.program_id(1)\n    \n    output_offset = pid_batch * n_channels + pid_channel\n    base_ptr = pid_batch * n_spatial * n_channels + pid_channel\n    \n    # Accumulate sum across spatial locations\n    total = 0.0\n    for idx in range(0, n_spatial, BLOCK_SIZE):\n        offsets = base_ptr + (idx + tl.arange(0, BLOCK_SIZE)) * n_channels\n        mask = (idx + tl.arange(0, BLOCK_SIZE)) < n_spatial\n        vals = tl.load(temp_softmax_ptr + offsets, mask=mask, other=0.0)\n        total += tl.sum(vals, axis=0)\n    \n    # Compute and store mean\n    mean_val = total / n_spatial\n    tl.store(output_ptr + output_offset, mean_val)\n\nclass ModelNew(nn.Module):\n    \"\"\"\n    Optimized model using Triton for fused operations\n    \"\"\"\n    def __init__(self, in_channels, out_channels, kernel_size, bias=True):\n        super(ModelNew, self).__init__()\n        self.conv = nn.Conv3d(in_channels, out_channels, kernel_size, bias=bias)\n\n    def forward(self, x):\n        # Apply convolution\n        x = self.conv(x)\n        \n        # Get tensor dimensions\n        B, C, D, H, W = x.shape\n        n_spatial = D * H * W\n        \n        # Reshape tensor: [B, C, D, H, W] -> [B, n_spatial, C]\n        x = x.permute(0, 2, 3, 4, 1).contiguous()\n        x = x.view(B, n_spatial, C)\n        \n        # Allocate temporary tensor for softmax results\n        temp_softmax = torch.empty_like(x)\n        \n        # Launch softmax kernel\n        grid_softmax = (B, n_spatial)\n        BLOCK_SIZE_C = triton.next_power_of_2(C)\n        softmax_kernel[grid_softmax](\n            x, temp_softmax, n_spatial, C, BLOCK_SIZE_C=BLOCK_SIZE_C\n        )\n        \n        # Allocate output tensor\n        output = torch.empty((B, C), device=x.device, dtype=x.dtype)\n        \n        # Launch mean kernel\n        grid_mean = (B, C)\n        BLOCK_SIZE_SPATIAL = min(1024, n_spatial)  # Optimal block size for spatial reduction\n        mean_kernel[grid_mean](\n            temp_softmax, output, n_spatial, C, BLOCK_SIZE=BLOCK_SIZE_SPATIAL\n        )\n        \n        return output\n\nbatch_size = 128\nin_channels = 3\nout_channels = 16\ndepth, height, width = 16, 32, 32\nkernel_size = 3\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_channels, depth, height, width)]\n\ndef get_init_inputs():\n    return [in_channels, out_channels, kernel_size]\n# =================== EVOLVE-BLOCK-END ===================", "language": "python", "parent_id": "ea01b96b-7f70-4dd6-8a6e-714df0252a73", "generation": 2, "timestamp": 1754568602.1342118, "iteration_found": 14, "metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": false, "score": 20, "speed_up": 0.044, "runtime_ms": 1.77, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:0", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.0784, "speed_up": 0.044, "custom_timing": 1.77}}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": true, "correctness": false, "score": 10, "stage": "wrong_answer", "verify_payload": {"id": "level2_27_Conv3d_HardSwish_ReLU_Softmax_Mean", "result": {"compiled": true, "correctness": false, "metadata": {"hardware": "NVIDIA L20Y", "device": "cuda:4", "max_difference": ["0.065478", "0.065580", "0.065615", "0.065568", "0.065696"], "avg_difference": ["0.062421", "0.062421", "0.062421", "0.062421", "0.062421"], "correctness_issue": "Output mismatch", "correctness_trials": "(0 / 5)", "reference_timing_ms": 0.0784, "speed_up": -1.0, "custom_timing": -1.0}, "runtime": -1.0, "runtime_stats": {}}}}, "island": 0}, "artifacts_json": null, "artifact_dir": null}