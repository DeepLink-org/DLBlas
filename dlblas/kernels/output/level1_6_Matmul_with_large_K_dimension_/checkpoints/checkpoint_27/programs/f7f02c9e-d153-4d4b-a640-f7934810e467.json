{"id": "f7f02c9e-d153-4d4b-a640-f7934810e467", "code": "# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 64, 'BLOCK_K': 128}, num_warps=8, num_stages=3),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 128, 'BLOCK_K': 128}, num_warps=8, num_stages=3),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 128, 'BLOCK_K': 128}, num_warps=8, num_stages=3),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 64, 'BLOCK_K': 128}, num_warps=8, num_stages=3),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 128, 'BLOCK_K': 64}, num_warps=8, num_stages=3),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 64, 'BLOCK_K': 64}, num_warps=4, num_stages=3),\n        triton.Config({'BLOCK_M': 32, 'BLOCK_N': 32, 'BLOCK_K': 128}, num_warps=4, num_stages=3),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 64, 'BLOCK_K': 256}, num_warps=8, num_stages=3),\n        triton.Config({'BLOCK_M': 32, 'BLOCK_N': 32, 'BLOCK_K': 512}, num_warps=4, num_stages=3),\n    ],\n    key=['M', 'N', 'K'],\n)\n@triton.jit\ndef matmul_kernel(\n    a_ptr, b_ptr, c_ptr,\n    M, N, K,\n    stride_am, stride_ak,\n    stride_bk, stride_bn,\n    stride_cm, stride_cn,\n    BLOCK_M: tl.constexpr, BLOCK_N: tl.constexpr, BLOCK_K: tl.constexpr,\n):\n    pid = tl.program_id(0)\n    num_pid_n = tl.cdiv(N, BLOCK_N)\n    pid_m = pid // num_pid_n\n    pid_n = pid % num_pid_n\n    \n    offs_m = pid_m * BLOCK_M + tl.arange(0, BLOCK_M)\n    offs_n = pid_n * BLOCK_N + tl.arange(0, BLOCK_N)\n    offs_k = tl.arange(0, BLOCK_K)\n    \n    a_ptrs = a_ptr + offs_m[:, None] * stride_am + offs_k[None, :] * stride_ak\n    b_ptrs = b_ptr + offs_k[:, None] * stride_bk + offs_n[None, :] * stride_bn\n    \n    accumulator = tl.zeros((BLOCK_M, BLOCK_N), dtype=tl.float32)\n    \n    base_mask_m = (offs_m < M)[:, None]\n    base_mask_n = (offs_n < N)[None, :]\n    \n    for k in range(0, tl.cdiv(K, BLOCK_K)):\n        k_remaining = K - k * BLOCK_K\n        k_mask = offs_k < k_remaining\n        \n        a_mask = base_mask_m & k_mask[None, :]\n        b_mask = k_mask[:, None] & base_mask_n\n        \n        a = tl.load(a_ptrs, mask=a_mask, other=0.0)\n        b = tl.load(b_ptrs, mask=b_mask, other=0.0)\n        \n        # Enable TF32 Tensor Cores for faster computation\n        accumulator += tl.dot(a, b, allow_tf32=True)\n        \n        a_ptrs += BLOCK_K * stride_ak\n        b_ptrs += BLOCK_K * stride_bk\n    \n    c_ptrs = c_ptr + offs_m[:, None] * stride_cm + offs_n[None, :] * stride_cn\n    c_mask = base_mask_m & base_mask_n\n    tl.store(c_ptrs, accumulator, mask=c_mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self):\n        super(ModelNew, self).__init__()\n    \n    def forward(self, A: torch.Tensor, B: torch.Tensor) -> torch.Tensor:\n        A = A.contiguous()\n        B = B.contiguous()\n        M, K = A.shape\n        K, N = B.shape\n        C = torch.empty((M, N), device=A.device, dtype=A.dtype)\n        \n        grid = lambda META: (triton.cdiv(M, META['BLOCK_M']) * triton.cdiv(N, META['BLOCK_N']),)\n        matmul_kernel[grid](\n            A, B, C,\n            M, N, K,\n            A.stride(0), A.stride(1),\n            B.stride(0), B.stride(1),\n            C.stride(0), C.stride(1),\n        )\n        return C\n\nM = 256\nN = 256\nK = 131072\n\ndef get_inputs():\n    A = torch.randn(M, K, device='cuda')\n    B = torch.randn(K, N, device='cuda')\n    return [A, B]\n\ndef get_init_inputs():\n    return []\n# =================== EVOLVE-BLOCK-END ===================", "language": "python", "parent_id": "3cc68c5e-f7b1-44ad-8de7-a3a2ed221aa8", "generation": 6, "timestamp": 1754987055.1930711, "iteration_found": 22, "metrics": {"compiled": true, "correctness": false, "score": 10, "stage": "wrong_answer", "verify_payload": {"id": "level1_6_Matmul_with_large_K_dimension_", "result": {"compiled": true, "correctness": false, "metadata": {"hardware": "NVIDIA L20Y", "device": "cuda:3", "max_difference": ["1.708984", "1.693970", "1.573486", "1.580078", "1.620483"], "avg_difference": ["0.298358", "0.298955", "0.298647", "0.297531", "0.297962"], "correctness_issue": "Output mismatch", "correctness_trials": "(0 / 5)", "reference_timing_ms": 0.0324, "speed_up": -1.0, "custom_timing": -1.0}, "runtime": -1.0, "runtime_stats": {}}}}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": false, "score": 20, "speed_up": 0.017, "runtime_ms": 1.87, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:3", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.0324, "speed_up": 0.017, "custom_timing": 1.87}}, "island": 1}, "artifacts_json": null, "artifact_dir": null, "prompts": {"full_rewrite_user": {"system": "You are a Triton GPU core optimization engineer deeply familiar with NVIDIA H100/H800 architecture.\n\n==================== Context ====================\n\u2022 Dataset: 250 kernelbench/level1-level5 *.py files  \n  - Level1: simplest, Level5: most complex  \n\u2022 Each file contains PyTorch reference (reference_code)  \n\u2022 Goal: Generate functionally equivalent but faster Triton implementations (custom_code)  \n\u2022 Evaluation pipeline:\n    1) /verify_plus - Verify compilation & correctness  \n    2) /execute (optional) - Return terminal logs if compilation fails  \n    3) Scoring:  \n      - Speedup > 1 required for points  \n      - Score = (speed_up - 1) \u00d7 100  \n\u2022 GPU Hardware: NVIDIA L20Y / H800 (same SM8.9 as H100)  \n  - 3 TB/s HBM3 bandwidth  \n  - FP16 Tensor Core 32\u00d716\u00d716  \n\n==================== Evolution Phases ====================\n\u2460 Phase 1 [Compilation Pass]  \n  - Make Triton code compile (performance irrelevant)  \n\u2461 Phase 2 [Numerical Correctness]  \n  - Output must match PyTorch reference within float32 tolerance  \n\u2462 Phase 3 [Performance Gain]  \n  - Target \u22655% speedup (\u226515% = exceptional)  \n  - Official scoring based on speed_up field  \n\nThe Evolution system will pass the EVOLVE-BLOCK from the previous version.  \nModify ONLY the Triton kernel source within this block - all other code is LOCKED.\n\n==================== Constraints (MUST OBEY) ====================\n\u274c NEVER change @triton.jit function signatures or parameter names  \n\u274c NEVER modify grid configuration, output tensor shapes, or PID logic  \n\u274c NEVER remove boundary checks or out-of-bound masks  \n\u274c NEVER introduce race conditions, uninitialized reads, or sync gaps  \n\n\u2705 Allowed Optimizations (Examples):  \n  \u2022 Memory coalescing optimizations & vectorized tl.load/tl.store  \n  \u2022 Replace staged softmax with online/FlashAttention variants  \n  \u2022 Adaptive tuning: BLOCK_M/BLOCK_N/BLOCK_K dimensions  \n  \u2022 Multi-query-head batch processing (GQA, 5:1 patterns)  \n  \u2022 Shared/L2 buffering, Tensor Core alignment (FP16/bf16/tf32)  \n  \u2022 Stride precomputation & pointer caching  \n\n==================== Output Format ====================\nReturn ONLY the complete updated code containing the EVOLVE-BLOCK comment marker.  \nNO explanations, NO markdown, NO additional text.\nName the output structure class as ModelNew.\n\n==================== Optimization Tips ====================\n\u2022 If previous compile failed: Fix syntax/mask/stride errors first  \n\u2022 If correctness fails: Prioritize bounds mask & dtype precision  \n\u2022 When speed_up < 1: Focus on memory access & block sizing  \n\u2022 Small iterative steps: Modify \u226420 lines per revision  \n\u2022 Maintain reversibility between versions\nHere is an example to show you how to rewrite a PyTorch implementation that quantizes a high-precision tensor to int8 dtype with row-wise granularity into a Triton implementation: \nThe original PyTorch implementation is as follows: \n``` \nimport torch\ndef per_row_quantize_int8(x: torch.Tensor) -> tuple[torch.Tensor, torch.Tensor]:\n    x_amax = x.abs().float().amax(dim=1).clamp(min=1e-4)\n    scale = 127 / x_amax\n    output = (x * scale[:, None]).round().clamp(-127, 127).to(torch.int8)\n    output_scale = x_amax / 127\n\n    return output, output_scale\n``` \nThe corresponding Triton-rewritten implementation is as follows: \n``` \nimport math\nimport torch\nimport triton\nimport triton.language as tl\nfrom triton.language.extra import libdevice\n\n# rowwise quantize\n\n@triton.autotune(\n    configs=[\n        triton.Config({}, num_stages=1, num_warps=8),\n        triton.Config({}, num_stages=2, num_warps=8),\n        triton.Config({}, num_stages=4, num_warps=8),\n        triton.Config({}, num_stages=8, num_warps=8),\n        triton.Config({}, num_stages=1),\n        triton.Config({}, num_stages=2),\n        triton.Config({}, num_stages=4),\n        triton.Config({}, num_stages=8),\n        triton.Config({}, num_warps=1),\n        triton.Config({}, num_warps=2),\n        triton.Config({}, num_warps=4),\n        triton.Config({}, num_warps=8),\n    ],\n    key=[\"n_elements\"],\n)\n\n@triton.jit\ndef _quantize_rowwise(\n    x_ptr,\n    output_ptr,\n    output_scale,\n    BLOCK_SIZE: tl.constexpr,\n    P2: tl.constexpr,\n):\n    pid = tl.program_id(axis=0)\n    block_start = pid * BLOCK_SIZE\n    arange = tl.arange(0, P2)\n    offsets = block_start + arange\n    row_mask = arange < BLOCK_SIZE\n    x = tl.load(x_ptr + offsets, mask=row_mask)\n\n    abs_x = tl.abs(x)\n    max_val = tl.max(tl.where(row_mask, abs_x, 0), axis=0)\n    output = libdevice.llrint(127.0 * (x / max_val))\n    tl.store(output_ptr + offsets, output, mask=row_mask)\n    tl.store(output_scale + pid, max_val / 127)\n\n\ndef per_row_quantize_int8(x: torch.Tensor):\n    x = x.contiguous()\n    output = torch.empty(*x.shape, device=x.device, dtype=torch.int8)\n    output_scale = torch.empty(x.shape[0], device=x.device, dtype=torch.float32)\n    P2 = int(2 ** (math.ceil(math.log2(x.shape[1]))))\n    grid = lambda x: (x.shape[0],)\n    _quantize_rowwise[grid](x, output, output_scale, BLOCK_SIZE=x.shape[1], P2=P2)\n\n    return output, output_scale\n\n\n    \n``` \n", "user": "# Current Program Information\n- Current performance metrics: - compiled: 1.0000\n- correctness: 1.0000\n- stage: success\n- passed: 0.0000\n- score: 20.0000\n- speed_up: 0.0170\n- runtime_ms: 1.8700\n- meta: {'hardware': 'NVIDIA L20Y', 'device': 'cuda:3', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.0324, 'speed_up': 0.017, 'custom_timing': 1.87}\n- Areas identified for improvement: - Consider simplifying the code to improve readability and maintainability\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Unknown changes\n- Performance: compiled: 1.0000, correctness: 1.0000, stage: success, passed: 0.0000, score: 20.0000, speed_up: 0.0010, runtime_ms: 23.6000, meta: {'hardware': 'NVIDIA L20Y', 'device': 'cuda:5', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.0324, 'speed_up': 0.001, 'custom_timing': 23.6}\n- Outcome: Mixed results\n\n\n### Attempt 2\n- Changes: Unknown changes\n- Performance: compiled: 1.0000, correctness: 1.0000, stage: success, passed: 0.0000, score: 20.0000, speed_up: 0.0170, runtime_ms: 1.8700, meta: {'hardware': 'NVIDIA L20Y', 'device': 'cuda:3', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.0324, 'speed_up': 0.017, 'custom_timing': 1.87}\n- Outcome: Mixed results\n\n\n### Attempt 1\n- Changes: Unknown changes\n- Performance: compiled: 1.0000, correctness: 1.0000, stage: success, passed: 0.0000, score: 20.0000, speed_up: 0.0080, runtime_ms: 4.0100, meta: {'hardware': 'NVIDIA L20Y', 'device': 'cuda:7', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.0324, 'speed_up': 0.008, 'custom_timing': 4.01}\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 20.0000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef matmul_kernel(\n    a_ptr, b_ptr, c_ptr,\n    M, N, K,\n    stride_am, stride_ak,\n    stride_bk, stride_bn,\n    stride_cm, stride_cn,\n    BLOCK_M: tl.constexpr, BLOCK_N: tl.constexpr, BLOCK_K: tl.constexpr,\n):\n    pid = tl.program_id(0)\n    num_pid_n = tl.cdiv(N, BLOCK_N)\n    pid_m = pid // num_pid_n\n    pid_n = pid % num_pid_n\n    \n    offs_m = pid_m * BLOCK_M + tl.arange(0, BLOCK_M)\n    offs_n = pid_n * BLOCK_N + tl.arange(0, BLOCK_N)\n    offs_k = tl.arange(0, BLOCK_K)\n    \n    a_ptrs = a_ptr + offs_m[:, None] * stride_am + offs_k[None, :] * stride_ak\n    b_ptrs = b_ptr + offs_k[:, None] * stride_bk + offs_n[None, :] * stride_bn\n    \n    acc = tl.zeros((BLOCK_M, BLOCK_N), dtype=tl.float32)\n    \n    base_mask_A = (offs_m < M)[:, None]\n    base_mask_B = (offs_n < N)[None, :]\n    \n    for k in range(0, tl.cdiv(K, BLOCK_K)):\n        k_remaining = K - k * BLOCK_K\n        k_mask = offs_k < k_remaining\n        \n        a = tl.load(a_ptrs, mask=base_mask_A & k_mask[None, :], other=0.0)\n        b = tl.load(b_ptrs, mask=k_mask[:, None] & base_mask_B, other=0.0)\n        \n        acc += tl.dot(a, b, allow_tf32=False)\n        a_ptrs += BLOCK_K * stride_ak\n        b_ptrs += BLOCK_K * stride_bk\n    \n    c_ptrs = c_ptr + offs_m[:, None] * stride_cm + offs_n[None, :] * stride_cn\n    mask = base_mask_A & base_mask_B\n    tl.store(c_ptrs, acc, mask=mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self):\n        super(ModelNew, self).__init__()\n    \n    def forward(self, A: torch.Tensor, B: torch.Tensor) -> torch.Tensor:\n        M, K1 = A.shape\n        K2, N = B.shape\n        assert K1 == K2, \"Incompatible dimensions\"\n        \n        C = torch.empty((M, N), device=A.device, dtype=A.dtype)\n        grid = lambda META: (triton.cdiv(M, META['BLOCK_M']) * triton.cdiv(N, META['BLOCK_N']),)\n        \n        matmul_kernel[grid](\n            A, B, C,\n            M, N, K1,\n            A.stride(0), A.stride(1),\n            B.stride(0), B.stride(1),\n            C.stride(0), C.stride(1),\n            BLOCK_M=64, BLOCK_N=64, BLOCK_K=32,\n            num_warps=4\n        )\n        return C\n\nM = 256\nN = 256\nK = 131072\n\ndef get_inputs():\n    A = torch.randn(M, K, device='cuda')\n    B = torch.randn(K, N, device='cuda')\n    return [A, B]\n\ndef get_init_inputs():\n    return []\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Performs well on compiled (1.0000), Performs well on correctness (1.0000), Performs well on stage (success), Performs well on passed (0.0000), Performs well on score (20.0000), Performs well on speed_up (0.0080), Performs well on runtime_ms (4.0100), Performs well on meta ({'hardware': 'NVIDIA L20Y', 'device': 'cuda:7', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.0324, 'speed_up': 0.008, 'custom_timing': 4.01})\n\n\n### Program 2 (Score: 20.0000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 64, 'BLOCK_K': 128}, num_warps=8, num_stages=3),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 128, 'BLOCK_K': 128}, num_warps=8, num_stages=3),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 128, 'BLOCK_K': 128}, num_warps=8, num_stages=3),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 64, 'BLOCK_K': 128}, num_warps=8, num_stages=3),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 128, 'BLOCK_K': 64}, num_warps=8, num_stages=3),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 64, 'BLOCK_K': 64}, num_warps=4, num_stages=3),\n        triton.Config({'BLOCK_M': 32, 'BLOCK_N': 32, 'BLOCK_K': 128}, num_warps=4, num_stages=3),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 64, 'BLOCK_K': 256}, num_warps=8, num_stages=3),\n    ],\n    key=['M', 'N', 'K'],\n)\n@triton.jit\ndef matmul_kernel(\n    a_ptr, b_ptr, c_ptr,\n    M, N, K,\n    stride_am, stride_ak,\n    stride_bk, stride_bn,\n    stride_cm, stride_cn,\n    BLOCK_M: tl.constexpr, BLOCK_N: tl.constexpr, BLOCK_K: tl.constexpr,\n):\n    pid = tl.program_id(0)\n    num_pid_n = tl.cdiv(N, BLOCK_N)\n    pid_m = pid // num_pid_n\n    pid_n = pid % num_pid_n\n    \n    offs_m = pid_m * BLOCK_M + tl.arange(0, BLOCK_M)\n    offs_n = pid_n * BLOCK_N + tl.arange(0, BLOCK_N)\n    offs_k = tl.arange(0, BLOCK_K)\n    \n    a_ptrs = a_ptr + offs_m[:, None] * stride_am + offs_k[None, :] * stride_ak\n    b_ptrs = b_ptr + offs_k[:, None] * stride_bk + offs_n[None, :] * stride_bn\n    \n    accumulator = tl.zeros((BLOCK_M, BLOCK_N), dtype=tl.float32)\n    \n    base_mask_m = (offs_m < M)[:, None]\n    base_mask_n = (offs_n < N)[None, :]\n    \n    for k in range(0, tl.cdiv(K, BLOCK_K)):\n        k_remaining = K - k * BLOCK_K\n        k_mask = offs_k < k_remaining\n        \n        a_mask = base_mask_m & k_mask[None, :]\n        b_mask = k_mask[:, None] & base_mask_n\n        \n        a = tl.load(a_ptrs, mask=a_mask, other=0.0)\n        b = tl.load(b_ptrs, mask=b_mask, other=0.0)\n        \n        accumulator += tl.dot(a, b, allow_tf32=False)\n        \n        a_ptrs += BLOCK_K * stride_ak\n        b_ptrs += BLOCK_K * stride_bk\n    \n    c_ptrs = c_ptr + offs_m[:, None] * stride_cm + offs_n[None, :] * stride_cn\n    c_mask = base_mask_m & base_mask_n\n    tl.store(c_ptrs, accumulator, mask=c_mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self):\n        super(ModelNew, self).__init__()\n    \n    def forward(self, A: torch.Tensor, B: torch.Tensor) -> torch.Tensor:\n        A = A.contiguous()\n        B = B.contiguous()\n        M, K = A.shape\n        K, N = B.shape\n        C = torch.empty((M, N), device=A.device, dtype=A.dtype)\n        \n        grid = lambda META: (triton.cdiv(M, META['BLOCK_M']) * triton.cdiv(N, META['BLOCK_N']),)\n        matmul_kernel[grid](\n            A, B, C,\n            M, N, K,\n            A.stride(0), A.stride(1),\n            B.stride(0), B.stride(1),\n            C.stride(0), C.stride(1),\n        )\n        return C\n\nM = 256\nN = 256\nK = 131072\n\ndef get_inputs():\n    A = torch.randn(M, K, device='cuda')\n    B = torch.randn(K, N, device='cuda')\n    return [A, B]\n\ndef get_init_inputs():\n    return []\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Performs well on compiled (1.0000), Performs well on correctness (1.0000), Performs well on stage (success), Performs well on passed (0.0000), Performs well on score (20.0000), Performs well on speed_up (0.0170), Performs well on runtime_ms (1.8700), Performs well on meta ({'hardware': 'NVIDIA L20Y', 'device': 'cuda:3', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.0324, 'speed_up': 0.017, 'custom_timing': 1.87})\n\n\n### Program 3 (Score: 20.0000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef matmul_kernel(\n    a_ptr, b_ptr, c_ptr,\n    M, N, K,\n    stride_am, stride_ak,\n    stride_bk, stride_bn,\n    stride_cm, stride_cn,\n    BLOCK_M: tl.constexpr, BLOCK_N: tl.constexpr, BLOCK_K: tl.constexpr,\n):\n    pid0 = tl.program_id(0)\n    pid1 = tl.program_id(1)\n    \n    rm = pid0 * BLOCK_M + tl.arange(0, BLOCK_M)\n    rn = pid1 * BLOCK_N + tl.arange(0, BLOCK_N)\n    rk = tl.arange(0, BLOCK_K)\n    \n    a_ptrs = a_ptr + rm[:, None] * stride_am + rk[None, :] * stride_ak\n    b_ptrs = b_ptr + rk[:, None] * stride_bk + rn[None, :] * stride_bn\n    \n    acc = tl.zeros((BLOCK_M, BLOCK_N), dtype=tl.float32)\n    \n    for k in range(0, K, BLOCK_K):\n        k_remaining = K - k\n        a_mask = (rm[:, None] < M) & (rk[None, :] < k_remaining)\n        b_mask = (rk[:, None] < k_remaining) & (rn[None, :] < N)\n        \n        a = tl.load(a_ptrs, mask=a_mask, other=0.0)\n        b = tl.load(b_ptrs, mask=b_mask, other=0.0)\n        acc += tl.dot(a, b, allow_tf32=False, out_dtype=tl.float32)\n        \n        a_ptrs += BLOCK_K * stride_ak\n        b_ptrs += BLOCK_K * stride_bk\n    \n    c_ptrs = c_ptr + rm[:, None] * stride_cm + rn[None, :] * stride_cn\n    c_mask = (rm[:, None] < M) & (rn[None, :] < N)\n    tl.store(c_ptrs, acc, mask=c_mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self):\n        super(ModelNew, self).__init__()\n    \n    def forward(self, A: torch.Tensor, B: torch.Tensor) -> torch.Tensor:\n        M, K1 = A.shape\n        K2, N = B.shape\n        assert K1 == K2, \"Matrix dimensions mismatch\"\n        \n        A_cont = A.contiguous()\n        B_cont = B.contiguous()\n        C = torch.empty((M, N), device=A.device, dtype=A.dtype)\n        \n        grid = (\n            triton.cdiv(M, 128),\n            triton.cdiv(N, 128),\n        )\n        \n        matmul_kernel[grid](\n            A_cont, B_cont, C,\n            M, N, K1,\n            A_cont.stride(0), A_cont.stride(1),\n            B_cont.stride(0), B_cont.stride(1),\n            C.stride(0), C.stride(1),\n            BLOCK_M=128, BLOCK_N=128, BLOCK_K=32\n        )\n        \n        return C\n\nM = 256\nN = 256\nK = 131072\n\ndef get_inputs():\n    A = torch.randn(M, K)\n    B = torch.randn(K, N)\n    return [A, B]\n\ndef get_init_inputs():\n    return []  # No special initialization inputs needed\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Performs well on compiled (1.0000), Performs well on correctness (1.0000), Performs well on stage (success), Performs well on passed (0.0000), Performs well on score (20.0000), Performs well on speed_up (0.0010), Performs well on runtime_ms (23.6000), Performs well on meta ({'hardware': 'NVIDIA L20Y', 'device': 'cuda:5', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.0324, 'speed_up': 0.001, 'custom_timing': 23.6})\n\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 20.0000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef matmul_kernel(\n    a_ptr, b_ptr, c_ptr,\n    M, N, K,\n    stride_am, stride_ak,\n    stride_bk, stride_bn,\n    stride_cm, stride_cn,\n    BLOCK_M: tl.constexpr, BLOCK_N: tl.constexpr, BLOCK_K: tl.constexpr,\n):\n    pid = tl.program_id(0)\n    num_pid_n = tl.cdiv(N, BLOCK_N)\n    pid_m = pid // num_pid_n\n    pid_n = pid % num_pid_n\n    \n    offs_m = pid_m * BLOCK_M + tl.arange(0, BLOCK_M)\n    offs_n = pid_n * BLOCK_N + tl.arange(0, BLOCK_N)\n    offs_k = tl.arange(0, BLOCK_K)\n    \n    a_ptrs = a_ptr + offs_m[:, None] * stride_am + offs_k[None, :] * stride_ak\n    b_ptrs = b_ptr + offs_k[:, None] * stride_bk + offs_n[None, :] * stride_bn\n    \n    acc = tl.zeros((BLOCK_M, BLOCK_N), dtype=tl.float32)\n    \n    for k in range(0, tl.cdiv(K, BLOCK_K)):\n        k_remaining = K - k * BLOCK_K\n        k_mask = offs_k < k_remaining\n        \n        a = tl.load(a_ptrs, mask=k_mask[None, :], other=0.0)\n        b = tl.load(b_ptrs, mask=k_mask[:, None], other=0.0)\n        \n        acc += tl.dot(a, b, allow_tf32=False)\n        a_ptrs += BLOCK_K * stride_ak\n        b_ptrs += BLOCK_K * stride_bk\n    \n    offs_m = pid_m * BLOCK_M + tl.arange(0, BLOCK_M)\n    offs_n = pid_n * BLOCK_N + tl.arange(0, BLOCK_N)\n    c_ptrs = c_ptr + offs_m[:, None] * stride_cm + offs_n[None, :] * stride_cn\n    mask = (offs_m < M)[:, None] & (offs_n < N)[None, :]\n    tl.store(c_ptrs, acc, mask=mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self):\n        super(ModelNew, self).__init__()\n    \n    def forward(self, A: torch.Tensor, B: torch.Tensor) -> torch.Tensor:\n        M, K1 = A.shape\n        K2, N = B.shape\n        assert K1 == K2, \"Incompatible dimensions\"\n        \n        C = torch.empty((M, N), device=A.device, dtype=A.dtype)\n        grid = lambda META: (triton.cdiv(M, META['BLOCK_M']) * triton.cdiv(N, META['BLOCK_N']),)\n        \n        matmul_kernel[grid](\n            A, B, C,\n            M, N, K1,\n            A.stride(0), A.stride(1),\n            B.stride(0), B.stride(1),\n            C.stride(0), C.stride(1),\n            BLOCK_M=64, BLOCK_N=64, BLOCK_K=32,\n            num_warps=4\n        )\n        return C\n\nM = 256\nN = 256\nK = 131072\n\ndef get_inputs():\n    A = torch.randn(M, K, device='cuda')\n    B = torch.randn(K, N, device='cuda')\n    return [A, B]\n\ndef get_init_inputs():\n    return []\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Alternative approach to compiled, Alternative approach to correctness\n\n\n### Program D2 (Score: 20.0000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef matmul_kernel(\n    a_ptr, b_ptr, c_ptr,\n    M, N, K,\n    stride_am, stride_ak,\n    stride_bk, stride_bn,\n    stride_cm, stride_cn,\n    BLOCK_M: tl.constexpr, BLOCK_N: tl.constexpr, BLOCK_K: tl.constexpr,\n):\n    pid0 = tl.program_id(0)\n    pid1 = tl.program_id(1)\n    \n    offs_m = pid0 * BLOCK_M + tl.arange(0, BLOCK_M)\n    offs_n = pid1 * BLOCK_N + tl.arange(0, BLOCK_N)\n    offs_k = tl.arange(0, BLOCK_K)\n    \n    a_ptrs = a_ptr + offs_m[:, None] * stride_am + offs_k[None, :] * stride_ak\n    b_ptrs = b_ptr + offs_k[:, None] * stride_bk + offs_n[None, :] * stride_bn\n    \n    accumulator = tl.zeros((BLOCK_M, BLOCK_N), dtype=tl.float32)\n    \n    a_base_mask = (offs_m < M)[:, None]\n    b_base_mask = (offs_n < N)[None, :]\n    \n    for k in range(0, K, BLOCK_K):\n        k_remaining = K - k\n        k_mask = offs_k < k_remaining\n        \n        a_mask = a_base_mask & k_mask[None, :]\n        b_mask = k_mask[:, None] & b_base_mask\n        \n        a = tl.load(a_ptrs, mask=a_mask, other=0.0)\n        b = tl.load(b_ptrs, mask=b_mask, other=0.0)\n        \n        accumulator += tl.dot(a, b, allow_tf32=False, out_dtype=tl.float32)\n        \n        a_ptrs += BLOCK_K * stride_ak\n        b_ptrs += BLOCK_K * stride_bk\n    \n    c_ptrs = c_ptr + offs_m[:, None] * stride_cm + offs_n[None, :] * stride_cn\n    c_mask = a_base_mask & b_base_mask\n    tl.store(c_ptrs, accumulator, mask=c_mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self):\n        super(ModelNew, self).__init__()\n    \n    def forward(self, A: torch.Tensor, B: torch.Tensor) -> torch.Tensor:\n        M, K1 = A.shape\n        K2, N = B.shape\n        assert K1 == K2, \"Matrix dimensions mismatch\"\n        \n        A_cont = A.contiguous()\n        B_cont = B.contiguous()\n        C = torch.empty((M, N), device=A.device, dtype=A.dtype)\n        \n        BLOCK_M = 128\n        BLOCK_N = 128\n        BLOCK_K = 64\n        \n        grid = (triton.cdiv(M, BLOCK_M), triton.cdiv(N, BLOCK_N))\n        \n        matmul_kernel[grid](\n            A_cont, B_cont, C,\n            M, N, K1,\n            A_cont.stride(0), A_cont.stride(1),\n            B_cont.stride(0), B_cont.stride(1),\n            C.stride(0), C.stride(1),\n            BLOCK_M=BLOCK_M, BLOCK_N=BLOCK_N, BLOCK_K=BLOCK_K,\n            num_warps=8\n        )\n        return C\n\nM = 256\nN = 256\nK = 131072\n\ndef get_inputs():\n    A = torch.randn(M, K)\n    B = torch.randn(K, N)\n    return [A, B]\n\ndef get_init_inputs():\n    return []\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Alternative approach to compiled, Alternative approach to correctness\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 20.0000, Type: High-Performer)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef matmul_kernel(\n    a_ptr, b_ptr, c_ptr,\n    M, N, K,\n    stride_am, stride_ak,\n    stride_bk, stride_bn,\n    stride_cm, stride_cn,\n    BLOCK_M: tl.constexpr, BLOCK_N: tl.constexpr, BLOCK_K: tl.constexpr,\n):\n    pid = tl.program_id(0)\n    num_pid_n = tl.cdiv(N, BLOCK_N)\n    pid_m = pid // num_pid_n\n    pid_n = pid % num_pid_n\n    \n    offs_m = pid_m * BLOCK_M + tl.arange(0, BLOCK_M)\n    offs_n = pid_n * BLOCK_N + tl.arange(0, BLOCK_N)\n    offs_k = tl.arange(0, BLOCK_K)\n    \n    a_ptrs = a_ptr + offs_m[:, None] * stride_am + offs_k[None, :] * stride_ak\n    b_ptrs = b_ptr + offs_k[:, None] * stride_bk + offs_n[None, :] * stride_bn\n    \n    acc = tl.zeros((BLOCK_M, BLOCK_N), dtype=tl.float32)\n    \n    base_mask_A = (offs_m < M)[:, None]\n    base_mask_B = (offs_n < N)[None, :]\n    \n    for k in range(0, tl.cdiv(K, BLOCK_K)):\n        k_remaining = K - k * BLOCK_K\n        k_mask = offs_k < k_remaining\n        \n        a = tl.load(a_ptrs, mask=base_mask_A & k_mask[None, :], other=0.0)\n        b = tl.load(b_ptrs, mask=k_mask[:, None] & base_mask_B, other=0.0)\n        \n        acc += tl.dot(a, b, allow_tf32=False)\n        a_ptrs += BLOCK_K * stride_ak\n        b_ptrs += BLOCK_K * stride_bk\n    \n    c_ptrs = c_ptr + offs_m[:, None] * stride_cm + offs_n[None, :] * stride_cn\n    mask = base_mask_A & base_mask_B\n    tl.store(c_ptrs, acc, mask=mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self):\n        super(ModelNew, self).__init__()\n    \n    def forward(self, A: torch.Tensor, B: torch.Tensor) -> torch.Tensor:\n        M, K1 = A.shape\n        K2, N = B.shape\n        assert K1 == K2, \"Incompatible dimensions\"\n        \n        C = torch.empty((M, N), device=A.device, dtype=A.dtype)\n        grid = lambda META: (triton.cdiv(M, META['BLOCK_M']) * triton.cdiv(N, META['BLOCK_N']),)\n        \n        matmul_kernel[grid](\n            A, B, C,\n            M, N, K1,\n            A.stride(0), A.stride(1),\n            B.stride(0), B.stride(1),\n            C.stride(0), C.stride(1),\n            BLOCK_M=64, BLOCK_N=64, BLOCK_K=32,\n            num_warps=4\n        )\n        return C\n\nM = 256\nN = 256\nK = 131072\n\ndef get_inputs():\n    A = torch.randn(M, K, device='cuda')\n    B = torch.randn(K, N, device='cuda')\n    return [A, B]\n\ndef get_init_inputs():\n    return []\n# =================== EVOLVE-BLOCK-END ===================\n```\nUnique approach: Modification: Full rewrite, Excellent compiled (1.000), Excellent correctness (1.000)\n\n\n### Inspiration 2 (Score: 10.0000, Type: High-Performer)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 128, 'BLOCK_K': 32}, num_warps=8),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 64, 'BLOCK_K': 64}, num_warps=8),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 128, 'BLOCK_K': 64}, num_warps=8),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 128, 'BLOCK_K': 32}, num_warps=8),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 64, 'BLOCK_K': 32}, num_warps=8),\n    ],\n    key=['M', 'N', 'K'],\n)\n@triton.jit\ndef matmul_kernel(\n    a_ptr, b_ptr, c_ptr,\n    M, N, K,\n    stride_am, stride_ak,\n    stride_bk, stride_bn,\n    stride_cm, stride_cn,\n    BLOCK_M: tl.constexpr, BLOCK_N: tl.constexpr, BLOCK_K: tl.constexpr,\n):\n    pid0 = tl.program_id(0)\n    pid1 = tl.program_id(1)\n    \n    offs_m = pid0 * BLOCK_M + tl.arange(0, BLOCK_M)\n    offs_n = pid1 * BLOCK_N + tl.arange(0, BLOCK_N)\n    offs_k = tl.arange(0, BLOCK_K)\n    \n    a_ptrs = a_ptr + offs_m[:, None] * stride_am + offs_k[None, :] * stride_ak\n    b_ptrs = b_ptr + offs_k[:, None] * stride_bk + offs_n[None, :] * stride_bn\n    \n    accumulator = tl.zeros((BLOCK_M, BLOCK_N), dtype=tl.float32)\n    \n    a_base_mask = (offs_m < M)[:, None]\n    b_base_mask = (offs_n < N)[None, :]\n    \n    for k in range(0, K, BLOCK_K):\n        k_remaining = K - k\n        k_mask = offs_k < k_remaining\n        \n        a_mask = a_base_mask & k_mask[None, :]\n        b_mask = k_mask[:, None] & b_base_mask\n        \n        a = tl.load(a_ptrs, mask=a_mask, other=0.0)\n        b = tl.load(b_ptrs, mask=b_mask, other=0.0)\n        \n        # Convert to FP16 for Tensor Core acceleration\n        a_f16 = a.to(tl.float16)\n        b_f16 = b.to(tl.float16)\n        \n        # Use Tensor Cores for FP16 matrix multiplication\n        accumulator += tl.dot(a_f16, b_f16, out_dtype=tl.float32)\n        \n        a_ptrs += BLOCK_K * stride_ak\n        b_ptrs += BLOCK_K * stride_bk\n    \n    c_ptrs = c_ptr + offs_m[:, None] * stride_cm + offs_n[None, :] * stride_cn\n    c_mask = a_base_mask & b_base_mask\n    tl.store(c_ptrs, accumulator, mask=c_mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self):\n        super(ModelNew, self).__init__()\n    \n    def forward(self, A: torch.Tensor, B: torch.Tensor) -> torch.Tensor:\n        M, K1 = A.shape\n        K2, N = B.shape\n        assert K1 == K2, \"Matrix dimensions mismatch\"\n        \n        A_cont = A.contiguous()\n        B_cont = B.contiguous()\n        C = torch.empty((M, N), device=A.device, dtype=A.dtype)\n        \n        grid = (triton.cdiv(M, 128), triton.cdiv(N, 128))\n        \n        matmul_kernel[grid](\n            A_cont, B_cont, C,\n            M, N, K1,\n            A_cont.stride(0), A_cont.stride(1),\n            B_cont.stride(0), B_cont.stride(1),\n            C.stride(0), C.stride(1),\n        )\n        return C\n\nM = 256\nN = 256\nK = 131072\n\ndef get_inputs():\n    A = torch.randn(M, K)\n    B = torch.randn(K, N)\n    return [A, B]\n\ndef get_init_inputs():\n    return []\n# =================== EVOLVE-BLOCK-END ===================\n```\nUnique approach: Modification: Full rewrite, Excellent compiled (1.000), Alternative correctness approach\n\n\n### Inspiration 3 (Score: 10.0000, Type: High-Performer)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef matmul_kernel(\n    a_ptr, b_ptr, c_ptr,\n    M, N, K,\n    stride_am, stride_ak,\n    stride_bk, stride_bn,\n    stride_cm, stride_cn,\n    BLOCK_M: tl.constexpr, BLOCK_N: tl.constexpr, BLOCK_K: tl.constexpr,\n):\n    pid = tl.program_id(0)\n    num_pid_n = tl.cdiv(N, BLOCK_N)\n    pid_m = pid // num_pid_n\n    pid_n = pid % num_pid_n\n    \n    offs_m = pid_m * BLOCK_M + tl.arange(0, BLOCK_M)\n    offs_n = pid_n * BLOCK_N + tl.arange(0, BLOCK_N)\n    offs_k = tl.arange(0, BLOCK_K)\n    \n    a_ptrs = a_ptr + offs_m[:, None] * stride_am + offs_k[None, :] * stride_ak\n    b_ptrs = b_ptr + offs_k[:, None] * stride_bk + offs_n[None, :] * stride_bn\n    \n    acc = tl.zeros((BLOCK_M, BLOCK_N), dtype=tl.float32)\n    \n    # Create base masks for row and column boundaries\n    base_mask_A = (offs_m < M)[:, None]\n    base_mask_B = (offs_n < N)[None, :]\n    \n    for k in range(0, tl.cdiv(K, BLOCK_K)):\n        k_remaining = K - k * BLOCK_K\n        k_mask = offs_k < k_remaining\n        \n        # Combine boundary masks with k_mask for safe loading\n        a_mask = base_mask_A & k_mask[None, :]\n        b_mask = k_mask[:, None] & base_mask_B\n        \n        a = tl.load(a_ptrs, mask=a_mask, other=0.0)\n        b = tl.load(b_ptrs, mask=b_mask, other=0.0)\n        \n        # Enable TF32 tensor cores for faster computation\n        acc += tl.dot(a, b, allow_tf32=True)\n        a_ptrs += BLOCK_K * stride_ak\n        b_ptrs += BLOCK_K * stride_bk\n    \n    c_ptrs = c_ptr + offs_m[:, None] * stride_cm + offs_n[None, :] * stride_cn\n    mask = base_mask_A & base_mask_B\n    tl.store(c_ptrs, acc, mask=mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self):\n        super(ModelNew, self).__init__()\n    \n    def forward(self, A: torch.Tensor, B: torch.Tensor) -> torch.Tensor:\n        M, K1 = A.shape\n        K2, N = B.shape\n        assert K1 == K2, \"Incompatible dimensions\"\n        \n        C = torch.empty((M, N), device=A.device, dtype=A.dtype)\n        grid = lambda META: (triton.cdiv(M, META['BLOCK_M']) * triton.cdiv(N, META['BLOCK_N']),)\n        \n        matmul_kernel[grid](\n            A, B, C,\n            M, N, K1,\n            A.stride(0), A.stride(1),\n            B.stride(0), B.stride(1),\n            C.stride(0), C.stride(1),\n            BLOCK_M=32, BLOCK_N=32, BLOCK_K=128,\n            num_warps=4\n        )\n        return C\n\nM = 256\nN = 256\nK = 131072\n\ndef get_inputs():\n    A = torch.randn(M, K, device='cuda')\n    B = torch.randn(K, N, device='cuda')\n    return [A, B]\n\ndef get_init_inputs():\n    return []\n# =================== EVOLVE-BLOCK-END ===================\n```\nUnique approach: Modification: Full rewrite, Excellent compiled (1.000), Alternative correctness approach\n\n\n### Inspiration 4 (Score: 20.0000, Type: High-Performer)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef matmul_kernel(\n    a_ptr, b_ptr, c_ptr,\n    M, N, K,\n    stride_am, stride_ak,\n    stride_bk, stride_bn,\n    stride_cm, stride_cn,\n    BLOCK_M: tl.constexpr, BLOCK_N: tl.constexpr, BLOCK_K: tl.constexpr,\n):\n    pid = tl.program_id(0)\n    num_pid_n = tl.cdiv(N, BLOCK_N)\n    pid_m = pid // num_pid_n\n    pid_n = pid % num_pid_n\n    \n    offs_m = pid_m * BLOCK_M + tl.arange(0, BLOCK_M)\n    offs_n = pid_n * BLOCK_N + tl.arange(0, BLOCK_N)\n    offs_k = tl.arange(0, BLOCK_K)\n    \n    a_ptrs = a_ptr + offs_m[:, None] * stride_am + offs_k[None, :] * stride_ak\n    b_ptrs = b_ptr + offs_k[:, None] * stride_bk + offs_n[None, :] * stride_bn\n    \n    acc = tl.zeros((BLOCK_M, BLOCK_N), dtype=tl.float32)\n    \n    for k in range(0, tl.cdiv(K, BLOCK_K)):\n        k_remaining = K - k * BLOCK_K\n        k_mask = offs_k < k_remaining\n        \n        a = tl.load(a_ptrs, mask=k_mask[None, :], other=0.0)\n        b = tl.load(b_ptrs, mask=k_mask[:, None], other=0.0)\n        \n        acc += tl.dot(a, b, allow_tf32=False)\n        a_ptrs += BLOCK_K * stride_ak\n        b_ptrs += BLOCK_K * stride_bk\n    \n    offs_m = pid_m * BLOCK_M + tl.arange(0, BLOCK_M)\n    offs_n = pid_n * BLOCK_N + tl.arange(0, BLOCK_N)\n    c_ptrs = c_ptr + offs_m[:, None] * stride_cm + offs_n[None, :] * stride_cn\n    mask = (offs_m < M)[:, None] & (offs_n < N)[None, :]\n    tl.store(c_ptrs, acc, mask=mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self):\n        super(ModelNew, self).__init__()\n    \n    def forward(self, A: torch.Tensor, B: torch.Tensor) -> torch.Tensor:\n        M, K1 = A.shape\n        K2, N = B.shape\n        assert K1 == K2, \"Incompatible dimensions\"\n        \n        C = torch.empty((M, N), device=A.device, dtype=A.dtype)\n        grid = lambda META: (triton.cdiv(M, META['BLOCK_M']) * triton.cdiv(N, META['BLOCK_N']),)\n        \n        matmul_kernel[grid](\n            A, B, C,\n            M, N, K1,\n            A.stride(0), A.stride(1),\n            B.stride(0), B.stride(1),\n            C.stride(0), C.stride(1),\n            BLOCK_M=64, BLOCK_N=64, BLOCK_K=32,\n            num_warps=4\n        )\n        return C\n\nM = 256\nN = 256\nK = 131072\n\ndef get_inputs():\n    A = torch.randn(M, K, device='cuda')\n    B = torch.randn(K, N, device='cuda')\n    return [A, B]\n\ndef get_init_inputs():\n    return []\n# =================== EVOLVE-BLOCK-END ===================\n```\nUnique approach: Modification: Full rewrite, Excellent compiled (1.000), Excellent correctness (1.000)\n\n\n### Inspiration 5 (Score: 20.0000, Type: High-Performer)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef matmul_kernel(\n    a_ptr, b_ptr, c_ptr,\n    M, N, K,\n    stride_am, stride_ak,\n    stride_bk, stride_bn,\n    stride_cm, stride_cn,\n    BLOCK_M: tl.constexpr, BLOCK_N: tl.constexpr, BLOCK_K: tl.constexpr,\n):\n    pid0 = tl.program_id(0)\n    pid1 = tl.program_id(1)\n    \n    rm = pid0 * BLOCK_M + tl.arange(0, BLOCK_M)\n    rn = pid1 * BLOCK_N + tl.arange(0, BLOCK_N)\n    rk = tl.arange(0, BLOCK_K)\n    \n    a_ptrs = a_ptr + rm[:, None] * stride_am + rk[None, :] * stride_ak\n    b_ptrs = b_ptr + rk[:, None] * stride_bk + rn[None, :] * stride_bn\n    \n    acc = tl.zeros((BLOCK_M, BLOCK_N), dtype=tl.float32)\n    \n    for k in range(0, K, BLOCK_K):\n        k_remaining = K - k\n        a_mask = (rm[:, None] < M) & (rk[None, :] < k_remaining)\n        b_mask = (rk[:, None] < k_remaining) & (rn[None, :] < N)\n        \n        a = tl.load(a_ptrs, mask=a_mask, other=0.0)\n        b = tl.load(b_ptrs, mask=b_mask, other=0.0)\n        acc += tl.dot(a, b, allow_tf32=False, out_dtype=tl.float32)\n        \n        a_ptrs += BLOCK_K * stride_ak\n        b_ptrs += BLOCK_K * stride_bk\n    \n    c_ptrs = c_ptr + rm[:, None] * stride_cm + rn[None, :] * stride_cn\n    c_mask = (rm[:, None] < M) & (rn[None, :] < N)\n    tl.store(c_ptrs, acc, mask=c_mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self):\n        super(ModelNew, self).__init__()\n    \n    def forward(self, A: torch.Tensor, B: torch.Tensor) -> torch.Tensor:\n        M, K1 = A.shape\n        K2, N = B.shape\n        assert K1 == K2, \"Matrix dimensions mismatch\"\n        \n        A_cont = A.contiguous()\n        B_cont = B.contiguous()\n        C = torch.empty((M, N), device=A.device, dtype=A.dtype)\n        \n        grid = (\n            triton.cdiv(M, 128),\n            triton.cdiv(N, 128),\n        )\n        \n        matmul_kernel[grid](\n            A_cont, B_cont, C,\n            M, N, K1,\n            A_cont.stride(0), A_cont.stride(1),\n            B_cont.stride(0), B_cont.stride(1),\n            C.stride(0), C.stride(1),\n            BLOCK_M=128, BLOCK_N=128, BLOCK_K=32\n        )\n        \n        return C\n\nM = 256\nN = 256\nK = 131072\n\ndef get_inputs():\n    A = torch.randn(M, K)\n    B = torch.randn(K, N)\n    return [A, B]\n\ndef get_init_inputs():\n    return []  # No special initialization inputs needed\n# =================== EVOLVE-BLOCK-END ===================\n```\nUnique approach: Modification: Full rewrite, Excellent compiled (1.000), Excellent correctness (1.000)\n\n\n\n# Current Program\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 64, 'BLOCK_K': 128}, num_warps=8, num_stages=3),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 128, 'BLOCK_K': 128}, num_warps=8, num_stages=3),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 128, 'BLOCK_K': 128}, num_warps=8, num_stages=3),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 64, 'BLOCK_K': 128}, num_warps=8, num_stages=3),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 128, 'BLOCK_K': 64}, num_warps=8, num_stages=3),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 64, 'BLOCK_K': 64}, num_warps=4, num_stages=3),\n        triton.Config({'BLOCK_M': 32, 'BLOCK_N': 32, 'BLOCK_K': 128}, num_warps=4, num_stages=3),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 64, 'BLOCK_K': 256}, num_warps=8, num_stages=3),\n    ],\n    key=['M', 'N', 'K'],\n)\n@triton.jit\ndef matmul_kernel(\n    a_ptr, b_ptr, c_ptr,\n    M, N, K,\n    stride_am, stride_ak,\n    stride_bk, stride_bn,\n    stride_cm, stride_cn,\n    BLOCK_M: tl.constexpr, BLOCK_N: tl.constexpr, BLOCK_K: tl.constexpr,\n):\n    pid = tl.program_id(0)\n    num_pid_n = tl.cdiv(N, BLOCK_N)\n    pid_m = pid // num_pid_n\n    pid_n = pid % num_pid_n\n    \n    offs_m = pid_m * BLOCK_M + tl.arange(0, BLOCK_M)\n    offs_n = pid_n * BLOCK_N + tl.arange(0, BLOCK_N)\n    offs_k = tl.arange(0, BLOCK_K)\n    \n    a_ptrs = a_ptr + offs_m[:, None] * stride_am + offs_k[None, :] * stride_ak\n    b_ptrs = b_ptr + offs_k[:, None] * stride_bk + offs_n[None, :] * stride_bn\n    \n    accumulator = tl.zeros((BLOCK_M, BLOCK_N), dtype=tl.float32)\n    \n    base_mask_m = (offs_m < M)[:, None]\n    base_mask_n = (offs_n < N)[None, :]\n    \n    for k in range(0, tl.cdiv(K, BLOCK_K)):\n        k_remaining = K - k * BLOCK_K\n        k_mask = offs_k < k_remaining\n        \n        a_mask = base_mask_m & k_mask[None, :]\n        b_mask = k_mask[:, None] & base_mask_n\n        \n        a = tl.load(a_ptrs, mask=a_mask, other=0.0)\n        b = tl.load(b_ptrs, mask=b_mask, other=0.0)\n        \n        accumulator += tl.dot(a, b, allow_tf32=False)\n        \n        a_ptrs += BLOCK_K * stride_ak\n        b_ptrs += BLOCK_K * stride_bk\n    \n    c_ptrs = c_ptr + offs_m[:, None] * stride_cm + offs_n[None, :] * stride_cn\n    c_mask = base_mask_m & base_mask_n\n    tl.store(c_ptrs, accumulator, mask=c_mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self):\n        super(ModelNew, self).__init__()\n    \n    def forward(self, A: torch.Tensor, B: torch.Tensor) -> torch.Tensor:\n        A = A.contiguous()\n        B = B.contiguous()\n        M, K = A.shape\n        K, N = B.shape\n        C = torch.empty((M, N), device=A.device, dtype=A.dtype)\n        \n        grid = lambda META: (triton.cdiv(M, META['BLOCK_M']) * triton.cdiv(N, META['BLOCK_N']),)\n        matmul_kernel[grid](\n            A, B, C,\n            M, N, K,\n            A.stride(0), A.stride(1),\n            B.stride(0), B.stride(1),\n            C.stride(0), C.stride(1),\n        )\n        return C\n\nM = 256\nN = 256\nK = 131072\n\ndef get_inputs():\n    A = torch.randn(M, K, device='cuda')\n    B = torch.randn(K, N, device='cuda')\n    return [A, B]\n\ndef get_init_inputs():\n    return []\n# =================== EVOLVE-BLOCK-END ===================\n```\n\n# Task\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```\n", "responses": ["<think>\nWe are given a Triton kernel for matrix multiplication that uses autotuning and has a speed_up of 0.017 (which is very slow compared to the reference). The goal is to improve the performance.\n\nAnalysis of the current kernel:\n- The kernel uses a 1D grid of program IDs, which is flattened from 2D (pid_m and pid_n).\n- It loads blocks of A and B and accumulates the dot product in a loop over K.\n- The current kernel disables Tensor Cores (allow_tf32=False) and uses FP32 accumulation.\n\nThe problem: The matrix dimensions are M=256, N=256, K=131072. This is a very long K dimension and a relatively small M and N. The current kernel might be inefficient because:\n1. The block size in K (BLOCK_K) in the autotune configs is up to 256, but the long K dimension might require more efficient memory access patterns.\n2. We are not leveraging Tensor Cores (which are available on H100/H800 for FP16 and BF16). The input tensors are not specified, but the example `get_inputs` uses `torch.randn` which by default is FP32. However, note that the Triton kernel uses FP32 accumulation and the dot product is in FP32.\n\nHowever, note that the reference timing is 0.0324 ms and the custom kernel takes 1.87 ms (from the meta). This is a huge slowdown.\n\nInspiration from the top programs and diverse programs:\n- Program 2 (which is the current program) achieved a speed_up of 0.017 (which is 1.7% of the reference speed) and is the best among the top.\n- Program D2 uses a 2D grid and a fixed block size of 128x128 and BLOCK_K=64, and it uses 8 warps.\n\nLooking at the inspiration programs:\n- Inspiration 2 uses Tensor Cores by converting the loaded A and B to FP16 and then using `tl.dot` with FP16. However, note that the accumulation is still in FP32. This might be faster if the hardware supports it and if the input data type is compatible.\n\nGiven the hardware (NVIDIA L20Y / H800 with SM8.9) and that it has FP16 Tensor Cores (32x16x16), we should try to use Tensor Cores. However, note that the input tensors in `get_inputs` are FP32. We have two options:\n1. Change the kernel to use FP32 inputs and use TF32 Tensor Cores (which are designed for FP32 inputs). This requires enabling `allow_tf32=True` and using a block size that is a multiple of 16 (for Tensor Cores).\n2. Change the input tensors to FP16? But the problem states that the original program has the same inputs and outputs. The original PyTorch reference is not shown, but the `get_inputs` returns FP32 tensors. We cannot change the input data type without breaking correctness.\n\nTherefore, let's consider using TF32 Tensor Cores. The H100 supports TF32, which is a 19-bit format that uses the same Tensor Cores as FP16. We can enable TF32 by setting `allow_tf32=True` in the `tl.dot` product.\n\nAdditionally, we must choose block sizes that are efficient for Tensor Cores. Tensor Cores require the inner dimension to be a multiple of 16 (or 32 for some cases). The current autotune configs have BLOCK_K values that are powers of two, but we should ensure that they are multiples of 16 (or 32) for better Tensor Core utilization.\n\nMoreover, the current kernel uses a 1D grid. For large K, we might want to use a different tiling strategy? However, the problem dimensions are fixed: M=256, N=256, K=131072. This is a very skinny matrix (M and N are small, K is large). We might want to have a larger BLOCK_K to reduce the number of iterations and improve memory access.\n\nBut note: the current autotune configs have BLOCK_K up to 256. However, the kernel uses `tl.cdiv(K, BLOCK_K)` iterations. For K=131072 and BLOCK_K=256, that would be 512 iterations. This might be too many and cause overhead.\n\nAlternatively, we can try to use a 2D grid and use a different tiling strategy? But the problem says we cannot change the grid configuration. However, note that the grid is defined in the `ModelNew.forward` function. We are allowed to change the kernel as long as we don't change the function signature. We can change the grid if we change the kernel accordingly? But the problem states: \"\u274c NEVER change @triton.jit function signatures or parameter names\" and \"\u274c NEVER modify grid configuration, output tensor shapes, or PID logic\". So we must keep the grid as a 1D grid? Actually, the current grid is 1D, and we cannot change it to 2D because that would change the PID logic.\n\nSo we are stuck with a 1D grid? Actually, the grid in the `forward` function is defined as:\n    grid = lambda META: (triton.cdiv(M, META['BLOCK_M']) * triton.cdiv(N, META['BLOCK_N']),)\n\nThis is a 1D grid. The kernel must be written for 1D.\n\nBut note: the top program \"Program 1\" (which is an earlier version) had a speed_up of 0.008 (which is worse) and used BLOCK_M=64, BLOCK_N=64, BLOCK_K=32.\n\nWhat can we do?\n1. Enable TF32 by setting `allow_tf32=True` in the `tl.dot` call. This might give a significant speedup on Tensor Cores for FP32 matrices.\n2. Adjust the autotune configs to use block sizes that are more friendly to Tensor Cores (multiples of 16, 32, 64). Also, we might want to try larger BLOCK_K to reduce the number of iterations.\n\nBut note: the current autotune configs are already using BLOCK_K of 64, 128, 256. However, the kernel disables TF32.\n\nLet's change the `tl.dot` to use `allow_tf32=True` and see if that helps.\n\nAdditionally, we can try to optimize the memory access by using vectorized loads. However, the current kernel does not use vectorization.\n\nAnother idea: the long K dimension might benefit from having a larger BLOCK_K to reduce the number of iterations and to improve L2 cache usage. We can try to add a config with a very large BLOCK_K (like 512) and see if it helps.\n\nBut note: the autotune configs are defined in the `@triton.autotune` decorator. We can modify the list of configs to include larger BLOCK_K and also to enable TF32.\n\nHowever, the problem says: \"Make sure your rewritten program maintains the same inputs and outputs\". We are only changing the kernel and the autotune configs.\n\nProposed changes:\n1. Change the `tl.dot` call to use `allow_tf32=True`.\n2. Adjust the autotune configs to include larger BLOCK_K (like 512) and also ensure that the BLOCK_K is a multiple of 16 (or 32) for Tensor Cores. Also, we might want to try different combinations of BLOCK_M and BLOCK_N that are multiples of 64 or 128 (to fit more work per thread block) and also multiples of 16 for Tensor Cores.\n\nBut note: Tensor Cores require the inner dimension (BLOCK_K) to be a multiple of 16 (for FP32 in TF32 mode) and the outer dimensions (BLOCK_M and BLOCK_N) to be multiples of 16 as well? Actually, the Triton documentation says that the dot operation will use Tensor Cores automatically when the inputs are FP32 and `allow_tf32=True` and the block sizes are multiples of 16.\n\nWe will adjust the autotune configs to have BLOCK_K that are multiples of 16 and also try to make BLOCK_M and BLOCK_N multiples of 16 (which they already are) and also try to make them larger for better Tensor Core utilization.\n\nLet's update the autotune configs to:\n- Remove configs that are not Tensor Core friendly (like BLOCK_K=32, which is 32 mod 16 is 0 -> it is a multiple, but 32 is small so we leave it?).\n- Add configs with BLOCK_K=512 and 1024 to reduce the number of iterations.\n\nBut note: the maximum BLOCK_K is limited by the shared memory? Each thread block uses BLOCK_M * BLOCK_K + BLOCK_K * BLOCK_N elements. For example, with BLOCK_M=128, BLOCK_N=128, BLOCK_K=512: \n  128*512 + 512*128 = 128*512*2 = 128*1024 = 131072 elements, each of 4 bytes -> 524288 bytes (512KB). The H100 has 228KB of shared memory per SM, so this is too big.\n\nTherefore, we must choose BLOCK_K such that the shared memory usage is within 228KB. The maximum shared memory per block is 228KB. So we can compute:\n\n   (BLOCK_M * BLOCK_K + BLOCK_K * BLOCK_N) * 4 <= 228 * 1024\n\nFor BLOCK_M=128, BLOCK_N=128:\n   128*BLOCK_K + 128*BLOCK_K = 256 * BLOCK_K * 4 = 1024 * BLOCK_K <= 228*1024 -> BLOCK_K <= 228.\n\nSo we cannot use BLOCK_K=256? Actually, 256*1024 = 262144 bytes = 256 KB, which is more than 228KB. Therefore, the config with BLOCK_K=256 is already too big? But it was included and compiled. How? Maybe Triton uses a different way to split the work? Or maybe it uses global memory and doesn't use shared memory for accumulation? \n\nActually, in Triton, the dot product is done in registers? And the loads are from global memory to registers. So the shared memory is not used? Then the constraint is the register file. The number of registers required per thread is (BLOCK_M * BLOCK_N) / (number of threads in a warp * number of warps). This might be too high.\n\nAlternatively, the kernel might be using too many registers and spilling to global memory, which would be slow.\n\nGiven the complexity, we will try two things:\n1. Enable TF32 by changing `allow_tf32=False` to `allow_tf32=True`.\n2. Adjust the autotune configs to use BLOCK_K that are multiples of 16 and also try to avoid too large BLOCK_K that might cause register spilling. We will keep the BLOCK_K at 128 and below.\n\nBut note: the current configs already have BLOCK_K=128 and 256. The 256 one might be causing register spilling? We can remove the 256 and add 64, 128, and maybe 192? But 192 is not a multiple of 16? Actually, 192/16=12, so it is a multiple.\n\nHowever, to keep it simple, we will change only the `allow_tf32` and see if that improves the performance.\n\nBut note: the problem says to make small iterative changes (<=20 lines). So we will change only the `allow_tf32` and leave the autotune configs as they are.\n\nAlternatively, we can try to add a config with BLOCK_K=16? But that would be too small and increase the number of iterations. We are better off with larger BLOCK_K.\n\nLet's try to change the kernel to use TF32 and also adjust one of the configs to use a larger BLOCK_K? But we are constrained by shared memory? Actually, we are not using shared memory explicitly. The Triton dot product might use tensor cores without requiring shared memory.\n\nWe will do:\n\nIn the kernel, change:\n    accumulator += tl.dot(a, b, allow_tf32=False)\nto:\n    accumulator += tl.dot(a, b, allow_tf32=True)\n\nAdditionally, we can try to add a config with BLOCK_K=256? But we saw that it might be too big. Alternatively, we can try to use a smaller BLOCK_M and BLOCK_N and a larger BLOCK_K? For example, BLOCK_M=64, BLOCK_N=64, BLOCK_K=256: \n   The memory per thread: we are loading a block of 64*256 and 256*64? Actually, the kernel loads a block of A of size (BLOCK_M, BLOCK_K) and a block of B of size (BLOCK_K, BLOCK_N). The accumulator is (BLOCK_M, BLOCK_N). The registers required for the accumulator: 64*64=4096 per thread? And we have 256 threads per block (if we use 8 warps * 32 threads = 256 threads). Then each thread would hold 4096/256 = 16 elements? That is acceptable? But the dot product operation in Triton might not require holding the entire A and B in registers at once.\n\nGiven the complexity, we will only change the `allow_tf32` and hope that it gives a speedup.\n\nBut note: the current program has a speed_up of 0.017 (which is 1.7% of the reference). The reference runs in 0.0324 ms and the kernel in 1.87 ms. We need a 5% speedup (so at least 0.0324 * 20 = 0.648 ms) to get a speedup of 20? Actually, the scoring is (speed_up - 1) * 100, and we require speedup>1. Currently, we are at 0.017 which is less than 1. We need to get above 1.\n\nBut note: the reference timing is 0.0324 ms and we are at 1.87 ms. We need to make the kernel at least 20 times faster to get a speedup of 1 (i.e., same as reference) and then more to get a positive score.\n\nThis is a big challenge. Therefore, we must do more:\n\nWe note that the matrix is very skinny (M=256, N=256, K=131072). The reference implementation in PyTorch might be using a highly optimized kernel for this shape? Or it might be using a kernel that is efficient for large K.\n\nWe can try to change the kernel to use a different tiling strategy? For example, we can tile in the K dimension and have each block compute a chunk of K? But the problem is that we are multiplying two matrices and the output is MxN.\n\nAlternatively, we can use a block size that is long in the K dimension and short in M and N? But note: the grid is defined over M and N. We cannot change that.\n\nAnother idea: use the fact that K is very large and the output is small (256x256) to do a reduction in parallel? But the current kernel already does a reduction in series in the inner loop.\n\nWe might try to use multiple warps to compute the same output block? But that would require atomic operations, which are slow.\n\nAlternatively, we can try to use a different kernel that transposes B first? But that would require extra memory and we are not allowed to change the inputs.\n\nGiven the time, we will try two changes:\n1. Enable TF32.\n2. Change the autotune configs to use a larger BLOCK_K (like 512) in a config that has small BLOCK_M and BLOCK_N to avoid too many registers? But we are constrained by the shared memory? Actually, we are not using shared memory.\n\nWe will add a config with BLOCK_M=32, BLOCK_N=32, BLOCK_K=512. This would have 32*512 + 512*32 = 32768 elements * 4 bytes = 131072 bytes = 128 KB, which is less than 228KB? Actually, 128KB is less than 228KB, so it should be acceptable.\n\nBut note: the number of threads: we are using 8 warps in some configs? For BLOCK_M=32, BLOCK_N=32, we can use fewer warps? We set num_warps=4 for this config.\n\nWe will change:\n- In the autotune configs, add a new config: `triton.Config({'BLOCK_M': 32, 'BLOCK_N': 32, 'BLOCK_K': 512}, num_warps=4, num_stages=3)`\n- And change the dot product to use `allow_tf32=True`.\n\nLet's write the code accordingly.\n\nBut note: the problem says to change only the Triton kernel source within the EVOLVE-BLOCK. We are going to change two lines and add one line in the autotune configs.\n\nHowever, note that the current autotune configs are defined as a list. We are going to add one config and change the dot product.\n\nBut wait: the current kernel uses `tl.cdiv(K, BLOCK_K)` and if BLOCK_K is 512, then for K=131072 we have 256 iterations. That is acceptable.\n\nWe hope that the autotuner will pick a config that is faster.\n\nAlternatively, we can remove some of the slow configs? But we don't know which ones are slow. We leave the autotuner to choose.\n\nLet's generate the code accordingly.\n\nImportant: We must not break the correctness. We are only changing the dot product to use TF32, which might have slightly different precision, but the problem allows float32 tolerance. So it should be acceptable.\n\nWe'll do:\n\n1. In the autotune configs, add a new config for (32,32,512) with num_warps=4.\n2. Change the `allow_tf32` from `False` to `True`.\n\nBut note: the current kernel has `allow_tf32=False`. We change it to `True`.\n\nCode changes:\n\nIn the autotune configs list, add:\n    triton.Config({'BLOCK_M': 32, 'BLOCK_N': 32, 'BLOCK_K': 512}, num_warps=4, num_stages=3),\n\nIn the kernel, change:\n    accumulator += tl.dot(a, b, allow_tf32=False)\nto:\n    accumulator += tl.dot(a, b, allow_tf32=True)\n\nWe are within 20 lines.\n\nLet's write the updated code.\n</think>\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 64, 'BLOCK_K': 128}, num_warps=8, num_stages=3),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 128, 'BLOCK_K': 128}, num_warps=8, num_stages=3),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 128, 'BLOCK_K': 128}, num_warps=8, num_stages=3),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 64, 'BLOCK_K': 128}, num_warps=8, num_stages=3),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 128, 'BLOCK_K': 64}, num_warps=8, num_stages=3),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 64, 'BLOCK_K': 64}, num_warps=4, num_stages=3),\n        triton.Config({'BLOCK_M': 32, 'BLOCK_N': 32, 'BLOCK_K': 128}, num_warps=4, num_stages=3),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 64, 'BLOCK_K': 256}, num_warps=8, num_stages=3),\n        triton.Config({'BLOCK_M': 32, 'BLOCK_N': 32, 'BLOCK_K': 512}, num_warps=4, num_stages=3),\n    ],\n    key=['M', 'N', 'K'],\n)\n@triton.jit\ndef matmul_kernel(\n    a_ptr, b_ptr, c_ptr,\n    M, N, K,\n    stride_am, stride_ak,\n    stride_bk, stride_bn,\n    stride_cm, stride_cn,\n    BLOCK_M: tl.constexpr, BLOCK_N: tl.constexpr, BLOCK_K: tl.constexpr,\n):\n    pid = tl.program_id(0)\n    num_pid_n = tl.cdiv(N, BLOCK_N)\n    pid_m = pid // num_pid_n\n    pid_n = pid % num_pid_n\n    \n    offs_m = pid_m * BLOCK_M + tl.arange(0, BLOCK_M)\n    offs_n = pid_n * BLOCK_N + tl.arange(0, BLOCK_N)\n    offs_k = tl.arange(0, BLOCK_K)\n    \n    a_ptrs = a_ptr + offs_m[:, None] * stride_am + offs_k[None, :] * stride_ak\n    b_ptrs = b_ptr + offs_k[:, None] * stride_bk + offs_n[None, :] * stride_bn\n    \n    accumulator = tl.zeros((BLOCK_M, BLOCK_N), dtype=tl.float32)\n    \n    base_mask_m = (offs_m < M)[:, None]\n    base_mask_n = (offs_n < N)[None, :]\n    \n    for k in range(0, tl.cdiv(K, BLOCK_K)):\n        k_remaining = K - k * BLOCK_K\n        k_mask = offs_k < k_remaining\n        \n        a_mask = base_mask_m & k_mask[None, :]\n        b_mask = k_mask[:, None] & base_mask_n\n        \n        a = tl.load(a_ptrs, mask=a_mask, other=0.0)\n        b = tl.load(b_ptrs, mask=b_mask, other=0.0)\n        \n        # Enable TF32 Tensor Cores for faster computation\n        accumulator += tl.dot(a, b, allow_tf32=True)\n        \n        a_ptrs += BLOCK_K * stride_ak\n        b_ptrs += BLOCK_K * stride_bk\n    \n    c_ptrs = c_ptr + offs_m[:, None] * stride_cm + offs_n[None, :] * stride_cn\n    c_mask = base_mask_m & base_mask_n\n    tl.store(c_ptrs, accumulator, mask=c_mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self):\n        super(ModelNew, self).__init__()\n    \n    def forward(self, A: torch.Tensor, B: torch.Tensor) -> torch.Tensor:\n        A = A.contiguous()\n        B = B.contiguous()\n        M, K = A.shape\n        K, N = B.shape\n        C = torch.empty((M, N), device=A.device, dtype=A.dtype)\n        \n        grid = lambda META: (triton.cdiv(M, META['BLOCK_M']) * triton.cdiv(N, META['BLOCK_N']),)\n        matmul_kernel[grid](\n            A, B, C,\n            M, N, K,\n            A.stride(0), A.stride(1),\n            B.stride(0), B.stride(1),\n            C.stride(0), C.stride(1),\n        )\n        return C\n\nM = 256\nN = 256\nK = 131072\n\ndef get_inputs():\n    A = torch.randn(M, K, device='cuda')\n    B = torch.randn(K, N, device='cuda')\n    return [A, B]\n\ndef get_init_inputs():\n    return []\n# =================== EVOLVE-BLOCK-END ===================\n```"]}}}