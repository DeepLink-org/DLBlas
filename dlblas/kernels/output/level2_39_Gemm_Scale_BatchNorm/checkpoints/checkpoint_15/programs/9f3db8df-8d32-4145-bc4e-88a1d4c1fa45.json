{"id": "9f3db8df-8d32-4145-bc4e-88a1d4c1fa45", "code": "# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 64, 'BLOCK_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 128, 'BLOCK_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 64, 'BLOCK_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 128, 'BLOCK_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 32, 'BLOCK_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_M': 32, 'BLOCK_N': 128, 'BLOCK_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 32, 'BLOCK_K': 128}, num_warps=4),\n        triton.Config({'BLOCK_M': 32, 'BLOCK_N': 64, 'BLOCK_K': 128}, num_warps=4),\n        triton.Config({'BLOCK_M': 32, 'BLOCK_N': 32, 'BLOCK_K': 256}, num_warps=4),\n    ],\n    key=['M', 'N', 'K'],\n)\n@triton.jit\ndef fused_linear_scale_kernel(\n    x_ptr, w_ptr, b_ptr, s_ptr, out_ptr,\n    M, N, K,\n    stride_xm, stride_xk,\n    stride_wn, stride_wk,\n    stride_bn,\n    stride_sn,\n    stride_outm, stride_outn,\n    BLOCK_M: tl.constexpr, BLOCK_N: tl.constexpr, BLOCK_K: tl.constexpr,\n):\n    pid0 = tl.program_id(0)\n    pid1 = tl.program_id(1)\n    \n    offs_m = pid0 * BLOCK_M + tl.arange(0, BLOCK_M)\n    offs_n = pid1 * BLOCK_N + tl.arange(0, BLOCK_N)\n    offs_k = tl.arange(0, BLOCK_K)\n    \n    x_ptrs = x_ptr + offs_m[:, None] * stride_xm + offs_k[None, :] * stride_xk\n    w_ptrs = w_ptr + offs_n[:, None] * stride_wn + offs_k[None, :] * stride_wk\n    \n    acc = tl.zeros((BLOCK_M, BLOCK_N), dtype=tl.float32)\n    for k in range(0, tl.cdiv(K, BLOCK_K)):\n        k_remaining = K - k * BLOCK_K\n        k_mask = offs_k < k_remaining\n        x = tl.load(x_ptrs, mask=k_mask[None, :] & (offs_m[:, None] < M), other=0.0)\n        w = tl.load(w_ptrs, mask=k_mask[None, :] & (offs_n[:, None] < N), other=0.0)\n        w = tl.transpose(w)\n        acc += tl.dot(x, w, allow_tf32=True)\n        x_ptrs += BLOCK_K * stride_xk\n        w_ptrs += BLOCK_K * stride_wk\n    \n    if b_ptr is not None:\n        b_ptrs = b_ptr + offs_n\n        b = tl.load(b_ptrs, mask=offs_n < N, other=0.0)\n        acc += b[None, :]\n    \n    s_ptrs = s_ptr + offs_n\n    scale = tl.load(s_ptrs, mask=offs_n < N, other=0.0)\n    acc *= scale[None, :]\n    \n    out_ptrs = out_ptr + offs_m[:, None] * stride_outm + offs_n[None, :] * stride_outn\n    out_mask = (offs_m[:, None] < M) & (offs_n[None, :] < N)\n    tl.store(out_ptrs, acc, mask=out_mask)\n\ndef fused_linear_scale(x, weight, bias, scale):\n    M, K = x.shape\n    N, _ = weight.shape\n    x = x.contiguous()\n    weight = weight.contiguous()\n    bias = bias.contiguous() if bias is not None else None\n    scale = scale.contiguous()\n    output = torch.empty((M, N), device=x.device, dtype=x.dtype)\n    \n    grid = lambda META: (\n        triton.cdiv(M, META['BLOCK_M']),\n        triton.cdiv(N, META['BLOCK_N'])\n    )\n    fused_linear_scale_kernel[grid](\n        x, weight, bias, scale, output,\n        M, N, K,\n        x.stride(0), x.stride(1),\n        weight.stride(0), weight.stride(1),\n        bias.stride(0) if bias is not None else 0,\n        scale.stride(0),\n        output.stride(0), output.stride(1),\n    )\n    return output\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, scale_shape, eps=1e-5, momentum=0.1):\n        super(ModelNew, self).__init__()\n        self.gemm = nn.Linear(in_features, out_features)\n        self.scale = nn.Parameter(torch.randn(scale_shape))\n        self.bn = nn.BatchNorm1d(out_features, eps=eps, momentum=momentum)\n    \n    def forward(self, x):\n        x = fused_linear_scale(\n            x, \n            self.gemm.weight, \n            self.gemm.bias, \n            self.scale\n        )\n        x = self.bn(x)\n        return x\n\nbatch_size = 128\nin_features = 1024\nout_features = 512\nscale_shape = (out_features,)\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, scale_shape]\n# =================== EVOLVE-BLOCK-END ===================", "language": "python", "parent_id": "47494b3f-453a-4bd8-89c0-62a2b9e82c24", "generation": 2, "timestamp": 1754575063.1423128, "iteration_found": 11, "metrics": {"compiled": true, "correctness": false, "score": 10, "stage": "wrong_answer", "verify_payload": {"id": "level2_39_Gemm_Scale_BatchNorm", "result": {"compiled": true, "correctness": false, "metadata": {"hardware": "NVIDIA L20Y", "device": "cuda:2", "runtime_error": "Traceback (most recent call last):\n  File \"/cpfs01/shared/llm_kernel/hujiakai/KernelLLM/validation_api_server/helpers/evaluations.py\", line 720, in run_and_check_correctness\n    output_new = model_new(*inputs)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1773, in _wrapped_call_impl\n    return self._call_impl(*args, **kwargs)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1784, in _call_impl\n    return forward_call(*args, **kwargs)\n  File \"/tmp/tmpfcadeu8g.py\", line 98, in forward\n    x = fused_linear_scale(\n  File \"/tmp/tmpfcadeu8g.py\", line 79, in fused_linear_scale\n    fused_linear_scale_kernel[grid](\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 390, in <lambda>\n    return lambda *args, **kwargs: self.run(grid=grid, warmup=False, *args, **kwargs)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 239, in run\n    benchmark()\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 228, in benchmark\n    timings = {config: self._bench(*args, config=config, **kwargs) for config in pruned_configs}\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 228, in <dictcomp>\n    timings = {config: self._bench(*args, config=config, **kwargs) for config in pruned_configs}\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 160, in _bench\n    return self.do_bench(kernel_call, quantiles=(0.5, 0.2, 0.8))\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/testing.py\", line 149, in do_bench\n    fn()\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 146, in kernel_call\n    self.fn.run(\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 594, in run\n    kernel = self.compile(src, target=target, options=options.__dict__)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/compiler/compiler.py\", line 281, in compile\n    key = f\"{triton_key()}-{src.hash()}-{backend.hash()}-{options.hash()}-{str(sorted(env_vars.items()))}\"\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/compiler/compiler.py\", line 78, in hash\n    key = f\"{self.fn.cache_key}-{str(self.attrs)}-{sorted_sig}-{constants_key}\"\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 696, in cache_key\n    dependencies_finder.visit(self.parse())\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/ast.py\", line 418, in visit\n    return visitor(node)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/ast.py\", line 426, in generic_visit\n    self.visit(item)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/ast.py\", line 418, in visit\n    return visitor(node)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 163, in visit_FunctionDef\n    self.generic_visit(node)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/ast.py\", line 426, in generic_visit\n    self.visit(item)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/ast.py\", line 418, in visit\n    return visitor(node)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 229, in visit_For\n    self.generic_visit(node)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/ast.py\", line 426, in generic_visit\n    self.visit(item)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/ast.py\", line 418, in visit\n    return visitor(node)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 217, in visit_Assign\n    self.generic_visit(node)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/ast.py\", line 428, in generic_visit\n    self.visit(value)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/ast.py\", line 418, in visit\n    return visitor(node)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/ast.py\", line 428, in generic_visit\n    self.visit(value)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/ast.py\", line 418, in visit\n    return visitor(node)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 156, in visit_Attribute\n    ret = getattr(lhs, node.attr)\nAttributeError: module 'triton.language' has no attribute 'transpose'\n", "runtime_error_name": "builtins.AttributeError", "reference_timing_ms": 0.0935, "speed_up": -1.0, "custom_timing": -1.0}, "runtime": -1.0, "runtime_stats": {}}}}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": true, "correctness": false, "score": 10, "stage": "wrong_answer", "verify_payload": {"id": "level2_39_Gemm_Scale_BatchNorm", "result": {"compiled": true, "correctness": false, "metadata": {"hardware": "NVIDIA L20Y", "device": "cuda:7", "runtime_error": "Traceback (most recent call last):\n  File \"/cpfs01/shared/llm_kernel/hujiakai/KernelLLM/validation_api_server/helpers/evaluations.py\", line 720, in run_and_check_correctness\n    output_new = model_new(*inputs)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1773, in _wrapped_call_impl\n    return self._call_impl(*args, **kwargs)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1784, in _call_impl\n    return forward_call(*args, **kwargs)\n  File \"/tmp/tmp404aa7lr.py\", line 96, in forward\n    x = fused_linear_scale(\n  File \"/tmp/tmp404aa7lr.py\", line 75, in fused_linear_scale\n    grid = (triton.cdiv(M, BLOCK_M), triton.cdiv(N, BLOCK_N))\nNameError: name 'BLOCK_M' is not defined\n", "runtime_error_name": "builtins.NameError", "reference_timing_ms": 0.0935, "speed_up": -1.0, "custom_timing": -1.0}, "runtime": -1.0, "runtime_stats": {}}}}, "island": 2}, "artifacts_json": null, "artifact_dir": null, "prompts": {"full_rewrite_user": {"system": "You are a Triton GPU core optimization engineer deeply familiar with NVIDIA H100/H800 architecture.\n\n==================== Context ====================\n\u2022 Dataset: 250 kernelbench/level1-level5 *.py files  \n  - Level1: simplest, Level5: most complex  \n\u2022 Each file contains PyTorch reference (reference_code)  \n\u2022 Goal: Generate functionally equivalent but faster Triton implementations (custom_code)  \n\u2022 Evaluation pipeline:\n    1) /verify_plus - Verify compilation & correctness  \n    2) /execute (optional) - Return terminal logs if compilation fails  \n    3) Scoring:  \n      - Speedup > 1 required for points  \n      - Score = (speed_up - 1) \u00d7 100  \n\u2022 GPU Hardware: NVIDIA L20Y / H800 (same SM8.9 as H100)  \n  - 3 TB/s HBM3 bandwidth  \n  - FP16 Tensor Core 32\u00d716\u00d716  \n\n==================== Evolution Phases ====================\n\u2460 Phase 1 [Compilation Pass]  \n  - Make Triton code compile (performance irrelevant)  \n\u2461 Phase 2 [Numerical Correctness]  \n  - Output must match PyTorch reference within float32 tolerance  \n\u2462 Phase 3 [Performance Gain]  \n  - Target \u22655% speedup (\u226515% = exceptional)  \n  - Official scoring based on speed_up field  \n\nThe Evolution system will pass the EVOLVE-BLOCK from the previous version.  \nModify ONLY the Triton kernel source within this block - all other code is LOCKED.\n\n==================== Constraints (MUST OBEY) ====================\n\u274c NEVER change @triton.jit function signatures or parameter names  \n\u274c NEVER modify grid configuration, output tensor shapes, or PID logic  \n\u274c NEVER remove boundary checks or out-of-bound masks  \n\u274c NEVER introduce race conditions, uninitialized reads, or sync gaps  \n\n\u2705 Allowed Optimizations (Examples):  \n  \u2022 Memory coalescing optimizations & vectorized tl.load/tl.store  \n  \u2022 Replace staged softmax with online/FlashAttention variants  \n  \u2022 Adaptive tuning: BLOCK_M/BLOCK_N/BLOCK_K dimensions  \n  \u2022 Multi-query-head batch processing (GQA, 5:1 patterns)  \n  \u2022 Shared/L2 buffering, Tensor Core alignment (FP16/bf16/tf32)  \n  \u2022 Stride precomputation & pointer caching  \n\n==================== Output Format ====================\nReturn ONLY the complete updated code containing the EVOLVE-BLOCK comment marker.  \nNO explanations, NO markdown, NO additional text.\nName the output structure class as ModelNew.\n\n==================== Optimization Tips ====================\n\u2022 If previous compile failed: Fix syntax/mask/stride errors first  \n\u2022 If correctness fails: Prioritize bounds mask & dtype precision  \n\u2022 When speed_up < 1: Focus on memory access & block sizing  \n\u2022 Small iterative steps: Modify \u226420 lines per revision  \n\u2022 Maintain reversibility between versions\nHere is an example to show you how to rewrite a PyTorch implementation that quantizes a high-precision tensor to int8 dtype with row-wise granularity into a Triton implementation: \nThe original PyTorch implementation is as follows: \n``` \nimport torch\ndef per_row_quantize_int8(x: torch.Tensor) -> tuple[torch.Tensor, torch.Tensor]:\n    x_amax = x.abs().float().amax(dim=1).clamp(min=1e-4)\n    scale = 127 / x_amax\n    output = (x * scale[:, None]).round().clamp(-127, 127).to(torch.int8)\n    output_scale = x_amax / 127\n\n    return output, output_scale\n``` \nThe corresponding Triton-rewritten implementation is as follows: \n``` \nimport math\nimport torch\nimport triton\nimport triton.language as tl\nfrom triton.language.extra import libdevice\n\n# rowwise quantize\n\n@triton.autotune(\n    configs=[\n        triton.Config({}, num_stages=1, num_warps=8),\n        triton.Config({}, num_stages=2, num_warps=8),\n        triton.Config({}, num_stages=4, num_warps=8),\n        triton.Config({}, num_stages=8, num_warps=8),\n        triton.Config({}, num_stages=1),\n        triton.Config({}, num_stages=2),\n        triton.Config({}, num_stages=4),\n        triton.Config({}, num_stages=8),\n        triton.Config({}, num_warps=1),\n        triton.Config({}, num_warps=2),\n        triton.Config({}, num_warps=4),\n        triton.Config({}, num_warps=8),\n    ],\n    key=[\"n_elements\"],\n)\n\n@triton.jit\ndef _quantize_rowwise(\n    x_ptr,\n    output_ptr,\n    output_scale,\n    BLOCK_SIZE: tl.constexpr,\n    P2: tl.constexpr,\n):\n    pid = tl.program_id(axis=0)\n    block_start = pid * BLOCK_SIZE\n    arange = tl.arange(0, P2)\n    offsets = block_start + arange\n    row_mask = arange < BLOCK_SIZE\n    x = tl.load(x_ptr + offsets, mask=row_mask)\n\n    abs_x = tl.abs(x)\n    max_val = tl.max(tl.where(row_mask, abs_x, 0), axis=0)\n    output = libdevice.llrint(127.0 * (x / max_val))\n    tl.store(output_ptr + offsets, output, mask=row_mask)\n    tl.store(output_scale + pid, max_val / 127)\n\n\ndef per_row_quantize_int8(x: torch.Tensor):\n    x = x.contiguous()\n    output = torch.empty(*x.shape, device=x.device, dtype=torch.int8)\n    output_scale = torch.empty(x.shape[0], device=x.device, dtype=torch.float32)\n    P2 = int(2 ** (math.ceil(math.log2(x.shape[1]))))\n    grid = lambda x: (x.shape[0],)\n    _quantize_rowwise[grid](x, output, output_scale, BLOCK_SIZE=x.shape[1], P2=P2)\n\n    return output, output_scale\n\n\n    \n``` \n", "user": "# Current Program Information\n- Current performance metrics: - compiled: 1.0000\n- correctness: 0.0000\n- score: 10.0000\n- stage: wrong_answer\n- verify_payload: {'id': 'level2_39_Gemm_Scale_BatchNorm', 'result': {'compiled': True, 'correctness': False, 'metadata': {'hardware': 'NVIDIA L20Y', 'device': 'cuda:7', 'runtime_error': 'Traceback (most recent call last):\\n  File \"/cpfs01/shared/llm_kernel/hujiakai/KernelLLM/validation_api_server/helpers/evaluations.py\", line 720, in run_and_check_correctness\\n    output_new = model_new(*inputs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1773, in _wrapped_call_impl\\n    return self._call_impl(*args, **kwargs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1784, in _call_impl\\n    return forward_call(*args, **kwargs)\\n  File \"/tmp/tmp404aa7lr.py\", line 96, in forward\\n    x = fused_linear_scale(\\n  File \"/tmp/tmp404aa7lr.py\", line 75, in fused_linear_scale\\n    grid = (triton.cdiv(M, BLOCK_M), triton.cdiv(N, BLOCK_N))\\nNameError: name \\'BLOCK_M\\' is not defined\\n', 'runtime_error_name': 'builtins.NameError', 'reference_timing_ms': 0.0935, 'speed_up': -1.0, 'custom_timing': -1.0}, 'runtime': -1.0, 'runtime_stats': {}}}\n- Areas identified for improvement: - Consider simplifying the code to improve readability and maintainability\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Unknown changes\n- Performance: compiled: 1.0000, correctness: 0.0000, score: 10.0000, stage: wrong_answer, verify_payload: {'id': 'level2_39_Gemm_Scale_BatchNorm', 'result': {'compiled': True, 'correctness': False, 'metadata': {'hardware': 'NVIDIA L20Y', 'device': 'cuda:3', 'runtime_error': 'Traceback (most recent call last):\\n  File \"/cpfs01/shared/llm_kernel/hujiakai/KernelLLM/validation_api_server/helpers/evaluations.py\", line 720, in run_and_check_correctness\\n    output_new = model_new(*inputs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1773, in _wrapped_call_impl\\n    return self._call_impl(*args, **kwargs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1784, in _call_impl\\n    return forward_call(*args, **kwargs)\\n  File \"/tmp/tmpumd5sxyc.py\", line 92, in forward\\n    x = self.bn(x)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1773, in _wrapped_call_impl\\n    return self._call_impl(*args, **kwargs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1784, in _call_impl\\n    return forward_call(*args, **kwargs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/batchnorm.py\", line 193, in forward\\n    return F.batch_norm(\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/functional.py\", line 2817, in batch_norm\\n    return torch.batch_norm(\\nRuntimeError: running_mean should contain 1024 elements not 512\\n', 'runtime_error_name': 'builtins.RuntimeError', 'reference_timing_ms': 0.0935, 'speed_up': -1.0, 'custom_timing': -1.0}, 'runtime': -1.0, 'runtime_stats': {}}}\n- Outcome: Mixed results\n\n\n### Attempt 2\n- Changes: Unknown changes\n- Performance: compiled: 1.0000, correctness: 0.0000, score: 10.0000, stage: wrong_answer, verify_payload: {'id': 'level2_39_Gemm_Scale_BatchNorm', 'result': {'compiled': True, 'correctness': False, 'metadata': {'hardware': 'NVIDIA L20Y', 'device': 'cuda:7', 'runtime_error': 'Traceback (most recent call last):\\n  File \"/cpfs01/shared/llm_kernel/hujiakai/KernelLLM/validation_api_server/helpers/evaluations.py\", line 720, in run_and_check_correctness\\n    output_new = model_new(*inputs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1773, in _wrapped_call_impl\\n    return self._call_impl(*args, **kwargs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1784, in _call_impl\\n    return forward_call(*args, **kwargs)\\n  File \"/tmp/tmp404aa7lr.py\", line 96, in forward\\n    x = fused_linear_scale(\\n  File \"/tmp/tmp404aa7lr.py\", line 75, in fused_linear_scale\\n    grid = (triton.cdiv(M, BLOCK_M), triton.cdiv(N, BLOCK_N))\\nNameError: name \\'BLOCK_M\\' is not defined\\n', 'runtime_error_name': 'builtins.NameError', 'reference_timing_ms': 0.0935, 'speed_up': -1.0, 'custom_timing': -1.0}, 'runtime': -1.0, 'runtime_stats': {}}}\n- Outcome: Mixed results\n\n\n### Attempt 1\n- Changes: Unknown changes\n- Performance: compiled: 1.0000, correctness: 1.0000, stage: success, passed: 0.0000, score: 20.0000, speed_up: 0.9260, runtime_ms: 0.1010, meta: {'hardware': 'NVIDIA L20Y', 'device': 'cuda:7', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.0935, 'speed_up': 0.926, 'custom_timing': 0.101}\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 20.0000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef fused_linear_scale_kernel(\n    x_ptr, w_ptr, b_ptr, s_ptr, out_ptr,\n    in_features, out_features,\n    stride_x, stride_w, stride_b, stride_s, stride_out,\n    BLOCK_SIZE_N: tl.constexpr, BLOCK_SIZE_K: tl.constexpr,\n):\n    pid0 = tl.program_id(0)  # Batch index\n    pid1 = tl.program_id(1)  # Output feature block index\n    \n    # Create ranges for current block\n    offs_n = pid1 * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n    offs_k = tl.arange(0, BLOCK_SIZE_K)\n    \n    # Create masks for boundaries\n    mask_n = offs_n < out_features\n    mask_k = offs_k < in_features\n    \n    # Initialize accumulator\n    acc = tl.zeros((BLOCK_SIZE_N,), dtype=tl.float32)\n    \n    # Loop over input features\n    for k in range(0, in_features, BLOCK_SIZE_K):\n        # Load block of input data\n        x_vals = tl.load(\n            x_ptr + pid0 * stride_x + k + offs_k, \n            mask=mask_k, other=0.0\n        )\n        \n        # Load block of weights\n        w_vals = tl.load(\n            w_ptr + (offs_n[:, None]) * stride_w + (k + offs_k[None, :]), \n            mask=mask_n[:, None] & mask_k[None, :], other=0.0\n        )\n        \n        # Compute partial dot product\n        x_vals_f16 = x_vals.to(tl.float16)\n        w_vals_f16 = w_vals.to(tl.float16)\n        partial = tl.sum(x_vals_f16[None, :] * w_vals_f16, axis=1)\n        acc += partial.to(tl.float32)\n    \n    # Load bias and scale\n    b_vals = tl.load(b_ptr + offs_n, mask=mask_n, other=0.0)\n    s_vals = tl.load(s_ptr + offs_n, mask=mask_n, other=0.0)\n    \n    # Apply bias and scale\n    output = (acc + b_vals) * s_vals\n    \n    # Store result\n    tl.store(\n        out_ptr + pid0 * stride_out + offs_n, \n        output, mask=mask_n\n    )\n\ndef fused_linear_scale(x, weight, bias, scale):\n    batch_size, in_features = x.shape\n    out_features = weight.shape[0]\n    \n    # Preallocate output tensor\n    output = torch.empty((batch_size, out_features), \n                         device=x.device, dtype=torch.float32)\n    \n    # Calculate grid dimensions\n    grid = lambda meta: (\n        batch_size, \n        triton.cdiv(out_features, meta['BLOCK_SIZE_N'])\n    )\n    \n    # Launch kernel with optimized block sizes\n    fused_linear_scale_kernel[grid](\n        x, weight, bias, scale, output,\n        in_features, out_features,\n        x.stride(0), weight.stride(0), \n        bias.stride(0), scale.stride(0), output.stride(0),\n        BLOCK_SIZE_N=128, BLOCK_SIZE_K=64\n    )\n    return output\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, scale_shape, eps=1e-5, momentum=0.1):\n        super(ModelNew, self).__init__()\n        self.gemm = nn.Linear(in_features, out_features)\n        self.scale = nn.Parameter(torch.randn(scale_shape))\n        self.bn = nn.BatchNorm1d(out_features, eps=eps, momentum=momentum)\n    \n    def forward(self, x):\n        # Fused linear layer + scaling\n        x = fused_linear_scale(x, self.gemm.weight, self.gemm.bias, self.scale)\n        x = self.bn(x)\n        return x\n\nbatch_size = 128\nin_features = 1024\nout_features = 512\nscale_shape = (out_features,)\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, scale_shape]\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Performs well on compiled (1.0000), Performs well on correctness (1.0000), Performs well on stage (success), Performs well on passed (0.0000), Performs well on score (20.0000), Performs well on speed_up (0.9260), Performs well on runtime_ms (0.1010), Performs well on meta ({'hardware': 'NVIDIA L20Y', 'device': 'cuda:7', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.0935, 'speed_up': 0.926, 'custom_timing': 0.101})\n\n\n### Program 2 (Score: 10.0000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 64, 'BLOCK_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 128, 'BLOCK_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 64, 'BLOCK_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 128, 'BLOCK_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 32, 'BLOCK_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_M': 32, 'BLOCK_N': 128, 'BLOCK_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 32, 'BLOCK_K': 128}, num_warps=4),\n        triton.Config({'BLOCK_M': 32, 'BLOCK_N': 64, 'BLOCK_K': 128}, num_warps=4),\n        triton.Config({'BLOCK_M': 32, 'BLOCK_N': 32, 'BLOCK_K': 256}, num_warps=4),\n    ],\n    key=['M', 'N', 'K'],\n)\n@triton.jit\ndef fused_linear_scale_kernel(\n    x_ptr, w_ptr, b_ptr, s_ptr, out_ptr,\n    M, N, K,\n    stride_xm, stride_xk,\n    stride_wn, stride_wk,\n    stride_bn,\n    stride_sn,\n    stride_outm, stride_outn,\n    BLOCK_M: tl.constexpr, BLOCK_N: tl.constexpr, BLOCK_K: tl.constexpr,\n):\n    pid0 = tl.program_id(0)\n    pid1 = tl.program_id(1)\n    \n    offs_m = pid0 * BLOCK_M + tl.arange(0, BLOCK_M)\n    offs_n = pid1 * BLOCK_N + tl.arange(0, BLOCK_N)\n    offs_k = tl.arange(0, BLOCK_K)\n    \n    x_ptrs = x_ptr + offs_m[:, None] * stride_xm + offs_k[None, :] * stride_xk\n    w_ptrs = w_ptr + offs_n[:, None] * stride_wn + offs_k[None, :] * stride_wk\n    \n    acc = tl.zeros((BLOCK_M, BLOCK_N), dtype=tl.float32)\n    for k in range(0, tl.cdiv(K, BLOCK_K)):\n        k_remaining = K - k * BLOCK_K\n        k_mask = offs_k < k_remaining\n        x = tl.load(x_ptrs, mask=k_mask[None, :] & (offs_m[:, None] < M), other=0.0)\n        w = tl.load(w_ptrs, mask=k_mask[None, :] & (offs_n[:, None] < N), other=0.0)\n        w = tl.trans(w)\n        acc += tl.dot(x, w, allow_tf32=True)\n        x_ptrs += BLOCK_K * stride_xk\n        w_ptrs += BLOCK_K * stride_wk\n    \n    if b_ptr is not None:\n        b_ptrs = b_ptr + offs_n\n        b = tl.load(b_ptrs, mask=offs_n < N, other=0.0)\n        acc += b[None, :]\n    \n    s_ptrs = s_ptr + offs_n\n    scale = tl.load(s_ptrs, mask=offs_n < N, other=0.0)\n    acc *= scale[None, :]\n    \n    out_ptrs = out_ptr + offs_m[:, None] * stride_outm + offs_n[None, :] * stride_outn\n    out_mask = (offs_m[:, None] < M) & (offs_n[None, :] < N)\n    tl.store(out_ptrs, acc, mask=out_mask)\n\ndef fused_linear_scale(x, weight, bias, scale):\n    M, K = x.shape\n    N, _ = weight.shape\n    x = x.contiguous()\n    weight = weight.contiguous()\n    bias = bias.contiguous() if bias is not None else None\n    scale = scale.contiguous()\n    output = torch.empty((M, N), device=x.device, dtype=x.dtype)\n    \n    grid = (triton.cdiv(M, BLOCK_M), triton.cdiv(N, BLOCK_N))\n    fused_linear_scale_kernel[grid](\n        x, weight, bias, scale, output,\n        M, N, K,\n        x.stride(0), x.stride(1),\n        weight.stride(0), weight.stride(1),\n        bias.stride(0) if bias is not None else 0,\n        scale.stride(0),\n        output.stride(0), output.stride(1),\n        BLOCK_M=BLOCK_M, BLOCK_N=BLOCK_N, BLOCK_K=BLOCK_K\n    )\n    return output\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, scale_shape, eps=1e-5, momentum=0.1):\n        super(ModelNew, self).__init__()\n        self.gemm = nn.Linear(in_features, out_features)\n        self.scale = nn.Parameter(torch.randn(scale_shape))\n        self.bn = nn.BatchNorm1d(out_features, eps=eps, momentum=momentum)\n    \n    def forward(self, x):\n        x = fused_linear_scale(\n            x, \n            self.gemm.weight, \n            self.gemm.bias, \n            self.scale\n        )\n        x = self.bn(x)\n        return x\n\nbatch_size = 128\nin_features = 1024\nout_features = 512\nscale_shape = (out_features,)\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, scale_shape]\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Performs well on compiled (1.0000), Performs well on correctness (0.0000), Performs well on score (10.0000), Performs well on stage (wrong_answer), Performs well on verify_payload ({'id': 'level2_39_Gemm_Scale_BatchNorm', 'result': {'compiled': True, 'correctness': False, 'metadata': {'hardware': 'NVIDIA L20Y', 'device': 'cuda:7', 'runtime_error': 'Traceback (most recent call last):\\n  File \"/cpfs01/shared/llm_kernel/hujiakai/KernelLLM/validation_api_server/helpers/evaluations.py\", line 720, in run_and_check_correctness\\n    output_new = model_new(*inputs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1773, in _wrapped_call_impl\\n    return self._call_impl(*args, **kwargs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1784, in _call_impl\\n    return forward_call(*args, **kwargs)\\n  File \"/tmp/tmp404aa7lr.py\", line 96, in forward\\n    x = fused_linear_scale(\\n  File \"/tmp/tmp404aa7lr.py\", line 75, in fused_linear_scale\\n    grid = (triton.cdiv(M, BLOCK_M), triton.cdiv(N, BLOCK_N))\\nNameError: name \\'BLOCK_M\\' is not defined\\n', 'runtime_error_name': 'builtins.NameError', 'reference_timing_ms': 0.0935, 'speed_up': -1.0, 'custom_timing': -1.0}, 'runtime': -1.0, 'runtime_stats': {}}})\n\n\n### Program 3 (Score: 10.0000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_M': 16, 'BLOCK_N': 64, 'BLOCK_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_M': 32, 'BLOCK_N': 64, 'BLOCK_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 32, 'BLOCK_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_M': 32, 'BLOCK_N': 32, 'BLOCK_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_M': 16, 'BLOCK_N': 128, 'BLOCK_K': 32}, num_warps=4),\n    ],\n    key=['M', 'N', 'K'],\n)\n@triton.jit\ndef fused_linear_scale_kernel(\n    x_ptr, w_ptr, b_ptr, s_ptr, out_ptr,\n    M, N, K,\n    stride_xm, stride_xk,\n    stride_wn, stride_wk,\n    stride_bn,\n    stride_sn,\n    stride_outm, stride_outn,\n    BLOCK_M: tl.constexpr, BLOCK_N: tl.constexpr, BLOCK_K: tl.constexpr,\n):\n    pid0 = tl.program_id(0)\n    pid1 = tl.program_id(1)\n    \n    offs_m = pid0 * BLOCK_M + tl.arange(0, BLOCK_M)\n    offs_n = pid1 * BLOCK_N + tl.arange(0, BLOCK_N)\n    offs_k = tl.arange(0, BLOCK_K)\n    \n    x_ptrs = x_ptr + offs_m[:, None] * stride_xm + offs_k[None, :] * stride_xk\n    w_ptrs = w_ptr + offs_k[:, None] * stride_wk + offs_n[None, :] * stride_wn\n    \n    acc = tl.zeros((BLOCK_M, BLOCK_N), dtype=tl.float32)\n    for k in range(0, tl.cdiv(K, BLOCK_K)):\n        k_remaining = K - k * BLOCK_K\n        k_mask = offs_k < k_remaining\n        x = tl.load(x_ptrs, mask=k_mask[None, :], other=0.0)\n        w = tl.load(w_ptrs, mask=k_mask[:, None], other=0.0)\n        acc += tl.dot(x, w, allow_tf32=True)\n        x_ptrs += BLOCK_K * stride_xk\n        w_ptrs += BLOCK_K * stride_wk\n    \n    b = tl.load(b_ptr + offs_n, mask=offs_n < N, other=0.0)\n    scale = tl.load(s_ptr + offs_n, mask=offs_n < N, other=0.0)\n    \n    acc += b[None, :]\n    acc *= scale[None, :]\n    \n    out_ptrs = out_ptr + offs_m[:, None] * stride_outm + offs_n[None, :] * stride_outn\n    out_mask = (offs_m[:, None] < M) & (offs_n[None, :] < N)\n    tl.store(out_ptrs, acc, mask=out_mask)\n\ndef fused_linear_scale(x, weight, bias, scale):\n    M, K = x.shape\n    _, N = weight.shape\n    output = torch.empty((M, N), device=x.device, dtype=x.dtype)\n    \n    grid = lambda META: (\n        triton.cdiv(M, META['BLOCK_M']),\n        triton.cdiv(N, META['BLOCK_N']),\n    )\n    fused_linear_scale_kernel[grid](\n        x, weight, bias, scale, output,\n        M, N, K,\n        x.stride(0), x.stride(1),\n        weight.stride(0), weight.stride(1),\n        bias.stride(0),\n        scale.stride(0),\n        output.stride(0), output.stride(1),\n    )\n    return output\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, scale_shape, eps=1e-5, momentum=0.1):\n        super(ModelNew, self).__init__()\n        self.gemm = nn.Linear(in_features, out_features)\n        self.scale = nn.Parameter(torch.randn(scale_shape))\n        self.bn = nn.BatchNorm1d(out_features, eps=eps, momentum=momentum)\n    \n    def forward(self, x):\n        x = fused_linear_scale(\n            x, \n            self.gemm.weight, \n            self.gemm.bias, \n            self.scale\n        )\n        x = self.bn(x)\n        return x\n\nbatch_size = 128\nin_features = 1024\nout_features = 512\nscale_shape = (out_features,)\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, scale_shape]\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Performs well on compiled (1.0000), Performs well on correctness (0.0000), Performs well on score (10.0000), Performs well on stage (wrong_answer), Performs well on verify_payload ({'id': 'level2_39_Gemm_Scale_BatchNorm', 'result': {'compiled': True, 'correctness': False, 'metadata': {'hardware': 'NVIDIA L20Y', 'device': 'cuda:3', 'runtime_error': 'Traceback (most recent call last):\\n  File \"/cpfs01/shared/llm_kernel/hujiakai/KernelLLM/validation_api_server/helpers/evaluations.py\", line 720, in run_and_check_correctness\\n    output_new = model_new(*inputs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1773, in _wrapped_call_impl\\n    return self._call_impl(*args, **kwargs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1784, in _call_impl\\n    return forward_call(*args, **kwargs)\\n  File \"/tmp/tmpumd5sxyc.py\", line 92, in forward\\n    x = self.bn(x)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1773, in _wrapped_call_impl\\n    return self._call_impl(*args, **kwargs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1784, in _call_impl\\n    return forward_call(*args, **kwargs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/batchnorm.py\", line 193, in forward\\n    return F.batch_norm(\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/functional.py\", line 2817, in batch_norm\\n    return torch.batch_norm(\\nRuntimeError: running_mean should contain 1024 elements not 512\\n', 'runtime_error_name': 'builtins.RuntimeError', 'reference_timing_ms': 0.0935, 'speed_up': -1.0, 'custom_timing': -1.0}, 'runtime': -1.0, 'runtime_stats': {}}})\n\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.0000)\n```python\n\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\n\nclass ModelNew(nn.Module):\n    \"\"\"\n    Simple model that performs a matrix multiplication, scales the result, and applies batch normalization.\n    \"\"\"\n    def __init__(self, in_features, out_features, scale_shape, eps=1e-5, momentum=0.1):\n        super(ModelNew, self).__init__()\n        self.gemm = nn.Linear(in_features, out_features)\n        self.scale = nn.Parameter(torch.randn(scale_shape))\n        self.bn = nn.BatchNorm1d(out_features, eps=eps, momentum=momentum)\n\n    def forward(self, x):\n        x = self.gemm(x)\n        x = x * self.scale\n        x = self.bn(x)\n        return x\n\nbatch_size = 128\nin_features = 1024\nout_features = 512\nscale_shape = (out_features,)\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, scale_shape]\n# =================== EVOLVE-BLOCK-END ===================\n\n```\nKey features: Alternative approach to compiled, Alternative approach to correctness\n\n\n### Program D2 (Score: 10.0000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 256, 'BLOCK_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 128, 'BLOCK_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 256, 'BLOCK_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_M': 256, 'BLOCK_N': 128, 'BLOCK_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 64, 'BLOCK_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 64, 'BLOCK_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 128, 'BLOCK_K': 32}, num_warps=4),\n    ],\n    key=['M', 'N', 'K'],\n)\n@triton.jit\ndef matmul_kernel(\n    a_ptr, b_ptr, c_ptr, bias_ptr,\n    M, N, K,\n    stride_am, stride_ak,\n    stride_bk, stride_bn,\n    stride_cm, stride_cn,\n    BLOCK_M: tl.constexpr, BLOCK_N: tl.constexpr, BLOCK_K: tl.constexpr,\n):\n    pid = tl.program_id(0)\n    num_pid_n = tl.cdiv(N, BLOCK_N)\n    pid_m = pid // num_pid_n\n    pid_n = pid % num_pid_n\n    \n    offs_m = pid_m * BLOCK_M + tl.arange(0, BLOCK_M)\n    offs_n = pid_n * BLOCK_N + tl.arange(0, BLOCK_N)\n    offs_k = tl.arange(0, BLOCK_K)\n    a_ptrs = a_ptr + offs_m[:, None] * stride_am + offs_k[None, :] * stride_ak\n    b_ptrs = b_ptr + offs_k[:, None] * stride_bk + offs_n[None, :] * stride_bn\n    \n    accumulator = tl.zeros((BLOCK_M, BLOCK_N), dtype=tl.float32)\n    for k in range(0, tl.cdiv(K, BLOCK_K)):\n        k_remaining = K - k * BLOCK_K\n        k_mask = offs_k < k_remaining\n        a = tl.load(a_ptrs, mask=k_mask[None, :], other=0.0)\n        b = tl.load(b_ptrs, mask=k_mask[:, None], other=0.0)\n        a = a.to(tl.float16)\n        b = b.to(tl.float16)\n        accumulator += tl.dot(a, b)\n        a_ptrs += BLOCK_K * stride_ak\n        b_ptrs += BLOCK_K * stride_bk\n    \n    offs_cm = offs_m[:, None]\n    offs_cn = offs_n[None, :]\n    c_ptrs = c_ptr + stride_cm * offs_cm + stride_cn * offs_cn\n    c_mask = (offs_cm < M) & (offs_cn < N)\n    \n    if bias_ptr is not None:\n        bias_ptrs = bias_ptr + offs_n\n        bias = tl.load(bias_ptrs, mask=offs_n < N, other=0.0)\n        accumulator += bias[None, :]\n    \n    tl.store(c_ptrs, accumulator, mask=c_mask)\n\ndef triton_linear(x, weight, bias=None):\n    M, K = x.shape\n    K, N = weight.shape\n    x = x.contiguous()\n    weight = weight.contiguous().t()\n    output = torch.empty((M, N), device=x.device, dtype=torch.float32)\n    \n    grid = lambda opt: (triton.cdiv(M, opt['BLOCK_M']) * triton.cdiv(N, opt['BLOCK_N']),)\n    matmul_kernel[grid](\n        x, weight, output, bias,\n        M, N, K,\n        x.stride(0), x.stride(1),\n        weight.stride(0), weight.stride(1),\n        output.stride(0), output.stride(1),\n    )\n    return output\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, scale_shape, eps=1e-5, momentum=0.1):\n        super(ModelNew, self).__init__()\n        self.weight = nn.Parameter(torch.randn(out_features, in_features))\n        self.bias = nn.Parameter(torch.randn(out_features))\n        self.scale = nn.Parameter(torch.randn(scale_shape))\n        self.bn = nn.BatchNorm1d(out_features, eps=eps, momentum=momentum)\n    \n    def forward(self, x):\n        x = triton_linear(x, self.weight, self.bias)\n        x = x * self.scale\n        x = self.bn(x)\n        return x\n\nbatch_size = 128\nin_features = 1024\nout_features = 512\nscale_shape = (out_features,)\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, scale_shape]\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Alternative approach to compiled, Alternative approach to correctness\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 20.0000, Type: High-Performer)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef fused_linear_scale_kernel(\n    x_ptr, w_ptr, b_ptr, s_ptr, out_ptr,\n    in_features, out_features,\n    stride_x, stride_w, stride_b, stride_s, stride_out,\n    BLOCK_SIZE_N: tl.constexpr, BLOCK_SIZE_K: tl.constexpr,\n):\n    pid0 = tl.program_id(0)  # Batch index\n    pid1 = tl.program_id(1)  # Output feature block index\n    \n    # Create ranges for current block\n    offs_n = pid1 * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n    offs_k = tl.arange(0, BLOCK_SIZE_K)\n    \n    # Create masks for boundaries\n    mask_n = offs_n < out_features\n    mask_k = offs_k < in_features\n    \n    # Initialize accumulator\n    acc = tl.zeros((BLOCK_SIZE_N,), dtype=tl.float32)\n    \n    # Loop over input features\n    for k in range(0, in_features, BLOCK_SIZE_K):\n        # Load block of input data\n        x_vals = tl.load(\n            x_ptr + pid0 * stride_x + k + offs_k, \n            mask=mask_k, other=0.0\n        )\n        \n        # Load block of weights\n        w_vals = tl.load(\n            w_ptr + (offs_n[:, None]) * stride_w + (k + offs_k[None, :]), \n            mask=mask_n[:, None] & mask_k[None, :], other=0.0\n        )\n        \n        # Compute partial dot product\n        x_vals_f16 = x_vals.to(tl.float16)\n        w_vals_f16 = w_vals.to(tl.float16)\n        partial = tl.sum(x_vals_f16[None, :] * w_vals_f16, axis=1)\n        acc += partial.to(tl.float32)\n    \n    # Load bias and scale\n    b_vals = tl.load(b_ptr + offs_n, mask=mask_n, other=0.0)\n    s_vals = tl.load(s_ptr + offs_n, mask=mask_n, other=0.0)\n    \n    # Apply bias and scale\n    output = (acc + b_vals) * s_vals\n    \n    # Store result\n    tl.store(\n        out_ptr + pid0 * stride_out + offs_n, \n        output, mask=mask_n\n    )\n\ndef fused_linear_scale(x, weight, bias, scale):\n    batch_size, in_features = x.shape\n    out_features = weight.shape[0]\n    \n    # Preallocate output tensor\n    output = torch.empty((batch_size, out_features), \n                         device=x.device, dtype=torch.float32)\n    \n    # Calculate grid dimensions\n    grid = lambda meta: (\n        batch_size, \n        triton.cdiv(out_features, meta['BLOCK_SIZE_N'])\n    )\n    \n    # Launch kernel with optimized block sizes\n    fused_linear_scale_kernel[grid](\n        x, weight, bias, scale, output,\n        in_features, out_features,\n        x.stride(0), weight.stride(0), \n        bias.stride(0), scale.stride(0), output.stride(0),\n        BLOCK_SIZE_N=128, BLOCK_SIZE_K=64\n    )\n    return output\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, scale_shape, eps=1e-5, momentum=0.1):\n        super(ModelNew, self).__init__()\n        self.gemm = nn.Linear(in_features, out_features)\n        self.scale = nn.Parameter(torch.randn(scale_shape))\n        self.bn = nn.BatchNorm1d(out_features, eps=eps, momentum=momentum)\n    \n    def forward(self, x):\n        # Fused linear layer + scaling\n        x = fused_linear_scale(x, self.gemm.weight, self.gemm.bias, self.scale)\n        x = self.bn(x)\n        return x\n\nbatch_size = 128\nin_features = 1024\nout_features = 512\nscale_shape = (out_features,)\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, scale_shape]\n# =================== EVOLVE-BLOCK-END ===================\n```\nUnique approach: Modification: Full rewrite, Excellent compiled (1.000), Excellent correctness (1.000)\n\n\n\n# Current Program\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 64, 'BLOCK_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 128, 'BLOCK_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 64, 'BLOCK_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 128, 'BLOCK_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 32, 'BLOCK_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_M': 32, 'BLOCK_N': 128, 'BLOCK_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 32, 'BLOCK_K': 128}, num_warps=4),\n        triton.Config({'BLOCK_M': 32, 'BLOCK_N': 64, 'BLOCK_K': 128}, num_warps=4),\n        triton.Config({'BLOCK_M': 32, 'BLOCK_N': 32, 'BLOCK_K': 256}, num_warps=4),\n    ],\n    key=['M', 'N', 'K'],\n)\n@triton.jit\ndef fused_linear_scale_kernel(\n    x_ptr, w_ptr, b_ptr, s_ptr, out_ptr,\n    M, N, K,\n    stride_xm, stride_xk,\n    stride_wn, stride_wk,\n    stride_bn,\n    stride_sn,\n    stride_outm, stride_outn,\n    BLOCK_M: tl.constexpr, BLOCK_N: tl.constexpr, BLOCK_K: tl.constexpr,\n):\n    pid0 = tl.program_id(0)\n    pid1 = tl.program_id(1)\n    \n    offs_m = pid0 * BLOCK_M + tl.arange(0, BLOCK_M)\n    offs_n = pid1 * BLOCK_N + tl.arange(0, BLOCK_N)\n    offs_k = tl.arange(0, BLOCK_K)\n    \n    x_ptrs = x_ptr + offs_m[:, None] * stride_xm + offs_k[None, :] * stride_xk\n    w_ptrs = w_ptr + offs_n[:, None] * stride_wn + offs_k[None, :] * stride_wk\n    \n    acc = tl.zeros((BLOCK_M, BLOCK_N), dtype=tl.float32)\n    for k in range(0, tl.cdiv(K, BLOCK_K)):\n        k_remaining = K - k * BLOCK_K\n        k_mask = offs_k < k_remaining\n        x = tl.load(x_ptrs, mask=k_mask[None, :] & (offs_m[:, None] < M), other=0.0)\n        w = tl.load(w_ptrs, mask=k_mask[None, :] & (offs_n[:, None] < N), other=0.0)\n        w = tl.trans(w)\n        acc += tl.dot(x, w, allow_tf32=True)\n        x_ptrs += BLOCK_K * stride_xk\n        w_ptrs += BLOCK_K * stride_wk\n    \n    if b_ptr is not None:\n        b_ptrs = b_ptr + offs_n\n        b = tl.load(b_ptrs, mask=offs_n < N, other=0.0)\n        acc += b[None, :]\n    \n    s_ptrs = s_ptr + offs_n\n    scale = tl.load(s_ptrs, mask=offs_n < N, other=0.0)\n    acc *= scale[None, :]\n    \n    out_ptrs = out_ptr + offs_m[:, None] * stride_outm + offs_n[None, :] * stride_outn\n    out_mask = (offs_m[:, None] < M) & (offs_n[None, :] < N)\n    tl.store(out_ptrs, acc, mask=out_mask)\n\ndef fused_linear_scale(x, weight, bias, scale):\n    M, K = x.shape\n    N, _ = weight.shape\n    x = x.contiguous()\n    weight = weight.contiguous()\n    bias = bias.contiguous() if bias is not None else None\n    scale = scale.contiguous()\n    output = torch.empty((M, N), device=x.device, dtype=x.dtype)\n    \n    grid = (triton.cdiv(M, BLOCK_M), triton.cdiv(N, BLOCK_N))\n    fused_linear_scale_kernel[grid](\n        x, weight, bias, scale, output,\n        M, N, K,\n        x.stride(0), x.stride(1),\n        weight.stride(0), weight.stride(1),\n        bias.stride(0) if bias is not None else 0,\n        scale.stride(0),\n        output.stride(0), output.stride(1),\n        BLOCK_M=BLOCK_M, BLOCK_N=BLOCK_N, BLOCK_K=BLOCK_K\n    )\n    return output\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, scale_shape, eps=1e-5, momentum=0.1):\n        super(ModelNew, self).__init__()\n        self.gemm = nn.Linear(in_features, out_features)\n        self.scale = nn.Parameter(torch.randn(scale_shape))\n        self.bn = nn.BatchNorm1d(out_features, eps=eps, momentum=momentum)\n    \n    def forward(self, x):\n        x = fused_linear_scale(\n            x, \n            self.gemm.weight, \n            self.gemm.bias, \n            self.scale\n        )\n        x = self.bn(x)\n        return x\n\nbatch_size = 128\nin_features = 1024\nout_features = 512\nscale_shape = (out_features,)\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, scale_shape]\n# =================== EVOLVE-BLOCK-END ===================\n```\n\n# Task\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```\n", "responses": ["<think>\nWe are given a program that is currently failing with a NameError: name 'BLOCK_M' is not defined.\n The issue is in the `fused_linear_scale` function, where we try to use `BLOCK_M` and `BLOCK_N` without defining them.\n However, note that the kernel is autotuned and the block sizes are passed as kernel parameters (BLOCK_M, BLOCK_N, BLOCK_K) and are not global variables.\n\n In the current code, the grid function uses `BLOCK_M` and `BLOCK_N` as if they were defined in the scope of `fused_linear_scale`, but they are not.\n\n We have two options:\n  1. Use the autotune mechanism to get the block sizes for the grid. However, note that the grid function in Triton is typically defined as a lambda that uses the META parameters.\n  2. Alternatively, we can define the grid using the autotune's META parameter.\n\n Looking at the kernel, it is decorated with @triton.autotune, which means that the block sizes (BLOCK_M, BLOCK_N, BLOCK_K) are provided at kernel launch via the config.\n\n How Triton autotune works: The grid function is defined as a lambda that takes the META dictionary (which contains the current config's block sizes) and returns the grid dimensions.\n\n Therefore, we should change the grid to be a lambda that uses the META parameters.\n\n Additionally, we see that the kernel call in `fused_linear_scale` currently tries to pass BLOCK_M, BLOCK_N, BLOCK_K as explicit arguments. But note that these are already part of the kernel's static arguments (via the autotune config) and are passed via the META dictionary.\n\n We must change the grid to use the META parameters and remove the explicit passing of BLOCK_M, BLOCK_N, BLOCK_K.\n\n Steps:\n  1. Change the grid to: \n        grid = lambda META: (triton.cdiv(M, META['BLOCK_M']), triton.cdiv(N, META['BLOCK_N']))\n  2. In the kernel launch, remove the explicit BLOCK_M, BLOCK_N, BLOCK_K arguments because they are passed by the autotuner via the META dictionary.\n\n Also note: The kernel signature includes BLOCK_M, BLOCK_N, BLOCK_K as tl.constexpr. The autotuner will set these from the config.\n\n However, the current kernel call is:\n    fused_linear_scale_kernel[grid]( ... , BLOCK_M=BLOCK_M, ... )\n\n We should remove these because they are now provided by the autotuner. Instead, we rely on the autotuner to set them.\n\n Let's restructure the kernel launch:\n\n    grid = lambda META: (triton.cdiv(M, META['BLOCK_M']), triton.cdiv(N, META['BLOCK_N']))\n    fused_linear_scale_kernel[grid](\n        x, weight, bias, scale, output,\n        M, N, K,\n        x.stride(0), x.stride(1),\n        weight.stride(0), weight.stride(1),\n        bias.stride(0) if bias is not None else 0,\n        scale.stride(0),\n        output.stride(0), output.stride(1),\n        # We do not pass BLOCK_M, BLOCK_N, BLOCK_K explicitly because they are in META\n    )\n\n But note: the kernel expects BLOCK_M, BLOCK_N, BLOCK_K as static arguments. The autotuner will set them from the config.\n\n However, we must be cautious: the kernel also has other arguments (like the strides) that are not static. The static ones (BLOCK_*) are passed by the autotuner.\n\n Therefore, we remove the explicit BLOCK_M, BLOCK_N, BLOCK_K from the call.\n\n Additionally, we must ensure that the kernel's autotune configs are valid. They are defined and should work.\n\n Another issue: In the current program, the batch normalization layer expects the input to have `out_features` as the channel dimension. However, the output of the fused linear layer is of shape (M, N) = (batch_size, out_features). The BatchNorm1d expects the input to be (batch_size, channels, ...) but here we have (batch_size, out_features). We need to transpose? Actually, BatchNorm1d in PyTorch for a 2D input (batch_size, features) applies per-feature normalization. So it should be fine.\n\n But note: the error in one of the previous attempts was: \n        RuntimeError: running_mean should contain 1024 elements not 512\n\n This suggests that the batch norm was initialized with the wrong number of features. In our ModelNew, we initialize:\n        self.bn = nn.BatchNorm1d(out_features, ...)   # out_features is 512\n\n But the input to the batch norm is the output of the linear layer which has 512 features. So why 1024? \n This error might be from a different version of the code. In the current code, the linear layer output is 512.\n\n We are not changing the model structure, so we assume that the ModelNew is correctly initialized.\n\n Let's focus on the immediate error: NameError: name 'BLOCK_M' is not defined.\n\n We'll change the grid definition and remove the explicit block size arguments.\n\n Also note: the autotune decorator is set, so we must use the META in the grid.\n\n However, the current code in the `fused_linear_scale` function:\n\n    grid = (triton.cdiv(M, BLOCK_M), triton.cdiv(N, BLOCK_N))\n\n This is wrong because BLOCK_M and BLOCK_N are not defined.\n\n We change it to:\n\n    grid = lambda META: (triton.cdiv(M, META['BLOCK_M']), triton.cdiv(N, META['BLOCK_N']))\n\n And then in the kernel launch, we remove the BLOCK_M, BLOCK_N, BLOCK_K arguments.\n\n We also note that the kernel expects the static arguments (BLOCK_M, BLOCK_N, BLOCK_K) to be passed as tl.constexpr. The autotuner will handle that.\n\n Let's rewrite the `fused_linear_scale` function accordingly.\n\n Additionally, we must ensure that the kernel is called with the grid function that uses META.\n\n We'll make these changes.\n\n Since the program is currently failing to run (due to the NameError), we fix that first.\n\n We also note that the kernel uses `tl.trans(w)` which is not defined. It should be `tl.transpose(w)`? Actually, the kernel does:\n        w = tl.trans(w)\n\n But in Triton, the function is `tl.transpose`. So we should change that to `w = tl.transpose(w)`\n\n However, note that in the previous attempt that passed correctness (Program 1) they did not use a dot product with transposed weights? They used a different kernel structure.\n\n But let's look at the kernel: \n        w_ptrs = w_ptr + offs_n[:, None] * stride_wn + offs_k[None, :] * stride_wk\n\n This loads a block of weight of shape (BLOCK_N, BLOCK_K). Then we do:\n        w = tl.trans(w)\n\n This transposes it to (BLOCK_K, BLOCK_N). Then we do:\n        acc += tl.dot(x, w, allow_tf32=True)\n\n Here, x is (BLOCK_M, BLOCK_K) and w is (BLOCK_K, BLOCK_N) -> so the dot product is (BLOCK_M, BLOCK_N). That is correct.\n\n But the function `tl.trans` is not valid. It should be `tl.transpose`. So we change that.\n\n We'll change:\n        w = tl.trans(w)   ->   w = tl.transpose(w)\n\n Alternatively, note that the Triton dot operation can handle the layout without explicit transpose if we adjust the pointers? But the current way is acceptable.\n\n So we have two changes:\n  1. Fix the grid to use META and remove the explicit block sizes.\n  2. Fix the transpose function.\n\n Let's write the corrected code.\n\n We are also going to remove the explicit BLOCK_M, BLOCK_N, BLOCK_K from the kernel call.\n\n We note that the kernel call now becomes:\n\n    fused_linear_scale_kernel[grid](\n        x, weight, bias, scale, output,\n        M, N, K,\n        x.stride(0), x.stride(1),\n        weight.stride(0), weight.stride(1),\n        bias.stride(0) if bias is not None else 0,\n        scale.stride(0),\n        output.stride(0), output.stride(1),\n    )\n\n And we change the grid to:\n\n    grid = lambda META: (triton.cdiv(M, META['BLOCK_M']), triton.cdiv(N, META['BLOCK_N']))\n\n We'll also change the transpose.\n\n We'll also note that the kernel uses:\n        out_ptrs = out_ptr + offs_m[:, None] * stride_outm + offs_n[None, :] * stride_outn\n\n And then we store with:\n        tl.store(out_ptrs, acc, mask=out_mask)\n\n This is correct.\n\n Let's write the entire block with these changes.\n\n We are also going to remove the autotune configs that might be invalid? But the autotune configs are defined and should be okay.\n\n We are going to make minimal changes to fix the current errors.\n\n Note: The current program also has an issue in the kernel with the transpose function. We fix that too.\n\n We output the entire EVOLVE-BLOCK.\n\n IMPORTANT: We must not change the class name (ModelNew) and the function signatures (like forward, __init__) and the get_inputs, get_init_inputs.\n\n We only change the fused_linear_scale function and the kernel.\n\n However, note that the kernel is inside the EVOLVE-BLOCK and we are allowed to change it.\n\n Let's write the corrected code.\n</think>\nI'll rewrite the program to fix the NameError by properly using Triton's autotune mechanism. The key changes are:\n1. Define grid dimensions using a lambda function that accesses META parameters\n2. Remove explicit BLOCK arguments from kernel call\n3. Fix transpose operation in kernel\n\nHere's the complete solution:\n\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 64, 'BLOCK_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 128, 'BLOCK_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 64, 'BLOCK_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 128, 'BLOCK_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 32, 'BLOCK_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_M': 32, 'BLOCK_N': 128, 'BLOCK_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 32, 'BLOCK_K': 128}, num_warps=4),\n        triton.Config({'BLOCK_M': 32, 'BLOCK_N': 64, 'BLOCK_K': 128}, num_warps=4),\n        triton.Config({'BLOCK_M': 32, 'BLOCK_N': 32, 'BLOCK_K': 256}, num_warps=4),\n    ],\n    key=['M', 'N', 'K'],\n)\n@triton.jit\ndef fused_linear_scale_kernel(\n    x_ptr, w_ptr, b_ptr, s_ptr, out_ptr,\n    M, N, K,\n    stride_xm, stride_xk,\n    stride_wn, stride_wk,\n    stride_bn,\n    stride_sn,\n    stride_outm, stride_outn,\n    BLOCK_M: tl.constexpr, BLOCK_N: tl.constexpr, BLOCK_K: tl.constexpr,\n):\n    pid0 = tl.program_id(0)\n    pid1 = tl.program_id(1)\n    \n    offs_m = pid0 * BLOCK_M + tl.arange(0, BLOCK_M)\n    offs_n = pid1 * BLOCK_N + tl.arange(0, BLOCK_N)\n    offs_k = tl.arange(0, BLOCK_K)\n    \n    x_ptrs = x_ptr + offs_m[:, None] * stride_xm + offs_k[None, :] * stride_xk\n    w_ptrs = w_ptr + offs_n[:, None] * stride_wn + offs_k[None, :] * stride_wk\n    \n    acc = tl.zeros((BLOCK_M, BLOCK_N), dtype=tl.float32)\n    for k in range(0, tl.cdiv(K, BLOCK_K)):\n        k_remaining = K - k * BLOCK_K\n        k_mask = offs_k < k_remaining\n        x = tl.load(x_ptrs, mask=k_mask[None, :] & (offs_m[:, None] < M), other=0.0)\n        w = tl.load(w_ptrs, mask=k_mask[None, :] & (offs_n[:, None] < N), other=0.0)\n        w = tl.transpose(w)\n        acc += tl.dot(x, w, allow_tf32=True)\n        x_ptrs += BLOCK_K * stride_xk\n        w_ptrs += BLOCK_K * stride_wk\n    \n    if b_ptr is not None:\n        b_ptrs = b_ptr + offs_n\n        b = tl.load(b_ptrs, mask=offs_n < N, other=0.0)\n        acc += b[None, :]\n    \n    s_ptrs = s_ptr + offs_n\n    scale = tl.load(s_ptrs, mask=offs_n < N, other=0.0)\n    acc *= scale[None, :]\n    \n    out_ptrs = out_ptr + offs_m[:, None] * stride_outm + offs_n[None, :] * stride_outn\n    out_mask = (offs_m[:, None] < M) & (offs_n[None, :] < N)\n    tl.store(out_ptrs, acc, mask=out_mask)\n\ndef fused_linear_scale(x, weight, bias, scale):\n    M, K = x.shape\n    N, _ = weight.shape\n    x = x.contiguous()\n    weight = weight.contiguous()\n    bias = bias.contiguous() if bias is not None else None\n    scale = scale.contiguous()\n    output = torch.empty((M, N), device=x.device, dtype=x.dtype)\n    \n    grid = lambda META: (\n        triton.cdiv(M, META['BLOCK_M']),\n        triton.cdiv(N, META['BLOCK_N'])\n    )\n    fused_linear_scale_kernel[grid](\n        x, weight, bias, scale, output,\n        M, N, K,\n        x.stride(0), x.stride(1),\n        weight.stride(0), weight.stride(1),\n        bias.stride(0) if bias is not None else 0,\n        scale.stride(0),\n        output.stride(0), output.stride(1),\n    )\n    return output\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, scale_shape, eps=1e-5, momentum=0.1):\n        super(ModelNew, self).__init__()\n        self.gemm = nn.Linear(in_features, out_features)\n        self.scale = nn.Parameter(torch.randn(scale_shape))\n        self.bn = nn.BatchNorm1d(out_features, eps=eps, momentum=momentum)\n    \n    def forward(self, x):\n        x = fused_linear_scale(\n            x, \n            self.gemm.weight, \n            self.gemm.bias, \n            self.scale\n        )\n        x = self.bn(x)\n        return x\n\nbatch_size = 128\nin_features = 1024\nout_features = 512\nscale_shape = (out_features,)\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, scale_shape]\n# =================== EVOLVE-BLOCK-END ===================\n```"]}}}