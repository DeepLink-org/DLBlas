{"id": "f35618c8-19b2-4b2b-b947-f73811d393f1", "code": "# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\nimport math\n\n@triton.jit\ndef depthwise_conv2d_kernel(\n    x_ptr,\n    w_ptr,\n    output_ptr,\n    bias_ptr,\n    batch_size,\n    in_channels,\n    height,\n    width,\n    out_channels,\n    OH,\n    OW,\n    kernel_size,\n    stride,\n    padding,\n    BLOCK_OW: tl.constexpr,\n):\n    pid_bc = tl.program_id(0)\n    pid_oh = tl.program_id(1)\n    pid_owb = tl.program_id(2)\n    \n    batch_idx = pid_bc // out_channels\n    channel_idx = pid_bc % out_channels\n    group_idx = channel_idx // (out_channels // in_channels)\n    \n    ow_start = pid_owb * BLOCK_OW\n    ow_offsets = ow_start + tl.arange(0, BLOCK_OW)\n    ow_mask = ow_offsets < OW\n    \n    acc = tl.zeros((BLOCK_OW,), dtype=tl.float32)\n    \n    for kh in range(kernel_size):\n        for kw in range(kernel_size):\n            h_in = pid_oh * stride + kh - padding\n            w_in = ow_offsets * stride + kw - padding\n            \n            h_valid = (h_in >= 0) & (h_in < height)\n            w_valid = (w_in >= 0) & (w_in < width)\n            valid_mask = h_valid & w_valid & ow_mask\n            \n            x_offsets = batch_idx * in_channels * height * width + \\\n                        group_idx * height * width + \\\n                        h_in * width + w_in\n            x_vals = tl.load(x_ptr + x_offsets, mask=valid_mask, other=0.0)\n            \n            w_offsets = channel_idx * kernel_size * kernel_size + \\\n                        kh * kernel_size + kw\n            w_val = tl.load(w_ptr + w_offsets)\n            \n            acc += x_vals * w_val\n    \n    if bias_ptr is not None:\n        bias = tl.load(bias_ptr + channel_idx)\n        acc += bias\n    \n    output_offsets = batch_idx * out_channels * OH * OW + \\\n                    channel_idx * OH * OW + \\\n                    pid_oh * OW + ow_offsets\n    tl.store(output_ptr + output_offsets, acc, mask=ow_mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_channels: int, out_channels: int, kernel_size: int, stride: int = 1, padding: int = 0, bias: bool = False):\n        super(ModelNew, self).__init__()\n        assert out_channels % in_channels == 0, \"out_channels must be divisible by in_channels\"\n        self.in_channels = in_channels\n        self.out_channels = out_channels\n        self.kernel_size = kernel_size\n        self.stride = stride\n        self.padding = padding\n        \n        self.weight = nn.Parameter(torch.empty(out_channels, 1, kernel_size, kernel_size))\n        if bias:\n            self.bias = nn.Parameter(torch.empty(out_channels))\n        else:\n            self.bias = None\n            \n        nn.init.kaiming_uniform_(self.weight, a=math.sqrt(5))\n        if bias:\n            fan_in = in_channels * kernel_size * kernel_size\n            bound = 1 / math.sqrt(fan_in)\n            nn.init.uniform_(self.bias, -bound, bound)\n\n    def forward(self, x: torch.Tensor) -> torch.Tensor:\n        B, C, H, W = x.shape\n        assert C == self.in_channels, \"Input channels must match layer channels\"\n        \n        H_out = (H + 2 * self.padding - self.kernel_size) // self.stride + 1\n        W_out = (W + 2 * self.padding - self.kernel_size) // self.stride + 1\n        output = torch.empty(B, self.out_channels, H_out, W_out, device=x.device, dtype=x.dtype)\n        \n        BLOCK_OW = 64\n        grid = (B * self.out_channels, H_out, triton.cdiv(W_out, BLOCK_OW))\n        bias_ptr = self.bias.data_ptr() if self.bias is not None else None\n        \n        depthwise_conv2d_kernel[grid](\n            x, self.weight, output, bias_ptr,\n            B, self.in_channels, H, W, self.out_channels,\n            H_out, W_out, self.kernel_size, self.stride, self.padding, BLOCK_OW,\n        )\n        return output\n\n# Test code\nbatch_size = 16\nin_channels = 3\nout_channels = 3\nkernel_size = 3\nwidth_in = 256\nheight_in = 128\nstride = 1\npadding = 0\n\ndef get_inputs():\n    x = torch.randn(batch_size, in_channels, height_in, width_in)\n    return [x]\n\ndef get_init_inputs():\n    return [in_channels, out_channels, kernel_size, stride, padding]\n# =================== EVOLVE-BLOCK-END ===================", "language": "python", "parent_id": "1895fb2b-9ce7-4f06-82b1-f7ec3415a40f", "generation": 3, "timestamp": 1754647941.5355918, "iteration_found": 13, "metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": false, "score": 20, "speed_up": 0.343, "runtime_ms": 0.0878, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:1", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.0301, "speed_up": 0.343, "custom_timing": 0.0878}}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": false, "correctness": false, "score": 1, "stage": "compile_error", "compile_log": "CUDA error: an illegal memory access was encountered\nCUDA kernel errors might be asynchronously reported at some other API call, so the stacktrace below might be incorrect.\nFor debugging consider passing CUDA_LAUNCH_BLOCKING=1\nCompile with `TORCH_USE_CUDA_DSA` to enable device-side assertions.\n\nTraceback (most recent call last):\n  File \"/cpfs01/shared/llm_kernel/hujiakai/KernelLLM/validation_api_server/evaluator.py\", line 173, in _verification_worker\n    result: KernelExecResult = eval_kernel_against_ref(\n  File \"/cpfs01/shared/llm_kernel/hujiakai/KernelLLM/validation_api_server/helpers/evaluations.py\", line 578, in eval_kernel_against_ref\n    graceful_eval_cleanup(context, device, tempfile)\n  File \"/cpfs01/shared/llm_kernel/hujiakai/KernelLLM/validation_api_server/helpers/evaluations.py\", line 230, in graceful_eval_cleanup\n    torch.cuda.empty_cache()\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/cuda/memory.py\", line 224, in empty_cache\n    torch._C._cuda_emptyCache()\ntorch.AcceleratorError: CUDA error: an illegal memory access was encountered\nCUDA kernel errors might be asynchronously reported at some other API call, so the stacktrace below might be incorrect.\nFor debugging consider passing CUDA_LAUNCH_BLOCKING=1\nCompile with `TORCH_USE_CUDA_DSA` to enable device-side assertions.\n\n", "exec_log": "[Child] \u7ed1\u5b9a GPU 0, torch sees 1 device(s)\n\n[Exception]\nTraceback (most recent call last):\n  File \"/cpfs01/shared/llm_kernel/hujiakai/KernelLLM/validation_api_server/code_executor.py\", line 71, in _exec_worker\n    exec(textwrap.dedent(code_src), mod.__dict__)\n  File \"<string>\", line 72, in <module>\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 844, in jit\n    return decorator(fn)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 832, in decorator\n    return JITFunction(\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 635, in __init__\n    self.starting_line_number = inspect.getsourcelines(fn)[1]\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/inspect.py\", line 1121, in getsourcelines\n    lines, lnum = findsource(object)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/inspect.py\", line 958, in findsource\n    raise OSError('could not get source code')\nOSError: could not get source code\n", "exit_code": "1"}, "island": 2}, "artifacts_json": null, "artifact_dir": null}