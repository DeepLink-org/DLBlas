{"id": "6050f193-4d5a-4856-ae63-86bbb127c7a6", "code": "# ================== EVOLVE-BLOCK-START ==================\nimport math\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef _conv2d_kernel(\n    x_ptr,\n    w_ptr,\n    b_ptr,\n    y_ptr,\n    stride_h,\n    stride_w,\n    padding_h,\n    padding_w,\n    dilation_h,\n    dilation_w,\n    in_channels,\n    out_channels,\n    height,\n    width,\n    kernel_h,\n    kernel_w,\n    height_out,\n    width_out,\n    BLOCK_OC: tl.constexpr,\n    BLOCK_IC: tl.constexpr,\n    BLOCK_H: tl.constexpr,\n    BLOCK_W: tl.constexpr\n):\n    pid_b = tl.program_id(0)\n    pid_oc_block = tl.program_id(1)\n    pid_spatial = tl.program_id(2)\n    \n    # Calculate spatial block indices\n    num_blocks_w = (width_out + BLOCK_W - 1) // BLOCK_W\n    pid_oh = pid_spatial // num_blocks_w\n    pid_ow = pid_spatial % num_blocks_w\n    \n    # Output spatial offsets\n    oh_start = pid_oh * BLOCK_H\n    ow_start = pid_ow * BLOCK_W\n    oh = oh_start + tl.arange(0, BLOCK_H)\n    ow = ow_start + tl.arange(0, BLOCK_W)\n    \n    # Masks for spatial boundaries\n    oh_mask = (oh < height_out)\n    ow_mask = (ow < width_out)\n    spatial_mask = oh_mask[:, None] & ow_mask[None, :]\n    \n    # Output channel offsets\n    oc_offsets = pid_oc_block * BLOCK_OC + tl.arange(0, BLOCK_OC)\n    oc_mask = oc_offsets < out_channels\n    \n    # Accumulator initialization\n    acc = tl.zeros((BLOCK_H, BLOCK_W, BLOCK_OC), dtype=tl.float32)\n    \n    # Process input channels in blocks\n    for ic_block in range(0, in_channels, BLOCK_IC):\n        ic_offsets = ic_block + tl.arange(0, BLOCK_IC)\n        ic_mask = ic_offsets < in_channels\n        \n        for kh in range(kernel_h):\n            for kw in range(kernel_w):\n                # Compute input positions\n                ih = oh * stride_h + kh * dilation_h - padding_h\n                iw = ow * stride_w + kw * dilation_w - padding_w\n                \n                # Boundary checks\n                ih_mask = (ih >= 0) & (ih < height)\n                iw_mask = (iw >= 0) & (iw < width)\n                valid_mask = spatial_mask & ih_mask[:, None] & iw_mask[None, :]\n                \n                # Load input block (vectorized)\n                x_ptrs = (\n                    x_ptr + pid_b * height * width * in_channels +\n                    ih[:, None, None] * width * in_channels +\n                    iw[None, :, None] * in_channels +\n                    ic_offsets[None, None, :]\n                )\n                x_val = tl.load(\n                    x_ptrs, \n                    mask=valid_mask[:, :, None] & ic_mask[None, None, :],\n                    other=0.0\n                )\n                \n                # Load weight block (vectorized)\n                w_ptrs = (\n                    w_ptr + \n                    oc_offsets[None, None, :, None] * in_channels * kernel_h * kernel_w +\n                    ic_offsets[None, None, None, :] * kernel_h * kernel_w +\n                    kh * kernel_w + kw\n                )\n                w_val = tl.load(\n                    w_ptrs, \n                    mask=oc_mask[None, None, :, None] & ic_mask[None, None, None, :],\n                    other=0.0\n                )\n                \n                # Compute partial sums\n                acc += tl.sum(x_val[:, :, None, :] * w_val, axis=3)\n    \n    # Add bias if available\n    if b_ptr is not None:\n        b_val = tl.load(b_ptr + oc_offsets, mask=oc_mask, other=0.0)\n        acc += b_val[None, None, :]\n    \n    # Store results\n    y_ptrs = (\n        y_ptr + pid_b * out_channels * height_out * width_out +\n        oh[:, None, None] * width_out * out_channels +\n        ow[None, :, None] * out_channels +\n        oc_offsets[None, None, :]\n    )\n    tl.store(\n        y_ptrs, \n        acc, \n        mask=spatial_mask[:, :, None] & oc_mask[None, None, :]\n    )\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_channels: int, out_channels: int, kernel_size: tuple, stride: int = 1, padding: tuple = (0, 0), dilation: tuple = (1, 1), bias: bool = False):\n        super(ModelNew, self).__init__()\n        self.in_channels = in_channels\n        self.out_channels = out_channels\n        self.kernel_size = kernel_size\n        self.stride = stride\n        self.padding = padding\n        self.dilation = dilation\n        \n        self.weight = nn.Parameter(torch.empty(out_channels, in_channels, kernel_size[0], kernel_size[1]))\n        if bias:\n            self.bias = nn.Parameter(torch.empty(out_channels))\n        else:\n            self.register_parameter('bias', None)\n        \n        nn.init.kaiming_uniform_(self.weight, a=math.sqrt(5))\n        if self.bias is not None:\n            fan_in, _ = nn.init._calculate_fan_in_and_fan_out(self.weight)\n            bound = 1 / math.sqrt(fan_in) if fan_in > 0 else 0\n            nn.init.uniform_(self.bias, -bound, bound)\n            \n    def forward(self, x: torch.Tensor) -> torch.Tensor:\n        batch_size, _, height, width = x.shape\n        kernel_h, kernel_w = self.kernel_size\n        padding_h, padding_w = self.padding\n        dilation_h, dilation_w = self.dilation\n        \n        height_out = (height + 2 * padding_h - dilation_h * (kernel_h - 1) - 1) // self.stride + 1\n        width_out = (width + 2 * padding_w - dilation_w * (kernel_w - 1) - 1) // self.stride + 1\n        \n        y = torch.empty(batch_size, self.out_channels, height_out, width_out, \n                        device=x.device, dtype=x.dtype)\n        \n        # Tuning parameters\n        BLOCK_OC, BLOCK_IC, BLOCK_H, BLOCK_W = 32, 32, 16, 16\n        \n        # Calculate grid dimensions\n        grid_oc = triton.cdiv(self.out_channels, BLOCK_OC)\n        grid_spatial = (\n            (height_out + BLOCK_H - 1) // BLOCK_H * \n            (width_out + BLOCK_W - 1) // BLOCK_W\n        )\n        grid = (batch_size, grid_oc, grid_spatial)\n        \n        # Launch kernel\n        _conv2d_kernel[grid](\n            x, self.weight, self.bias, y,\n            self.stride, self.stride,\n            padding_h, padding_w,\n            dilation_h, dilation_w,\n            self.in_channels, self.out_channels,\n            height, width,\n            kernel_h, kernel_w,\n            height_out, width_out,\n            BLOCK_OC, BLOCK_IC, BLOCK_H, BLOCK_W\n        )\n        return y\n\n# Test code\nbatch_size = 16\nin_channels = 3\nout_channels = 64\nkernel_size = (3, 5) # Asymmetric kernel\nwidth = 256\nheight = 256\nstride = 1\npadding = (1, 2) # Asymmetric padding\ndilation = (2, 1) # Asymmetric dilation\n\ndef get_inputs():\n    x = torch.randn(batch_size, in_channels, height, width)\n    return [x]\n\ndef get_init_inputs():\n    return [in_channels, out_channels, kernel_size, stride, padding, dilation]\n# =================== EVOLVE-BLOCK-END ===================", "language": "python", "parent_id": "6e20edaa-3ad6-4731-be40-34ea157b6a4e", "generation": 3, "timestamp": 1754649947.3256927, "iteration_found": 29, "metrics": {"compiled": true, "correctness": false, "score": 10, "stage": "wrong_answer", "verify_payload": {"id": "level1_80_conv_standard_2D_square_input_asymmetric_kernel___dilated____padded__", "result": {"compiled": true, "correctness": false, "metadata": {"hardware": "NVIDIA L20Y", "device": "cuda:4", "max_difference": ["4.744956", "4.794898", "4.724915", "4.624421", "4.622984"], "avg_difference": ["0.642946", "0.643300", "0.643032", "0.642779", "0.643125"], "correctness_issue": "Output mismatch", "correctness_trials": "(0 / 5)", "reference_timing_ms": 0.044, "speed_up": -1.0, "custom_timing": -1.0}, "runtime": -1.0, "runtime_stats": {}}}}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": false, "score": 20, "speed_up": 0.0, "runtime_ms": 200.0, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:2", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.044, "speed_up": 0.0, "custom_timing": 200.0}}, "island": 2}, "artifacts_json": null, "artifact_dir": null}