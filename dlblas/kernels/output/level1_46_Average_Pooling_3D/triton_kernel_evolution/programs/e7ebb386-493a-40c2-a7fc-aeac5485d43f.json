{"id": "e7ebb386-493a-40c2-a7fc-aeac5485d43f", "code": "# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef _avg_pool3d_forward(\n    x_ptr, \n    output_ptr,\n    # Tensor dimensions\n    B, C, D, H, W,\n    stride_b, stride_c, stride_d, stride_h, stride_w,\n    output_D, output_H, output_W,\n    divisor,\n    # Constant expressions\n    KERNEL_SIZE: tl.constexpr,\n    STRIDE: tl.constexpr,\n    PADDING: tl.constexpr,\n    BLOCK_SIZE: tl.constexpr\n):\n    pid_b = tl.program_id(0)\n    pid_c = tl.program_id(1)\n    pid_spatial = tl.program_id(2)\n    \n    # Reconstruct spatial indices\n    hw_size = output_H * output_W\n    d_idx = pid_spatial // hw_size\n    hw_idx = pid_spatial % hw_size\n    h_idx = hw_idx // output_W\n    w_idx = hw_idx % output_W\n    \n    # Compute window start positions\n    start_d = d_idx * STRIDE - PADDING\n    start_h = h_idx * STRIDE - PADDING\n    start_w = w_idx * STRIDE - PADDING\n    \n    # Accumulate values\n    total = 0.0\n    for kd in tl.static_range(KERNEL_SIZE):\n        for kh in tl.static_range(KERNEL_SIZE):\n            for kw in tl.static_range(KERNEL_SIZE):\n                id = start_d + kd\n                ih = start_h + kh\n                iw = start_w + kw\n                \n                # Check boundaries\n                within_bounds = (id >= 0) & (id < D) & (ih >= 0) & (ih < H) & (iw >= 0) & (iw < W)\n                offset = pid_b * stride_b + pid_c * stride_c + id * stride_d + ih * stride_h + iw * stride_w\n                val = tl.load(x_ptr + offset, mask=within_bounds, other=0.0)\n                total += val\n    \n    # Compute average and store result\n    out_offset = pid_b * (C * output_D * output_H * output_W) + pid_c * (output_D * output_H * output_W) + d_idx * (output_H * output_W) + h_idx * output_W + w_idx\n    tl.store(output_ptr + out_offset, total / divisor)\n\nclass ModelNew(nn.Module):\n    def __init__(self, kernel_size: int, stride: int = None, padding: int = 0):\n        super(ModelNew, self).__init__()\n        self.kernel_size = kernel_size\n        self.stride = stride if stride is not None else kernel_size\n        self.padding = padding\n        \n    def forward(self, x: torch.Tensor) -> torch.Tensor:\n        D, H, W = x.shape[2:]\n        k = self.kernel_size\n        s = self.stride\n        p = self.padding\n        \n        # Compute output dimensions\n        output_D = (D + 2 * p - k) // s + 1\n        output_H = (H + 2 * p - k) // s + 1\n        output_W = (W + 2 * p - k) // s + 1\n        \n        output = torch.empty((x.shape[0], x.shape[1], output_D, output_H, output_W), \n                             device=x.device, dtype=x.dtype)\n        \n        # Ensure contiguous memory\n        x = x.contiguous()\n        \n        # Get tensor strides\n        stride_b, stride_c, stride_d, stride_h, stride_w = x.stride()\n        divisor = float(k ** 3)  # Precompute divisor\n        \n        # Total spatial elements per channel\n        total_spatial = output_D * output_H * output_W\n        \n        # Configure grid (batch, channels, spatial)\n        grid = (x.shape[0], x.shape[1], total_spatial)\n        \n        # Launch optimized kernel\n        _avg_pool3d_forward[grid](\n            x, output,\n            x.shape[0], x.shape[1], D, H, W,\n            stride_b, stride_c, stride_d, stride_h, stride_w,\n            output_D, output_H, output_W,\n            divisor,\n            KERNEL_SIZE=k,\n            STRIDE=s,\n            PADDING=p,\n            BLOCK_SIZE=1\n        )\n        return output\n\nbatch_size = 16\nchannels = 32\ndepth = 64\nheight = 64\nwidth = 64\nkernel_size = 3\nstride = 2\npadding = 1\n\ndef get_inputs():\n    x = torch.randn(batch_size, channels, depth, height, width)\n    return [x]\n\ndef get_init_inputs():\n    return [kernel_size, stride, padding]\n# =================== EVOLVE-BLOCK-END ===================", "language": "python", "parent_id": "1579e0d4-24a4-40a1-bad6-ad884d19cccd", "generation": 1, "timestamp": 1754638758.4635952, "iteration_found": 0, "metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": false, "score": 20, "speed_up": 0.001, "runtime_ms": 26.0, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:2", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.0237, "speed_up": 0.001, "custom_timing": 26.0}}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": true, "correctness": true, "stage": "reference code", "passed": false, "score": 0.0, "speed_up": 1.0, "runtime_ms": 0.55, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:3", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.0237, "speed_up": 0.043, "custom_timing": 0.55}}, "island": 0}, "artifacts_json": null, "artifact_dir": null}