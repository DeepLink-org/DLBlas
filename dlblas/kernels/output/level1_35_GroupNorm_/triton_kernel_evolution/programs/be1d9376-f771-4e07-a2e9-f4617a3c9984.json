{"id": "be1d9376-f771-4e07-a2e9-f4617a3c9984", "code": "# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport triton\nimport triton.language as tl\n\nclass ModelNew(torch.nn.Module):\n    def __init__(self, num_features: int, num_groups: int):\n        super().__init__()\n        self.num_features = num_features\n        self.num_groups = num_groups\n        self.weight = torch.nn.Parameter(torch.ones(num_features))\n        self.bias = torch.nn.Parameter(torch.zeros(num_features))\n        self.eps = 1e-5\n\n    @triton.jit\n    def _group_norm_fwd_kernel(\n        x_ptr, y_ptr, gamma_ptr, beta_ptr, N, C, H, W, G, eps,\n        stride_xn, stride_xc, stride_xh, stride_xw,\n        stride_yn, stride_yc, stride_yh, stride_yw,\n        BLOCK_SIZE: tl.constexpr,\n    ):\n        # Compute program indices\n        pid_n = tl.program_id(0)\n        pid_g = tl.program_id(1)\n        pid = tl.program_id(2)\n        \n        # Compute group parameters\n        channels_per_group = C // G\n        group_start = pid_g * channels_per_group\n        group_end = group_start + channels_per_group\n        group_size = channels_per_group * H * W\n        \n        # Initialize reduction buffers\n        sum_val = tl.zeros([BLOCK_SIZE], dtype=tl.float32)\n        sq_val = tl.zeros([BLOCK_SIZE], dtype=tl.float32)\n        \n        # Compute reduction across group elements\n        for off in range(0, group_size, BLOCK_SIZE):\n            idx = off + pid\n            if idx < group_size:\n                # Calculate spatial indices\n                c_idx = idx // (H * W)\n                hw_idx = idx % (H * W)\n                h_idx = hw_idx // W\n                w_idx = hw_idx % W\n                \n                # Calculate memory offsets\n                x_offset = pid_n * stride_xn + (group_start + c_idx) * stride_xc + h_idx * stride_xh + w_idx * stride_xw\n                x_val = tl.load(x_ptr + x_offset)\n                sum_val += x_val\n                sq_val += x_val * x_val\n        \n        # Parallel reduction\n        total_sum = tl.sum(sum_val, axis=0)\n        total_sq = tl.sum(sq_val, axis=0)\n        mean = total_sum / group_size\n        variance = (total_sq / group_size) - (mean * mean)\n        inv_std = 1.0 / tl.sqrt(variance + eps)\n        \n        # Normalize and apply affine transformation\n        for off in range(0, group_size, BLOCK_SIZE):\n            idx = off + pid\n            if idx < group_size:\n                # Calculate spatial indices\n                c_idx = idx // (H * W)\n                hw_idx = idx % (H * W)\n                h_idx = hw_idx // W\n                w_idx = hw_idx % W\n                \n                # Calculate memory offsets\n                x_offset = pid_n * stride_xn + (group_start + c_idx) * stride_xc + h_idx * stride_xh + w_idx * stride_xw\n                y_offset = pid_n * stride_yn + (group_start + c_idx) * stride_yc + h_idx * stride_yh + w_idx * stride_yw\n                gamma_offset = group_start + c_idx\n                beta_offset = group_start + c_idx\n                \n                x_val = tl.load(x_ptr + x_offset)\n                gamma_val = tl.load(gamma_ptr + gamma_offset)\n                beta_val = tl.load(beta_ptr + beta_offset)\n                \n                # Normalize and transform\n                normalized = (x_val - mean) * inv_std\n                out_val = normalized * gamma_val + beta_val\n                tl.store(y_ptr + y_offset, out_val)\n\n    def forward(self, x: torch.Tensor) -> torch.Tensor:\n        N, C, H, W = x.shape\n        y = torch.empty_like(x)\n        grid = (N, self.num_groups, triton.next_power_of_2(C * H * W // self.num_groups))\n        \n        self._group_norm_fwd_kernel[grid](\n            x, y, self.weight, self.bias, \n            N, C, H, W, self.num_groups, self.eps,\n            x.stride(0), x.stride(1), x.stride(2), x.stride(3),\n            y.stride(0), y.stride(1), y.stride(2), y.stride(3),\n            BLOCK_SIZE=128\n        )\n        return y\n\nbatch_size = 16\nfeatures = 64\nnum_groups = 8\ndim1 = 256\ndim2 = 256\n\ndef get_inputs():\n    x = torch.randn(batch_size, features, dim1, dim2, device='cuda')\n    return [x]\n\ndef get_init_inputs():\n    return [features, num_groups]\n# =================== EVOLVE-BLOCK-END ===================", "language": "python", "parent_id": "5f291ba5-b0b3-4880-923f-458c02123def", "generation": 1, "timestamp": 1754635027.7273564, "iteration_found": 1, "metrics": {"compiled": true, "correctness": false, "score": 10, "stage": "wrong_answer", "verify_payload": {"id": "level1_35_GroupNorm_", "result": {"compiled": true, "correctness": false, "metadata": {"hardware": "NVIDIA L20Y", "device": "cuda:0", "runtime_error": "Traceback (most recent call last):\n  File \"/cpfs01/shared/llm_kernel/hujiakai/KernelLLM/validation_api_server/helpers/evaluations.py\", line 720, in run_and_check_correctness\n    output_new = model_new(*inputs)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1773, in _wrapped_call_impl\n    return self._call_impl(*args, **kwargs)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1784, in _call_impl\n    return forward_call(*args, **kwargs)\n  File \"/tmp/tmp6tcpajd8.py\", line 90, in forward\n    self._group_norm_fwd_kernel[grid](\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 390, in <lambda>\n    return lambda *args, **kwargs: self.run(grid=grid, warmup=False, *args, **kwargs)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 617, in run\n    kernel.run(grid_0, grid_1, grid_2, stream, kernel.function, kernel.packed_metadata, launch_metadata,\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/backends/nvidia/driver.py\", line 708, in __call__\n    self.launch(gridX, gridY, gridZ, stream, function, self.launch_cooperative_grid, self.launch_pdl,\nRuntimeError: Triton Error [CUDA]: invalid argument\n", "runtime_error_name": "builtins.RuntimeError", "reference_timing_ms": 0.0497, "speed_up": -1.0, "custom_timing": -1.0}, "runtime": -1.0, "runtime_stats": {}}}}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": true, "correctness": true, "stage": "reference code", "passed": false, "score": 0.0, "speed_up": 1.0, "runtime_ms": 0.678, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:5", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.0497, "speed_up": 0.073, "custom_timing": 0.678}}, "island": 1}, "artifacts_json": null, "artifact_dir": null}