{"id": "de7ebe90-3ce9-4bdf-81fe-1ce395339efd", "code": "# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport triton\nimport triton.language as tl\n\nclass ModelNew(torch.nn.Module):\n    def __init__(self, num_features: int, num_groups: int):\n        super().__init__()\n        self.num_features = num_features\n        self.num_groups = num_groups\n        self.weight = torch.nn.Parameter(torch.ones(num_features))\n        self.bias = torch.nn.Parameter(torch.zeros(num_features))\n        self.eps = 1e-5\n\n    @triton.jit\n    def _group_norm_fwd_kernel(\n        x_ptr, y_ptr, gamma_ptr, beta_ptr, \n        N, C, H, W, G, eps,\n        stride_xn, stride_xc, stride_xh, stride_xw,\n        stride_yn, stride_yc, stride_yh, stride_yw,\n        BLOCK_SIZE: tl.constexpr,\n    ):\n        pid = tl.program_id(0)\n        pid_n = pid // G\n        pid_g = pid % G\n        \n        channels_per_group = C // G\n        group_start = pid_g * channels_per_group\n        spatial_size = H * W\n        group_size = channels_per_group * spatial_size\n        \n        base_x = x_ptr + pid_n * stride_xn + group_start * stride_xc\n        base_y = y_ptr + pid_n * stride_yn + group_start * stride_yc\n\n        # Combined first pass: compute sum and sum of squares\n        sum_val = 0.0\n        sq_val = 0.0\n        for offset in range(0, group_size, BLOCK_SIZE):\n            idx = offset + tl.arange(0, BLOCK_SIZE)\n            mask = idx < group_size\n            \n            c_in_group = idx // spatial_size\n            spatial_idx = idx % spatial_size\n            h = spatial_idx // W\n            w = spatial_idx % W\n            \n            off_x = base_x + c_in_group * stride_xc + h * stride_xh + w * stride_xw\n            data = tl.load(off_x, mask=mask, other=0.0)\n            sum_val += tl.sum(data, axis=0)\n            sq_val += tl.sum(data * data, axis=0)\n        \n        # Compute mean and variance\n        mean = sum_val / group_size\n        variance = sq_val / group_size - mean * mean\n        variance = tl.maximum(variance, 0.0)\n        rstd = 1.0 / tl.sqrt(variance + eps)\n\n        # Normalize and store\n        for offset in range(0, group_size, BLOCK_SIZE):\n            idx = offset + tl.arange(0, BLOCK_SIZE)\n            mask = idx < group_size\n            \n            c_in_group = idx // spatial_size\n            spatial_idx = idx % spatial_size\n            h = spatial_idx // W\n            w = spatial_idx % W\n            \n            off_x = base_x + c_in_group * stride_xc + h * stride_xh + w * stride_xw\n            data = tl.load(off_x, mask=mask, other=0.0)\n            normalized = (data - mean) * rstd\n            \n            gamma = tl.load(gamma_ptr + group_start + c_in_group)\n            beta = tl.load(beta_ptr + group_start + c_in_group)\n            out = normalized * gamma + beta\n            \n            off_y = base_y + c_in_group * stride_yc + h * stride_yh + w * stride_yw\n            tl.store(off_y, out, mask=mask)\n\n    def forward(self, x: torch.Tensor) -> torch.Tensor:\n        N, C, H, W = x.shape\n        y = torch.empty_like(x)\n        grid = (N * self.num_groups,)\n        \n        self._group_norm_fwd_kernel[grid](\n            x, y, self.weight, self.bias, \n            N, C, H, W, self.num_groups, self.eps,\n            x.stride(0), x.stride(1), x.stride(2), x.stride(3),\n            y.stride(0), y.stride(1), y.stride(2), y.stride(3),\n            BLOCK_SIZE=1024\n        )\n        return y\n\nbatch_size = 16\nfeatures = 64\nnum_groups = 8\ndim1 = 256\ndim2 = 256\n\ndef get_inputs():\n    x = torch.randn(batch_size, features, dim1, dim2, device='cuda')\n    return [x]\n\ndef get_init_inputs():\n    return [features, num_groups]\n# =================== EVOLVE-BLOCK-END ===================", "language": "python", "parent_id": "22bdd339-ec20-4322-b813-6c5e69a36591", "generation": 3, "timestamp": 1754638870.9455616, "iteration_found": 17, "metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": false, "score": 20, "speed_up": 0.024, "runtime_ms": 2.09, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:7", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.0497, "speed_up": 0.024, "custom_timing": 2.09}}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": false, "score": 20, "speed_up": 0.02, "runtime_ms": 2.43, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:2", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.0497, "speed_up": 0.02, "custom_timing": 2.43}}, "island": 2}, "artifacts_json": null, "artifact_dir": null}