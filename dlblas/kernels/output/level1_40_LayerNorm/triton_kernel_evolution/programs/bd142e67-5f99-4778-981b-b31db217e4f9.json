{"id": "bd142e67-5f99-4778-981b-b31db217e4f9", "code": "# ================== EVOLVE-BLOCK-START ==================\nimport math\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef _layer_norm_fused_kernel(\n    x_ptr,\n    weight_ptr,\n    bias_ptr,\n    output_ptr,\n    stride_x_batch,\n    n_elements,\n    eps,\n    BLOCK_SIZE: tl.constexpr,\n):\n    row_idx = tl.program_id(0)\n    row_start_ptr = x_ptr + row_idx * stride_x_batch\n    output_row_ptr = output_ptr + row_idx * stride_x_batch\n    \n    # Initialize accumulators\n    mean = 0.0\n    m2 = 0.0\n    count = 0.0\n    \n    # First pass: compute mean and variance\n    for offset in range(0, n_elements, BLOCK_SIZE):\n        cols = offset + tl.arange(0, BLOCK_SIZE)\n        mask = cols < n_elements\n        x = tl.load(row_start_ptr + cols, mask=mask, other=0.0)\n        chunk_sum = tl.sum(x, axis=0)\n        chunk_sum_sq = tl.sum(x * x, axis=0)\n        chunk_count = tl.sum(mask, axis=0)\n        mean += chunk_sum\n        m2 += chunk_sum_sq\n        count += chunk_count\n        \n    mean = mean / count\n    variance = m2 / count - mean * mean\n    inv_std = 1.0 / tl.sqrt(variance + eps)\n    \n    # Second pass: normalize and store\n    for offset in range(0, n_elements, BLOCK_SIZE):\n        cols = offset + tl.arange(0, BLOCK_SIZE)\n        mask = cols < n_elements\n        x = tl.load(row_start_ptr + cols, mask=mask, other=0.0)\n        w = tl.load(weight_ptr + cols, mask=mask, other=0.0)\n        b = tl.load(bias_ptr + cols, mask=mask, other=0.0)\n        x_hat = (x - mean) * inv_std\n        y = x_hat * w + b\n        tl.store(output_row_ptr + cols, y, mask=mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, normalized_shape: tuple):\n        super().__init__()\n        self.normalized_shape = normalized_shape\n        self.weight = nn.Parameter(torch.ones(*normalized_shape))\n        self.bias = nn.Parameter(torch.zeros(*normalized_shape))\n        self.eps = 1e-5\n\n    def forward(self, x: torch.Tensor) -> torch.Tensor:\n        input_shape = x.shape\n        normalized_ndim = len(self.normalized_shape)\n        batch_dims = input_shape[:-normalized_ndim]\n        batch_size = 1\n        for d in batch_dims:\n            batch_size *= d\n        N = 1\n        for d in self.normalized_shape:\n            N *= d\n            \n        x_flat = x.reshape(batch_size, N)\n        output_flat = torch.empty_like(x_flat)\n        weight_flat = self.weight.reshape(-1)\n        bias_flat = self.bias.reshape(-1)\n        \n        grid = (batch_size,)\n        BLOCK_SIZE = 4096\n        _layer_norm_fused_kernel[grid](\n            x_flat, weight_flat, bias_flat, output_flat,\n            x_flat.stride(0), N, self.eps,\n            BLOCK_SIZE=BLOCK_SIZE,\n            num_warps=8\n        )\n        \n        return output_flat.reshape(input_shape)\n\nbatch_size = 16\nfeatures = 64\ndim1 = 256\ndim2 = 256\n\ndef get_inputs():\n    x = torch.randn(batch_size, features, dim1, dim2)\n    return [x]\n\ndef get_init_inputs():\n    return [(features, dim1, dim2)]\n# =================== EVOLVE-BLOCK-END ===================", "language": "python", "parent_id": "ec4b83af-313d-405c-b233-f50b94d5e291", "generation": 2, "timestamp": 1754643942.3950095, "iteration_found": 20, "metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": false, "score": 20, "speed_up": 0.011, "runtime_ms": 2.9, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:5", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.0314, "speed_up": 0.011, "custom_timing": 2.9}}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": false, "score": 20, "speed_up": 0.09, "runtime_ms": 0.347, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:7", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.0314, "speed_up": 0.09, "custom_timing": 0.347}}, "island": 2}, "artifacts_json": null, "artifact_dir": null}