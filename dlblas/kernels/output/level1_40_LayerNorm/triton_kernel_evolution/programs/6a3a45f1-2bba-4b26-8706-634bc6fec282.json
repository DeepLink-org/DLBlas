{"id": "6a3a45f1-2bba-4b26-8706-634bc6fec282", "code": "# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\nclass ModelNew(nn.Module):\n    def __init__(self, normalized_shape: tuple):\n        super(ModelNew, self).__init__()\n        self.normalized_shape = normalized_shape\n        self.eps = 1e-5\n        self.weight = nn.Parameter(torch.ones(*normalized_shape))\n        self.bias = nn.Parameter(torch.zeros(*normalized_shape))\n\n    def forward(self, x: torch.Tensor) -> torch.Tensor:\n        reshaped_x = x.reshape(x.size(0), -1)\n        normalized_size = reshaped_x.size(1)\n        y = torch.empty_like(reshaped_x)\n        grid = (x.size(0),)\n        \n        # Flatten parameters\n        weight_flat = self.weight.reshape(-1)\n        bias_flat = self.bias.reshape(-1)\n        \n        # Launch Triton kernel\n        _layer_norm_fwd[grid](\n            reshaped_x, y, weight_flat, bias_flat,\n            reshaped_x.stride(0), normalized_size, self.eps,\n            BLOCK_SIZE=min(triton.next_power_of_2(normalized_size), 4096),\n            num_warps=8,\n        )\n        \n        return y.reshape(x.shape)\n\n@triton.jit\ndef _layer_norm_fwd(\n    x_ptr, y_ptr, w_ptr, b_ptr,\n    stride_x_batch, n_elements, eps,\n    BLOCK_SIZE: tl.constexpr,\n):\n    row_idx = tl.program_id(0)\n    row_start_ptr = x_ptr + row_idx * stride_x_batch\n    \n    # Initialize accumulators\n    mean_acc = 0.0\n    sq_acc = 0.0\n    \n    # First pass: compute mean and squared sum\n    for offset in range(0, n_elements, BLOCK_SIZE):\n        cols = offset + tl.arange(0, BLOCK_SIZE)\n        mask = cols < n_elements\n        x = tl.load(row_start_ptr + cols, mask=mask, other=0.0)\n        mean_acc += tl.sum(x, axis=0)\n        sq_acc += tl.sum(x * x, axis=0)\n    \n    # Compute final mean and variance\n    mean = mean_acc / n_elements\n    variance = sq_acc / n_elements - mean * mean\n    inv_std = 1.0 / tl.sqrt(variance + eps)\n    \n    # Second pass: normalize and transform\n    for offset in range(0, n_elements, BLOCK_SIZE):\n        cols = offset + tl.arange(0, BLOCK_SIZE)\n        mask = cols < n_elements\n        x = tl.load(row_start_ptr + cols, mask=mask, other=0.0)\n        \n        # Normalize\n        normalized = (x - mean) * inv_std\n        \n        # Apply affine transformation\n        w = tl.load(w_ptr + cols, mask=mask)\n        b = tl.load(b_ptr + cols, mask=mask)\n        y = normalized * w + b\n        \n        tl.store(y_ptr + row_idx * stride_x_batch + cols, y, mask=mask)\n\nbatch_size = 16\nfeatures = 64\ndim1 = 256\ndim2 = 256\n\ndef get_inputs():\n    x = torch.randn(batch_size, features, dim1, dim2)\n    return [x]\n\ndef get_init_inputs():\n    return [(features, dim1, dim2)]\n# =================== EVOLVE-BLOCK-END ===================", "language": "python", "parent_id": "7027bfde-7af2-45c1-975a-03414eb544a9", "generation": 1, "timestamp": 1754640958.2170298, "iteration_found": 3, "metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": false, "score": 20, "speed_up": 0.012, "runtime_ms": 2.72, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:6", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.0314, "speed_up": 0.012, "custom_timing": 2.72}}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": true, "correctness": true, "stage": "reference code", "passed": false, "score": 0.0, "speed_up": 1.0, "runtime_ms": 8.24, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:2", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.0314, "speed_up": 0.004, "custom_timing": 8.24}}, "island": 0}, "artifacts_json": null, "artifact_dir": null}