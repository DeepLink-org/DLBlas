{"id": "c28b9905-fabf-4d8f-b149-de86f43d5efb", "code": "# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef _linear_kernel(\n    x_ptr, \n    w_ptr, \n    bias_ptr, \n    output_ptr, \n    batch_size,  # Add batch_size as an explicit argument\n    in_features, \n    out_features, \n    stride_xb,  # Batch stride for x\n    stride_xf,  # Feature stride for x\n    stride_wr,  # Row stride for w\n    stride_wc,  # Column stride for w\n    stride_ob,  # Batch stride for output\n    stride_of,  # Feature stride for output\n    BLOCK_SIZE_M: tl.constexpr,\n    BLOCK_SIZE_N: tl.constexpr,\n    BLOCK_SIZE_K: tl.constexpr,\n    USE_BIAS: tl.constexpr,\n):\n    # Program indices\n    pid_m = tl.program_id(0)  # Batch dimension\n    pid_n = tl.program_id(1)  # Feature dimension\n    \n    # Create ranges\n    rm = pid_m * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)\n    rn = pid_n * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n    rk = tl.arange(0, BLOCK_SIZE_K)\n    \n    # Initialize accumulator\n    acc = tl.zeros((BLOCK_SIZE_M, BLOCK_SIZE_N), dtype=tl.float32)\n    \n    # Loop over K dimension\n    num_blocks_k = tl.cdiv(in_features, BLOCK_SIZE_K)\n    for k in range(0, num_blocks_k):\n        k_offsets = k * BLOCK_SIZE_K + rk\n        k_mask = k_offsets < in_features\n        \n        # Create masks for input and weight\n        x_mask = (rm < batch_size)[:, None] & k_mask[None, :]\n        w_mask = (rn < out_features)[:, None] & k_mask[None, :]\n        \n        # Load input block - [M, K]\n        x_ptr_block = x_ptr + rm[:, None] * stride_xb + k_offsets[None, :] * stride_xf\n        x = tl.load(x_ptr_block, mask=x_mask, other=0.0)\n        \n        # Load weight block - [N, K] and transpose to [K, N] for dot product\n        w_ptr_block = w_ptr + rn[:, None] * stride_wr + k_offsets[None, :] * stride_wc\n        w = tl.load(w_ptr_block, mask=w_mask, other=0.0)\n        w = tl.trans(w)  # Transpose to [K, N] for matrix multiplication\n        \n        # Compute partial dot product: [M, K] @ [K, N] -> [M, N]\n        acc += tl.dot(x, w)\n    \n    # Add bias if enabled\n    if USE_BIAS:\n        bias = tl.load(bias_ptr + rn, mask=rn < out_features, other=0.0)\n        acc += bias[None, :]  # Broadcast bias to all rows\n    \n    # Store results\n    output_mask = (rm < batch_size)[:, None] & (rn < out_features)[None, :]\n    output_ptr_block = output_ptr + rm[:, None] * stride_ob + rn[None, :] * stride_of\n    tl.store(output_ptr_block, acc, mask=output_mask)\n\nclass TritonLinear(nn.Module):\n    def __init__(self, in_features, out_features, bias=True):\n        super().__init__()\n        self.in_features = in_features\n        self.out_features = out_features\n        self.weight = nn.Parameter(torch.randn(out_features, in_features))\n        if bias:\n            self.bias = nn.Parameter(torch.randn(out_features))\n        else:\n            self.register_parameter('bias', None)\n    \n    def forward(self, x):\n        batch_size, _ = x.shape\n        output = torch.empty(batch_size, self.out_features, device=x.device, dtype=x.dtype)\n        \n        # Configure grid and block sizes\n        grid = lambda _: (\n            triton.cdiv(batch_size, 64), \n            triton.cdiv(self.out_features, 64)\n        )\n        \n        # Launch kernel with optimized parameters\n        _linear_kernel[grid](\n            x, \n            self.weight, \n            self.bias if self.bias is not None else None,  # Pass None for no bias\n            output,\n            batch_size,  # Explicit batch size\n            self.in_features,\n            self.out_features,\n            x.stride(0),  # Batch stride\n            x.stride(1),  # Feature stride\n            self.weight.stride(0),  # Row stride\n            self.weight.stride(1),  # Column stride\n            output.stride(0),  # Batch stride\n            output.stride(1),  # Feature stride\n            BLOCK_SIZE_M=64,\n            BLOCK_SIZE_N=64,\n            BLOCK_SIZE_K=128,\n            USE_BIAS=self.bias is not None\n        )\n        return output\n\nclass ModelNew(nn.Module):\n    def __init__(self, input_size, layer_sizes, output_size):\n        super(ModelNew, self).__init__()\n        layers = []\n        current_input_size = input_size\n        for layer_size in layer_sizes:\n            layers.append(TritonLinear(current_input_size, layer_size))\n            layers.append(nn.ReLU())\n            current_input_size = layer_size\n        layers.append(TritonLinear(current_input_size, output_size))\n        self.network = nn.Sequential(*layers)\n    \n    def forward(self, x):\n        return self.network(x)\n\n# Test code\nbatch_size = 1\ninput_size = 1000\nlayer_sizes = [400, 800]\noutput_size = 500\n\ndef get_inputs():\n    return [torch.randn(batch_size, input_size)]\n\ndef get_init_inputs():\n    return [input_size, layer_sizes, output_size]\n# =================== EVOLVE-BLOCK-END ===================", "language": "python", "parent_id": "3e7943a9-f7f5-4e19-b289-ea38215de96d", "generation": 4, "timestamp": 1754591895.4941666, "iteration_found": 26, "metrics": {"compiled": true, "correctness": false, "score": 10, "stage": "wrong_answer", "verify_payload": {"id": "level3_1_MLP", "result": {"compiled": true, "correctness": false, "metadata": {"hardware": "NVIDIA L20Y", "device": "cuda:0", "max_difference": ["26601.345703", "27566.744141", "28845.599609", "28096.292969", "30303.111328"], "avg_difference": ["7181.867188", "6773.234375", "7556.789551", "7431.846191", "7621.541992"], "correctness_issue": "Output mismatch", "correctness_trials": "(0 / 5)", "reference_timing_ms": 0.081, "speed_up": -1.0, "custom_timing": -1.0}, "runtime": -1.0, "runtime_stats": {}}}}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": true, "correctness": false, "score": 10, "stage": "wrong_answer", "verify_payload": {"id": "level3_1_MLP", "result": {"compiled": true, "correctness": false, "metadata": {"hardware": "NVIDIA L20Y", "device": "cuda:0", "runtime_error": "Traceback (most recent call last):\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/language/core.py\", line 42, in wrapper\n    return fn(*args, **kwargs)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/language/core.py\", line 2045, in dot\n    return _semantic.dot(input, other, acc, input_precision, max_num_imprecise_acc, out_dtype)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/language/semantic.py\", line 1498, in dot\n    assert lhs.shape[-1].value == rhs.shape[\nAssertionError: First input shape (['constexpr[64]', 'constexpr[128]']) and second input shape ['constexpr[64]', 'constexpr[128]'] are not compatible for matmul (second index of first shape (128) must be equal to first index of second shape (64)\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"/cpfs01/shared/llm_kernel/hujiakai/KernelLLM/validation_api_server/helpers/evaluations.py\", line 720, in run_and_check_correctness\n    output_new = model_new(*inputs)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1773, in _wrapped_call_impl\n    return self._call_impl(*args, **kwargs)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1784, in _call_impl\n    return forward_call(*args, **kwargs)\n  File \"/tmp/tmphu8ai_t7.py\", line 123, in forward\n    return self.network(x)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1773, in _wrapped_call_impl\n    return self._call_impl(*args, **kwargs)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1784, in _call_impl\n    return forward_call(*args, **kwargs)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/container.py\", line 244, in forward\n    input = module(input)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1773, in _wrapped_call_impl\n    return self._call_impl(*args, **kwargs)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1784, in _call_impl\n    return forward_call(*args, **kwargs)\n  File \"/tmp/tmphu8ai_t7.py\", line 90, in forward\n    _linear_kernel[grid](\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 390, in <lambda>\n    return lambda *args, **kwargs: self.run(grid=grid, warmup=False, *args, **kwargs)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 594, in run\n    kernel = self.compile(src, target=target, options=options.__dict__)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/compiler/compiler.py\", line 339, in compile\n    module = src.make_ir(options, codegen_fns, module_map, context)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/compiler/compiler.py\", line 83, in make_ir\n    return ast_to_ttir(self.fn, self, context=context, options=options, codegen_fns=codegen_fns,\ntriton.compiler.errors.CompilationError: at 49:15:\n        w_mask = (rn < out_features)[:, None] & k_mask[None, :]\n\n        # Load input block\n        x_ptr_block = x_ptr + rm[:, None] * stride_xb + k_offsets[None, :] * stride_xf\n        x = tl.load(x_ptr_block, mask=x_mask, other=0.0)\n\n        # Load weight block\n        w_ptr_block = w_ptr + rn[:, None] * stride_wr + k_offsets[None, :] * stride_wc\n        w = tl.load(w_ptr_block, mask=w_mask, other=0.0)\n\n        # Compute partial dot product\n        acc += tl.dot(x, w)\n               ^\n\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/language/core.py\", line 42, in wrapper\n    return fn(*args, **kwargs)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/language/core.py\", line 2045, in dot\n    return _semantic.dot(input, other, acc, input_precision, max_num_imprecise_acc, out_dtype)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/language/semantic.py\", line 1498, in dot\n    assert lhs.shape[-1].value == rhs.shape[\nAssertionError: First input shape (['constexpr[64]', 'constexpr[128]']) and second input shape ['constexpr[64]', 'constexpr[128]'] are not compatible for matmul (second index of first shape (128) must be equal to first index of second shape (64)\n", "runtime_error_name": "triton.compiler.errors.CompilationError", "reference_timing_ms": 0.081, "speed_up": -1.0, "custom_timing": -1.0}, "runtime": -1.0, "runtime_stats": {}}}}, "island": 0}, "artifacts_json": null, "artifact_dir": null}