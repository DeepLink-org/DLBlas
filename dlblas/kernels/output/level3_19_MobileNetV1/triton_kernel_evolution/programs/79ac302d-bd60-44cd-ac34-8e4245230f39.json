{"id": "79ac302d-bd60-44cd-ac34-8e4245230f39", "code": "# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\nimport math\n\n@triton.jit\ndef global_avg_pool_kernel(\n    input_ptr, \n    output_ptr,\n    input_batch_stride, \n    input_channel_stride, \n    input_height_stride, \n    input_width_stride,\n    output_batch_stride, \n    output_channel_stride,\n    height, \n    width,\n    P2: tl.constexpr,   # the next power of two for the spatial dimension\n):\n    pid_batch = tl.program_id(0)\n    pid_channel = tl.program_id(1)\n    \n    input_offset = pid_batch * input_batch_stride + pid_channel * input_channel_stride\n    spatial_size = height * width\n    spatial_indices = tl.arange(0, P2)\n    mask = spatial_indices < spatial_size\n\n    h = spatial_indices // width\n    w = spatial_indices % width\n    spatial_offsets = h * input_height_stride + w * input_width_stride\n    pointers = input_ptr + input_offset + spatial_offsets\n    \n    values = tl.load(pointers, mask=mask, other=0.0)\n    channel_sum = tl.sum(values, axis=0)\n    channel_avg = channel_sum / spatial_size\n    \n    output_offset = pid_batch * output_batch_stride + pid_channel * output_channel_stride\n    tl.store(output_ptr + output_offset, channel_avg)\n\nclass TritonGlobalAvgPool2d(nn.Module):\n    def __init__(self):\n        super().__init__()\n        \n    def forward(self, x):\n        N, C = x.shape[0], x.shape[1]\n        output = torch.empty((N, C), device=x.device, dtype=x.dtype)\n        \n        if x.is_contiguous():\n            x = x.contiguous()\n            \n        strides = x.stride()\n        spatial_size = x.shape[2] * x.shape[3]\n        P2 = 1 << (spatial_size - 1).bit_length()  # Next power of two\n        \n        grid = lambda _: (N, C)\n        global_avg_pool_kernel[grid](\n            x,\n            output,\n            strides[0],\n            strides[1],\n            strides[2],\n            strides[3],\n            output.stride(0),\n            output.stride(1),\n            x.shape[2],\n            x.shape[3],\n            P2=P2\n        )\n        return output\n\nclass DepthwiseConv2d(nn.Module):\n    def __init__(self, inp, oup, stride):\n        super().__init__()\n        self.conv = nn.Conv2d(inp, inp, 3, stride, 1, groups=inp, bias=False)\n        self.bn = nn.BatchNorm2d(inp)\n        self.relu = nn.ReLU(inplace=True)\n        self.pointwise = nn.Conv2d(inp, oup, 1, 1, 0, bias=False)\n        self.bn2 = nn.BatchNorm2d(oup)\n        self.relu2 = nn.ReLU(inplace=True)\n        \n    def forward(self, x):\n        x = self.conv(x)\n        x = self.bn(x)\n        x = self.relu(x)\n        x = self.pointwise(x)\n        x = self.bn2(x)\n        x = self.relu2(x)\n        return x\n\nclass ModelNew(nn.Module):\n    def __init__(self, num_classes=1000, input_channels=3, alpha=1.0):\n        super(ModelNew, self).__init__()\n        \n        def conv_bn(inp, oup, stride):\n            return nn.Sequential(\n                nn.Conv2d(inp, oup, 3, stride, 1, bias=False),\n                nn.BatchNorm2d(oup),\n                nn.ReLU(inplace=True)\n            )\n        \n        self.model = nn.Sequential(\n            conv_bn(input_channels, int(32 * alpha), 2),\n            DepthwiseConv2d(int(32 * alpha), int(64 * alpha), 1),\n            DepthwiseConv2d(int(64 * alpha), int(128 * alpha), 2),\n            DepthwiseConv2d(int(128 * alpha), int(128 * alpha), 1),\n            DepthwiseConv2d(int(128 * alpha), int(256 * alpha), 2),\n            DepthwiseConv2d(int(256 * alpha), int(256 * alpha), 1),\n            DepthwiseConv2d(int(256 * alpha), int(512 * alpha), 2),\n            DepthwiseConv2d(int(512 * alpha), int(512 * alpha), 1),\n            DepthwiseConv2d(int(512 * alpha), int(512 * alpha), 1),\n            DepthwiseConv2d(int(512 * alpha), int(512 * alpha), 1),\n            DepthwiseConv2d(int(512 * alpha), int(512 * alpha), 1),\n            DepthwiseConv2d(int(512 * alpha), int(512 * alpha), 1),\n            DepthwiseConv2d(int(512 * alpha), int(1024 * alpha), 2),\n            DepthwiseConv2d(int(1024 * alpha), int(1024 * alpha), 1),\n            TritonGlobalAvgPool2d(),\n        )\n        self.fc = nn.Linear(int(1024 * alpha), num_classes)\n    \n    def forward(self, x):\n        x = self.model(x)\n        x = self.fc(x)\n        return x\n\n# Test code\nbatch_size = 10\ninput_channels = 3\nheight = 224\nwidth = 224\nnum_classes = 1000\nalpha = 1.0\n\ndef get_inputs():\n    return [torch.randn(batch_size, input_channels, height, width)]\n\ndef get_init_inputs():\n    return [num_classes, input_channels, alpha]\n# =================== EVOLVE-BLOCK-END ===================", "language": "python", "parent_id": "30bf6814-c055-4b13-ad59-5584f3e74036", "generation": 2, "timestamp": 1754585549.0801332, "iteration_found": 12, "metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": false, "score": 20, "speed_up": 0.756, "runtime_ms": 1.8, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:0", "correctness_trials": "(5 / 5)", "reference_timing_ms": 1.36, "speed_up": 0.756, "custom_timing": 1.8}}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": false, "correctness": false, "score": -100.0, "stage": "no_valid_triton_code", "feedback": "You need to generate real and valid triton code for the core function. The key word 'import triton' is not found."}, "island": 2}, "artifacts_json": null, "artifact_dir": null}