{"id": "235f2562-6f3d-46b9-8dd0-7c820a996a6b", "code": "# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n# Optimized Triton kernel with FP16 Tensor Core utilization\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 256, 'BLOCK_SIZE_K': 64}, num_stages=3, num_warps=8),\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 256, 'BLOCK_SIZE_K': 32}, num_stages=4, num_warps=4),\n        triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 32}, num_stages=4, num_warps=4),\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 64}, num_stages=3, num_warps=4),\n        triton.Config({'BLOCK_SIZE_M': 256, 'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 32}, num_stages=4, num_warps=8),\n        # New configurations for better tiling\n        triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 1024, 'BLOCK_SIZE_K': 64}, num_stages=4, num_warps=8),\n        triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 512, 'BLOCK_SIZE_K': 64}, num_stages=4, num_warps=8),\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 1024, 'BLOCK_SIZE_K': 64}, num_stages=4, num_warps=8),\n        triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 256, 'BLOCK_SIZE_K': 64}, num_stages=4, num_warps=8),\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 512, 'BLOCK_SIZE_K': 64}, num_stages=4, num_warps=8),\n    ],\n    key=['M', 'N', 'K'],\n)\n@triton.jit\ndef fused_gemm_bn_kernel(\n    a_ptr, b_ptr, c_ptr, bias_ptr,\n    M, N, K,\n    stride_am, stride_ak,\n    stride_bk, stride_bn,\n    stride_cm, stride_cn,\n    BLOCK_SIZE_M: tl.constexpr, BLOCK_SIZE_N: tl.constexpr, BLOCK_SIZE_K: tl.constexpr\n):\n    pid = tl.program_id(0)\n    num_pid_n = tl.cdiv(N, BLOCK_SIZE_N)\n    pid_m = pid // num_pid_n\n    pid_n = pid % num_pid_n\n\n    offs_m = pid_m * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)\n    offs_n = pid_n * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n    offs_k = tl.arange(0, BLOCK_SIZE_K)\n    \n    # Compute masks for M and N boundaries\n    mask_m = offs_m < M\n    mask_n = offs_n < N\n    \n    a_ptrs = a_ptr + offs_m[:, None] * stride_am + offs_k[None, :] * stride_ak\n    b_ptrs = b_ptr + offs_k[:, None] * stride_bk + offs_n[None, :] * stride_bn\n    \n    accumulator = tl.zeros((BLOCK_SIZE_M, BLOCK_SIZE_N), dtype=tl.float32)\n    for k in range(0, K, BLOCK_SIZE_K):\n        k_remaining = K - k\n        mask_k = offs_k < k_remaining\n        # Apply full masks including M/N boundaries\n        mask_a = mask_m[:, None] & mask_k[None, :]\n        mask_b = mask_k[:, None] & mask_n[None, :]\n        # Use FP16 inputs with Tensor Core optimized dot product\n        a = tl.load(a_ptrs, mask=mask_a, other=0.0, dtype=tl.float16)\n        b = tl.load(b_ptrs, mask=mask_b, other=0.0, dtype=tl.float16)\n        accumulator += tl.dot(a, b, out_dtype=tl.float32)\n        a_ptrs += BLOCK_SIZE_K * stride_ak\n        b_ptrs += BLOCK_SIZE_K * stride_bk\n    \n    if bias_ptr is not None:\n        bias = tl.load(bias_ptr + offs_n, mask=mask_n, other=0.0)\n        accumulator += bias[None, :]\n    \n    c_ptrs = c_ptr + offs_m[:, None] * stride_cm + offs_n[None, :] * stride_cn\n    mask = mask_m[:, None] & mask_n[None, :]\n    tl.store(c_ptrs, accumulator, mask=mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, num_groups):\n        super(ModelNew, self).__init__()\n        self.gemm = nn.Linear(in_features, out_features)\n        self.batch_norm = nn.BatchNorm1d(out_features)\n        self.group_norm = nn.GroupNorm(num_groups, out_features)\n        self.fused_weight = None\n        self.fused_bias = None\n\n    def forward(self, x):\n        if not self.training:\n            if self.fused_weight is None or self.fused_bias is None:\n                with torch.no_grad():\n                    eps = self.batch_norm.eps\n                    running_var = self.batch_norm.running_var\n                    weight_bn = self.batch_norm.weight\n                    bias_bn = self.batch_norm.bias\n                    total_scale = weight_bn / torch.sqrt(running_var + eps)\n                    fused_bias = (self.gemm.bias * total_scale) + (bias_bn - self.batch_norm.running_mean * total_scale)\n                    self.fused_weight = (self.gemm.weight * total_scale.unsqueeze(1)).t().contiguous()\n                    self.fused_bias = fused_bias.contiguous()\n            \n            M, K = x.shape\n            N = self.fused_weight.shape[1]\n            output = torch.empty(M, N, device=x.device, dtype=x.dtype)\n            grid = lambda opt: (triton.cdiv(M, opt.BLOCK_SIZE_M) * triton.cdiv(N, opt.BLOCK_SIZE_N),)\n            fused_gemm_bn_kernel[grid](\n                x, self.fused_weight, output, self.fused_bias,\n                M, N, K,\n                x.stride(0), x.stride(1),\n                self.fused_weight.stride(0), self.fused_weight.stride(1),\n                output.stride(0), output.stride(1),\n            )\n            x = output\n        else:\n            x = self.gemm(x)\n            x = self.batch_norm(x)\n        \n        x = torch.nn.functional.gelu(x)\n        x = self.group_norm(x)\n        x = torch.mean(x, dim=1, keepdim=True)\n        x = torch.relu(x)\n        return x\n\nbatch_size = 128\nin_features = 512\nout_features = 1024\nnum_groups = 8\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, num_groups]\n# =================== EVOLVE-BLOCK-END ===================", "language": "python", "parent_id": "e96b1253-b727-470c-ab3e-5e2a59bb8fa2", "generation": 3, "timestamp": 1754575253.010107, "iteration_found": 15, "metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": false, "score": 20, "speed_up": 0.915, "runtime_ms": 0.13, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:7", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.119, "speed_up": 0.915, "custom_timing": 0.13}}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": false, "score": 20, "speed_up": 0.922, "runtime_ms": 0.129, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:4", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.119, "speed_up": 0.922, "custom_timing": 0.129}}, "island": 2}, "artifacts_json": null, "artifact_dir": null}