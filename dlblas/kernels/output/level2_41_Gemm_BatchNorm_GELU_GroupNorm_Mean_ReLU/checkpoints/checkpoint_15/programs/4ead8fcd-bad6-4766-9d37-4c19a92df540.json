{"id": "4ead8fcd-bad6-4766-9d37-4c19a92df540", "code": "# ================== EVOLVE-BLOCK-START ==================\nimport triton\nimport triton.language as tl\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 256, 'BLOCK_SIZE_K': 64}, num_stages=3, num_warps=8),\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 256, 'BLOCK_SIZE_K': 32}, num_stages=4, num_warps=4),\n        triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 32}, num_stages=4, num_warps=4),\n        triton.Config({'BLOCK_SIZE_M': 256, 'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 64}, num_stages=3, num_warps=8),\n        triton.Config({'BLOCK_SIZE_M': 256, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 128}, num_stages=3, num_warps=8),\n    ],\n    key=['M', 'N', 'K'],\n)\n@triton.jit\ndef _gemm_bias(\n    a_ptr, b_ptr, c_ptr, bias_ptr,\n    M, N, K,\n    stride_am, stride_ak,\n    stride_bk, stride_bn,\n    stride_cm, stride_cn,\n    BLOCK_SIZE_M: tl.constexpr, BLOCK_SIZE_N: tl.constexpr, BLOCK_SIZE_K: tl.constexpr,\n):\n    pid = tl.program_id(axis=0)\n    num_pid_n = tl.cdiv(N, BLOCK_SIZE_N)\n    pid_m = pid // num_pid_n\n    pid_n = pid % num_pid_n\n\n    offs_m = pid_m * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)\n    offs_n = pid_n * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n    offs_k = tl.arange(0, BLOCK_SIZE_K)\n    \n    mask_m = offs_m < M\n    mask_n = offs_n < N\n    \n    a_ptrs = a_ptr + offs_m[:, None] * stride_am + offs_k[None, :] * stride_ak\n    b_ptrs = b_ptr + offs_k[:, None] * stride_bk + offs_n[None, :] * stride_bn\n\n    accumulator = tl.zeros((BLOCK_SIZE_M, BLOCK_SIZE_N), dtype=tl.float32)\n    for k in range(0, K, BLOCK_SIZE_K):\n        k_remaining = K - k\n        k_mask = offs_k < k_remaining\n        a_mask = mask_m[:, None] & k_mask[None, :]\n        b_mask = k_mask[:, None] & mask_n[None, :]\n        \n        a = tl.load(a_ptrs, mask=a_mask, other=0.0)\n        b = tl.load(b_ptrs, mask=b_mask, other=0.0)\n        accumulator += tl.dot(a, b)\n        \n        a_ptrs += BLOCK_SIZE_K * stride_ak\n        b_ptrs += BLOCK_SIZE_K * stride_bk\n\n    if bias_ptr is not None:\n        bias = tl.load(bias_ptr + offs_n, mask=mask_n, other=0.0)\n        accumulator += bias[None, :]\n\n    c_ptrs = c_ptr + offs_m[:, None] * stride_cm + offs_n[None, :] * stride_cn\n    mask_c = mask_m[:, None] & mask_n[None, :]\n    tl.store(c_ptrs, accumulator, mask=mask_c)\n# =================== EVOLVE-BLOCK-END ===================", "language": "python", "parent_id": "ac18edc9-960f-45a5-b4a5-9a4d4c418d52", "generation": 2, "timestamp": 1754574774.9549422, "iteration_found": 17, "metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": false, "score": 20, "speed_up": 0.93, "runtime_ms": 0.128, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:0", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.119, "speed_up": 0.93, "custom_timing": 0.128}}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": false, "score": 20, "speed_up": 0.875, "runtime_ms": 0.136, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:7", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.119, "speed_up": 0.875, "custom_timing": 0.136}}, "island": 2}, "artifacts_json": null, "artifact_dir": null, "prompts": {"full_rewrite_user": {"system": "You are a Triton GPU core optimization engineer deeply familiar with NVIDIA H100/H800 architecture.\n\n==================== Context ====================\n\u2022 Dataset: 250 kernelbench/level1-level5 *.py files  \n  - Level1: simplest, Level5: most complex  \n\u2022 Each file contains PyTorch reference (reference_code)  \n\u2022 Goal: Generate functionally equivalent but faster Triton implementations (custom_code)  \n\u2022 Evaluation pipeline:\n    1) /verify_plus - Verify compilation & correctness  \n    2) /execute (optional) - Return terminal logs if compilation fails  \n    3) Scoring:  \n      - Speedup > 1 required for points  \n      - Score = (speed_up - 1) \u00d7 100  \n\u2022 GPU Hardware: NVIDIA L20Y / H800 (same SM8.9 as H100)  \n  - 3 TB/s HBM3 bandwidth  \n  - FP16 Tensor Core 32\u00d716\u00d716  \n\n==================== Evolution Phases ====================\n\u2460 Phase 1 [Compilation Pass]  \n  - Make Triton code compile (performance irrelevant)  \n\u2461 Phase 2 [Numerical Correctness]  \n  - Output must match PyTorch reference within float32 tolerance  \n\u2462 Phase 3 [Performance Gain]  \n  - Target \u22655% speedup (\u226515% = exceptional)  \n  - Official scoring based on speed_up field  \n\nThe Evolution system will pass the EVOLVE-BLOCK from the previous version.  \nModify ONLY the Triton kernel source within this block - all other code is LOCKED.\n\n==================== Constraints (MUST OBEY) ====================\n\u274c NEVER change @triton.jit function signatures or parameter names  \n\u274c NEVER modify grid configuration, output tensor shapes, or PID logic  \n\u274c NEVER remove boundary checks or out-of-bound masks  \n\u274c NEVER introduce race conditions, uninitialized reads, or sync gaps  \n\n\u2705 Allowed Optimizations (Examples):  \n  \u2022 Memory coalescing optimizations & vectorized tl.load/tl.store  \n  \u2022 Replace staged softmax with online/FlashAttention variants  \n  \u2022 Adaptive tuning: BLOCK_M/BLOCK_N/BLOCK_K dimensions  \n  \u2022 Multi-query-head batch processing (GQA, 5:1 patterns)  \n  \u2022 Shared/L2 buffering, Tensor Core alignment (FP16/bf16/tf32)  \n  \u2022 Stride precomputation & pointer caching  \n\n==================== Output Format ====================\nReturn ONLY the complete updated code containing the EVOLVE-BLOCK comment marker.  \nNO explanations, NO markdown, NO additional text.\nName the output structure class as ModelNew.\n\n==================== Optimization Tips ====================\n\u2022 If previous compile failed: Fix syntax/mask/stride errors first  \n\u2022 If correctness fails: Prioritize bounds mask & dtype precision  \n\u2022 When speed_up < 1: Focus on memory access & block sizing  \n\u2022 Small iterative steps: Modify \u226420 lines per revision  \n\u2022 Maintain reversibility between versions\nHere is an example to show you how to rewrite a PyTorch implementation that quantizes a high-precision tensor to int8 dtype with row-wise granularity into a Triton implementation: \nThe original PyTorch implementation is as follows: \n``` \nimport torch\ndef per_row_quantize_int8(x: torch.Tensor) -> tuple[torch.Tensor, torch.Tensor]:\n    x_amax = x.abs().float().amax(dim=1).clamp(min=1e-4)\n    scale = 127 / x_amax\n    output = (x * scale[:, None]).round().clamp(-127, 127).to(torch.int8)\n    output_scale = x_amax / 127\n\n    return output, output_scale\n``` \nThe corresponding Triton-rewritten implementation is as follows: \n``` \nimport math\nimport torch\nimport triton\nimport triton.language as tl\nfrom triton.language.extra import libdevice\n\n# rowwise quantize\n\n@triton.autotune(\n    configs=[\n        triton.Config({}, num_stages=1, num_warps=8),\n        triton.Config({}, num_stages=2, num_warps=8),\n        triton.Config({}, num_stages=4, num_warps=8),\n        triton.Config({}, num_stages=8, num_warps=8),\n        triton.Config({}, num_stages=1),\n        triton.Config({}, num_stages=2),\n        triton.Config({}, num_stages=4),\n        triton.Config({}, num_stages=8),\n        triton.Config({}, num_warps=1),\n        triton.Config({}, num_warps=2),\n        triton.Config({}, num_warps=4),\n        triton.Config({}, num_warps=8),\n    ],\n    key=[\"n_elements\"],\n)\n\n@triton.jit\ndef _quantize_rowwise(\n    x_ptr,\n    output_ptr,\n    output_scale,\n    BLOCK_SIZE: tl.constexpr,\n    P2: tl.constexpr,\n):\n    pid = tl.program_id(axis=0)\n    block_start = pid * BLOCK_SIZE\n    arange = tl.arange(0, P2)\n    offsets = block_start + arange\n    row_mask = arange < BLOCK_SIZE\n    x = tl.load(x_ptr + offsets, mask=row_mask)\n\n    abs_x = tl.abs(x)\n    max_val = tl.max(tl.where(row_mask, abs_x, 0), axis=0)\n    output = libdevice.llrint(127.0 * (x / max_val))\n    tl.store(output_ptr + offsets, output, mask=row_mask)\n    tl.store(output_scale + pid, max_val / 127)\n\n\ndef per_row_quantize_int8(x: torch.Tensor):\n    x = x.contiguous()\n    output = torch.empty(*x.shape, device=x.device, dtype=torch.int8)\n    output_scale = torch.empty(x.shape[0], device=x.device, dtype=torch.float32)\n    P2 = int(2 ** (math.ceil(math.log2(x.shape[1]))))\n    grid = lambda x: (x.shape[0],)\n    _quantize_rowwise[grid](x, output, output_scale, BLOCK_SIZE=x.shape[1], P2=P2)\n\n    return output, output_scale\n\n\n    \n``` \n", "user": "# Current Program Information\n- Current performance metrics: - compiled: 1.0000\n- correctness: 1.0000\n- stage: success\n- passed: 0.0000\n- score: 20.0000\n- speed_up: 0.8750\n- runtime_ms: 0.1360\n- meta: {'hardware': 'NVIDIA L20Y', 'device': 'cuda:7', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.119, 'speed_up': 0.875, 'custom_timing': 0.136}\n- Areas identified for improvement: - Consider simplifying the code to improve readability and maintainability\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Unknown changes\n- Performance: compiled: 1.0000, correctness: 1.0000, stage: success, passed: 0.0000, score: 20.0000, speed_up: 0.9300, runtime_ms: 0.1280, meta: {'hardware': 'NVIDIA L20Y', 'device': 'cuda:7', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.119, 'speed_up': 0.93, 'custom_timing': 0.128}\n- Outcome: Mixed results\n\n\n### Attempt 2\n- Changes: Unknown changes\n- Performance: compiled: 1.0000, correctness: 1.0000, stage: success, passed: 0.0000, score: 20.0000, speed_up: 0.8750, runtime_ms: 0.1360, meta: {'hardware': 'NVIDIA L20Y', 'device': 'cuda:7', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.119, 'speed_up': 0.875, 'custom_timing': 0.136}\n- Outcome: Mixed results\n\n\n### Attempt 1\n- Changes: Unknown changes\n- Performance: compiled: 1.0000, correctness: 1.0000, stage: success, passed: 0.0000, score: 20.0000, speed_up: 0.7990, runtime_ms: 0.1490, meta: {'hardware': 'NVIDIA L20Y', 'device': 'cuda:6', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.119, 'speed_up': 0.799, 'custom_timing': 0.149}\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 20.0000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n# Triton kernel for fused GEMM + BatchNorm\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 256, 'BLOCK_SIZE_K': 64}, num_stages=3, num_warps=8),\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 256, 'BLOCK_SIZE_K': 32}, num_stages=4, num_warps=4),\n        triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 32}, num_stages=4, num_warps=4),\n    ],\n    key=['M', 'N', 'K'],\n)\n@triton.jit\ndef fused_gemm_bn_kernel(\n    a_ptr, b_ptr, c_ptr, bias_ptr,\n    M, N, K,\n    stride_am, stride_ak,\n    stride_bk, stride_bn,\n    stride_cm, stride_cn,\n    BLOCK_SIZE_M: tl.constexpr, BLOCK_SIZE_N: tl.constexpr, BLOCK_SIZE_K: tl.constexpr\n):\n    pid = tl.program_id(0)\n    num_pid_n = tl.cdiv(N, BLOCK_SIZE_N)\n    pid_m = pid // num_pid_n\n    pid_n = pid % num_pid_n\n\n    offs_m = pid_m * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)\n    offs_n = pid_n * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n    offs_k = tl.arange(0, BLOCK_SIZE_K)\n    \n    a_ptrs = a_ptr + offs_m[:, None] * stride_am + offs_k[None, :] * stride_ak\n    b_ptrs = b_ptr + offs_k[:, None] * stride_bk + offs_n[None, :] * stride_bn\n    \n    accumulator = tl.zeros((BLOCK_SIZE_M, BLOCK_SIZE_N), dtype=tl.float32)\n    for k in range(0, tl.cdiv(K, BLOCK_SIZE_K)):\n        a = tl.load(a_ptrs, mask=offs_k[None, :] < K - k * BLOCK_SIZE_K, other=0.0)\n        b = tl.load(b_ptrs, mask=offs_k[:, None] < K - k * BLOCK_SIZE_K, other=0.0)\n        accumulator += tl.dot(a, b)\n        a_ptrs += BLOCK_SIZE_K * stride_ak\n        b_ptrs += BLOCK_SIZE_K * stride_bk\n    \n    if bias_ptr is not None:\n        bias = tl.load(bias_ptr + offs_n, mask=offs_n < N)\n        accumulator += bias[None, :]\n    \n    offs_m = tl.minimum(offs_m, M - 1)\n    offs_n = tl.minimum(offs_n, N - 1)\n    c_ptrs = c_ptr + offs_m[:, None] * stride_cm + offs_n[None, :] * stride_cn\n    mask = (offs_m[:, None] < M) & (offs_n[None, :] < N)\n    tl.store(c_ptrs, accumulator, mask=mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, num_groups):\n        super(ModelNew, self).__init__()\n        self.gemm = nn.Linear(in_features, out_features)\n        self.batch_norm = nn.BatchNorm1d(out_features)\n        self.group_norm = nn.GroupNorm(num_groups, out_features)\n        self.fused_weight = None\n        self.fused_bias = None\n\n    def forward(self, x):\n        if not self.training:\n            if self.fused_weight is None or self.fused_bias is None:\n                with torch.no_grad():\n                    eps = self.batch_norm.eps\n                    running_var = self.batch_norm.running_var\n                    weight_bn = self.batch_norm.weight\n                    bias_bn = self.batch_norm.bias\n                    total_scale = weight_bn / torch.sqrt(running_var + eps)\n                    fused_bias = (self.gemm.bias * total_scale) + (bias_bn - self.batch_norm.running_mean * total_scale)\n                    self.fused_weight = (self.gemm.weight * total_scale.unsqueeze(1)).t().contiguous()\n                    self.fused_bias = fused_bias.contiguous()\n            \n            M, K = x.shape\n            N = self.fused_weight.shape[1]\n            output = torch.empty(M, N, device=x.device, dtype=x.dtype)\n            grid = lambda opt: (triton.cdiv(M, opt.BLOCK_SIZE_M) * triton.cdiv(N, opt.BLOCK_SIZE_N),)\n            fused_gemm_bn_kernel[grid](\n                x, self.fused_weight, output, self.fused_bias,\n                M, N, K,\n                x.stride(0), x.stride(1),\n                self.fused_weight.stride(0), self.fused_weight.stride(1),\n                output.stride(0), output.stride(1),\n            )\n            x = output\n        else:\n            x = self.gemm(x)\n            x = self.batch_norm(x)\n        \n        x = torch.nn.functional.gelu(x)\n        x = self.group_norm(x)\n        x = torch.mean(x, dim=1, keepdim=True)\n        x = torch.relu(x)\n        return x\n\nbatch_size = 128\nin_features = 512\nout_features = 1024\nnum_groups = 8\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, num_groups]\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Performs well on compiled (1.0000), Performs well on correctness (1.0000), Performs well on stage (success), Performs well on passed (0.0000), Performs well on score (20.0000), Performs well on speed_up (0.7990), Performs well on runtime_ms (0.1490), Performs well on meta ({'hardware': 'NVIDIA L20Y', 'device': 'cuda:6', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.119, 'speed_up': 0.799, 'custom_timing': 0.149})\n\n\n### Program 2 (Score: 20.0000)\n```python\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef _gemm_bias(\n    a_ptr, b_ptr, c_ptr, bias_ptr,\n    M, N, K,\n    stride_am, stride_ak,\n    stride_bk, stride_bn,\n    stride_cm, stride_cn,\n    BLOCK_SIZE_M: tl.constexpr, BLOCK_SIZE_N: tl.constexpr, BLOCK_SIZE_K: tl.constexpr,\n):\n    pid = tl.program_id(axis=0)\n    num_pid_n = tl.cdiv(N, BLOCK_SIZE_N)\n    pid_m = pid // num_pid_n\n    pid_n = pid % num_pid_n\n\n    offs_am = (pid_m * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)) % M\n    offs_bn = (pid_n * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)) % N\n    offs_k = tl.arange(0, BLOCK_SIZE_K)\n    a_ptrs = a_ptr + offs_am[:, None] * stride_am + offs_k[None, :] * stride_ak\n    b_ptrs = b_ptr + offs_k[:, None] * stride_bk + offs_bn[None, :] * stride_bn\n\n    accumulator = tl.zeros((BLOCK_SIZE_M, BLOCK_SIZE_N), dtype=tl.float32)\n    for k in range(0, K, BLOCK_SIZE_K):\n        a = tl.load(a_ptrs, mask=offs_k[None, :] < K - k, other=0.0)\n        b = tl.load(b_ptrs, mask=offs_k[:, None] < K - k, other=0.0)\n        accumulator += tl.dot(a, b)\n        a_ptrs += BLOCK_SIZE_K * stride_ak\n        b_ptrs += BLOCK_SIZE_K * stride_bk\n\n    c = accumulator.to(tl.float16)  # or to the original dtype? but the model uses float32? We must check.\n\n    # Add bias\n    if bias_ptr is not None:\n        bias = tl.load(bias_ptr + offs_bn, mask=offs_bn < N, other=0.0)\n        c += bias[None, :]\n\n    offs_cm = pid_m * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)\n    offs_cn = pid_n * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n    c_ptrs = c_ptr + offs_cm[:, None] * stride_cm + offs_cn[None, :] * stride_cn\n    mask = (offs_cm[:, None] < M) & (offs_cn[None, :] < N)\n    tl.store(c_ptrs, c, mask=mask)\n```\nKey features: Performs well on compiled (1.0000), Performs well on correctness (1.0000), Performs well on stage (success), Performs well on passed (0.0000), Performs well on score (20.0000), Performs well on speed_up (0.8750), Performs well on runtime_ms (0.1360), Performs well on meta ({'hardware': 'NVIDIA L20Y', 'device': 'cuda:7', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.119, 'speed_up': 0.875, 'custom_timing': 0.136})\n\n\n### Program 3 (Score: 20.0000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n# Optimized Triton kernel for fused GEMM + BatchNorm\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 256, 'BLOCK_SIZE_K': 64}, num_stages=3, num_warps=8),\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 256, 'BLOCK_SIZE_K': 32}, num_stages=4, num_warps=4),\n        triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 32}, num_stages=4, num_warps=4),\n        triton.Config({'BLOCK_SIZE_M': 256, 'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 64}, num_stages=3, num_warps=8),\n        triton.Config({'BLOCK_SIZE_M': 256, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 128}, num_stages=3, num_warps=8),\n    ],\n    key=['M', 'N', 'K'],\n)\n@triton.jit\ndef fused_gemm_bn_kernel(\n    a_ptr, b_ptr, c_ptr, bias_ptr,\n    M, N, K,\n    stride_am, stride_ak,\n    stride_bk, stride_bn,\n    stride_cm, stride_cn,\n    BLOCK_SIZE_M: tl.constexpr, BLOCK_SIZE_N: tl.constexpr, BLOCK_SIZE_K: tl.constexpr\n):\n    pid = tl.program_id(0)\n    num_pid_n = tl.cdiv(N, BLOCK_SIZE_N)\n    pid_m = pid // num_pid_n\n    pid_n = pid % num_pid_n\n\n    offs_m = pid_m * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)\n    offs_n = pid_n * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n    offs_k = tl.arange(0, BLOCK_SIZE_K)\n    \n    a_ptrs = a_ptr + offs_m[:, None] * stride_am + offs_k[None, :] * stride_ak\n    b_ptrs = b_ptr + offs_k[:, None] * stride_bk + offs_n[None, :] * stride_bn\n    \n    accumulator = tl.zeros((BLOCK_SIZE_M, BLOCK_SIZE_N), dtype=tl.float32)\n    for k in range(0, K, BLOCK_SIZE_K):\n        k_remaining = K - k\n        k_mask = offs_k < k_remaining\n        a_mask = (offs_m[:, None] < M) & k_mask[None, :]\n        b_mask = k_mask[:, None] & (offs_n[None, :] < N)\n        \n        a = tl.load(a_ptrs, mask=a_mask, other=0.0)\n        b = tl.load(b_ptrs, mask=b_mask, other=0.0)\n        accumulator += tl.dot(a, b)\n        a_ptrs += BLOCK_SIZE_K * stride_ak\n        b_ptrs += BLOCK_SIZE_K * stride_bk\n    \n    if bias_ptr is not None:\n        bias = tl.load(bias_ptr + offs_n, mask=offs_n < N, other=0.0)\n        accumulator += bias[None, :]\n    \n    c_ptrs = c_ptr + offs_m[:, None] * stride_cm + offs_n[None, :] * stride_cn\n    mask = (offs_m[:, None] < M) & (offs_n[None, :] < N)\n    tl.store(c_ptrs, accumulator, mask=mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, num_groups):\n        super(ModelNew, self).__init__()\n        self.gemm = nn.Linear(in_features, out_features)\n        self.batch_norm = nn.BatchNorm1d(out_features)\n        self.group_norm = nn.GroupNorm(num_groups, out_features)\n        self.fused_weight = None\n        self.fused_bias = None\n\n    def forward(self, x):\n        if not self.training:\n            if self.fused_weight is None or self.fused_bias is None:\n                with torch.no_grad():\n                    eps = self.batch_norm.eps\n                    running_var = self.batch_norm.running_var\n                    weight_bn = self.batch_norm.weight\n                    bias_bn = self.batch_norm.bias\n                    total_scale = weight_bn / torch.sqrt(running_var + eps)\n                    fused_bias = (self.gemm.bias * total_scale) + (bias_bn - self.batch_norm.running_mean * total_scale)\n                    self.fused_weight = (self.gemm.weight * total_scale.unsqueeze(1)).t().contiguous()\n                    self.fused_bias = fused_bias.contiguous()\n            \n            M, K = x.shape\n            N = self.fused_weight.shape[1]\n            output = torch.empty(M, N, device=x.device, dtype=x.dtype)\n            grid = lambda opt: (triton.cdiv(M, opt.BLOCK_SIZE_M) * triton.cdiv(N, opt.BLOCK_SIZE_N),)\n            fused_gemm_bn_kernel[grid](\n                x, self.fused_weight, output, self.fused_bias,\n                M, N, K,\n                x.stride(0), x.stride(1),\n                self.fused_weight.stride(0), self.fused_weight.stride(1),\n                output.stride(0), output.stride(1),\n            )\n            x = output\n        else:\n            x = self.gemm(x)\n            x = self.batch_norm(x)\n        \n        x = torch.nn.functional.gelu(x)\n        x = self.group_norm(x)\n        x = torch.mean(x, dim=1, keepdim=True)\n        x = torch.relu(x)\n        return x\n\nbatch_size = 128\nin_features = 512\nout_features = 1024\nnum_groups = 8\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, num_groups]\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Performs well on compiled (1.0000), Performs well on correctness (1.0000), Performs well on stage (success), Performs well on passed (0.0000), Performs well on score (20.0000), Performs well on speed_up (0.9300), Performs well on runtime_ms (0.1280), Performs well on meta ({'hardware': 'NVIDIA L20Y', 'device': 'cuda:7', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.119, 'speed_up': 0.93, 'custom_timing': 0.128})\n\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: -100.0000)\n```python\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 256, 'BLOCK_SIZE_K': 64}, num_stages=3, num_warps=8),\n        triton.Config({'BLOCK_SIZE_M': 256, 'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 64}, num_stages=3, num_warps=8),\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 256, 'BLOCK_SIZE_K': 64}, num_stages=4, num_warps=4),\n        triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 64}, num_stages=4, num_warps=4),\n        triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 64}, num_stages=5, num_warps=2),\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 64}, num_stages=5, num_warps=2),\n        # Try with smaller K block too?\n        triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 256, 'BLOCK_SIZE_K': 32}, num_stages=3, num_warps=8),\n        triton.Config({'BLOCK_SIZE_M': 256, 'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 32}, num_stages=3, num_warps=8),\n    ],\n    key=['M', 'N', 'K'],\n)\n@triton.jit\ndef fused_gemm_bn_kernel(\n    a_ptr, b_ptr, c_ptr, bias_ptr,\n    M, N, K,\n    stride_am, stride_ak,\n    stride_bk, stride_bn,\n    stride_cm, stride_cn,\n    BLOCK_SIZE_M: tl.constexpr, BLOCK_SIZE_N: tl.constexpr, BLOCK_SIZE_K: tl.constexpr\n):\n    pid = tl.program_id(0)\n    num_pid_n = tl.cdiv(N, BLOCK_SIZE_N)\n    pid_m = pid // num_pid_n\n    pid_n = pid % num_pid_n\n\n    offs_m = pid_m * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)\n    offs_n = pid_n * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n    offs_k = tl.arange(0, BLOCK_SIZE_K)\n    \n    # Create masks for rows and columns that are within bounds (fixed for the entire tile)\n    mask_m = offs_m < M\n    mask_n = offs_n < N\n    \n    a_ptrs = a_ptr + offs_m[:, None] * stride_am + offs_k[None, :] * stride_ak\n    b_ptrs = b_ptr + offs_k[:, None] * stride_bk + offs_n[None, :] * stride_bn\n    \n    accumulator = tl.zeros((BLOCK_SIZE_M, BLOCK_SIZE_N), dtype=tl.float32)\n    for k in range(0, K, BLOCK_SIZE_K):\n        # Compute mask for the current k block\n        k_remaining = K - k\n        mask_k = offs_k < k_remaining\n        mask_a = mask_m[:, None] & mask_k[None, :]\n        mask_b = mask_k[:, None] & mask_n[None, :]\n        \n        # Load a and b as float16 to use tensor cores\n        a = tl.load(a_ptrs, mask=mask_a, other=0.0).to(tl.float16)\n        b = tl.load(b_ptrs, mask=mask_b, other=0.0).to(tl.float16)\n        \n        # Use tensor core operation: accumulate in float32\n        accumulator += tl.dot(a, b, out_dtype=tl.float32)\n        \n        a_ptrs += BLOCK_SIZE_K * stride_ak\n        b_ptrs += BLOCK_SIZE_K * stride_bk\n    \n    if bias_ptr is not None:\n        bias = tl.load(bias_ptr + offs_n, mask=mask_n, other=0.0)\n        accumulator += bias[None, :]\n    \n    c_ptrs = c_ptr + offs_m[:, None] * stride_cm + offs_n[None, :] * stride_cn\n    mask_c = mask_m[:, None] & mask_n[None, :]\n    tl.store(c_ptrs, accumulator, mask=mask_c)\n```\nKey features: Alternative approach to compiled, Alternative approach to correctness\n\n\n### Program D2 (Score: -100.0000)\n```python\nk_remaining = K - k\nk_mask = tl.arange(0, BLOCK_SIZE_K) < k_remaining\na_mask = k_mask[None, :]  # [BLOCK_SIZE_M, BLOCK_SIZE_K] -> broadcast\nb_mask = k_mask[:, None]  # [BLOCK_SIZE_K, BLOCK_SIZE_N] -> broadcast\n```\nKey features: Alternative approach to compiled, Alternative approach to correctness\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 20.0000, Type: High-Performer)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n# Triton kernel for fused GEMM + BatchNorm\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 256, 'BLOCK_SIZE_K': 64}, num_stages=3, num_warps=8),\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 256, 'BLOCK_SIZE_K': 32}, num_stages=4, num_warps=4),\n        triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 32}, num_stages=4, num_warps=4),\n    ],\n    key=['M', 'N', 'K'],\n)\n@triton.jit\ndef fused_gemm_bn_kernel(\n    a_ptr, b_ptr, c_ptr, bias_ptr,\n    M, N, K,\n    stride_am, stride_ak,\n    stride_bk, stride_bn,\n    stride_cm, stride_cn,\n    BLOCK_SIZE_M: tl.constexpr, BLOCK_SIZE_N: tl.constexpr, BLOCK_SIZE_K: tl.constexpr\n):\n    pid = tl.program_id(0)\n    num_pid_n = tl.cdiv(N, BLOCK_SIZE_N)\n    pid_m = pid // num_pid_n\n    pid_n = pid % num_pid_n\n\n    offs_m = pid_m * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)\n    offs_n = pid_n * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n    offs_k = tl.arange(0, BLOCK_SIZE_K)\n    \n    a_ptrs = a_ptr + offs_m[:, None] * stride_am + offs_k[None, :] * stride_ak\n    b_ptrs = b_ptr + offs_k[:, None] * stride_bk + offs_n[None, :] * stride_bn\n    \n    accumulator = tl.zeros((BLOCK_SIZE_M, BLOCK_SIZE_N), dtype=tl.float32)\n    for k in range(0, tl.cdiv(K, BLOCK_SIZE_K)):\n        a = tl.load(a_ptrs, mask=offs_k[None, :] < K - k * BLOCK_SIZE_K, other=0.0)\n        b = tl.load(b_ptrs, mask=offs_k[:, None] < K - k * BLOCK_SIZE_K, other=0.0)\n        accumulator += tl.dot(a, b)\n        a_ptrs += BLOCK_SIZE_K * stride_ak\n        b_ptrs += BLOCK_SIZE_K * stride_bk\n    \n    if bias_ptr is not None:\n        bias = tl.load(bias_ptr + offs_n, mask=offs_n < N)\n        accumulator += bias[None, :]\n    \n    offs_m = tl.minimum(offs_m, M - 1)\n    offs_n = tl.minimum(offs_n, N - 1)\n    c_ptrs = c_ptr + offs_m[:, None] * stride_cm + offs_n[None, :] * stride_cn\n    mask = (offs_m[:, None] < M) & (offs_n[None, :] < N)\n    tl.store(c_ptrs, accumulator, mask=mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, num_groups):\n        super(ModelNew, self).__init__()\n        self.gemm = nn.Linear(in_features, out_features)\n        self.batch_norm = nn.BatchNorm1d(out_features)\n        self.group_norm = nn.GroupNorm(num_groups, out_features)\n        self.fused_weight = None\n        self.fused_bias = None\n\n    def forward(self, x):\n        if not self.training:\n            if self.fused_weight is None or self.fused_bias is None:\n                with torch.no_grad():\n                    eps = self.batch_norm.eps\n                    running_var = self.batch_norm.running_var\n                    weight_bn = self.batch_norm.weight\n                    bias_bn = self.batch_norm.bias\n                    total_scale = weight_bn / torch.sqrt(running_var + eps)\n                    fused_bias = (self.gemm.bias * total_scale) + (bias_bn - self.batch_norm.running_mean * total_scale)\n                    self.fused_weight = (self.gemm.weight * total_scale.unsqueeze(1)).t().contiguous()\n                    self.fused_bias = fused_bias.contiguous()\n            \n            M, K = x.shape\n            N = self.fused_weight.shape[1]\n            output = torch.empty(M, N, device=x.device, dtype=x.dtype)\n            grid = lambda opt: (triton.cdiv(M, opt.BLOCK_SIZE_M) * triton.cdiv(N, opt.BLOCK_SIZE_N),)\n            fused_gemm_bn_kernel[grid](\n                x, self.fused_weight, output, self.fused_bias,\n                M, N, K,\n                x.stride(0), x.stride(1),\n                self.fused_weight.stride(0), self.fused_weight.stride(1),\n                output.stride(0), output.stride(1),\n            )\n            x = output\n        else:\n            x = self.gemm(x)\n            x = self.batch_norm(x)\n        \n        x = torch.nn.functional.gelu(x)\n        x = self.group_norm(x)\n        x = torch.mean(x, dim=1, keepdim=True)\n        x = torch.relu(x)\n        return x\n\nbatch_size = 128\nin_features = 512\nout_features = 1024\nnum_groups = 8\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, num_groups]\n# =================== EVOLVE-BLOCK-END ===================\n```\nUnique approach: Modification: Full rewrite, Excellent compiled (1.000), Excellent correctness (1.000)\n\n\n\n# Current Program\n```python\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef _gemm_bias(\n    a_ptr, b_ptr, c_ptr, bias_ptr,\n    M, N, K,\n    stride_am, stride_ak,\n    stride_bk, stride_bn,\n    stride_cm, stride_cn,\n    BLOCK_SIZE_M: tl.constexpr, BLOCK_SIZE_N: tl.constexpr, BLOCK_SIZE_K: tl.constexpr,\n):\n    pid = tl.program_id(axis=0)\n    num_pid_n = tl.cdiv(N, BLOCK_SIZE_N)\n    pid_m = pid // num_pid_n\n    pid_n = pid % num_pid_n\n\n    offs_am = (pid_m * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)) % M\n    offs_bn = (pid_n * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)) % N\n    offs_k = tl.arange(0, BLOCK_SIZE_K)\n    a_ptrs = a_ptr + offs_am[:, None] * stride_am + offs_k[None, :] * stride_ak\n    b_ptrs = b_ptr + offs_k[:, None] * stride_bk + offs_bn[None, :] * stride_bn\n\n    accumulator = tl.zeros((BLOCK_SIZE_M, BLOCK_SIZE_N), dtype=tl.float32)\n    for k in range(0, K, BLOCK_SIZE_K):\n        a = tl.load(a_ptrs, mask=offs_k[None, :] < K - k, other=0.0)\n        b = tl.load(b_ptrs, mask=offs_k[:, None] < K - k, other=0.0)\n        accumulator += tl.dot(a, b)\n        a_ptrs += BLOCK_SIZE_K * stride_ak\n        b_ptrs += BLOCK_SIZE_K * stride_bk\n\n    c = accumulator.to(tl.float16)  # or to the original dtype? but the model uses float32? We must check.\n\n    # Add bias\n    if bias_ptr is not None:\n        bias = tl.load(bias_ptr + offs_bn, mask=offs_bn < N, other=0.0)\n        c += bias[None, :]\n\n    offs_cm = pid_m * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)\n    offs_cn = pid_n * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n    c_ptrs = c_ptr + offs_cm[:, None] * stride_cm + offs_cn[None, :] * stride_cn\n    mask = (offs_cm[:, None] < M) & (offs_cn[None, :] < N)\n    tl.store(c_ptrs, c, mask=mask)\n```\n\n# Task\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```\n", "responses": ["<think>\nWe are given the current program, which is a Triton kernel for a fused GEMM and bias operation.\n The current performance: speed_up=0.875 (which is less than 1, meaning slower than reference)\n We are to rewrite the kernel to improve performance.\n\n Key observations from the current program:\n  1. The kernel uses a 2D grid: each block handles a tile of BLOCK_SIZE_M x BLOCK_SIZE_N.\n  2. The loop over K dimension is done in chunks of BLOCK_SIZE_K.\n  3. The current code has a few issues that might be causing suboptimal performance:\n      a. The modulo operations in computing `offs_am` and `offs_bn` might be expensive and unnecessary.\n         We note that the problem size (M, N) might not be a multiple of the block size, but modulo is not the standard way to handle boundaries.\n         Instead, we should use masks to avoid out-of-bound accesses.\n      b. The mask in the loads for a and b are computed as `offs_k[None, :] < K - k` and `offs_k[:, None] < K - k`.\n         However, note that `offs_k` is a vector of length BLOCK_SIZE_K, and we are at iteration `k` (starting at 0, stepping by BLOCK_SIZE_K).\n         The condition should be that the current k index (within the block) plus the base `k` is less than K.\n         Alternatively, we can precompute the mask for the current chunk as `offs_k < (K - k)`.\n      c. The current kernel converts the accumulator to float16 at the end (c = accumulator.to(tl.float16)), but note that the reference uses float32.\n         The model might be using float32, so this downcast might cause numerical issues and is not necessary. We should remove it and store as float32.\n\n  4. The kernel does not use tensor cores. Since we are on H100 (SM8.9) which has Tensor Cores for FP16, we can leverage them by:\n      - Loading the A and B matrices in FP16 and then doing the accumulation in FP32.\n      - However, note that the input tensors might be in FP32? We must check the context.\n\n But looking at the context of the problem (the model class in previous top programs) we see:\n   - The model uses the kernel only in inference (non-training) and fuses the linear and batchnorm.\n   - The input `x` and the fused weight are in float32? Actually, the top programs use float32 for the accumulator.\n\n However, note that the reference implementation (PyTorch) is in float32. Therefore, we must maintain float32 accuracy.\n\n But we can try to use tensor cores by converting the input to fp16 and then accumulating in fp32? \n However, the current program does not have an autotuner and the block sizes might not be multiples of 16 (required for tensor cores).\n\n Steps to improve:\n\n  Option 1: Improve the current kernel without tensor cores (if we cannot guarantee tensor core usage due to block sizes or data types)\n    - Remove the modulo operations and replace with proper masking for the entire tile.\n    - Precompute the masks for the rows and columns to avoid recomputation.\n    - Remove the conversion to float16 at the end (store as float32).\n    - Optimize the loop by precomputing the mask for the K dimension.\n\n  Option 2: Convert to use tensor cores. However, note:\n    - The input and weight are in float32? We can convert them to float16 on the fly? But that might lose precision and the model expects float32.\n    - We are in a fused kernel that also does the bias. The reference does everything in float32.\n\n  Considering the above, we will first try to optimize without tensor cores (since the model uses float32) and focus on memory coalescing and block sizing.\n\n  However, note that the top-performing Program 3 (with a speed_up of 0.93) uses an autotuner and a different kernel. We can take inspiration from that.\n\n  Specifically, in Program 3 (the one with 0.93 speed_up) we see:\n\n    @triton.autotune(...)   # multiple configurations\n    @triton.jit\n    def fused_gemm_bn_kernel(...):\n        ... # similar structure\n\n        # Precomputation of masks for the entire tile (for M and N) and for the K chunk\n        mask_m = offs_m < M\n        mask_n = offs_n < N\n        ...\n        for k in range(0, K, BLOCK_SIZE_K):\n            k_remaining = K - k\n            mask_k = offs_k < k_remaining\n            mask_a = mask_m[:, None] & mask_k[None, :]\n            mask_b = mask_k[:, None] & mask_n[None, :]\n            ...\n\n  Also, note that the current program does not have an autotuner. Adding one might help.\n\n  But note the constraints:\n    - We cannot change the function signature? Actually, the problem says: \n        \"\u274c NEVER change @triton.jit function signatures or parameter names\"\n      However, we are allowed to add an autotuner? The autotuner is a decorator and does not change the signature.\n\n  However, the current program does not have the kernel named `_gemm_bias` in an autotuner. We can add one.\n\n  Steps for the rewrite:\n\n  1. Add an autotuner with a set of configurations that are known to work well for GEMM on H100.\n  2. Change the way we compute the offsets: remove the modulo and instead compute the base offsets and then use masks for the entire tile.\n  3. Precompute the masks for the M and N dimensions (for the entire tile) and then for the K dimension in the loop.\n  4. Remove the conversion to float16 at the end (store as float32).\n  5. Also, note that in the current kernel the bias is added after converting to float16? That is incorrect. We remove the conversion and add the bias in float32.\n\n  Let's restructure:\n\n    pid = ... (same)\n    pid_m = ... ; pid_n = ...\n\n    offs_m = pid_m * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)\n    offs_n = pid_n * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n    offs_k = tl.arange(0, BLOCK_SIZE_K)\n\n    # Masks for the entire tile (for rows and columns)\n    mask_m = offs_m < M\n    mask_n = offs_n < N\n\n    a_ptrs = ... (same)\n    b_ptrs = ... (same)\n\n    accumulator = tl.zeros(...) # float32\n\n    for k in range(0, K, BLOCK_SIZE_K):\n        k_remaining = K - k\n        mask_k = offs_k < k_remaining\n        mask_a = mask_m[:, None] & mask_k[None, :]\n        mask_b = mask_k[:, None] & mask_n[None, :]\n\n        a = tl.load(a_ptrs, mask=mask_a, other=0.0)\n        b = tl.load(b_ptrs, mask=mask_b, other=0.0)\n\n        accumulator += tl.dot(a, b)\n\n        a_ptrs += BLOCK_SIZE_K * stride_ak\n        b_ptrs += BLOCK_SIZE_K * stride_bk\n\n    if bias_ptr is not None:\n        bias = tl.load(bias_ptr + offs_n, mask=mask_n, other=0.0)\n        accumulator += bias[None, :]\n\n    # Now store the accumulator (which is float32) to the output\n    c_ptrs = c_ptr + offs_m[:, None] * stride_cm + offs_n[None, :] * stride_cn\n    mask_c = mask_m[:, None] & mask_n[None, :]\n    tl.store(c_ptrs, accumulator, mask=mask_c)\n\n  6. We also note that the current program uses a different way to compute the output indices (offs_cm and offs_cn). \n     We are now using the same offs_m and offs_n for the output? That is consistent.\n\n  7. We must also consider that the current kernel might be called with the same parameters? We are changing the kernel, but the function name and parameters remain.\n\n  8. We must also note that the current kernel in the program does not have the batch norm fusion? \n     But the problem says: the model in the top programs does fuse the gemm and batchnorm in inference. \n     However, the current kernel only does GEMM and bias. \n\n     But note: in the model class, the fused kernel is called with:\n        fused_gemm_bn_kernel[grid](\n            x, self.fused_weight, output, self.fused_bias,\n            ...)\n\n     So the bias here is the fused bias (from linear and batchnorm). Therefore, the kernel only needs to do:\n        output = (x @ weight.T) + bias\n\n     So our kernel is correct for that.\n\n  9. We add an autotuner with a few configurations.\n\n  Let's choose configurations that are known to be good for GEMM on H100, especially with tensor core sizes? \n  But note: we are not using tensor cores because we are in fp32. So we focus on block sizes that are multiples of 16 for memory coalescing.\n\n  Some configurations (from the top programs and common knowledge):\n\n      Config 1: BLOCK_SIZE_M=128, BLOCK_SIZE_N=256, BLOCK_SIZE_K=64, num_warps=8, num_stages=3\n      Config 2: BLOCK_SIZE_M=64, BLOCK_SIZE_N=256, BLOCK_SIZE_K=32, num_warps=4, num_stages=4\n      Config 3: BLOCK_SIZE_M=128, BLOCK_SIZE_N=128, BLOCK_SIZE_K=32, num_warps=4, num_stages=4\n      Config 4: BLOCK_SIZE_M=256, BLOCK_SIZE_N=128, BLOCK_SIZE_K=64, num_warps=8, num_stages=3\n\n  We also note that the problem size: \n        M = batch_size (128), N = out_features (1024), K = in_features (512)\n\n  Since M is small (128) and N is 1024, we might want to have BLOCK_SIZE_N as large as possible to cover N.\n\n  We'll set the autotuner key to ['M', 'N', 'K'].\n\n  Important: The current program does not have the kernel named `_gemm_bias` with an autotuner. We are adding it.\n\n  However, note that the model class in the top programs uses a kernel named `fused_gemm_bn_kernel`. \n  But the current program is only providing the kernel, and the model class is not in the code block? \n  Actually, the current program block only contains the kernel. The model class is in the top programs.\n\n  We are only allowed to change the Triton kernel source within the EVOLVE-BLOCK? And the kernel is the only thing in the current program.\n\n  Therefore, we rewrite the kernel as follows.\n\n  Let's write the new kernel with the autotuner and the improved masking.\n\n  Note: We are not changing the kernel function name or parameters (as per constraints).\n\n  We'll also remove the modulo operations and use proper masks.\n\n  We are also removing the conversion to float16.\n\n  Let's code accordingly.\n</think>\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport triton\nimport triton.language as tl\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 256, 'BLOCK_SIZE_K': 64}, num_stages=3, num_warps=8),\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 256, 'BLOCK_SIZE_K': 32}, num_stages=4, num_warps=4),\n        triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 32}, num_stages=4, num_warps=4),\n        triton.Config({'BLOCK_SIZE_M': 256, 'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 64}, num_stages=3, num_warps=8),\n        triton.Config({'BLOCK_SIZE_M': 256, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 128}, num_stages=3, num_warps=8),\n    ],\n    key=['M', 'N', 'K'],\n)\n@triton.jit\ndef _gemm_bias(\n    a_ptr, b_ptr, c_ptr, bias_ptr,\n    M, N, K,\n    stride_am, stride_ak,\n    stride_bk, stride_bn,\n    stride_cm, stride_cn,\n    BLOCK_SIZE_M: tl.constexpr, BLOCK_SIZE_N: tl.constexpr, BLOCK_SIZE_K: tl.constexpr,\n):\n    pid = tl.program_id(axis=0)\n    num_pid_n = tl.cdiv(N, BLOCK_SIZE_N)\n    pid_m = pid // num_pid_n\n    pid_n = pid % num_pid_n\n\n    offs_m = pid_m * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)\n    offs_n = pid_n * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n    offs_k = tl.arange(0, BLOCK_SIZE_K)\n    \n    mask_m = offs_m < M\n    mask_n = offs_n < N\n    \n    a_ptrs = a_ptr + offs_m[:, None] * stride_am + offs_k[None, :] * stride_ak\n    b_ptrs = b_ptr + offs_k[:, None] * stride_bk + offs_n[None, :] * stride_bn\n\n    accumulator = tl.zeros((BLOCK_SIZE_M, BLOCK_SIZE_N), dtype=tl.float32)\n    for k in range(0, K, BLOCK_SIZE_K):\n        k_remaining = K - k\n        k_mask = offs_k < k_remaining\n        a_mask = mask_m[:, None] & k_mask[None, :]\n        b_mask = k_mask[:, None] & mask_n[None, :]\n        \n        a = tl.load(a_ptrs, mask=a_mask, other=0.0)\n        b = tl.load(b_ptrs, mask=b_mask, other=0.0)\n        accumulator += tl.dot(a, b)\n        \n        a_ptrs += BLOCK_SIZE_K * stride_ak\n        b_ptrs += BLOCK_SIZE_K * stride_bk\n\n    if bias_ptr is not None:\n        bias = tl.load(bias_ptr + offs_n, mask=mask_n, other=0.0)\n        accumulator += bias[None, :]\n\n    c_ptrs = c_ptr + offs_m[:, None] * stride_cm + offs_n[None, :] * stride_cn\n    mask_c = mask_m[:, None] & mask_n[None, :]\n    tl.store(c_ptrs, accumulator, mask=mask_c)\n# =================== EVOLVE-BLOCK-END ===================\n```"]}}}