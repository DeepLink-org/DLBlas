{"id": "af222441-bdaf-435d-95d6-d6063d8a1970", "code": "# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport triton\nimport triton.language as tl\nimport math\n\nclass ModelNew(torch.nn.Module):\n    \"\"\"\n    Optimized model using Triton for fused 3D transposed convolution, scaling, \n    average pooling, bias addition, and scaling operations.\n    \"\"\"\n    def __init__(self, in_channels, out_channels, kernel_size, stride, padding, scale1, scale2, bias_shape):\n        super(ModelNew, self).__init__()\n        self.in_channels = in_channels\n        self.out_channels = out_channels\n        self.kernel_size = kernel_size\n        self.stride = stride\n        self.padding = padding\n        self.scale1 = torch.nn.Parameter(torch.tensor(scale1))\n        self.scale2 = torch.nn.Parameter(torch.tensor(scale2))\n        self.bias = torch.nn.Parameter(torch.randn(bias_shape))\n        \n        # Weight initialization\n        self.weight = torch.nn.Parameter(\n            torch.empty(in_channels, out_channels, kernel_size, kernel_size, kernel_size)\n        )\n        torch.nn.init.kaiming_uniform_(self.weight, a=math.sqrt(5))\n\n    def forward(self, x):\n        B, C, D, H, W = x.shape\n        # Calculate output dimensions after transposed convolution\n        D_out = (D - 1) * self.stride - 2 * self.padding + self.kernel_size\n        H_out = (H - 1) * self.stride - 2 * self.padding + self.kernel_size\n        W_out = (W - 1) * self.stride - 2 * self.padding + self.kernel_size\n        \n        # Output after pooling\n        pool_out = torch.empty(\n            B, self.out_channels, \n            D_out // 2, H_out // 2, W_out // 2,\n            device=x.device, dtype=x.dtype\n        )\n        \n        # Grid configuration\n        grid = lambda opt: (triton.cdiv(pool_out.numel(), opt['BLOCK_SIZE']),)\n        \n        # Launch fused kernel\n        self.triton_fused_kernel[grid](\n            x, self.weight, self.bias,\n            pool_out,\n            self.scale1, self.scale2,\n            B, C, D, H, W,\n            D_out, H_out, W_out,\n            self.stride, self.padding,\n            x.stride(0), x.stride(1), x.stride(2), x.stride(3), x.stride(4),\n            pool_out.stride(0), pool_out.stride(1), pool_out.stride(2), pool_out.stride(3), pool_out.stride(4),\n            BLOCK_SIZE=1024,\n        )\n        return pool_out\n\n    @triton.jit\n    def triton_fused_kernel(\n        x_ptr, weight_ptr, bias_ptr, out_ptr,\n        scale1, scale2,\n        B, C, D, H, W,\n        D_out, H_out, W_out,\n        stride, padding,\n        x_batch_stride, x_channel_stride, x_d_stride, x_h_stride, x_w_stride,\n        out_batch_stride, out_channel_stride, out_d_stride, out_h_stride, out_w_stride,\n        BLOCK_SIZE: tl.constexpr,\n    ):\n        pid = tl.program_id(0)\n        num_output_elements = B * (D_out//2) * (H_out//2) * (W_out//2) * (C)\n        if pid * BLOCK_SIZE >= num_output_elements:\n            return\n        \n        # Decompose output index\n        offsets = pid * BLOCK_SIZE + tl.arange(0, BLOCK_SIZE)\n        b_idx = offsets // ((D_out//2) * (H_out//2) * (W_out//2) * C)\n        remainder = offsets % ((D_out//2) * (H_out//2) * (W_out//2) * C)\n        c_idx = remainder // ((D_out//2) * (H_out//2) * (W_out//2))\n        remainder = remainder % ((D_out//2) * (H_out//2) * (W_out//2))\n        d_out_idx = 2 * (remainder // ((H_out//2) * (W_out//2)))\n        remainder = remainder % ((H_out//2) * (W_out//2))\n        h_out_idx = 2 * (remainder // (W_out//2))\n        w_out_idx = 2 * (remainder % (W_out//2))\n        \n        # Initialize accumulator\n        acc = tl.zeros((BLOCK_SIZE,), dtype=tl.float32)\n        scale1_val = tl.load(scale1)\n        scale2_val = tl.load(scale2)\n        \n        # Loop over kernel and input channels\n        for kd in range(3):\n            for kh in range(3):\n                for kw in range(3):\n                    # Calculate input indices\n                    d_in = (d_out_idx + kd - padding) // stride\n                    h_in = (h_out_idx + kh - padding) // stride\n                    w_in = (w_out_idx + kw - padding) // stride\n                    \n                    # Check if indices are integer and within bounds\n                    valid_d = (d_out_idx + kd - padding) % stride == 0\n                    valid_h = (h_out_idx + kh - padding) % stride == 0\n                    valid_w = (w_out_idx + kw - padding) % stride == 0\n                    \n                    in_bounds = (\n                        (d_in >= 0) & (d_in < D) & \n                        (h_in >= 0) & (h_in < H) & \n                        (w_in >= 0) & (w_in < W)\n                    )\n                    valid_mask = valid_d & valid_h & valid_w & in_bounds\n                    \n                    # Load input and weight\n                    if tl.sum(valid_mask) > 0:\n                        x_offsets = (\n                            b_idx * x_batch_stride + \n                            d_in * x_d_stride + \n                            h_in * x_h_stride + \n                            w_in * x_w_stride\n                        )\n                        x_val = tl.load(\n                            x_ptr + x_offsets, \n                            mask=valid_mask, \n                            other=0.0\n                        )\n                        \n                        w_offsets = (\n                            c_idx * C * 27 +  # 3x3x3 kernel\n                            kd * 9 + kh * 3 + kw\n                        )\n                        w_val = tl.load(\n                            weight_ptr + w_offsets, \n                            mask=valid_mask, \n                            other=0.0\n                        )\n                        \n                        acc += x_val * w_val\n        \n        # Apply first scaling\n        acc = acc * scale1_val\n        \n        # Average pooling (sum then divide by 8)\n        pool_acc = tl.zeros((BLOCK_SIZE,), dtype=tl.float32)\n        count = tl.zeros((BLOCK_SIZE,), dtype=tl.int32)\n        for pd in range(2):\n            for ph in range(2):\n                for pw in range(2):\n                    d = d_out_idx + pd\n                    h = h_out_idx + ph\n                    w = w_out_idx + pw\n                    in_bounds = (d < D_out) & (h < H_out) & (w < W_out)\n                    if tl.sum(in_bounds) > 0:\n                        pool_acc += tl.where(in_bounds, acc, 0.0)\n                        count += tl.where(in_bounds, 1, 0)\n        pool_val = pool_acc / tl.maximum(count, 1)\n        \n        # Add bias and apply second scaling\n        bias_val = tl.load(bias_ptr + c_idx)\n        result = (pool_val + bias_val) * scale2_val\n        \n        # Store final result\n        out_offsets = (\n            b_idx * out_batch_stride + \n            c_idx * out_channel_stride + \n            (d_out_idx//2) * out_d_stride + \n            (h_out_idx//2) * out_h_stride + \n            (w_out_idx//2) * out_w_stride\n        )\n        tl.store(out_ptr + out_offsets, result)\n\nbatch_size = 128\nin_channels = 3\nout_channels = 16\ndepth, height, width = 16, 32, 32\nkernel_size = 3\nstride = 2\npadding = 1\nscale1 = 0.5\nscale2 = 1.0\nbias_shape = (out_channels, 1, 1, 1)\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_channels, depth, height, width)]\n\ndef get_init_inputs():\n    return [in_channels, out_channels, kernel_size, stride, padding, scale1, scale2, bias_shape]\n# =================== EVOLVE-BLOCK-END ===================", "language": "python", "parent_id": "f6bd4bd1-b1bd-4cca-a516-0639f0480ae5", "generation": 1, "timestamp": 1754572931.8523288, "iteration_found": 0, "metrics": {"compiled": true, "correctness": false, "score": 10, "stage": "wrong_answer", "verify_payload": {"id": "level2_50_ConvTranspose3d_Scaling_AvgPool_BiasAdd_Scaling", "result": {"compiled": true, "correctness": false, "metadata": {"hardware": "NVIDIA L20Y", "device": "cuda:7", "max_difference": ["3.319364", "3.312697", "3.315410", "3.316364", "3.322776"], "avg_difference": ["0.428296", "0.443136", "0.443136", "0.443132", "0.443136"], "correctness_issue": "Output mismatch", "correctness_trials": "(0 / 5)", "reference_timing_ms": 0.093, "speed_up": -1.0, "custom_timing": -1.0}, "runtime": -1.0, "runtime_stats": {}}}}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": true, "correctness": true, "stage": "reference code", "passed": false, "score": 0.0, "speed_up": 1.0, "runtime_ms": 5.72, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:7", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.093, "speed_up": 0.016, "custom_timing": 5.72}}, "island": 0}, "artifacts_json": null, "artifact_dir": null}