{"id": "f9dea8ee-f777-4ef4-860b-c5cce57e0f4d", "code": "# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef fused_softmax_bias_scale_sigmoid_kernel(\n    input_ptr, bias_ptr, output_ptr, scaling_factor,\n    batch_size, channels, height, width,\n    input_batch_stride, input_channel_stride, input_height_stride, input_width_stride,\n    bias_channel_stride,\n    output_batch_stride, output_channel_stride, output_height_stride, output_width_stride,\n    BLOCK_SIZE_H: tl.constexpr, BLOCK_SIZE_W: tl.constexpr, BLOCK_SIZE_C: tl.constexpr,\n):\n    pid_b = tl.program_id(0)\n    pid_h = tl.program_id(1)\n    pid_w = tl.program_id(2)\n    \n    offs_h = pid_h * BLOCK_SIZE_H + tl.arange(0, BLOCK_SIZE_H)\n    offs_w = pid_w * BLOCK_SIZE_W + tl.arange(0, BLOCK_SIZE_W)\n    offs_c = tl.arange(0, BLOCK_SIZE_C)\n    \n    mask_h = offs_h < height\n    mask_w = offs_w < width\n    mask_c = offs_c < channels\n    mask = mask_h[:, None, None] & mask_w[None, :, None] & mask_c[None, None, :]\n    \n    base = pid_b * input_batch_stride\n    input_ptrs = input_ptr + base + \\\n                 offs_h[:, None, None] * input_height_stride + \\\n                 offs_w[None, :, None] * input_width_stride + \\\n                 offs_c[None, None, :] * input_channel_stride\n                 \n    x_block = tl.load(input_ptrs, mask=mask, other=float('-inf'))\n    \n    max_vals = tl.max(x_block, axis=2)\n    x_block = tl.exp(x_block - max_vals[:, :, None])\n    sum_vals = tl.sum(x_block, axis=2)\n    softmax_out = x_block / sum_vals[:, :, None]\n    \n    bias_vec = tl.load(bias_ptr + offs_c * bias_channel_stride, mask=mask_c, other=0.0)\n    biased = softmax_out + bias_vec[None, None, :]\n    scaled = biased * scaling_factor\n    result = tl.sigmoid(scaled)\n    \n    output_ptrs = output_ptr + base + \\\n                  offs_h[:, None, None] * output_height_stride + \\\n                  offs_w[None, :, None] * output_width_stride + \\\n                  offs_c[None, None, :] * output_channel_stride\n                  \n    tl.store(output_ptrs, result, mask=mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_channels, out_channels, kernel_size, stride, padding, output_padding, bias_shape, scaling_factor):\n        super(ModelNew, self).__init__()\n        self.conv_transpose = nn.ConvTranspose2d(in_channels, out_channels, kernel_size, stride=stride, padding=padding, output_padding=output_padding)\n        self.bias = nn.Parameter(torch.randn(bias_shape).view(-1))\n        self.scaling_factor = scaling_factor\n\n    def forward(self, x):\n        x = self.conv_transpose(x)\n        batch_size, channels, height, width = x.shape\n        output = torch.empty_like(x)\n        \n        BLOCK_H, BLOCK_W, BLOCK_C = 16, 16, 64\n        grid = (\n            batch_size, \n            triton.cdiv(height, BLOCK_H), \n            triton.cdiv(width, BLOCK_W)\n        )\n        \n        fused_softmax_bias_scale_sigmoid_kernel[grid](\n            x, self.bias, output, self.scaling_factor,\n            batch_size, channels, height, width,\n            x.stride(0), x.stride(1), x.stride(2), x.stride(3),\n            self.bias.stride(0),\n            output.stride(0), output.stride(1), output.stride(2), output.stride(3),\n            BLOCK_SIZE_H=BLOCK_H, BLOCK_SIZE_W=BLOCK_W, BLOCK_SIZE_C=BLOCK_C\n        )\n        return output\n\nbatch_size = 128\nin_channels = 32\nout_channels = 64\nheight, width = 16, 16\nkernel_size = 4\nstride = 2\npadding = 1\noutput_padding = 1\nbias_shape = (out_channels, 1, 1)\nscaling_factor = 2.0\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_channels, height, width)]\n\ndef get_init_inputs():\n    return [in_channels, out_channels, kernel_size, stride, padding, output_padding, bias_shape, scaling_factor]\n# =================== EVOLVE-BLOCK-END ===================", "language": "python", "parent_id": "b56e2ec0-cf8e-4810-9686-0138d67c1f87", "generation": 4, "timestamp": 1754589387.6560016, "iteration_found": 16, "metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": false, "score": 20, "speed_up": 0.401, "runtime_ms": 0.24, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:6", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.0962, "speed_up": 0.401, "custom_timing": 0.24}}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": false, "score": 20, "speed_up": 0.358, "runtime_ms": 0.269, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:0", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.0962, "speed_up": 0.358, "custom_timing": 0.269}}, "island": 1}, "artifacts_json": null, "artifact_dir": null, "prompts": {"full_rewrite_user": {"system": "You are a Triton GPU core optimization engineer deeply familiar with NVIDIA H100/H800 architecture.\n\n==================== Context ====================\n\u2022 Dataset: 250 kernelbench/level1-level5 *.py files  \n  - Level1: simplest, Level5: most complex  \n\u2022 Each file contains PyTorch reference (reference_code)  \n\u2022 Goal: Generate functionally equivalent but faster Triton implementations (custom_code)  \n\u2022 Evaluation pipeline:\n    1) /verify_plus - Verify compilation & correctness  \n    2) /execute (optional) - Return terminal logs if compilation fails  \n    3) Scoring:  \n      - Speedup > 1 required for points  \n      - Score = (speed_up - 1) \u00d7 100  \n\u2022 GPU Hardware: NVIDIA L20Y / H800 (same SM8.9 as H100)  \n  - 3 TB/s HBM3 bandwidth  \n  - FP16 Tensor Core 32\u00d716\u00d716  \n\n==================== Evolution Phases ====================\n\u2460 Phase 1 [Compilation Pass]  \n  - Make Triton code compile (performance irrelevant)  \n\u2461 Phase 2 [Numerical Correctness]  \n  - Output must match PyTorch reference within float32 tolerance  \n\u2462 Phase 3 [Performance Gain]  \n  - Target \u22655% speedup (\u226515% = exceptional)  \n  - Official scoring based on speed_up field  \n\nThe Evolution system will pass the EVOLVE-BLOCK from the previous version.  \nModify ONLY the Triton kernel source within this block - all other code is LOCKED.\n\n==================== Constraints (MUST OBEY) ====================\n\u274c NEVER change @triton.jit function signatures or parameter names  \n\u274c NEVER modify grid configuration, output tensor shapes, or PID logic  \n\u274c NEVER remove boundary checks or out-of-bound masks  \n\u274c NEVER introduce race conditions, uninitialized reads, or sync gaps  \n\n\u2705 Allowed Optimizations (Examples):  \n  \u2022 Memory coalescing optimizations & vectorized tl.load/tl.store  \n  \u2022 Replace staged softmax with online/FlashAttention variants  \n  \u2022 Adaptive tuning: BLOCK_M/BLOCK_N/BLOCK_K dimensions  \n  \u2022 Multi-query-head batch processing (GQA, 5:1 patterns)  \n  \u2022 Shared/L2 buffering, Tensor Core alignment (FP16/bf16/tf32)  \n  \u2022 Stride precomputation & pointer caching  \n\n==================== Output Format ====================\nReturn ONLY the complete updated code containing the EVOLVE-BLOCK comment marker.  \nNO explanations, NO markdown, NO additional text.\nName the output structure class as ModelNew.\n\n==================== Optimization Tips ====================\n\u2022 If previous compile failed: Fix syntax/mask/stride errors first  \n\u2022 If correctness fails: Prioritize bounds mask & dtype precision  \n\u2022 When speed_up < 1: Focus on memory access & block sizing  \n\u2022 Small iterative steps: Modify \u226420 lines per revision  \n\u2022 Maintain reversibility between versions\nHere is an example to show you how to rewrite a PyTorch implementation that quantizes a high-precision tensor to int8 dtype with row-wise granularity into a Triton implementation: \nThe original PyTorch implementation is as follows: \n``` \nimport torch\ndef per_row_quantize_int8(x: torch.Tensor) -> tuple[torch.Tensor, torch.Tensor]:\n    x_amax = x.abs().float().amax(dim=1).clamp(min=1e-4)\n    scale = 127 / x_amax\n    output = (x * scale[:, None]).round().clamp(-127, 127).to(torch.int8)\n    output_scale = x_amax / 127\n\n    return output, output_scale\n``` \nThe corresponding Triton-rewritten implementation is as follows: \n``` \nimport math\nimport torch\nimport triton\nimport triton.language as tl\nfrom triton.language.extra import libdevice\n\n# rowwise quantize\n\n@triton.autotune(\n    configs=[\n        triton.Config({}, num_stages=1, num_warps=8),\n        triton.Config({}, num_stages=2, num_warps=8),\n        triton.Config({}, num_stages=4, num_warps=8),\n        triton.Config({}, num_stages=8, num_warps=8),\n        triton.Config({}, num_stages=1),\n        triton.Config({}, num_stages=2),\n        triton.Config({}, num_stages=4),\n        triton.Config({}, num_stages=8),\n        triton.Config({}, num_warps=1),\n        triton.Config({}, num_warps=2),\n        triton.Config({}, num_warps=4),\n        triton.Config({}, num_warps=8),\n    ],\n    key=[\"n_elements\"],\n)\n\n@triton.jit\ndef _quantize_rowwise(\n    x_ptr,\n    output_ptr,\n    output_scale,\n    BLOCK_SIZE: tl.constexpr,\n    P2: tl.constexpr,\n):\n    pid = tl.program_id(axis=0)\n    block_start = pid * BLOCK_SIZE\n    arange = tl.arange(0, P2)\n    offsets = block_start + arange\n    row_mask = arange < BLOCK_SIZE\n    x = tl.load(x_ptr + offsets, mask=row_mask)\n\n    abs_x = tl.abs(x)\n    max_val = tl.max(tl.where(row_mask, abs_x, 0), axis=0)\n    output = libdevice.llrint(127.0 * (x / max_val))\n    tl.store(output_ptr + offsets, output, mask=row_mask)\n    tl.store(output_scale + pid, max_val / 127)\n\n\ndef per_row_quantize_int8(x: torch.Tensor):\n    x = x.contiguous()\n    output = torch.empty(*x.shape, device=x.device, dtype=torch.int8)\n    output_scale = torch.empty(x.shape[0], device=x.device, dtype=torch.float32)\n    P2 = int(2 ** (math.ceil(math.log2(x.shape[1]))))\n    grid = lambda x: (x.shape[0],)\n    _quantize_rowwise[grid](x, output, output_scale, BLOCK_SIZE=x.shape[1], P2=P2)\n\n    return output, output_scale\n\n\n    \n``` \n", "user": "# Current Program Information\n- Current performance metrics: - compiled: 1.0000\n- correctness: 1.0000\n- stage: success\n- passed: 0.0000\n- score: 20.0000\n- speed_up: 0.3580\n- runtime_ms: 0.2690\n- meta: {'hardware': 'NVIDIA L20Y', 'device': 'cuda:0', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.0962, 'speed_up': 0.358, 'custom_timing': 0.269}\n- Areas identified for improvement: - Consider simplifying the code to improve readability and maintainability\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Unknown changes\n- Performance: compiled: 1.0000, correctness: 0.0000, score: 10.0000, stage: wrong_answer, verify_payload: {'id': 'level2_91_ConvTranspose2d_Softmax_BiasAdd_Scaling_Sigmoid', 'result': {'compiled': True, 'correctness': False, 'metadata': {'hardware': 'NVIDIA L20Y', 'device': 'cuda:0', 'max_difference': ['0.014576'], 'avg_difference': ['0.001216'], 'correctness_issue': 'Output mismatch', 'correctness_trials': '(4 / 5)', 'reference_timing_ms': 0.0962, 'speed_up': -1.0, 'custom_timing': -1.0}, 'runtime': -1.0, 'runtime_stats': {}}}\n- Outcome: Mixed results\n\n\n### Attempt 2\n- Changes: Unknown changes\n- Performance: compiled: 1.0000, correctness: 1.0000, stage: success, passed: 0.0000, score: 20.0000, speed_up: 0.3580, runtime_ms: 0.2690, meta: {'hardware': 'NVIDIA L20Y', 'device': 'cuda:0', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.0962, 'speed_up': 0.358, 'custom_timing': 0.269}\n- Outcome: Mixed results\n\n\n### Attempt 1\n- Changes: Unknown changes\n- Performance: compiled: 1.0000, correctness: 1.0000, stage: success, passed: 0.0000, score: 20.0000, speed_up: 0.3930, runtime_ms: 0.2450, meta: {'hardware': 'NVIDIA L20Y', 'device': 'cuda:3', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.0962, 'speed_up': 0.393, 'custom_timing': 0.245}\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 20.0000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef fused_softmax_bias_scale_sigmoid_kernel(\n    input_ptr, bias_ptr, output_ptr, scaling_factor,\n    batch_size, channels, height, width,\n    input_batch_stride, input_channel_stride, input_height_stride, input_width_stride,\n    bias_channel_stride,\n    output_batch_stride, output_channel_stride, output_height_stride, output_width_stride,\n    BLOCK_SIZE_H: tl.constexpr, BLOCK_SIZE_W: tl.constexpr, BLOCK_SIZE_C: tl.constexpr,\n):\n    pid_b = tl.program_id(0)\n    pid_h = tl.program_id(1)\n    pid_w = tl.program_id(2)\n    \n    offs_h = pid_h * BLOCK_SIZE_H + tl.arange(0, BLOCK_SIZE_H)\n    offs_w = pid_w * BLOCK_SIZE_W + tl.arange(0, BLOCK_SIZE_W)\n    offs_c = tl.arange(0, BLOCK_SIZE_C)\n    \n    mask_h = offs_h < height\n    mask_w = offs_w < width\n    mask_c = offs_c < channels\n    mask = mask_h[:, None, None] & mask_w[None, :, None] & mask_c[None, None, :]\n    \n    base = pid_b * input_batch_stride\n    input_ptrs = input_ptr + base + \\\n                 offs_h[:, None, None] * input_height_stride + \\\n                 offs_w[None, :, None] * input_width_stride + \\\n                 offs_c[None, None, :] * input_channel_stride\n                 \n    x_block = tl.load(input_ptrs, mask=mask, other=float('-inf'))\n    \n    max_vals = tl.max(x_block, axis=2)\n    x_block = tl.exp(x_block - max_vals[:, :, None])\n    sum_vals = tl.sum(x_block, axis=2)\n    softmax_out = x_block / sum_vals[:, :, None]\n    \n    bias_vec = tl.load(bias_ptr + offs_c * bias_channel_stride, mask=mask_c, other=0.0)\n    biased = softmax_out + bias_vec[None, None, :]\n    scaled = biased * scaling_factor\n    result = tl.sigmoid(scaled)\n    \n    output_ptrs = output_ptr + base + \\\n                  offs_h[:, None, None] * output_height_stride + \\\n                  offs_w[None, :, None] * output_width_stride + \\\n                  offs_c[None, None, :] * output_channel_stride\n                  \n    tl.store(output_ptrs, result, mask=mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_channels, out_channels, kernel_size, stride, padding, output_padding, bias_shape, scaling_factor):\n        super(ModelNew, self).__init__()\n        self.conv_transpose = nn.ConvTranspose2d(in_channels, out_channels, kernel_size, stride=stride, padding=padding, output_padding=output_padding)\n        self.bias = nn.Parameter(torch.randn(bias_shape).view(-1))\n        self.scaling_factor = scaling_factor\n\n    def forward(self, x):\n        x = self.conv_transpose(x)\n        batch_size, channels, height, width = x.shape\n        output = torch.empty_like(x)\n        \n        BLOCK_H, BLOCK_W, BLOCK_C = 16, 16, 64\n        grid = (\n            batch_size, \n            triton.cdiv(height, BLOCK_H), \n            triton.cdiv(width, BLOCK_W)\n        )\n        \n        fused_softmax_bias_scale_sigmoid_kernel[grid](\n            x, self.bias, output, self.scaling_factor,\n            batch_size, channels, height, width,\n            x.stride(0), x.stride(1), x.stride(2), x.stride(3),\n            self.bias.stride(0),\n            output.stride(0), output.stride(1), output.stride(2), output.stride(3),\n            BLOCK_SIZE_H=BLOCK_H, BLOCK_SIZE_W=BLOCK_W, BLOCK_SIZE_C=BLOCK_C\n        )\n        return output\n\nbatch_size = 128\nin_channels = 32\nout_channels = 64\nheight, width = 16, 16\nkernel_size = 4\nstride = 2\npadding = 1\noutput_padding = 1\nbias_shape = (out_channels, 1, 1)\nscaling_factor = 2.0\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_channels, height, width)]\n\ndef get_init_inputs():\n    return [in_channels, out_channels, kernel_size, stride, padding, output_padding, bias_shape, scaling_factor]\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Performs well on compiled (1.0000), Performs well on correctness (1.0000), Performs well on stage (success), Performs well on passed (0.0000), Performs well on score (20.0000), Performs well on speed_up (0.3930), Performs well on runtime_ms (0.2450), Performs well on meta ({'hardware': 'NVIDIA L20Y', 'device': 'cuda:3', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.0962, 'speed_up': 0.393, 'custom_timing': 0.245})\n\n\n### Program 2 (Score: 20.0000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef fused_softmax_bias_scale_sigmoid_kernel(\n    input_ptr, bias_ptr, output_ptr, scaling_factor,\n    batch_size, channels, height, width,\n    input_batch_stride, input_channel_stride, input_height_stride, input_width_stride,\n    bias_channel_stride,\n    output_batch_stride, output_channel_stride, output_height_stride, output_width_stride,\n    BLOCK_SIZE_H: tl.constexpr, BLOCK_SIZE_W: tl.constexpr, BLOCK_SIZE_C: tl.constexpr,\n):\n    pid_b = tl.program_id(0)\n    pid_h = tl.program_id(1)\n    pid_w = tl.program_id(2)\n    \n    offs_c = tl.arange(0, BLOCK_SIZE_C)\n    offs_h = pid_h * BLOCK_SIZE_H + tl.arange(0, BLOCK_SIZE_H)\n    offs_w = pid_w * BLOCK_SIZE_W + tl.arange(0, BLOCK_SIZE_W)\n    \n    mask_c = offs_c < channels\n    mask_h = offs_h < height\n    mask_w = offs_w < width\n    mask = mask_c[:, None, None] & mask_h[None, :, None] & mask_w[None, None, :]\n    \n    base = pid_b * input_batch_stride\n    input_ptrs = input_ptr + base + \\\n                 offs_c[:, None, None] * input_channel_stride + \\\n                 offs_h[None, :, None] * input_height_stride + \\\n                 offs_w[None, None, :] * input_width_stride\n                 \n    x_block = tl.load(input_ptrs, mask=mask, other=float('-inf'))\n    \n    max_vals = tl.max(x_block, axis=0)\n    x_block = tl.exp(x_block - max_vals[None, :, :])\n    sum_vals = tl.sum(x_block, axis=0)\n    softmax_out = x_block / sum_vals[None, :, :]\n    \n    bias_vec = tl.load(bias_ptr + offs_c * bias_channel_stride, mask=mask_c, other=0.0)\n    biased = softmax_out + bias_vec[:, None, None]\n    scaled = biased * scaling_factor\n    result = tl.sigmoid(scaled)\n    \n    output_ptrs = output_ptr + base + \\\n                  offs_c[:, None, None] * output_channel_stride + \\\n                  offs_h[None, :, None] * output_height_stride + \\\n                  offs_w[None, None, :] * output_width_stride\n                  \n    tl.store(output_ptrs, result, mask=mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_channels, out_channels, kernel_size, stride, padding, output_padding, bias_shape, scaling_factor):\n        super(ModelNew, self).__init__()\n        self.conv_transpose = nn.ConvTranspose2d(in_channels, out_channels, kernel_size, stride=stride, padding=padding, output_padding=output_padding)\n        self.bias = nn.Parameter(torch.randn(bias_shape).view(-1))\n        self.scaling_factor = scaling_factor\n\n    def forward(self, x):\n        x = self.conv_transpose(x)\n        batch_size, channels, height, width = x.shape\n        output = torch.empty_like(x)\n        \n        BLOCK_C, BLOCK_H, BLOCK_W = 64, 8, 8\n        grid = (\n            batch_size, \n            triton.cdiv(height, BLOCK_H), \n            triton.cdiv(width, BLOCK_W)\n        )\n        \n        fused_softmax_bias_scale_sigmoid_kernel[grid](\n            x, self.bias, output, self.scaling_factor,\n            batch_size, channels, height, width,\n            x.stride(0), x.stride(1), x.stride(2), x.stride(3),\n            self.bias.stride(0),\n            output.stride(0), output.stride(1), output.stride(2), output.stride(3),\n            BLOCK_SIZE_H=BLOCK_H, BLOCK_SIZE_W=BLOCK_W, BLOCK_SIZE_C=BLOCK_C,\n            num_warps=8\n        )\n        return output\n\nbatch_size = 128\nin_channels = 32\nout_channels = 64\nheight, width = 16, 16\nkernel_size = 4\nstride = 2\npadding = 1\noutput_padding = 1\nbias_shape = (out_channels, 1, 1)\nscaling_factor = 2.0\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_channels, height, width)]\n\ndef get_init_inputs():\n    return [in_channels, out_channels, kernel_size, stride, padding, output_padding, bias_shape, scaling_factor]\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Performs well on compiled (1.0000), Performs well on correctness (1.0000), Performs well on stage (success), Performs well on passed (0.0000), Performs well on score (20.0000), Performs well on speed_up (0.3580), Performs well on runtime_ms (0.2690), Performs well on meta ({'hardware': 'NVIDIA L20Y', 'device': 'cuda:0', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.0962, 'speed_up': 0.358, 'custom_timing': 0.269})\n\n\n### Program 3 (Score: 10.0000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.autotune(\n    configs=[\n        triton.Config({}, num_warps=1, num_stages=1),\n        triton.Config({}, num_warps=2, num_stages=1),\n        triton.Config({}, num_warps=4, num_stages=1),\n        triton.Config({}, num_warps=8, num_stages=1),\n        triton.Config({}, num_warps=1, num_stages=2),\n        triton.Config({}, num_warps=2, num_stages=2),\n        triton.Config({}, num_warps=4, num_stages=2),\n        triton.Config({}, num_warps=8, num_stages=2),\n        triton.Config({}, num_warps=1, num_stages=4),\n        triton.Config({}, num_warps=2, num_stages=4),\n        triton.Config({}, num_warps=4, num_stages=4),\n        triton.Config({}, num_warps=8, num_stages=4),\n    ],\n    key=['H', 'W', 'C'],\n)\n@triton.jit\ndef _fused_softmax_bias_scale_sigmoid(\n    input_ptr,\n    bias_ptr,\n    stride_n, stride_c, stride_h, stride_w,\n    H, W, C,\n    scaling_factor,\n    BLOCK_C: tl.constexpr,\n):\n    pid = tl.program_id(0)\n    n_hw = H * W\n    n_batch = pid // n_hw\n    n_hw_idx = pid % n_hw\n    h_idx = n_hw_idx // W\n    w_idx = n_hw_idx % W\n\n    base = input_ptr + n_batch * stride_n + h_idx * stride_h + w_idx * stride_w\n    c_offsets = tl.arange(0, BLOCK_C)\n    c_mask = c_offsets < C\n    x_ptrs = base + c_offsets * stride_c\n    x = tl.load(x_ptrs, mask=c_mask, other=-float('inf'))\n\n    bias = tl.load(bias_ptr + c_offsets, mask=c_mask, other=0)\n\n    max_val = tl.max(x, axis=0)\n    x_minus_max = x - max_val\n    exp_x = tl.exp(x_minus_max)\n    sum_exp = tl.sum(exp_x, axis=0)\n    softmax_out = exp_x / sum_exp\n\n    y = softmax_out + bias\n    y = y * scaling_factor\n    y = 1.0 / (1.0 + tl.exp(-y))\n\n    tl.store(x_ptrs, y, mask=c_mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_channels, out_channels, kernel_size, stride, padding, output_padding, bias_shape, scaling_factor):\n        super(ModelNew, self).__init__()\n        self.conv_transpose = nn.ConvTranspose2d(in_channels, out_channels, kernel_size, stride=stride, padding=padding, output_padding=output_padding)\n        self.bias = nn.Parameter(torch.randn(bias_shape)) \n        self.scaling_factor = scaling_factor\n\n    def forward(self, x):\n        x = self.conv_transpose(x)\n        batch_size, C, H, W = x.shape\n        total_elements = batch_size * H * W\n        stride_n = x.stride(0)\n        stride_c = x.stride(1)\n        stride_h = x.stride(2)\n        stride_w = x.stride(3)\n        \n        BLOCK_C = triton.next_power_of_2(C)\n        grid = (total_elements,)\n        _fused_softmax_bias_scale_sigmoid[grid](\n            x, \n            self.bias, \n            stride_n, stride_c, stride_h, stride_w,\n            H, W, C,\n            self.scaling_factor,\n            BLOCK_C=BLOCK_C,\n        )\n        return x\n\nbatch_size = 128\nin_channels = 32\nout_channels = 64\nheight, width = 16, 16\nkernel_size = 4\nstride = 2\npadding = 1\noutput_padding = 1\nbias_shape = (out_channels, 1, 1)\nscaling_factor = 2.0\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_channels, height, width)]\n\ndef get_init_inputs():\n    return [in_channels, out_channels, kernel_size, stride, padding, output_padding, bias_shape, scaling_factor]\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Performs well on compiled (1.0000), Performs well on correctness (0.0000), Performs well on score (10.0000), Performs well on stage (wrong_answer), Performs well on verify_payload ({'id': 'level2_91_ConvTranspose2d_Softmax_BiasAdd_Scaling_Sigmoid', 'result': {'compiled': True, 'correctness': False, 'metadata': {'hardware': 'NVIDIA L20Y', 'device': 'cuda:0', 'max_difference': ['0.014576'], 'avg_difference': ['0.001216'], 'correctness_issue': 'Output mismatch', 'correctness_trials': '(4 / 5)', 'reference_timing_ms': 0.0962, 'speed_up': -1.0, 'custom_timing': -1.0}, 'runtime': -1.0, 'runtime_stats': {}}})\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 20.0000, Type: High-Performer)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef fused_softmax_bias_scale_sigmoid_kernel(\n    input_ptr, bias_ptr, output_ptr, scaling_factor,\n    batch_size, channels, height, width,\n    input_batch_stride, input_channel_stride, input_height_stride, input_width_stride,\n    bias_channel_stride,\n    output_batch_stride, output_channel_stride, output_height_stride, output_width_stride,\n    BLOCK_SIZE_H: tl.constexpr, BLOCK_SIZE_W: tl.constexpr, BLOCK_SIZE_C: tl.constexpr,\n):\n    pid_b = tl.program_id(0)\n    pid_h = tl.program_id(1)\n    pid_w = tl.program_id(2)\n    \n    offs_h = pid_h * BLOCK_SIZE_H + tl.arange(0, BLOCK_SIZE_H)\n    offs_w = pid_w * BLOCK_SIZE_W + tl.arange(0, BLOCK_SIZE_W)\n    offs_c = tl.arange(0, BLOCK_SIZE_C)\n    \n    mask_h = offs_h < height\n    mask_w = offs_w < width\n    mask_c = offs_c < channels\n    mask = mask_h[:, None, None] & mask_w[None, :, None] & mask_c[None, None, :]\n    \n    base = pid_b * input_batch_stride\n    input_ptrs = input_ptr + base + \\\n                 offs_h[:, None, None] * input_height_stride + \\\n                 offs_w[None, :, None] * input_width_stride + \\\n                 offs_c[None, None, :] * input_channel_stride\n                 \n    x_block = tl.load(input_ptrs, mask=mask, other=float('-inf'))\n    \n    max_vals = tl.max(x_block, axis=2)\n    x_block = tl.exp(x_block - max_vals[:, :, None])\n    sum_vals = tl.sum(x_block, axis=2)\n    softmax_out = x_block / sum_vals[:, :, None]\n    \n    bias_vec = tl.load(bias_ptr + offs_c * bias_channel_stride, mask=mask_c, other=0.0)\n    biased = softmax_out + bias_vec[None, None, :]\n    scaled = biased * scaling_factor\n    result = tl.sigmoid(scaled)\n    \n    output_ptrs = output_ptr + base + \\\n                  offs_h[:, None, None] * output_height_stride + \\\n                  offs_w[None, :, None] * output_width_stride + \\\n                  offs_c[None, None, :] * output_channel_stride\n                  \n    tl.store(output_ptrs, result, mask=mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_channels, out_channels, kernel_size, stride, padding, output_padding, bias_shape, scaling_factor):\n        super(ModelNew, self).__init__()\n        self.conv_transpose = nn.ConvTranspose2d(in_channels, out_channels, kernel_size, stride=stride, padding=padding, output_padding=output_padding)\n        self.bias = nn.Parameter(torch.randn(bias_shape).view(-1))\n        self.scaling_factor = scaling_factor\n\n    def forward(self, x):\n        x = self.conv_transpose(x)\n        batch_size, channels, height, width = x.shape\n        output = torch.empty_like(x)\n        \n        BLOCK_H, BLOCK_W, BLOCK_C = 16, 16, 64\n        grid = (\n            batch_size, \n            triton.cdiv(height, BLOCK_H), \n            triton.cdiv(width, BLOCK_W)\n        )\n        \n        fused_softmax_bias_scale_sigmoid_kernel[grid](\n            x, self.bias, output, self.scaling_factor,\n            batch_size, channels, height, width,\n            x.stride(0), x.stride(1), x.stride(2), x.stride(3),\n            self.bias.stride(0),\n            output.stride(0), output.stride(1), output.stride(2), output.stride(3),\n            BLOCK_SIZE_H=BLOCK_H, BLOCK_SIZE_W=BLOCK_W, BLOCK_SIZE_C=BLOCK_C\n        )\n        return output\n\nbatch_size = 128\nin_channels = 32\nout_channels = 64\nheight, width = 16, 16\nkernel_size = 4\nstride = 2\npadding = 1\noutput_padding = 1\nbias_shape = (out_channels, 1, 1)\nscaling_factor = 2.0\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_channels, height, width)]\n\ndef get_init_inputs():\n    return [in_channels, out_channels, kernel_size, stride, padding, output_padding, bias_shape, scaling_factor]\n# =================== EVOLVE-BLOCK-END ===================\n```\nUnique approach: Modification: Full rewrite, Excellent compiled (1.000), Excellent correctness (1.000)\n\n\n\n# Current Program\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef fused_softmax_bias_scale_sigmoid_kernel(\n    input_ptr, bias_ptr, output_ptr, scaling_factor,\n    batch_size, channels, height, width,\n    input_batch_stride, input_channel_stride, input_height_stride, input_width_stride,\n    bias_channel_stride,\n    output_batch_stride, output_channel_stride, output_height_stride, output_width_stride,\n    BLOCK_SIZE_H: tl.constexpr, BLOCK_SIZE_W: tl.constexpr, BLOCK_SIZE_C: tl.constexpr,\n):\n    pid_b = tl.program_id(0)\n    pid_h = tl.program_id(1)\n    pid_w = tl.program_id(2)\n    \n    offs_c = tl.arange(0, BLOCK_SIZE_C)\n    offs_h = pid_h * BLOCK_SIZE_H + tl.arange(0, BLOCK_SIZE_H)\n    offs_w = pid_w * BLOCK_SIZE_W + tl.arange(0, BLOCK_SIZE_W)\n    \n    mask_c = offs_c < channels\n    mask_h = offs_h < height\n    mask_w = offs_w < width\n    mask = mask_c[:, None, None] & mask_h[None, :, None] & mask_w[None, None, :]\n    \n    base = pid_b * input_batch_stride\n    input_ptrs = input_ptr + base + \\\n                 offs_c[:, None, None] * input_channel_stride + \\\n                 offs_h[None, :, None] * input_height_stride + \\\n                 offs_w[None, None, :] * input_width_stride\n                 \n    x_block = tl.load(input_ptrs, mask=mask, other=float('-inf'))\n    \n    max_vals = tl.max(x_block, axis=0)\n    x_block = tl.exp(x_block - max_vals[None, :, :])\n    sum_vals = tl.sum(x_block, axis=0)\n    softmax_out = x_block / sum_vals[None, :, :]\n    \n    bias_vec = tl.load(bias_ptr + offs_c * bias_channel_stride, mask=mask_c, other=0.0)\n    biased = softmax_out + bias_vec[:, None, None]\n    scaled = biased * scaling_factor\n    result = tl.sigmoid(scaled)\n    \n    output_ptrs = output_ptr + base + \\\n                  offs_c[:, None, None] * output_channel_stride + \\\n                  offs_h[None, :, None] * output_height_stride + \\\n                  offs_w[None, None, :] * output_width_stride\n                  \n    tl.store(output_ptrs, result, mask=mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_channels, out_channels, kernel_size, stride, padding, output_padding, bias_shape, scaling_factor):\n        super(ModelNew, self).__init__()\n        self.conv_transpose = nn.ConvTranspose2d(in_channels, out_channels, kernel_size, stride=stride, padding=padding, output_padding=output_padding)\n        self.bias = nn.Parameter(torch.randn(bias_shape).view(-1))\n        self.scaling_factor = scaling_factor\n\n    def forward(self, x):\n        x = self.conv_transpose(x)\n        batch_size, channels, height, width = x.shape\n        output = torch.empty_like(x)\n        \n        BLOCK_C, BLOCK_H, BLOCK_W = 64, 8, 8\n        grid = (\n            batch_size, \n            triton.cdiv(height, BLOCK_H), \n            triton.cdiv(width, BLOCK_W)\n        )\n        \n        fused_softmax_bias_scale_sigmoid_kernel[grid](\n            x, self.bias, output, self.scaling_factor,\n            batch_size, channels, height, width,\n            x.stride(0), x.stride(1), x.stride(2), x.stride(3),\n            self.bias.stride(0),\n            output.stride(0), output.stride(1), output.stride(2), output.stride(3),\n            BLOCK_SIZE_H=BLOCK_H, BLOCK_SIZE_W=BLOCK_W, BLOCK_SIZE_C=BLOCK_C,\n            num_warps=8\n        )\n        return output\n\nbatch_size = 128\nin_channels = 32\nout_channels = 64\nheight, width = 16, 16\nkernel_size = 4\nstride = 2\npadding = 1\noutput_padding = 1\nbias_shape = (out_channels, 1, 1)\nscaling_factor = 2.0\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_channels, height, width)]\n\ndef get_init_inputs():\n    return [in_channels, out_channels, kernel_size, stride, padding, output_padding, bias_shape, scaling_factor]\n# =================== EVOLVE-BLOCK-END ===================\n```\n\n# Task\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```\n", "responses": ["<think>\nWe are given the current program which has a speedup of 0.358 (which is less than 1, meaning it's slower than the reference). We need to improve the performance.\n\n The current kernel is processing the input in blocks of [BLOCK_C, BLOCK_H, BLOCK_W] = [64, 8, 8]. The grid is over batches, height blocks, and width blocks.\n\n The kernel structure:\n   - Each block handles a fixed set of channels (BLOCK_C) for a block of height (BLOCK_H) and width (BLOCK_W).\n   - The mask is computed for the current block in C, H, W.\n   - The data is loaded in a [BLOCK_C, BLOCK_H, BLOCK_W] block, but note that the dimensions are ordered as (c, h, w) in the kernel.\n\n However, note that the softmax is applied along the channel dimension (axis=0 in the kernel). This is because the loaded block has shape [BLOCK_C, BLOCK_H, BLOCK_W] and the max/sum are taken along axis=0 (the channel dimension).\n\n The problem: \n   The current approach processes a small block of 8x8 in HxW and 64 in C. This might not be efficient because:\n     - The softmax is done per (h, w) independently, but the kernel is loading a 3D block and then doing the softmax along the channel for each (h, w) in the block. However, note that the softmax is done for each (h, w) independently? Actually, the kernel does:\n          max_vals = tl.max(x_block, axis=0)   -> This reduces the channel dimension, resulting in a [BLOCK_H, BLOCK_W] tensor.\n        Then it subtracts and exponentiates, and then sums along axis=0 again (channel) to get [BLOCK_H, BLOCK_W] and then normalizes.\n\n     So it is doing the softmax per (h, w) independently? Actually, note that the loaded x_block has dimensions [BLOCK_C, BLOCK_H, BLOCK_W]. When we do max along axis=0, we are reducing the channel dimension, so we get a [BLOCK_H, BLOCK_W] tensor. Then we subtract that from the entire block (broadcasted). Then we reduce again along the channel (axis=0) to get the denominator. So yes, it's doing independent softmax for each (h, w) in the block.\n\n   However, the way the block is loaded and stored is in a 3D block. The issue might be that the block size in H and W (8x8) is too small to effectively hide the memory latency and the computation might be memory bound.\n\n   Also note that the current kernel uses a block of channels (BLOCK_C=64) and then processes 8x8=64 spatial points. So the total number of elements per block is 64*64=4096. This might be acceptable, but we note that the reference implementation in PyTorch is faster.\n\n   Another issue: the kernel does a lot of operations (softmax and then sigmoid) and might be limited by the number of registers or shared memory.\n\n Proposed improvements:\n\n 1. Change the block size to improve memory coalescing and utilization of the GPU.\n\n    Currently, the kernel uses:\n        BLOCK_C, BLOCK_H, BLOCK_W = 64, 8, 8\n\n    But note that the tensor is stored in NCHW format. In the kernel, we are loading with:\n        input_ptrs = base + offs_c[:, None, None] * stride_c + ... \n    This means that consecutive elements in the channel dimension are stored contiguously? Actually, in NCHW, the channel dimension is the second dimension and has stride = x.stride(1). The spatial dimensions are then strided.\n\n    However, the kernel is loading a block of channels for a fixed set of spatial locations. This is not contiguous in memory because the channels for one spatial location are contiguous, but the next spatial location (in the same channel) is separated by a large stride.\n\n    We might consider transposing the order of the block: instead of having the channel as the first dimension in the block, we might make it the last. Then we can vectorize the loads and stores along the contiguous dimension (which would be the channel dimension). But note: the softmax is along the channel. If we make the channel the last dimension, then we can have the contiguous access in the channel dimension? Actually, in memory the channels are contiguous for a fixed spatial location. So if we process multiple channels for a fixed (h, w), then we are accessing contiguous memory. But the current kernel does the opposite: it loads a block of channels for multiple (h, w). That is non-contiguous.\n\n    Alternatively, we can restructure the kernel to process a block of spatial locations for a set of channels. But note that the softmax is along the channel, so we need all the channels for a given (h, w) to compute the softmax. Therefore, we cannot split the channel dimension arbitrarily without atomic operations (which we don't want).\n\n 2. We note that the top-performing program (Program 1) uses a different block ordering: [BLOCK_H, BLOCK_W, BLOCK_C] = [16, 16, 64]. In that kernel, the spatial dimensions are the first two and the channel is the last. They do:\n        offs_h = ... \n        offs_w = ...\n        offs_c = ...\n\n        mask = ... (all three)\n\n        input_ptrs = base + offs_h[:, None, None]*stride_h + offs_w[None, :, None]*stride_w + offs_c[None, None, :]*stride_c\n\n    Then the loaded block has shape [BLOCK_H, BLOCK_W, BLOCK_C]. The softmax is done along the last dimension (axis=2). This might be more efficient because:\n        - The loads and stores are along the contiguous channel dimension? Actually, note that the stride for the channel dimension is the smallest (x.stride(1) is the channel stride, and for a fixed (h, w) the channels are contiguous). So in this kernel, the inner dimension is the channel. Therefore, when we load a block of [H, W, C], we are loading a block that is contiguous in the channel dimension for each (h, w). This is more efficient because we can use vectorized loads.\n\n    Also, the block size in the spatial dimensions is larger (16x16 vs 8x8) which might help with better utilization.\n\n 3. We try to restructure the kernel to use the ordering [BLOCK_H, BLOCK_W, BLOCK_C] and then do the softmax along the channel (axis=2). We will also adjust the block sizes to be 16x16 in spatial and 64 in channels.\n\n 4. Additionally, we can try to use the autotune feature to find the best block sizes. However, we are constrained by the problem: we cannot change the grid configuration (the grid is defined by the user code in the ModelNew.forward). But note: the grid is computed based on the block sizes. So if we change the block sizes, we must change the grid accordingly. However, the problem says: \"NEVER modify grid configuration\", meaning we cannot change the way the grid is computed? Actually, the grid is computed in the ModelNew.forward function. We are allowed to change that because it is inside the EVOLVE-BLOCK.\n\n 5. We also note that the top-performing program (Program 1) had a speedup of 0.393 (which is better than our current 0.358). So we try to mimic that.\n\n Plan:\n\n   - Change the kernel to use the ordering: [BLOCK_H, BLOCK_W, BLOCK_C] for the block dimensions.\n   - Change the ModelNew.forward to set block sizes: BLOCK_H=16, BLOCK_W=16, BLOCK_C=64.\n   - Adjust the kernel to do the softmax along the channel (axis=2) and update the masking and pointer arithmetic accordingly.\n\n Let's rewrite the kernel:\n\n   pid_b, pid_h, pid_w as before.\n\n   offs_h = pid_h * BLOCK_SIZE_H + tl.arange(0, BLOCK_SIZE_H)\n   offs_w = pid_w * BLOCK_SIZE_W + tl.arange(0, BLOCK_SIZE_W)\n   offs_c = tl.arange(0, BLOCK_SIZE_C)\n\n   mask_h = offs_h < height\n   mask_w = offs_w < width\n   mask_c = offs_c < channels\n   mask = mask_h[:, None, None] & mask_w[None, :, None] & mask_c[None, None, :]\n\n   base = pid_b * input_batch_stride\n   input_ptrs = base + \n                offs_h[:, None, None] * input_height_stride + \n                offs_w[None, :, None] * input_width_stride + \n                offs_c[None, None, :] * input_channel_stride\n\n   Then we load a block of [BLOCK_H, BLOCK_W, BLOCK_C] and store it in a variable with shape [BLOCK_H, BLOCK_W, BLOCK_C].\n\n   Then we do:\n        max_vals = tl.max(x_block, axis=2)   # [BLOCK_H, BLOCK_W]\n        x_block = tl.exp(x_block - max_vals[:, :, None])   # subtract and exponentiate\n        sum_vals = tl.sum(x_block, axis=2)   # [BLOCK_H, BLOCK_W]\n        softmax_out = x_block / sum_vals[:, :, None]\n\n   Then we add the bias (which is of size [BLOCK_C]) and then scale and sigmoid.\n\n   Then we store similarly.\n\n 6. We also remove the `num_warps=8` in the kernel launch because we are going to let Triton choose the number of warps? Or we can try to set it to 8 as in the top-performing program. Actually, the top-performing program (Program 1) didn't set it explicitly. We can leave it out and let Triton choose.\n\n 7. We note that the top-performing program (Program 1) had a BLOCK_H=16, BLOCK_W=16, BLOCK_C=64 and did not use autotune. We try that.\n\n 8. We must be cautious with the correctness: we are changing the order of the block. We must ensure that the mask and the pointer arithmetic are correct.\n\n Let's write the new kernel and the ModelNew accordingly.\n\n We are going to replace the current kernel and the ModelNew.forward with the one that uses the new block ordering and block sizes.\n\n However, note that the problem says: \"Modify ONLY the Triton kernel source within this block - all other code is LOCKED.\" But actually, the ModelNew class and the block sizes are inside the EVOLVE-BLOCK. So we can change them.\n\n Steps:\n\n   a) Replace the kernel with the new one that uses [BLOCK_H, BLOCK_W, BLOCK_C] ordering and does the softmax along the channel (axis=2).\n   b) In the ModelNew.forward, set the block sizes to: BLOCK_H=16, BLOCK_W=16, BLOCK_C=64.\n   c) Change the grid to be (batch_size, triton.cdiv(height, BLOCK_H), triton.cdiv(width, BLOCK_W)).\n   d) Remove the `num_warps=8` in the kernel launch because we are not sure if it's optimal. We can let Triton choose. Alternatively, we can set it to 8 as in the top-performing program? Actually, the top-performing program did set it to 8? In the kernel launch in Program 1, they did not set any additional arguments. So we remove it.\n\n Let's write the code.\n\n Important: We must not change the function signature of the kernel. The parameters are the same.\n\n We are going to write the kernel with the new structure.\n\n Note: We are not changing the parameters, only the internal implementation.\n\n Let's do it.\n</think>\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef fused_softmax_bias_scale_sigmoid_kernel(\n    input_ptr, bias_ptr, output_ptr, scaling_factor,\n    batch_size, channels, height, width,\n    input_batch_stride, input_channel_stride, input_height_stride, input_width_stride,\n    bias_channel_stride,\n    output_batch_stride, output_channel_stride, output_height_stride, output_width_stride,\n    BLOCK_SIZE_H: tl.constexpr, BLOCK_SIZE_W: tl.constexpr, BLOCK_SIZE_C: tl.constexpr,\n):\n    pid_b = tl.program_id(0)\n    pid_h = tl.program_id(1)\n    pid_w = tl.program_id(2)\n    \n    offs_h = pid_h * BLOCK_SIZE_H + tl.arange(0, BLOCK_SIZE_H)\n    offs_w = pid_w * BLOCK_SIZE_W + tl.arange(0, BLOCK_SIZE_W)\n    offs_c = tl.arange(0, BLOCK_SIZE_C)\n    \n    mask_h = offs_h < height\n    mask_w = offs_w < width\n    mask_c = offs_c < channels\n    mask = mask_h[:, None, None] & mask_w[None, :, None] & mask_c[None, None, :]\n    \n    base = pid_b * input_batch_stride\n    input_ptrs = input_ptr + base + \\\n                 offs_h[:, None, None] * input_height_stride + \\\n                 offs_w[None, :, None] * input_width_stride + \\\n                 offs_c[None, None, :] * input_channel_stride\n                 \n    x_block = tl.load(input_ptrs, mask=mask, other=float('-inf'))\n    \n    max_vals = tl.max(x_block, axis=2)\n    x_block = tl.exp(x_block - max_vals[:, :, None])\n    sum_vals = tl.sum(x_block, axis=2)\n    softmax_out = x_block / sum_vals[:, :, None]\n    \n    bias_vec = tl.load(bias_ptr + offs_c * bias_channel_stride, mask=mask_c, other=0.0)\n    biased = softmax_out + bias_vec[None, None, :]\n    scaled = biased * scaling_factor\n    result = tl.sigmoid(scaled)\n    \n    output_ptrs = output_ptr + base + \\\n                  offs_h[:, None, None] * output_height_stride + \\\n                  offs_w[None, :, None] * output_width_stride + \\\n                  offs_c[None, None, :] * output_channel_stride\n                  \n    tl.store(output_ptrs, result, mask=mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_channels, out_channels, kernel_size, stride, padding, output_padding, bias_shape, scaling_factor):\n        super(ModelNew, self).__init__()\n        self.conv_transpose = nn.ConvTranspose2d(in_channels, out_channels, kernel_size, stride=stride, padding=padding, output_padding=output_padding)\n        self.bias = nn.Parameter(torch.randn(bias_shape).view(-1))\n        self.scaling_factor = scaling_factor\n\n    def forward(self, x):\n        x = self.conv_transpose(x)\n        batch_size, channels, height, width = x.shape\n        output = torch.empty_like(x)\n        \n        BLOCK_H, BLOCK_W, BLOCK_C = 16, 16, 64\n        grid = (\n            batch_size, \n            triton.cdiv(height, BLOCK_H), \n            triton.cdiv(width, BLOCK_W)\n        )\n        \n        fused_softmax_bias_scale_sigmoid_kernel[grid](\n            x, self.bias, output, self.scaling_factor,\n            batch_size, channels, height, width,\n            x.stride(0), x.stride(1), x.stride(2), x.stride(3),\n            self.bias.stride(0),\n            output.stride(0), output.stride(1), output.stride(2), output.stride(3),\n            BLOCK_SIZE_H=BLOCK_H, BLOCK_SIZE_W=BLOCK_W, BLOCK_SIZE_C=BLOCK_C\n        )\n        return output\n\nbatch_size = 128\nin_channels = 32\nout_channels = 64\nheight, width = 16, 16\nkernel_size = 4\nstride = 2\npadding = 1\noutput_padding = 1\nbias_shape = (out_channels, 1, 1)\nscaling_factor = 2.0\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_channels, height, width)]\n\ndef get_init_inputs():\n    return [in_channels, out_channels, kernel_size, stride, padding, output_padding, bias_shape, scaling_factor]\n# =================== EVOLVE-BLOCK-END ===================\n```"]}}}