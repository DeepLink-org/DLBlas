{"id": "085a6fe3-66fc-405d-b7d2-49a8833eb9ad", "code": "# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\nimport math\n\n@triton.jit\ndef transposed_conv1d_kernel(\n    x_ptr,\n    weight_ptr,\n    bias_ptr,\n    output_ptr,\n    batch_size,\n    in_channels,\n    out_channels,\n    length_in,\n    length_out,\n    kernel_size: tl.constexpr,\n    stride,\n    padding,\n    dilation,\n    numel,\n    BLOCK_SIZE: tl.constexpr,\n):\n    pid = tl.program_id(0)\n    offs = pid * BLOCK_SIZE + tl.arange(0, BLOCK_SIZE)\n    mask = offs < numel\n\n    output_channels_length = out_channels * length_out\n    b_idx = offs // output_channels_length\n    remainder = offs % output_channels_length\n    c_out_idx = remainder // length_out\n    i_out = remainder % length_out\n\n    acc = tl.zeros((BLOCK_SIZE,), dtype=tl.float32)\n    \n    if bias_ptr is not None:\n        bias = tl.load(bias_ptr + c_out_idx, mask=mask, other=0.0)\n        acc += bias\n\n    # Precompute base pointers\n    batch_base = b_idx * in_channels * length_in\n    weight_base = c_out_idx * kernel_size\n\n    # Unroll kernel dimension for efficiency\n    for k in tl.static_range(kernel_size):\n        # Compute input position\n        numerator = i_out + padding - k * dilation\n        cond1 = numerator >= 0\n        cond2 = (numerator % stride) == 0\n        j = numerator // stride\n        cond3 = (j >= 0) & (j < length_in)\n        cond = cond1 & cond2 & cond3\n\n        # Process all input channels efficiently\n        for c_in in range(0, in_channels):\n            # Compute offsets using precomputed bases\n            input_offset = batch_base + c_in * length_in + j\n            weight_offset = c_in * (out_channels * kernel_size) + weight_base + k\n            \n            # Load elements with proper masking\n            x_val = tl.load(x_ptr + input_offset, mask=mask & cond, other=0.0)\n            w_val = tl.load(weight_ptr + weight_offset, mask=mask, other=0.0)\n            \n            # Accumulate product\n            acc += x_val * w_val\n\n    # Store result\n    tl.store(output_ptr + offs, acc, mask=mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_channels: int, out_channels: int, kernel_size: int, stride: int = 1, padding: int = 0, dilation: int = 1, bias: bool = False):\n        super(ModelNew, self).__init__()\n        self.conv1d_transpose = nn.ConvTranspose1d(in_channels, out_channels, kernel_size, stride=stride, padding=padding, dilation=dilation, bias=bias)\n        \n    def forward(self, x: torch.Tensor) -> torch.Tensor:\n        batch_size, in_channels, length_in = x.shape\n        out_channels = self.conv1d_transpose.out_channels\n        kernel_size = self.conv1d_transpose.kernel_size[0]\n        stride = self.conv1d_transpose.stride[0]\n        padding = self.conv1d_transpose.padding[0]\n        dilation = self.conv1d_transpose.dilation[0]\n        \n        # Compute output length\n        length_out = (length_in - 1) * stride - 2 * padding + dilation * (kernel_size - 1) + 1\n        output = torch.empty((batch_size, out_channels, length_out), device=x.device, dtype=x.dtype)\n        \n        # Ensure contiguous memory access\n        x_contig = x.contiguous()\n        weight_contig = self.conv1d_transpose.weight.contiguous()\n        bias_contig = self.conv1d_transpose.bias if self.conv1d_transpose.bias is not None else None\n        \n        # Launch kernel configuration\n        numel = batch_size * out_channels * length_out\n        BLOCK_SIZE = 1024\n        grid = (triton.cdiv(numel, BLOCK_SIZE),)\n        \n        # Launch optimized kernel\n        transposed_conv1d_kernel[grid](\n            x_contig, \n            weight_contig, \n            bias_contig, \n            output,\n            batch_size, \n            in_channels, \n            out_channels, \n            length_in, \n            length_out,\n            kernel_size, \n            stride, \n            padding, \n            dilation,\n            numel,\n            BLOCK_SIZE=BLOCK_SIZE\n        )\n        \n        return output\n\n# Test code\nbatch_size = 16\nin_channels = 32\nout_channels = 64\nkernel_size = 3\nlength = 128\nstride = 2\npadding = 1\ndilation = 2\n\ndef get_inputs():\n    x = torch.randn(batch_size, in_channels, length)\n    return [x]\n\ndef get_init_inputs():\n    return [in_channels, out_channels, kernel_size, stride, padding, dilation]\n# =================== EVOLVE-BLOCK-END ===================", "language": "python", "parent_id": "64cdc2ae-7929-4ca7-b137-a15d92164602", "generation": 3, "timestamp": 1754992014.686294, "iteration_found": 10, "metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": true, "score": 20.6, "speed_up": 1.006, "runtime_ms": 0.0724, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:6", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.0728, "speed_up": 1.006, "custom_timing": 0.0724}}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": false, "score": 20, "speed_up": 0.633, "runtime_ms": 0.115, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:4", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.0728, "speed_up": 0.633, "custom_timing": 0.115}}, "island": 0}, "artifacts_json": null, "artifact_dir": null}