{"id": "d3631af2-aa34-4a8b-bab9-f4b488236e9a", "code": "# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\nimport math\n\n@triton.jit\ndef transposed_conv1d_kernel(\n    x_ptr,\n    weight_ptr,\n    bias_ptr,\n    output_ptr,\n    batch_size,\n    in_channels,\n    out_channels,\n    length_in,\n    length_out,\n    kernel_size: tl.constexpr,\n    stride,\n    padding,\n    dilation,\n    numel,\n    BLOCK_SIZE: tl.constexpr,\n    BLOCK_C: tl.constexpr\n):\n    pid = tl.program_id(0)\n    offs = pid * BLOCK_SIZE + tl.arange(0, BLOCK_SIZE)\n    mask = offs < numel\n\n    # Compute output element coordinates\n    output_channels_length = out_channels * length_out\n    b_idx = offs // output_channels_length\n    remainder = offs % output_channels_length\n    c_out_idx = remainder // length_out\n    i_out = remainder % length_out\n\n    # Initialize accumulator\n    acc = tl.zeros((BLOCK_SIZE,), dtype=tl.float32)\n    \n    # Load bias if present\n    if bias_ptr is not None:\n        bias = tl.load(bias_ptr + c_out_idx, mask=mask, other=0.0)\n        acc += bias\n\n    # Precompute base pointers\n    batch_base = b_idx * in_channels * length_in\n    weight_base = c_out_idx * kernel_size\n\n    # Unroll kernel dimension for efficiency\n    for k in tl.static_range(kernel_size):\n        # Compute input position\n        numerator = i_out + padding - k * dilation\n        cond1 = numerator >= 0\n        cond2 = (numerator % stride) == 0\n        j = numerator // stride\n        cond3 = (j >= 0) & (j < length_in)\n        cond = cond1 & cond2 & cond3\n\n        # Process input channels in blocks\n        for c_in_block in range(0, in_channels, BLOCK_C):\n            c_in_offsets = c_in_block + tl.arange(0, BLOCK_C)\n            c_in_mask = c_in_offsets < in_channels\n\n            # Compute input pointers\n            input_ptrs = x_ptr + batch_base[:, None] + c_in_offsets[None, :] * length_in + j[:, None]\n            # Compute weight pointers\n            weight_ptrs = weight_ptr + c_in_offsets[None, :] * (out_channels * kernel_size) + weight_base[:, None] + k\n            \n            # Create 2D mask\n            mask2d = mask[:, None] & cond[:, None] & c_in_mask[None, :]\n            \n            # Load values with vectorization\n            x_vals = tl.load(input_ptrs, mask=mask2d, other=0.0)\n            w_vals = tl.load(weight_ptrs, mask=mask2d, other=0.0)\n            \n            # Accumulate products\n            product = x_vals * w_vals\n            acc += tl.sum(product, axis=1)\n\n    # Store result\n    tl.store(output_ptr + offs, acc, mask=mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_channels: int, out_channels: int, kernel_size: int, stride: int = 1, padding: int = 0, dilation: int = 1, bias: bool = False):\n        super(ModelNew, self).__init__()\n        self.conv1d_transpose = nn.ConvTranspose1d(in_channels, out_channels, kernel_size, stride=stride, padding=padding, dilation=dilation, bias=bias)\n        \n    def forward(self, x: torch.Tensor) -> torch.Tensor:\n        batch_size, in_channels, length_in = x.shape\n        out_channels = self.conv1d_transpose.out_channels\n        kernel_size = self.conv1d_transpose.kernel_size[0]\n        stride = self.conv1d_transpose.stride[0]\n        padding = self.conv1d_transpose.padding[0]\n        dilation = self.conv1d_transpose.dilation[0]\n        \n        # Compute output length\n        length_out = (length_in - 1) * stride - 2 * padding + dilation * (kernel_size - 1) + 1\n        output = torch.empty((batch_size, out_channels, length_out), device=x.device, dtype=x.dtype)\n        \n        # Ensure contiguous memory access\n        x_contig = x.contiguous()\n        weight_contig = self.conv1d_transpose.weight.contiguous()\n        bias_contig = self.conv1d_transpose.bias if self.conv1d_transpose.bias is not None else None\n        \n        # Launch kernel configuration\n        numel = batch_size * out_channels * length_out\n        BLOCK_SIZE = 1024\n        BLOCK_C = 16\n        grid = (triton.cdiv(numel, BLOCK_SIZE),)\n        \n        # Launch optimized kernel\n        transposed_conv1d_kernel[grid](\n            x_contig, \n            weight_contig, \n            bias_contig, \n            output,\n            batch_size, \n            in_channels, \n            out_channels, \n            length_in, \n            length_out,\n            kernel_size, \n            stride, \n            padding, \n            dilation,\n            numel,\n            BLOCK_SIZE=BLOCK_SIZE,\n            BLOCK_C=BLOCK_C\n        )\n        \n        return output\n\n# Test code\nbatch_size = 16\nin_channels = 32\nout_channels = 64\nkernel_size = 3\nlength = 128\nstride = 2\npadding = 1\ndilation = 2\n\ndef get_inputs():\n    x = torch.randn(batch_size, in_channels, length)\n    return [x]\n\ndef get_init_inputs():\n    return [in_channels, out_channels, kernel_size, stride, padding, dilation]\n# =================== EVOLVE-BLOCK-END ===================", "language": "python", "parent_id": "b801c5f4-2a3a-4461-a605-d46e3b1adcdd", "generation": 4, "timestamp": 1754995081.5408318, "iteration_found": 25, "metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": true, "score": 30.80000000000001, "speed_up": 1.108, "runtime_ms": 0.0657, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:3", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.0728, "speed_up": 1.108, "custom_timing": 0.0657}}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": false, "score": 20, "speed_up": 0.963, "runtime_ms": 0.0756, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:1", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.0728, "speed_up": 0.963, "custom_timing": 0.0756}}, "island": 1}, "artifacts_json": null, "artifact_dir": null}