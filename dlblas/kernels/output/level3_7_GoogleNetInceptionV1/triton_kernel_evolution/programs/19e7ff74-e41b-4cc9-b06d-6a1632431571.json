{"id": "19e7ff74-e41b-4cc9-b06d-6a1632431571", "code": "# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport triton\nimport triton.language as tl\nimport math\n\n@triton.jit\ndef conv1x1_forward_kernel(\n    x_ptr, weight_ptr, bias_ptr, output_ptr,\n    batch_size, in_channels, height, width, out_channels,\n    stride_xb, stride_xc, stride_xh, stride_xw,\n    stride_wc, stride_wi,\n    stride_ob, stride_oc, stride_oh, stride_ow,\n    BLOCK_C: tl.constexpr,\n    BLOCK_K: tl.constexpr,\n):\n    pid_bhw = tl.program_id(0)\n    pid_oc = tl.program_id(1)\n    \n    num_bhw = batch_size * height * width\n    b_idx = pid_bhw // (height * width)\n    hw_idx = pid_bhw % (height * width)\n    h_idx = hw_idx // width\n    w_idx = hw_idx % width\n    \n    if b_idx >= batch_size or h_idx >= height or w_idx >= width:\n        return\n    \n    oc_block_index = pid_oc * BLOCK_C\n    oc_offsets = oc_block_index + tl.arange(0, BLOCK_C)\n    oc_mask = oc_offsets < out_channels\n    \n    acc = tl.zeros((BLOCK_C,), dtype=tl.float32)\n    \n    for ic_block in range(0, in_channels, BLOCK_K):\n        ic_offsets = ic_block + tl.arange(0, BLOCK_K)\n        ic_mask = ic_offsets < in_channels\n        \n        x_ptrs = x_ptr + b_idx * stride_xb + h_idx * stride_xh + w_idx * stride_xw + ic_offsets * stride_xc\n        x_vals = tl.load(x_ptrs, mask=ic_mask, other=0.0)\n        \n        w_ptrs = weight_ptr + oc_offsets[:, None] * stride_wc + ic_offsets[None, :] * stride_wi\n        w_vals = tl.load(w_ptrs, mask=oc_mask[:, None] & ic_mask[None, :], other=0.0)\n        \n        acc += tl.sum(w_vals * x_vals[None, :], axis=1)\n    \n    bias_ptrs = bias_ptr + oc_offsets\n    bias_vals = tl.load(bias_ptrs, mask=oc_mask, other=0.0)\n    acc += bias_vals\n    \n    output_ptrs = output_ptr + b_idx * stride_ob + h_idx * stride_oh + w_idx * stride_ow + oc_offsets * stride_oc\n    tl.store(output_ptrs, acc, mask=oc_mask)\n\nclass TritonConv1x1(nn.Module):\n    def __init__(self, in_channels, out_channels):\n        super().__init__()\n        self.in_channels = in_channels\n        self.out_channels = out_channels\n        self.weight = nn.Parameter(torch.empty(out_channels, in_channels, 1, 1))\n        self.bias = nn.Parameter(torch.empty(out_channels))\n        self.reset_parameters()\n        \n    def reset_parameters(self):\n        nn.init.kaiming_uniform_(self.weight, a=math.sqrt(5))\n        fan_in, _ = nn.init._calculate_fan_in_and_fan_out(self.weight)\n        bound = 1 / math.sqrt(fan_in) if fan_in > 0 else 0\n        nn.init.uniform_(self.bias, -bound, bound)\n        \n    def forward(self, x):\n        batch, in_channels, height, width = x.shape\n        output = torch.empty(batch, self.out_channels, height, width, \n                            device=x.device, dtype=x.dtype)\n        \n        grid_bhw = batch * height * width\n        grid_oc = triton.cdiv(self.out_channels, 128)\n        \n        weight_2d = self.weight.view(self.out_channels, self.in_channels)\n        \n        conv1x1_forward_kernel[(grid_bhw, grid_oc)](\n            x, weight_2d, self.bias, output,\n            batch, in_channels, height, width, self.out_channels,\n            x.stride(0), x.stride(1), x.stride(2), x.stride(3),\n            weight_2d.stride(0), weight_2d.stride(1),\n            output.stride(0), output.stride(1), output.stride(2), output.stride(3),\n            BLOCK_C=128,\n            BLOCK_K=64,\n            num_stages=4,\n            num_warps=8\n        )\n        return output\n\nclass InceptionModule(nn.Module):\n    def __init__(self, in_channels, out_1x1, reduce_3x3, out_3x3, reduce_5x5, out_5x5, pool_proj):\n        super(InceptionModule, self).__init__()\n        self.branch1x1 = TritonConv1x1(in_channels, out_1x1)\n        self.branch3x3 = nn.Sequential(\n            nn.Conv2d(in_channels, reduce_3x3, kernel_size=1),\n            nn.Conv2d(reduce_3x3, out_3x3, kernel_size=3, padding=1)\n        )\n        self.branch5x5 = nn.Sequential(\n            nn.Conv2d(in_channels, reduce_5x5, kernel_size=1),\n            nn.Conv2d(reduce_5x5, out_5x5, kernel_size=5, padding=2)\n        )\n        self.branch_pool = nn.Sequential(\n            nn.MaxPool2d(kernel_size=3, stride=1, padding=1),\n            nn.Conv2d(in_channels, pool_proj, kernel_size=1)\n        )\n    \n    def forward(self, x):\n        branch1x1 = self.branch1x1(x)\n        branch3x3 = self.branch3x3(x)\n        branch5x5 = self.branch5x5(x)\n        branch_pool = self.branch_pool(x)\n        outputs = [branch1x1, branch3x3, branch5x5, branch_pool]\n        return torch.cat(outputs, 1)\n\nclass ModelNew(nn.Module):\n    def __init__(self, num_classes=1000):\n        super(ModelNew, self).__init__()\n        self.conv1 = nn.Conv2d(3, 64, kernel_size=7, stride=2, padding=3)\n        self.maxpool1 = nn.MaxPool2d(3, stride=2, padding=1)\n        self.conv2 = nn.Conv2d(64, 64, kernel_size=1)\n        self.conv3 = nn.Conv2d(64, 192, kernel_size=3, padding=1)\n        self.maxpool2 = nn.MaxPool2d(3, stride=2, padding=1)\n        self.inception3a = InceptionModule(192, 64, 96, 128, 16, 32, 32)\n        self.inception3b = InceptionModule(256, 128, 128, 192, 32, 96, 64)\n        self.maxpool3 = nn.MaxPool2d(3, stride=2, padding=1)\n        self.inception4a = InceptionModule(480, 192, 96, 208, 16, 48, 64)\n        self.inception4b = InceptionModule(512, 160, 112, 224, 24, 64, 64)\n        self.inception4c = InceptionModule(512, 128, 128, 256, 24, 64, 64)\n        self.inception4d = InceptionModule(512, 112, 144, 288, 32, 64, 64)\n        self.inception4e = InceptionModule(528, 256, 160, 320, 32, 128, 128)\n        self.maxpool4 = nn.MaxPool2d(3, stride=2, padding=1)\n        self.inception5a = InceptionModule(832, 256, 160, 320, 32, 128, 128)\n        self.inception5b = InceptionModule(832, 384, 192, 384, 48, 128, 128)\n        self.avgpool = nn.AdaptiveAvgPool2d((1, 1))\n        self.dropout = nn.Dropout(0.0)\n        self.fc = nn.Linear(1024, num_classes)\n    \n    def forward(self, x):\n        x = self.maxpool1(F.relu(self.conv1(x)))\n        x = F.relu(self.conv2(x))\n        x = self.maxpool2(F.relu(self.conv3(x)))\n        x = self.inception3a(x)\n        x = self.inception3b(x)\n        x = self.maxpool3(x)\n        x = self.inception4a(x)\n        x = self.inception4b(x)\n        x = self.inception4c(x)\n        x = self.inception4d(x)\n        x = self.inception4e(x)\n        x = self.maxpool4(x)\n        x = self.inception5a(x)\n        x = self.inception5b(x)\n        x = self.avgpool(x)\n        x = torch.flatten(x, 1)\n        x = self.dropout(x)\n        x = self.fc(x)\n        return x\n\n# Test code\nbatch_size = 10\ninput_channels = 3\nheight = 224\nwidth = 224\nnum_classes = 1000\n\ndef get_inputs():\n    return [torch.randn(batch_size, input_channels, height, width)]\n\ndef get_init_inputs():\n    return [num_classes]\n# =================== EVOLVE-BLOCK-END ===================", "language": "python", "parent_id": "d2a6afab-c291-41b0-a654-da6def75264f", "generation": 2, "timestamp": 1754597065.597186, "iteration_found": 15, "metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": false, "score": 20, "speed_up": 0.84, "runtime_ms": 2.75, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:1", "correctness_trials": "(5 / 5)", "reference_timing_ms": 2.31, "speed_up": 0.84, "custom_timing": 2.75}}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": false, "score": 20, "speed_up": 0.882, "runtime_ms": 2.62, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:6", "correctness_trials": "(5 / 5)", "reference_timing_ms": 2.31, "speed_up": 0.882, "custom_timing": 2.62}}, "island": 0}, "artifacts_json": null, "artifact_dir": null}