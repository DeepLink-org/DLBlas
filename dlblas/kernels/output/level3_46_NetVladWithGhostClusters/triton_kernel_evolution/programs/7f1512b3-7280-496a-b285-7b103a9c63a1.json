{"id": "7f1512b3-7280-496a-b285-7b103a9c63a1", "code": "# ================== EVOLVE-BLOCK-START ==================\n# Copyright 2018 Antoine Miech All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS-IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"\nCode modified from here\nhttps://github.com/albanie/collaborative-experts/blob/master/model/net_vlad.py\n\"\"\"\n\n\nimport math\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport torch as th\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef batched_matmul_kernel(\n    a_ptr, b_ptr, c_ptr,\n    K, N, D,\n    stride_ab, stride_ak, stride_an,\n    stride_bb, stride_bn, stride_bd,\n    stride_cb, stride_ck, stride_cd,\n    BLOCK_K: tl.constexpr, BLOCK_D: tl.constexpr, BLOCK_N: tl.constexpr,\n):\n    pid_batch = tl.program_id(0)\n    pid_k = tl.program_id(1)\n    pid_d = tl.program_id(2)\n    \n    offs_k = pid_k * BLOCK_K + tl.arange(0, BLOCK_K)\n    offs_d = pid_d * BLOCK_D + tl.arange(0, BLOCK_D)\n    offs_n = tl.arange(0, BLOCK_N)\n    \n    a_ptrs = a_ptr + pid_batch * stride_ab + offs_k[:, None] * stride_ak + offs_n[None, :] * stride_an\n    b_ptrs = b_ptr + pid_batch * stride_bb + offs_n[:, None] * stride_bn + offs_d[None, :] * stride_bd\n    \n    acc = tl.zeros((BLOCK_K, BLOCK_D), dtype=tl.float32)\n    \n    for n in range(0, tl.cdiv(N, BLOCK_N)):\n        n_remaining = N - n * BLOCK_N\n        mask_n = offs_n < n_remaining\n        a = tl.load(a_ptrs, mask=mask_n[None, :], other=0.0)\n        b = tl.load(b_ptrs, mask=mask_n[:, None], other=0.0)\n        acc += tl.dot(a, b, allow_tf32=True)\n        a_ptrs += BLOCK_N * stride_an\n        b_ptrs += BLOCK_N * stride_bn\n    \n    mask_k = offs_k < K\n    mask_d = offs_d < D\n    c_ptrs = c_ptr + pid_batch * stride_cb + offs_k[:, None] * stride_ck + offs_d[None, :] * stride_cd\n    tl.store(c_ptrs, acc, mask=mask_k[:, None] & mask_d[None, :])\n\n\nclass ModelNew(nn.Module):\n    def __init__(self, cluster_size, feature_size, ghost_clusters):\n        super(ModelNew, self).__init__()\n\n        self.feature_size = feature_size\n        self.cluster_size = cluster_size\n        self.ghost_clusters = ghost_clusters\n\n        init_sc = (1 / math.sqrt(feature_size))\n        clusters = cluster_size + ghost_clusters\n\n        # The `clusters` weights are the `(w,b)` in the paper\n        self.clusters = nn.Parameter(init_sc * th.randn(feature_size, clusters))\n        self.batch_norm = nn.BatchNorm1d(clusters)\n        # The `clusters2` weights are the visual words `c_k` in the paper\n        self.clusters2 = nn.Parameter(init_sc * th.randn(1, feature_size, cluster_size))\n        self.out_dim = self.cluster_size * feature_size\n\n    def forward(self, x, mask=None):\n        \"\"\"Aggregates feature maps into a fixed size representation.  In the following\n        notation, B = batch_size, N = num_features, K = num_clusters, D = feature_size.\n\n        Args:\n            x (th.Tensor): B x N x D\n\n        Returns:\n            (th.Tensor): B x DK\n        \"\"\"\n        max_sample = x.size()[1]\n        x = x.view(-1, self.feature_size)  # B x N x D -> BN x D\n\n        if x.device != self.clusters.device:\n            msg = f\"x.device {x.device} != cluster.device {self.clusters.device}\"\n            raise ValueError(msg)\n\n        assignment = th.matmul(x, self.clusters)  # (BN x D) x (D x (K+G)) -> BN x (K+G)\n        assignment = self.batch_norm(assignment)\n\n        assignment = F.softmax(assignment, dim=1)  # BN x (K+G) -> BN x (K+G)\n        # remove ghost assigments\n        assignment = assignment[:, :self.cluster_size]\n        assignment = assignment.view(-1, max_sample, self.cluster_size)  # -> B x N x K\n        a_sum = th.sum(assignment, dim=1, keepdim=True)  # B x N x K -> B x 1 x K\n        a = a_sum * self.clusters2\n\n        assignment = assignment.transpose(1, 2)  # B x N x K -> B x K x N\n\n        x = x.view(-1, max_sample, self.feature_size)  # BN x D -> B x N x D\n        B, N, D = x.shape\n        _, K, _ = assignment.shape\n        \n        # Optimized batched matmul with Triton\n        vlad = torch.empty((B, K, D), device=x.device, dtype=x.dtype)\n        grid = (B, triton.cdiv(K, 32), triton.cdiv(D, 64))\n        batched_matmul_kernel[grid](\n            assignment, x, vlad, K, N, D,\n            assignment.stride(0), assignment.stride(1), assignment.stride(2),\n            x.stride(0), x.stride(1), x.stride(2),\n            vlad.stride(0), vlad.stride(1), vlad.stride(2),\n            BLOCK_K=32, BLOCK_D=64, BLOCK_N=32\n        )\n        vlad = vlad.transpose(1, 2)  # -> B x D x K\n        vlad = vlad - a\n\n        # L2 intra norm\n        vlad = F.normalize(vlad)\n\n        # flattening + L2 norm\n        vlad = vlad.reshape(-1, self.cluster_size * self.feature_size)  # -> B x DK\n        vlad = F.normalize(vlad)\n        return vlad  # B x DK\n\nbatch_size = 32\nnum_features = 100\nnum_clusters = 32\nfeature_size = 512\nghost_clusters = 16\n\ndef get_inputs():\n  return [torch.randn(batch_size, num_features, feature_size)]\n\ndef get_init_inputs():\n  return [num_clusters, feature_size, ghost_clusters]\n\n# =================== EVOLVE-BLOCK-END ===================", "language": "python", "parent_id": "820c6335-456b-4a78-8a3b-8e373302a9e9", "generation": 1, "timestamp": 1754589787.1326532, "iteration_found": 1, "metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": false, "score": 20, "speed_up": 0.796, "runtime_ms": 0.314, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:2", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.25, "speed_up": 0.796, "custom_timing": 0.314}}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": true, "correctness": true, "stage": "reference code", "passed": false, "score": 0.0, "speed_up": 1.0, "runtime_ms": 0.247, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:6", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.25, "speed_up": 1.012, "custom_timing": 0.247}}, "island": 0}, "artifacts_json": null, "artifact_dir": null}