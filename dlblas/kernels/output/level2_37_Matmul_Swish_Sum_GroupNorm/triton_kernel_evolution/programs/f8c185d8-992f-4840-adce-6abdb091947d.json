{"id": "f8c185d8-992f-4840-adce-6abdb091947d", "code": "# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef _linear_swish_bias(\n    x_ptr,\n    weight_ptr,\n    bias_ptr,\n    output_ptr,\n    M, N, K,  # Batch, Out_Features, In_Features\n    stride_xm, stride_xk,  # x strides\n    stride_wn, stride_wk,  # weight strides (transposed)\n    BLOCK_M: tl.constexpr,\n    BLOCK_N: tl.constexpr,\n    BLOCK_K: tl.constexpr,\n):\n    pid_m = tl.program_id(0)\n    pid_n = tl.program_id(1)\n    \n    # Create offsets for the block\n    offs_m = pid_m * BLOCK_M + tl.arange(0, BLOCK_M)\n    offs_n = pid_n * BLOCK_N + tl.arange(0, BLOCK_N)\n    offs_k = tl.arange(0, BLOCK_K)\n    \n    # Initialize accumulator\n    acc = tl.zeros((BLOCK_M, BLOCK_N), dtype=tl.float32)\n    \n    # Loop over K dimension\n    for k in range(0, tl.cdiv(K, BLOCK_K)):\n        k_remaining = K - k * BLOCK_K\n        k_size = tl.minimum(BLOCK_K, k_remaining)\n        \n        # Create masks for boundary conditions\n        mask_x = (offs_m[:, None] < M) & (offs_k[None, :] < k_size)\n        mask_w = (offs_k[:, None] < k_size) & (offs_n[None, :] < N)\n        \n        # Pointers to current block\n        x_ptrs = x_ptr + offs_m[:, None] * stride_xm + (k * BLOCK_K + offs_k[None, :]) * stride_xk\n        w_ptrs = weight_ptr + offs_k[:, None] * stride_wk + offs_n[None, :] * stride_wn\n        \n        # Load blocks with masking\n        x_block = tl.load(x_ptrs, mask=mask_x, other=0.0)\n        w_block = tl.load(w_ptrs, mask=mask_w, other=0.0)\n        \n        # Compute partial matrix multiplication\n        acc += tl.dot(x_block, w_block, allow_tf32=True)\n    \n    # Load bias block\n    bias_ptrs = bias_ptr + offs_n\n    bias_mask = offs_n < N\n    bias_block = tl.load(bias_ptrs, mask=bias_mask, other=0.0)\n    \n    # Add bias and apply Swish activation\n    acc += bias_block[None, :]\n    swish_output = acc * tl.sigmoid(acc)\n    \n    # Store results with boundary masking\n    out_ptrs = output_ptr + offs_m[:, None] * N + offs_n[None, :]\n    out_mask = (offs_m[:, None] < M) & (offs_n[None, :] < N)\n    tl.store(out_ptrs, swish_output, mask=out_mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, num_groups, bias_shape):\n        super(ModelNew, self).__init__()\n        self.matmul = nn.Linear(in_features, out_features)\n        self.bias = nn.Parameter(torch.randn(bias_shape))\n        self.group_norm = nn.GroupNorm(num_groups, out_features)\n\n    def forward(self, x):\n        # Prepare inputs\n        x = x.contiguous()\n        batch_size, in_features = x.shape\n        out_features = self.matmul.out_features\n        \n        # Pre-transpose weight for efficient access\n        weight_t = self.matmul.weight.t().contiguous()\n        \n        # Create output tensor\n        output = torch.empty((batch_size, out_features), device=x.device, dtype=x.dtype)\n        \n        # Configure kernel parameters\n        BLOCK_M, BLOCK_N, BLOCK_K = 64, 128, 32\n        grid = (\n            triton.cdiv(batch_size, BLOCK_M),\n            triton.cdiv(out_features, BLOCK_N)\n        )\n        \n        # Launch optimized kernel\n        _linear_swish_bias[grid](\n            x, weight_t, self.matmul.bias, output,\n            batch_size, out_features, in_features,\n            x.stride(0), x.stride(1),\n            weight_t.stride(0), weight_t.stride(1),\n            BLOCK_M, BLOCK_N, BLOCK_K\n        )\n        \n        # Add extra bias and apply group normalization\n        output = output + self.bias\n        return self.group_norm(output)\n\nbatch_size = 128\nin_features = 512\nout_features = 1024\nnum_groups = 32\nbias_shape = (out_features,)\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, num_groups, bias_shape]\n# =================== EVOLVE-BLOCK-END ===================", "language": "python", "parent_id": "c73caa41-3251-4b90-b3c1-15e62d413e92", "generation": 3, "timestamp": 1754579140.0027077, "iteration_found": 29, "metrics": {"compiled": true, "correctness": false, "score": 10, "stage": "wrong_answer", "verify_payload": {"id": "level2_37_Matmul_Swish_Sum_GroupNorm", "result": {"compiled": true, "correctness": false, "metadata": {"hardware": "NVIDIA L20Y", "device": "cuda:0", "max_difference": ["2.386162", "2.666337", "2.268856", "2.844433", "2.510204"], "avg_difference": ["0.269164", "0.269396", "0.268428", "0.269377", "0.270467"], "correctness_issue": "Output mismatch", "correctness_trials": "(0 / 5)", "reference_timing_ms": 0.0938, "speed_up": -1.0, "custom_timing": -1.0}, "runtime": -1.0, "runtime_stats": {}}}}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": false, "score": 20, "speed_up": 0.96, "runtime_ms": 0.0977, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:7", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.0938, "speed_up": 0.96, "custom_timing": 0.0977}}, "island": 2}, "artifacts_json": null, "artifact_dir": null}