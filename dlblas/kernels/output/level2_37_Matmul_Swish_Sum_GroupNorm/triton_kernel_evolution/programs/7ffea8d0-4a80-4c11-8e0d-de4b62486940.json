{"id": "7ffea8d0-4a80-4c11-8e0d-de4b62486940", "code": "# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef _linear_swish_bias(\n    x_ptr,\n    weight_ptr,\n    bias_ptr,\n    output_ptr,\n    in_features,\n    out_features,\n    stride_x_batch,\n    stride_x_feature,\n    stride_weight_out,\n    stride_weight_feature,\n    BLOCK_K: tl.constexpr,\n    BLOCK_OUT: tl.constexpr,\n    input_dtype: tl.constexpr,\n):\n    # 2D grid: batch index and output feature block index\n    batch_idx = tl.program_id(0)\n    out_feature_block_idx = tl.program_id(1)\n    \n    # Compute output feature block offsets\n    out_feature_offsets = out_feature_block_idx * BLOCK_OUT + tl.arange(0, BLOCK_OUT)\n    mask_out = out_feature_offsets < out_features\n    \n    # Initialize accumulator\n    acc = tl.zeros((BLOCK_OUT,), dtype=tl.float32)\n    \n    # Process input features in blocks\n    for k in range(0, in_features, BLOCK_K):\n        k_offsets = k + tl.arange(0, BLOCK_K)\n        mask_k = k_offsets < in_features\n        \n        # Load input block\n        x_ptr_row = x_ptr + batch_idx * stride_x_batch + k_offsets * stride_x_feature\n        x_val = tl.load(x_ptr_row, mask=mask_k, other=0.0)\n        \n        # Load weight block\n        weight_ptr_block = weight_ptr + out_feature_offsets[:, None] * stride_weight_out + k_offsets[None, :] * stride_weight_feature\n        weight_val = tl.load(weight_ptr_block, mask=mask_out[:, None] & mask_k[None, :], other=0.0)\n        \n        # Compute partial dot product\n        acc += tl.sum(weight_val * x_val[None, :], axis=1)\n    \n    # Load linear bias values only\n    bias_val = tl.load(bias_ptr + out_feature_offsets, mask=mask_out, other=0.0)\n    acc += bias_val\n    \n    # Apply Swish activation\n    swish_val = acc * tl.sigmoid(acc)\n    \n    # Convert to input dtype before storing\n    if input_dtype == tl.float16:\n        swish_val = swish_val.to(tl.float16)\n    \n    # Store results\n    output_ptr_block = output_ptr + batch_idx * out_features + out_feature_offsets\n    tl.store(output_ptr_block, swish_val, mask=mask_out)\n\nclass ModelNew(nn.Module):\n    \"\"\"\n    A model that performs a matrix multiplication, applies Swish activation, sums with a bias term, and normalizes with GroupNorm.\n    \"\"\"\n    def __init__(self, in_features, out_features, num_groups, bias_shape):\n        super(ModelNew, self).__init__()\n        self.matmul = nn.Linear(in_features, out_features)\n        self.bias = nn.Parameter(torch.randn(bias_shape))\n        self.group_norm = nn.GroupNorm(num_groups, out_features)\n\n    def forward(self, x):\n        \"\"\"\n        Args:\n            x (torch.Tensor): Input tensor of shape (batch_size, in_features).\n        Returns:\n            torch.Tensor: Output tensor of shape (batch_size, out_features).\n        \"\"\"\n        # Prepare inputs and outputs\n        x = x.contiguous()\n        batch_size, _ = x.shape\n        out_features = self.matmul.out_features\n        output = torch.empty((batch_size, out_features), device=x.device, dtype=x.dtype)\n        \n        # Configure kernel launch parameters\n        BLOCK_OUT = 128\n        BLOCK_K = 64\n        num_blocks_out = (out_features + BLOCK_OUT - 1) // BLOCK_OUT\n        grid = (batch_size, num_blocks_out)\n        \n        # Get tensor strides and ensure weight is contiguous\n        stride_x_batch = x.stride(0)\n        stride_x_feature = x.stride(1)\n        weight = self.matmul.weight.contiguous()\n        stride_weight_out = weight.stride(0)\n        stride_weight_feature = weight.stride(1)\n        \n        # Determine input dtype for kernel\n        input_dtype = triton.language.float16 if x.dtype == torch.float16 else triton.language.float32\n        \n        # Launch kernel with only linear bias\n        _linear_swish_bias[grid](\n            x, weight, self.matmul.bias, output, \n            in_features, out_features,\n            stride_x_batch, stride_x_feature,\n            stride_weight_out, stride_weight_feature,\n            BLOCK_K, BLOCK_OUT,\n            input_dtype\n        )\n        \n        # Add extra bias after Swish activation\n        output = output + self.bias\n        \n        # Apply group normalization\n        output = self.group_norm(output)\n        return output\n\nbatch_size = 128\nin_features = 512\nout_features = 1024\nnum_groups = 32\nbias_shape = (out_features,)\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, num_groups, bias_shape]\n# =================== EVOLVE-BLOCK-END ===================", "language": "python", "parent_id": "c1e5dc0b-10cb-4893-a78c-65c83dbcaa59", "generation": 3, "timestamp": 1754576915.8588316, "iteration_found": 18, "metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": false, "score": 20, "speed_up": 0.929, "runtime_ms": 0.101, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:1", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.0938, "speed_up": 0.929, "custom_timing": 0.101}}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": true, "correctness": false, "score": 10, "stage": "wrong_answer", "verify_payload": {"id": "level2_37_Matmul_Swish_Sum_GroupNorm", "result": {"compiled": true, "correctness": false, "metadata": {"hardware": "NVIDIA L20Y", "device": "cuda:3", "max_difference": ["2.996043", "3.023194", "3.023102", "2.981737", "2.958071"], "avg_difference": ["0.405675", "0.404696", "0.405433", "0.405280", "0.405121"], "correctness_issue": "Output mismatch", "correctness_trials": "(0 / 5)", "reference_timing_ms": 0.0938, "speed_up": -1.0, "custom_timing": -1.0}, "runtime": -1.0, "runtime_stats": {}}}}, "island": 1}, "artifacts_json": null, "artifact_dir": null}