{"id": "495a1f21-3fdf-4034-add2-997a38b342da", "code": "# ================== EVOLVE-BLOCK-START ==================\n# Copyright 2018 Antoine Miech All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS-IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"\nCode modified from here\nhttps://github.com/albanie/collaborative-experts/blob/master/model/net_vlad.py\n\"\"\"\n\n\nimport math\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport torch as th\nimport triton\nimport triton.language as tl\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 64}, num_warps=8, num_stages=4),\n        triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 128}, num_warps=4, num_stages=3),\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 128}, num_warps=8, num_stages=3),\n        triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 32, 'BLOCK_SIZE_K': 64}, num_warps=4, num_stages=4),\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 64}, num_warps=4, num_stages=4),\n    ],\n    key=['M', 'K', 'N'],\n)\n@triton.jit\ndef _vlad_matmul_kernel(\n    x_ptr, clusters_ptr, out_ptr,\n    stride_xm, stride_xk,\n    stride_ck, stride_cn,\n    stride_om, stride_on,\n    M, K, N,\n    BLOCK_SIZE_M: tl.constexpr, BLOCK_SIZE_N: tl.constexpr, BLOCK_SIZE_K: tl.constexpr,\n):\n    pid = tl.program_id(0)\n    num_pid_n = tl.cdiv(N, BLOCK_SIZE_N)\n    pid_m = pid // num_pid_n\n    pid_n = pid % num_pid_n\n\n    # Create block pointers for efficient memory access\n    a_block_ptr = tl.make_block_ptr(\n        base=x_ptr,\n        shape=(M, K),\n        strides=(stride_xm, stride_xk),\n        offsets=(pid_m * BLOCK_SIZE_M, 0),\n        block_shape=(BLOCK_SIZE_M, BLOCK_SIZE_K),\n        order=(0,1)\n    )\n    b_block_ptr = tl.make_block_ptr(\n        base=clusters_ptr,\n        shape=(K, N),\n        strides=(stride_ck, stride_cn),\n        offsets=(0, pid_n * BLOCK_SIZE_N),\n        block_shape=(BLOCK_SIZE_K, BLOCK_SIZE_N),\n        order=(0,1)\n    )\n\n    accumulator = tl.zeros((BLOCK_SIZE_M, BLOCK_SIZE_N), dtype=tl.float32)\n    for k in range(0, K, BLOCK_SIZE_K):\n        # Load blocks with boundary checks\n        a = tl.load(a_block_ptr, boundary_check=(0,1))\n        b = tl.load(b_block_ptr, boundary_check=(0,1))\n        \n        # Convert to FP16 for Tensor Core acceleration\n        a = a.to(tl.float16)\n        b = b.to(tl.float16)\n        \n        # Compute matrix product with Tensor Cores\n        accumulator += tl.dot(a, b, allow_tf32=True).to(tl.float32)\n        \n        # Advance pointers to next blocks\n        a_block_ptr = tl.advance(a_block_ptr, (0, BLOCK_SIZE_K))\n        b_block_ptr = tl.advance(b_block_ptr, (BLOCK_SIZE_K, 0))\n\n    # Compute output indices with proper masking\n    offs_m = pid_m * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)\n    offs_n = pid_n * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n    out_ptrs = out_ptr + offs_m[:, None] * stride_om + offs_n[None, :] * stride_on\n    out_mask = (offs_m[:, None] < M) & (offs_n[None, :] < N)\n    tl.store(out_ptrs, accumulator, mask=out_mask)\n\n\nclass ModelNew(nn.Module):\n    def __init__(self, cluster_size, feature_size, ghost_clusters):\n        super(ModelNew, self).__init__()\n\n        self.feature_size = feature_size\n        self.cluster_size = cluster_size\n        self.ghost_clusters = ghost_clusters\n\n        init_sc = (1 / math.sqrt(feature_size))\n        clusters = cluster_size + ghost_clusters\n\n        self.clusters = nn.Parameter(init_sc * th.randn(feature_size, clusters))\n        self.batch_norm = nn.BatchNorm1d(clusters)\n        self.clusters2 = nn.Parameter(init_sc * th.randn(1, feature_size, cluster_size))\n        self.out_dim = self.cluster_size * feature_size\n\n    def forward(self, x, mask=None):\n        max_sample = x.size()[1]\n        x = x.view(-1, self.feature_size)\n\n        if x.device != self.clusters.device:\n            msg = f\"x.device {x.device} != cluster.device {self.clusters.device}\"\n            raise ValueError(msg)\n\n        M, K = x.shape\n        N = self.clusters.shape[1]\n        assignment = torch.empty((M, N), device=x.device, dtype=x.dtype)\n        \n        grid = lambda meta: (triton.cdiv(M, meta['BLOCK_SIZE_M']) * triton.cdiv(N, meta['BLOCK_SIZE_N']),)\n        _vlad_matmul_kernel[grid](\n            x, self.clusters, assignment,\n            x.stride(0), x.stride(1),\n            self.clusters.stride(0), self.clusters.stride(1),\n            assignment.stride(0), assignment.stride(1),\n            M, K, N\n        )\n\n        assignment = self.batch_norm(assignment)\n        assignment = F.softmax(assignment, dim=1)\n        assignment = assignment[:, :self.cluster_size]\n        assignment = assignment.view(-1, max_sample, self.cluster_size)\n        a_sum = th.sum(assignment, dim=1, keepdim=True)\n        a = a_sum * self.clusters2\n\n        assignment = assignment.transpose(1, 2)\n        x = x.view(-1, max_sample, self.feature_size)\n        vlad = th.matmul(assignment, x)\n        vlad = vlad.transpose(1, 2)\n        vlad = vlad - a\n\n        vlad = F.normalize(vlad)\n        vlad = vlad.reshape(-1, self.cluster_size * self.feature_size)\n        vlad = F.normalize(vlad)\n        return vlad\n\nbatch_size = 32\nnum_features = 100\nnum_clusters = 32\nfeature_size = 512\nghost_clusters = 0\n\ndef get_inputs():\n  return [torch.randn(batch_size, num_features, feature_size)]\n\ndef get_init_inputs():\n  return [num_clusters, feature_size, ghost_clusters]\n\n# =================== EVOLVE-BLOCK-END ===================", "language": "python", "parent_id": "9a5f3ba5-8b81-4a22-a4dc-cb6405ae7fc1", "generation": 2, "timestamp": 1754598196.2464654, "iteration_found": 23, "metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": false, "score": 20, "speed_up": 0.755, "runtime_ms": 0.351, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:1", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.265, "speed_up": 0.755, "custom_timing": 0.351}}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": false, "score": 20, "speed_up": 0.791, "runtime_ms": 0.335, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:0", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.265, "speed_up": 0.791, "custom_timing": 0.335}}, "island": 1}, "artifacts_json": null, "artifact_dir": null}