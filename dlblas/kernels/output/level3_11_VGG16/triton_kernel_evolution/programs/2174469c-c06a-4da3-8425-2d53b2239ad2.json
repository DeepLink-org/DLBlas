{"id": "2174469c-c06a-4da3-8425-2d53b2239ad2", "code": "# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef linear_kernel(\n    input_ptr, weight_ptr, bias_ptr, output_ptr,\n    in_features, out_features, batch_size,\n    stride_x, stride_out,\n    BLOCK_SIZE: tl.constexpr,\n):\n    pid = tl.program_id(0)\n    pid_batch = pid // out_features\n    pid_feature = pid % out_features\n\n    if pid_batch >= batch_size or pid_feature >= out_features:\n        return\n\n    output_offset = pid_batch * stride_out + pid_feature\n    bias_val = tl.load(bias_ptr + pid_feature)\n    acc = bias_val\n\n    for block in range(0, in_features, BLOCK_SIZE):\n        offsets = block + tl.arange(0, BLOCK_SIZE)\n        mask = offsets < in_features\n        \n        input_offset = pid_batch * stride_x + offsets\n        weight_offset = pid_feature * in_features + offsets\n        \n        x = tl.load(input_ptr + input_offset, mask=mask, other=0.0)\n        w = tl.load(weight_ptr + weight_offset, mask=mask, other=0.0)\n        \n        acc += tl.sum(x * w)\n\n    tl.store(output_ptr + output_offset, acc)\n\nclass TritonLinear(nn.Module):\n    def __init__(self, in_features, out_features):\n        super().__init__()\n        self.weight = nn.Parameter(torch.empty(out_features, in_features))\n        self.bias = nn.Parameter(torch.empty(out_features))\n        self.in_features = in_features\n        self.out_features = out_features\n        self.reset_parameters()\n\n    def reset_parameters(self):\n        nn.init.kaiming_uniform_(self.weight, a=math.sqrt(5))\n        if self.bias is not None:\n            fan_in, _ = nn.init._calculate_fan_in_and_fan_out(self.weight)\n            bound = 1 / math.sqrt(fan_in) if fan_in > 0 else 0\n            nn.init.uniform_(self.bias, -bound, bound)\n\n    def forward(self, x):\n        output = torch.empty(x.size(0), self.out_features, device=x.device, dtype=x.dtype)\n        flat_x = x.view(-1, x.size(-1))\n        batch_size, in_features = flat_x.shape\n\n        grid = (batch_size * self.out_features,)\n        BLOCK_SIZE = 128\n        \n        linear_kernel[grid](\n            flat_x, self.weight, self.bias, output,\n            in_features, self.out_features, batch_size,\n            flat_x.stride(0), output.stride(0),\n            BLOCK_SIZE=BLOCK_SIZE\n        )\n        return output\n\nclass ModelNew(nn.Module):\n    def __init__(self, num_classes=1000):\n        super(ModelNew, self).__init__()\n        self.features = nn.Sequential(\n            nn.Conv2d(3, 64, kernel_size=3, padding=1),\n            nn.ReLU(inplace=True),\n            nn.Conv2d(64, 64, kernel_size=3, padding=1),\n            nn.ReLU(inplace=True),\n            nn.MaxPool2d(kernel_size=2, stride=2),\n            \n            nn.Conv2d(64, 128, kernel_size=3, padding=1),\n            nn.ReLU(inplace=True),\n            nn.Conv2d(128, 128, kernel_size=3, padding=1),\n            nn.ReLU(inplace=True),\n            nn.MaxPool2d(kernel_size=2, stride=2),\n            \n            nn.Conv2d(128, 256, kernel_size=3, padding=1),\n            nn.ReLU(inplace=True),\n            nn.Conv2d(256, 256, kernel_size=3, padding=1),\n            nn.ReLU(inplace=True),\n            nn.Conv2d(256, 256, kernel_size=3, padding=1),\n            nn.ReLU(inplace=True),\n            nn.MaxPool2d(kernel_size=2, stride=2),\n            \n            nn.Conv2d(256, 512, kernel_size=3, padding=1),\n            nn.ReLU(inplace=True),\n            nn.Conv2d(512, 512, kernel_size=3, padding=1),\n            nn.ReLU(inplace=True),\n            nn.Conv2d(512, 512, kernel_size=3, padding=1),\n            nn.ReLU(inplace=True),\n            nn.MaxPool2d(kernel_size=2, stride=2),\n            \n            nn.Conv2d(512, 512, kernel_size=3, padding=1),\n            nn.ReLU(inplace=True),\n            nn.Conv2d(512, 512, kernel_size=3, padding=1),\n            nn.ReLU(inplace=True),\n            nn.Conv2d(512, 512, kernel_size=3, padding=1),\n            nn.ReLU(inplace=True),\n            nn.MaxPool2d(kernel_size=2, stride=2)\n        )\n        \n        self.classifier = nn.Sequential(\n            TritonLinear(512 * 7 * 7, 4096),\n            nn.ReLU(inplace=True),\n            nn.Dropout(p=0.0),\n            nn.Linear(4096, 4096),\n            nn.ReLU(inplace=True),\n            nn.Dropout(p=0.0),\n            nn.Linear(4096, num_classes)\n        )\n    \n    def forward(self, x):\n        x = self.features(x)\n        x = torch.flatten(x, 1)\n        x = self.classifier(x)\n        return x\n\n# Test code\nimport math\nbatch_size = 10\nnum_classes = 1000\n\ndef get_inputs():\n    return [torch.randn(batch_size, 3, 224, 224)]\n\ndef get_init_inputs():\n    return [num_classes]\n# =================== EVOLVE-BLOCK-END ===================", "language": "python", "parent_id": "2a70b433-9542-4b52-aaa6-b1354a9c2330", "generation": 1, "timestamp": 1754584798.221227, "iteration_found": 0, "metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": false, "score": 20, "speed_up": 0.146, "runtime_ms": 5.64, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:6", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.824, "speed_up": 0.146, "custom_timing": 5.64}}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": true, "correctness": true, "stage": "reference code", "passed": false, "score": 0.0, "speed_up": 1.0, "runtime_ms": 3.42, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:2", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.824, "speed_up": 0.241, "custom_timing": 3.42}}, "island": 0}, "artifacts_json": null, "artifact_dir": null}