{"id": "80e07506-7aeb-4bcc-b47b-554c30e84cdd", "code": "# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef transition_kernel(\n    input_ptr,\n    output_ptr,\n    bn_scale_ptr,\n    bn_bias_ptr,\n    conv_weight_ptr,\n    num_input_features,\n    num_output_features,\n    height,\n    width,\n    stride_b,\n    stride_c,\n    stride_h,\n    stride_w,\n):\n    pid = tl.program_id(0)\n    total_output = tl.num_programs(0)\n    \n    # Calculate output dimensions\n    out_h = height // 2\n    out_w = width // 2\n    elements_per_batch = num_output_features * out_h * out_w\n    \n    # Decompose PID into batch, channel, and spatial components\n    batch_idx = pid // elements_per_batch\n    remainder = pid % elements_per_batch\n    channel_idx = remainder // (out_h * out_w)\n    spatial_idx = remainder % (out_h * out_w)\n    h_idx = spatial_idx // out_w\n    w_idx = spatial_idx % out_w\n    \n    # Calculate input window start position\n    in_h_start = h_idx * 2\n    in_w_start = w_idx * 2\n    \n    # Initialize accumulator\n    acc = 0.0\n    \n    # Loop over input channels\n    for c_in in range(num_input_features):\n        # Load batch normalization parameters\n        bn_scale = tl.load(bn_scale_ptr + c_in)\n        bn_bias = tl.load(bn_bias_ptr + c_in)\n        \n        # Process each pixel in 2x2 window\n        for di in range(2):\n            for dj in range(2):\n                # Calculate input offsets\n                offset = (batch_idx * stride_b + \n                         c_in * stride_c + \n                         (in_h_start + di) * stride_h + \n                         (in_w_start + dj) * stride_w)\n                # Load input value\n                val = tl.load(input_ptr + offset)\n                # Apply batch normalization\n                norm_val = val * bn_scale + bn_bias\n                # Apply ReLU\n                activated = tl.maximum(norm_val, 0.0)\n                # Load convolution weight\n                w_offset = channel_idx * num_input_features + c_in\n                weight_val = tl.load(conv_weight_ptr + w_offset)\n                # Accumulate convolution result\n                acc += activated * weight_val\n    \n    # Apply average pooling (divide by 4)\n    acc = acc * 0.25\n    # Store final result\n    tl.store(output_ptr + pid, acc)\n\nclass ModelNew(nn.Module):\n    def __init__(self, num_input_features: int, num_output_features: int):\n        super(ModelNew, self).__init__()\n        self.bn = nn.BatchNorm2d(num_input_features)\n        self.conv = nn.Conv2d(num_input_features, num_output_features, kernel_size=1, bias=False)\n        self.eps = self.bn.eps\n        \n    def forward(self, x):\n        # Precompute BN parameters\n        with torch.no_grad():\n            bn_scale = self.bn.weight / torch.sqrt(self.bn.running_var + self.bn.eps)\n            bn_bias = self.bn.bias - self.bn.running_mean * bn_scale\n        \n        # Prepare output tensor\n        batch_size, _, height, width = x.shape\n        output = torch.empty(\n            batch_size, \n            self.conv.out_channels, \n            height // 2, \n            width // 2, \n            device=x.device, \n            dtype=x.dtype\n        )\n        \n        # Reshape convolution weights to 2D\n        conv_weight_2d = self.conv.weight.view(self.conv.out_channels, -1)\n        \n        # Launch kernel\n        grid = (batch_size * self.conv.out_channels * (height//2) * (width//2),)\n        transition_kernel[grid](\n            x,\n            output.view(-1),\n            bn_scale,\n            bn_bias,\n            conv_weight_2d,\n            self.conv.in_channels,\n            self.conv.out_channels,\n            height,\n            width,\n            x.stride(0),\n            x.stride(1),\n            x.stride(2),\n            x.stride(3),\n        )\n        return output.view(batch_size, self.conv.out_channels, height//2, width//2)\n\nbatch_size = 10\nnum_input_features = 32\nnum_output_features = 64\nheight, width = 224, 224\n\ndef get_inputs():\n    return [torch.randn(batch_size, num_input_features, height, width)]\n\ndef get_init_inputs():\n    return [num_input_features, num_output_features]\n# =================== EVOLVE-BLOCK-END ===================", "language": "python", "parent_id": "17f5928e-2d2d-464c-a20f-a0d662fbc6c6", "generation": 2, "timestamp": 1754590940.6354043, "iteration_found": 22, "metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": false, "score": 20, "speed_up": 0.006, "runtime_ms": 53.7, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:0", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.301, "speed_up": 0.006, "custom_timing": 53.7}}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": true, "correctness": false, "score": 10, "stage": "wrong_answer", "verify_payload": {"id": "level3_13_DenseNet121TransitionLayer", "result": {"compiled": true, "correctness": false, "metadata": {"hardware": "NVIDIA L20Y", "device": "cuda:2", "correctness_issue": "Output shape mismatch: Expected torch.Size([10, 64, 112, 112]), got torch.Size([10, 32, 112, 112])", "correctness_issue_name": "correctness_issue", "reference_timing_ms": 0.301, "speed_up": -1.0, "custom_timing": -1.0}, "runtime": -1.0, "runtime_stats": {}}}}, "island": 0}, "artifacts_json": null, "artifact_dir": null}