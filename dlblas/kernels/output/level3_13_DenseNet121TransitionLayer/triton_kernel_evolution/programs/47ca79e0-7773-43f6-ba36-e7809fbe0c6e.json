{"id": "47ca79e0-7773-43f6-ba36-e7809fbe0c6e", "code": "# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef _forward_kernel(\n    x_ptr,\n    output_ptr,\n    weight_ptr,\n    bias_ptr,\n    num_input_features,\n    H, W,\n    stride_xb, stride_xc, stride_xh, stride_xw,\n    stride_output_b, stride_output_k, stride_output_h, stride_output_w,\n    BLOCK_SIZE_C: tl.constexpr,\n):\n    pid = tl.program_id(0)\n    num_output_features = bias_ptr.shape[0]\n    H_out = H // 2\n    W_out = W // 2\n    total_output_pixels = num_output_features * H_out * W_out\n    \n    b = pid // total_output_pixels\n    pid_in_batch = pid % total_output_pixels\n    k = pid_in_batch // (H_out * W_out)\n    pid_in_channel = pid_in_batch % (H_out * W_out)\n    i = pid_in_channel // W_out\n    j = pid_in_channel % W_out\n\n    bias = tl.load(bias_ptr + k)\n    h0 = 2 * i\n    h1 = 2 * i + 1\n    w0 = 2 * j\n    w1 = 2 * j + 1\n\n    acc = 0.0\n    for c_start in range(0, num_input_features, BLOCK_SIZE_C):\n        c_offsets = c_start + tl.arange(0, BLOCK_SIZE_C)\n        mask = c_offsets < num_input_features\n        \n        w = tl.load(weight_ptr + k * num_input_features + c_offsets, mask=mask, other=0.0)\n        base_ptr = x_ptr + b * stride_xb + c_offsets * stride_xc\n        \n        ptr00 = base_ptr + h0 * stride_xh + w0 * stride_xw\n        v00 = tl.load(ptr00, mask=mask, other=0.0)\n        v00 = tl.maximum(v00, 0.0)\n        \n        ptr01 = base_ptr + h0 * stride_xh + w1 * stride_xw\n        v01 = tl.load(ptr01, mask=mask, other=0.0)\n        v01 = tl.maximum(v01, 0.0)\n        \n        ptr10 = base_ptr + h1 * stride_xh + w0 * stride_xw\n        v10 = tl.load(ptr10, mask=mask, other=0.0)\n        v10 = tl.maximum(v10, 0.0)\n        \n        ptr11 = base_ptr + h1 * stride_xh + w1 * stride_xw\n        v11 = tl.load(ptr11, mask=mask, other=0.0)\n        v11 = tl.maximum(v11, 0.0)\n        \n        v_sum = v00 + v01 + v10 + v11\n        block_acc = tl.sum(w * v_sum, axis=0)\n        acc += block_acc\n\n    acc = acc / 4.0 + bias\n    output_index = b * stride_output_b + k * stride_output_k + i * stride_output_h + j * stride_output_w\n    tl.store(output_ptr + output_index, acc)\n\nclass ModelNew(nn.Module):\n    def __init__(self, num_input_features: int, num_output_features: int):\n        super(ModelNew, self).__init__()\n        self.bn = nn.BatchNorm2d(num_input_features)\n        self.conv = nn.Conv2d(num_input_features, num_output_features, kernel_size=1, bias=False)\n        self.bn_weight = self.bn.weight\n        self.bn_bias = self.bn.bias\n        self.bn_mean = self.bn.running_mean\n        self.bn_var = self.bn.running_var\n        self.bn_eps = self.bn.eps\n        self.conv_weight = self.conv.weight\n\n    def forward(self, x):\n        x = x.contiguous()\n        bn_scale = self.bn_weight / torch.sqrt(self.bn_var + self.bn_eps)\n        folded_weight = self.conv_weight * bn_scale[None, :, None, None]\n        folded_bias = self.bn_bias - self.bn_mean * bn_scale\n        \n        batch_size, C, H, W = x.shape\n        H_out = H // 2\n        W_out = W // 2\n        output = torch.empty(batch_size, folded_weight.shape[0], H_out, W_out, device=x.device, dtype=x.dtype)\n        total_output_elements = batch_size * folded_weight.shape[0] * H_out * W_out\n        grid = (total_output_elements,)\n        \n        _forward_kernel[grid](\n            x, output, \n            folded_weight.view(folded_weight.shape[0], folded_weight.shape[1]).contiguous(),\n            folded_bias.contiguous(),\n            C, H, W,\n            x.stride(0), x.stride(1), x.stride(2), x.stride(3),\n            output.stride(0), output.stride(1), output.stride(2), output.stride(3),\n            BLOCK_SIZE_C=16\n        )\n        return output\n\nbatch_size = 10\nnum_input_features = 32\nnum_output_features = 64\nheight, width = 224, 224\n\ndef get_inputs():\n    return [torch.randn(batch_size, num_input_features, height, width)]\n\ndef get_init_inputs():\n    return [num_input_features, num_output_features]\n\n# =================== EVOLVE-BLOCK-END ===================", "language": "python", "parent_id": "a93f6ff3-fa4b-41d4-8bf4-c87470b430f7", "generation": 1, "timestamp": 1754586649.224326, "iteration_found": 3, "metrics": {"compiled": true, "correctness": false, "score": 10, "stage": "wrong_answer", "verify_payload": {"id": "level3_13_DenseNet121TransitionLayer", "result": {"compiled": true, "correctness": false, "metadata": {"hardware": "NVIDIA L20Y", "device": "cuda:1", "runtime_error": "Traceback (most recent call last):\n  File \"/cpfs01/shared/llm_kernel/hujiakai/KernelLLM/validation_api_server/helpers/evaluations.py\", line 720, in run_and_check_correctness\n    output_new = model_new(*inputs)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1773, in _wrapped_call_impl\n    return self._call_impl(*args, **kwargs)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1784, in _call_impl\n    return forward_call(*args, **kwargs)\n  File \"/tmp/tmpwzx5xc1c.py\", line 84, in forward\n    bn_scale = self.bn_weight / torch.sqrt(self.bn_var + self.bn_eps)\nRuntimeError: Expected all tensors to be on the same device, but found at least two devices, cuda:1 and cpu!\n", "runtime_error_name": "builtins.RuntimeError", "reference_timing_ms": 0.301, "speed_up": -1.0, "custom_timing": -1.0}, "runtime": -1.0, "runtime_stats": {}}}}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": true, "correctness": true, "stage": "reference code", "passed": false, "score": 0.0, "speed_up": 1.0, "runtime_ms": 0.505, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:7", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.301, "speed_up": 0.596, "custom_timing": 0.505}}, "island": 2}, "artifacts_json": null, "artifact_dir": null}