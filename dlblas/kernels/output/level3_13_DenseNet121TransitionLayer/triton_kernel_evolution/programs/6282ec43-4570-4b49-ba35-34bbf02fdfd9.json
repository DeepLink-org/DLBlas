{"id": "6282ec43-4570-4b49-ba35-34bbf02fdfd9", "code": "# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef transition_kernel(\n    input_ptr,\n    output_ptr,\n    folded_scale_ptr,\n    folded_bias_ptr,\n    folded_weight_ptr,\n    num_input_features,\n    num_output_features,\n    H, W,\n    stride_b, stride_c, stride_h, stride_w,\n    BLOCK_C: tl.constexpr\n):\n    pid = tl.program_id(0)\n    H_out = H // 2\n    W_out = W // 2\n    elements_per_batch = num_output_features * H_out * W_out\n    total_elements = tl.num_programs(0)\n    \n    # Decompose PID into components\n    batch_idx = pid // elements_per_batch\n    pid_in_batch = pid % elements_per_batch\n    k = pid_in_batch // (H_out * W_out)\n    spatial_idx = pid_in_batch % (H_out * W_out)\n    i = spatial_idx // W_out\n    j = spatial_idx % W_out\n\n    # Initialize accumulator\n    acc = 0.0\n    \n    # Loop over input channels in blocks\n    for c_start in range(0, num_input_features, BLOCK_C):\n        c_offsets = c_start + tl.arange(0, BLOCK_C)\n        mask = c_offsets < num_input_features\n        \n        # Load parameters\n        scale_block = tl.load(folded_scale_ptr + c_offsets, mask=mask)\n        bias_block = tl.load(folded_bias_ptr + c_offsets, mask=mask)\n        weight_block = tl.load(folded_weight_ptr + k * num_input_features + c_offsets, mask=mask)\n        \n        # Process 2x2 window\n        for di in range(2):\n            for dj in range(2):\n                h = 2*i + di\n                w = 2*j + dj\n                if h < H and w < W:\n                    # Compute input offset\n                    offset = (batch_idx * stride_b + \n                             c_offsets * stride_c + \n                             h * stride_h + \n                             w * stride_w)\n                    # Load input\n                    x_val = tl.load(input_ptr + offset, mask=mask, other=0.0)\n                    # BN + ReLU\n                    norm_val = x_val * scale_block + bias_block\n                    activated = tl.where(norm_val > 0, norm_val, 0.0)\n                    # Weighted sum\n                    acc += tl.sum(activated * weight_block)\n    \n    # Average pooling\n    acc = acc / 4.0\n    # Store result\n    tl.store(output_ptr + pid, acc)\n\nclass ModelNew(nn.Module):\n    def __init__(self, num_input_features: int, num_output_features: int):\n        super(ModelNew, self).__init__()\n        self.bn = nn.BatchNorm2d(num_input_features)\n        self.conv = nn.Conv2d(num_input_features, num_output_features, kernel_size=1, bias=False)\n        self.eps = self.bn.eps\n        \n    def forward(self, x):\n        # Precompute folded BN parameters\n        with torch.no_grad():\n            bn_scale = self.bn.weight / torch.sqrt(self.bn.running_var + self.bn.eps)\n            bn_bias = self.bn.bias - self.bn.running_mean * bn_scale\n        \n        # Prepare output tensor\n        batch_size, _, H, W = x.shape\n        H_out = H // 2\n        W_out = W // 2\n        output = torch.empty(\n            batch_size, \n            self.conv.out_channels, \n            H_out, \n            W_out, \n            device=x.device, \n            dtype=x.dtype\n        )\n        \n        # Reshape convolution weights to 2D\n        conv_weight_2d = self.conv.weight.view(self.conv.out_channels, -1)\n        \n        # Launch kernel\n        total_elements = batch_size * self.conv.out_channels * H_out * W_out\n        grid = (total_elements,)\n        transition_kernel[grid](\n            x.contiguous(),\n            output.view(-1),\n            bn_scale,\n            bn_bias,\n            conv_weight_2d,\n            self.conv.in_channels,\n            self.conv.out_channels,\n            H, W,\n            x.stride(0),\n            x.stride(1),\n            x.stride(2),\n            x.stride(3),\n            BLOCK_C=32\n        )\n        return output\n\nbatch_size = 10\nnum_input_features = 32\nnum_output_features = 64\nheight, width = 224, 224\n\ndef get_inputs():\n    return [torch.randn(batch_size, num_input_features, height, width)]\n\ndef get_init_inputs():\n    return [num_input_features, num_output_features]\n# =================== EVOLVE-BLOCK-END ===================", "language": "python", "parent_id": "558f6302-aa9a-4b94-adc8-63ca17aa6222", "generation": 2, "timestamp": 1754589731.4889672, "iteration_found": 16, "metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": false, "score": 20, "speed_up": 0.016, "runtime_ms": 19.1, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:5", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.301, "speed_up": 0.016, "custom_timing": 19.1}}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": false, "correctness": false, "score": -100.0, "stage": "no_valid_triton_code", "feedback": "You need to generate real and valid triton code for the core function. The key word 'import triton.language as tl' is not found."}, "island": 0}, "artifacts_json": null, "artifact_dir": null}