{"id": "9d62806e-f987-4cdd-bb68-72796318f5ac", "code": "# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport triton\nimport triton.language as tl\nimport math\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_SIZE_OC': 64, 'BLOCK_SIZE_IC': 64}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_OC': 128, 'BLOCK_SIZE_IC': 64}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_OC': 64, 'BLOCK_SIZE_IC': 128}, num_warps=8),\n        triton.Config({'BLOCK_SIZE_OC': 128, 'BLOCK_SIZE_IC': 128}, num_warps=8),\n        triton.Config({'BLOCK_SIZE_OC': 256, 'BLOCK_SIZE_IC': 64}, num_warps=8),\n    ],\n    key=['num_input_features', 'num_output_features', 'height', 'width']\n)\n@triton.jit\ndef transition_kernel(\n    input_ptr,\n    output_ptr,\n    conv_weight_ptr,\n    batch_size,\n    num_input_features,\n    num_output_features,\n    height,\n    width,\n    stride_b,\n    stride_c,\n    stride_h,\n    stride_w,\n    BLOCK_SIZE_OC: tl.constexpr,\n    BLOCK_SIZE_IC: tl.constexpr,\n):\n    # 2D grid: pid0 = output pixel, pid1 = output channel block\n    pid0 = tl.program_id(0)\n    pid1 = tl.program_id(1)\n    \n    # Calculate output pixel coordinates\n    num_output_pixels = (height // 2) * (width // 2)\n    pixel_id = pid0 % num_output_pixels\n    batch_id = pid0 // num_output_pixels\n    i = pixel_id // (width // 2)\n    j = pixel_id % (width // 2)\n    \n    # Input window starting positions\n    h0 = 2 * i\n    w0 = 2 * j\n    \n    # Channel block indices\n    oc_block_start = pid1 * BLOCK_SIZE_OC\n    oc_offsets = oc_block_start + tl.arange(0, BLOCK_SIZE_OC)\n    oc_mask = oc_offsets < num_output_features\n    \n    # Initialize accumulator\n    accumulator = tl.zeros((BLOCK_SIZE_OC,), dtype=tl.float32)\n    \n    # Precompute input pointers for the 2x2 window\n    ptrs = tl.zeros((4,), dtype=tl.pointer_type)\n    masks = tl.zeros((4,), dtype=tl.int1)\n    count = 0\n    for di in range(2):\n        for dj in range(2):\n            h = h0 + di\n            w = w0 + dj\n            valid = (h < height) & (w < width)\n            ptrs = tl.where(tl.arange(0, 4) == count, \n                            input_ptr + batch_id * stride_b + h * stride_h + w * stride_w,\n                            ptrs)\n            masks = tl.where(tl.arange(0, 4) == count, valid, masks)\n            count += 1\n    \n    # Process input channels in blocks\n    for ic_block_start in range(0, num_input_features, BLOCK_SIZE_IC):\n        ic_offsets = ic_block_start + tl.arange(0, BLOCK_SIZE_IC)\n        ic_mask = ic_offsets < num_input_features\n        \n        # Initialize average vector\n        avg = tl.zeros((BLOCK_SIZE_IC,), dtype=tl.float32)\n        valid_count = 0\n        \n        # Load data from the 2x2 window\n        for k in range(4):\n            if masks[k]:\n                ptr = ptrs[k] + ic_block_start * stride_c\n                data = tl.load(ptr + tl.arange(0, BLOCK_SIZE_IC), \n                              mask=ic_mask, other=0.0)\n                avg += data\n                valid_count += 1\n        \n        # Compute average if valid pixels found\n        if valid_count > 0:\n            avg = avg / valid_count\n        \n        # Load weight block using vectorized approach\n        weight_ptr_current = conv_weight_ptr + oc_block_start * num_input_features + ic_block_start\n        weight_block = tl.load(\n            weight_ptr_current + \n            tl.arange(0, BLOCK_SIZE_OC)[:, None] * num_input_features + \n            tl.arange(0, BLOCK_SIZE_IC)[None, :],\n            mask=oc_mask[:, None] & ic_mask[None, :],\n            other=0.0\n        )\n        \n        # Optimized matrix multiplication\n        partial = tl.sum(weight_block * avg, axis=1)\n        accumulator += partial\n    \n    # Store results\n    output_ptr_current = (\n        output_ptr + \n        batch_id * num_output_features * (height//2) * (width//2) + \n        i * (width//2) * num_output_features + \n        j * num_output_features + \n        oc_block_start\n    )\n    tl.store(\n        output_ptr_current + tl.arange(0, BLOCK_SIZE_OC),\n        accumulator,\n        mask=oc_mask\n    )\n\nclass ModelNew(nn.Module):\n    def __init__(self, num_input_features: int, num_output_features: int):\n        super(ModelNew, self).__init__()\n        self.num_input_features = num_input_features\n        self.num_output_features = num_output_features\n        \n        # BatchNorm parameters\n        self.bn = nn.BatchNorm2d(num_input_features)\n        \n        # Convolution weight (1x1 kernel)\n        self.conv_weight = nn.Parameter(\n            torch.empty(num_output_features, num_input_features)\n        )\n        nn.init.kaiming_uniform_(self.conv_weight, a=math.sqrt(5))\n\n    def forward(self, x):\n        if x.is_cuda and not self.training:\n            # Apply BatchNorm and ReLU first\n            x = self.bn(x)\n            x = F.relu(x)\n            \n            batch_size, _, height, width = x.shape\n            output = torch.empty(\n                (batch_size, self.num_output_features, height//2, width//2),\n                device=x.device, dtype=x.dtype\n            )\n            \n            # Calculate grid dimensions\n            grid = (\n                batch_size * (height//2) * (width//2),\n                triton.cdiv(self.num_output_features, 64)\n            )\n            \n            # Get strides for input tensor\n            stride_b = x.stride(0)\n            stride_c = x.stride(1)\n            stride_h = x.stride(2)\n            stride_w = x.stride(3)\n            \n            # Launch Triton kernel\n            transition_kernel[grid](\n                x,\n                output,\n                self.conv_weight,\n                batch_size,\n                self.num_input_features,\n                self.num_output_features,\n                height,\n                width,\n                stride_b,\n                stride_c,\n                stride_h,\n                stride_w\n            )\n            return output\n        else:\n            # Training or CPU fallback\n            x = self.bn(x)\n            x = F.relu(x)\n            weight_4d = self.conv_weight.view(\n                self.num_output_features, self.num_input_features, 1, 1\n            )\n            x = F.conv2d(x, weight_4d, bias=None)\n            return F.avg_pool2d(x, kernel_size=2, stride=2)\n\nbatch_size = 10\nnum_input_features = 32\nnum_output_features = 64\nheight, width = 224, 224\n\ndef get_inputs():\n    return [torch.randn(batch_size, num_input_features, height, width)]\n\ndef get_init_inputs():\n    return [num_input_features, num_output_features]\n# =================== EVOLVE-BLOCK-END ===================", "language": "python", "parent_id": "e1555cf2-a4f9-470d-a339-b4a432e9a853", "generation": 3, "timestamp": 1754591923.5441852, "iteration_found": 26, "metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": false, "score": 20, "speed_up": 0.596, "runtime_ms": 0.505, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:3", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.301, "speed_up": 0.596, "custom_timing": 0.505}}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": true, "correctness": false, "score": 10, "stage": "wrong_answer", "verify_payload": {"id": "level3_13_DenseNet121TransitionLayer", "result": {"compiled": true, "correctness": false, "metadata": {"hardware": "NVIDIA L20Y", "device": "cuda:0", "runtime_error": "Traceback (most recent call last):\n  File \"/cpfs01/shared/llm_kernel/hujiakai/KernelLLM/validation_api_server/helpers/evaluations.py\", line 720, in run_and_check_correctness\n    output_new = model_new(*inputs)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1773, in _wrapped_call_impl\n    return self._call_impl(*args, **kwargs)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1784, in _call_impl\n    return forward_call(*args, **kwargs)\n  File \"/tmp/tmpjrvi48te.py\", line 104, in forward\n    _forward_kernel[grid](\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 390, in <lambda>\n    return lambda *args, **kwargs: self.run(grid=grid, warmup=False, *args, **kwargs)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 594, in run\n    kernel = self.compile(src, target=target, options=options.__dict__)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/compiler/compiler.py\", line 339, in compile\n    module = src.make_ir(options, codegen_fns, module_map, context)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/compiler/compiler.py\", line 83, in make_ir\n    return ast_to_ttir(self.fn, self, context=context, options=options, codegen_fns=codegen_fns,\ntriton.compiler.errors.CompilationError: at 13:26:\n    x_ptr,\n    output_ptr,\n    weight_ptr,\n    bias_ptr,\n    num_input_features,\n    H, W,\n    stride_xb, stride_xc, stride_xh, stride_xw,\n    stride_output_b, stride_output_k, stride_output_h, stride_output_w,\n    BLOCK_SIZE_C: tl.constexpr,\n):\n    pid = tl.program_id(0)\n    num_output_features = bias_ptr.shape[0]\n                          ^\nIndexError('list index out of range')\n\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/language/core.py\", line 1289, in __getitem__\n    return self.values[idx]\nIndexError: list index out of range\n", "runtime_error_name": "triton.compiler.errors.CompilationError", "reference_timing_ms": 0.301, "speed_up": -1.0, "custom_timing": -1.0}, "runtime": -1.0, "runtime_stats": {}}}}, "island": 2}, "artifacts_json": null, "artifact_dir": null}