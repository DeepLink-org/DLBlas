{"id": "04eee13e-3f92-4965-bb2a-5c5fec7525ea", "code": "# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\nimport math\n\n@triton.jit\ndef _depthwise_conv2d_kernel(\n    input_ptr, weight_ptr, bias_ptr, output_ptr,\n    N, C, H, W, OH, OW, KH, KW,\n    stride_n, stride_c, stride_h, stride_w,\n    weight_stride_c, weight_stride_kh, weight_stride_kw,\n    stride_h_conv, stride_w_conv, padding_h, padding_w, dilation_h, dilation_w,\n    output_stride_n, output_stride_c, output_stride_h, output_stride_w,\n    has_bias: tl.constexpr,\n    BLOCK_H: tl.constexpr, BLOCK_W: tl.constexpr,\n):\n    pid = tl.program_id(0)\n    num_pid_c = C\n    num_pid_oh = tl.cdiv(OH, BLOCK_H)\n    num_pid_ow = tl.cdiv(OW, BLOCK_W)\n    \n    pid_batch = pid // (num_pid_c * num_pid_oh * num_pid_ow)\n    pid_channel = (pid // (num_pid_oh * num_pid_ow)) % num_pid_c\n    pid_oh = (pid // num_pid_ow) % num_pid_oh\n    pid_ow = pid % num_pid_ow\n\n    oh_start = pid_oh * BLOCK_H\n    ow_start = pid_ow * BLOCK_W\n\n    ohs = oh_start + tl.arange(0, BLOCK_H)\n    ows = ow_start + tl.arange(0, BLOCK_W)\n    \n    acc = tl.zeros((BLOCK_H, BLOCK_W), dtype=tl.float32)\n    \n    if has_bias:\n        bias_val = tl.load(bias_ptr + pid_channel)\n        acc += bias_val\n\n    for kh in range(KH):\n        for kw in range(KW):\n            ihs = ohs * stride_h_conv + kh * dilation_h - padding_h\n            iws = ows * stride_w_conv + kw * dilation_w - padding_w\n            \n            mask_ih = (ihs >= 0) & (ihs < H)\n            mask_iw = (iws >= 0) & (iws < W)\n            mask = mask_ih[:, None] & mask_iw[None, :]\n            \n            input_ptrs = input_ptr + pid_batch * stride_n + pid_channel * stride_c + ihs[:, None] * stride_h + iws[None, :] * stride_w\n            input_vals = tl.load(input_ptrs, mask=mask, other=0.0)\n            \n            weight_val = tl.load(weight_ptr + pid_channel * weight_stride_c + kh * weight_stride_kh + kw * weight_stride_kw)\n            acc += input_vals * weight_val\n\n    mask_output = (ohs < OH)[:, None] & (ows < OW)[None, :]\n    output_ptrs = output_ptr + pid_batch * output_stride_n + pid_channel * output_stride_c + ohs[:, None] * output_stride_h + ows[None, :] * output_stride_w\n    tl.store(output_ptrs, acc, mask=mask_output)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_channels: int, out_channels: int, kernel_size_h: int, kernel_size_w: int, stride_h: int = 1, stride_w: int = 1, padding_h: int = 0, padding_w: int = 0, dilation_h: int = 1, dilation_w: int = 1, groups: int = 1, bias: bool = False):\n        super(ModelNew, self).__init__()\n        assert groups == in_channels, \"Depthwise convolution requires groups == in_channels\"\n        \n        self.in_channels = in_channels\n        self.out_channels = out_channels\n        self.kernel_size_h = kernel_size_h\n        self.kernel_size_w = kernel_size_w\n        self.stride_h = stride_h\n        self.stride_w = stride_w\n        self.padding_h = padding_h\n        self.padding_w = padding_w\n        self.dilation_h = dilation_h\n        self.dilation_w = dilation_w\n        self.groups = groups\n        \n        self.weight = nn.Parameter(torch.empty(out_channels, 1, kernel_size_h, kernel_size_w))\n        if bias:\n            self.bias = nn.Parameter(torch.empty(out_channels))\n        else:\n            self.register_parameter('bias', None)\n            \n        self.reset_parameters()\n        \n    def reset_parameters(self):\n        nn.init.kaiming_uniform_(self.weight, a=math.sqrt(5))\n        if self.bias is not None:\n            fan_in, _ = nn.init._calculate_fan_in_and_fan_out(self.weight)\n            bound = 1 / math.sqrt(fan_in)\n            nn.init.uniform_(self.bias, -bound, bound)\n            \n    def forward(self, x: torch.Tensor) -> torch.Tensor:\n        N, C, H, W = x.shape\n        OH = (H + 2 * self.padding_h - self.dilation_h * (self.kernel_size_h - 1) - 1) // self.stride_h + 1\n        OW = (W + 2 * self.padding_w - self.dilation_w * (self.kernel_size_w - 1) - 1) // self.stride_w + 1\n        \n        output = torch.empty((N, C, OH, OW), device=x.device, dtype=x.dtype)\n        \n        stride_n, stride_c, stride_h, stride_w = x.stride()\n        weight_flat = self.weight.squeeze(1)\n        weight_stride_c, weight_stride_kh, weight_stride_kw = weight_flat.stride()\n        output_stride_n, output_stride_c, output_stride_h, output_stride_w = output.stride()\n        \n        grid = (N * C * triton.cdiv(OH, 16) * triton.cdiv(OW, 16),)\n        \n        _depthwise_conv2d_kernel[grid](\n            x, weight_flat, self.bias, output,\n            N, C, H, W, OH, OW, self.kernel_size_h, self.kernel_size_w,\n            stride_n, stride_c, stride_h, stride_w,\n            weight_stride_c, weight_stride_kh, weight_stride_kw,\n            self.stride_h, self.stride_w, self.padding_h, self.padding_w, \n            self.dilation_h, self.dilation_w,\n            output_stride_n, output_stride_c, output_stride_h, output_stride_w,\n            self.bias is not None,\n            BLOCK_H=16, BLOCK_W=16\n        )\n        \n        return output\n\n# Test code\nbatch_size = 16\nin_channels = 3\nout_channels = in_channels\nkernel_size_h = 3\nkernel_size_w = 5\nwidth = 256\nheight = 128\nstride_h = 1\nstride_w = 1\npadding_h = 0\npadding_w = 0\ndilation_h = 1\ndilation_w = 1\ngroups = in_channels\n\ndef get_inputs():\n    x = torch.randn(batch_size, in_channels, height, width)\n    return [x]\n\ndef get_init_inputs():\n    return [in_channels, out_channels, kernel_size_h, kernel_size_w, stride_h, stride_w, padding_h, padding_w, dilation_h, dilation_w, groups]\n# =================== EVOLVE-BLOCK-END ===================", "language": "python", "parent_id": "82210f92-4335-4521-a3b3-bdfdec8474d9", "generation": 1, "timestamp": 1754645641.970845, "iteration_found": 3, "metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": false, "score": 20, "speed_up": 0.515, "runtime_ms": 0.079, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:4", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.0407, "speed_up": 0.515, "custom_timing": 0.079}}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": true, "correctness": true, "stage": "reference code", "passed": false, "score": 0.0, "speed_up": 1.0, "runtime_ms": 0.0404, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:7", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.0407, "speed_up": 1.007, "custom_timing": 0.0404}}, "island": 0}, "artifacts_json": null, "artifact_dir": null}