{"id": "258f234c-b237-4f60-9d23-8aba1f84bc5a", "code": "@triton.jit\ndef linear_kernel(\n    x_ptr, w_ptr, b_ptr, out_ptr,\n    M, N, K,\n    stride_xm, stride_xk,\n    stride_wk, stride_wn,   # note: we changed the order and meaning: now stride_wk is for the rows (dim0) of w, stride_wn for columns (dim1)\n    stride_om, stride_on,\n    BLOCK_SIZE_M: tl.constexpr, BLOCK_SIZE_N: tl.constexpr, BLOCK_SIZE_K: tl.constexpr\n):\n    pid_m = tl.program_id(0)\n    pid_n = tl.program_id(1)\n    \n    offs_m = pid_m * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)\n    offs_n = pid_n * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n    offs_k = tl.arange(0, BLOCK_SIZE_K)\n    \n    # For input matrix x: shape (M, K)\n    x_ptrs = x_ptr + offs_m[:, None] * stride_xm + offs_k[None, :] * stride_xk\n    # For weight matrix w: shape (K, N) - we are passing the transposed weight (contiguous)\n    w_ptrs = w_ptr + offs_k[:, None] * stride_wk + offs_n[None, :] * stride_wn\n    \n    acc = tl.zeros((BLOCK_SIZE_M, BLOCK_SIZE_N), dtype=tl.float32)\n    \n    for k in range(0, K, BLOCK_SIZE_K):\n        # Mask for input x: check that we are within bounds for M and for the current k block\n        mask_x = (offs_m[:, None] < M) & ((k + offs_k[None, :]) < K)\n        x_block = tl.load(x_ptrs, mask=mask_x, other=0.0)\n        \n        # Mask for weight w: check that we are within bounds for the current k block (rows) and for N (columns)\n        mask_w = ((k + offs_k[:, None]) < K) & (offs_n[None, :] < N)\n        w_block = tl.load(w_ptrs, mask=mask_w, other=0.0)\n        \n        # Compute the dot product: (BLOCK_SIZE_M, BLOCK_SIZE_K) @ (BLOCK_SIZE_K, BLOCK_SIZE_N) -> (BLOCK_SIZE_M, BLOCK_SIZE_N)\n        acc += tl.dot(x_block, w_block, allow_tf32=True)\n        \n        # Move the pointers to the next block in the K dimension\n        x_ptrs += BLOCK_SIZE_K * stride_xk\n        w_ptrs += BLOCK_SIZE_K * stride_wk   # note: we are moving the weight pointer by BLOCK_SIZE_K rows? So we add BLOCK_SIZE_K * stride_wk\n    \n    # Load the bias block: bias is of shape (N,)\n    b_ptrs = b_ptr + offs_n\n    b_block = tl.load(b_ptrs, mask=offs_n < N, other=0.0)\n    acc += b_block[None, :]   # add to every row\n    \n    # Store the output block\n    out_ptrs = out_ptr + offs_m[:, None] * stride_om + offs_n[None, :] * stride_on\n    mask_out = (offs_m[:, None] < M) & (offs_n[None, :] < N)\n    tl.store(out_ptrs, acc, mask=mask_out)", "language": "python", "parent_id": "220427e5-a531-4ff3-80bd-8b4f0291cfcb", "generation": 2, "timestamp": 1754582865.169712, "iteration_found": 12, "metrics": {"compiled": false, "correctness": false, "score": -100.0, "stage": "no_valid_triton_code", "feedback": "You need to generate real and valid triton code for the core function. The key word 'import triton' is not found."}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": false, "correctness": false, "score": -100.0, "stage": "no_valid_triton_code", "feedback": "You need to generate real and valid triton code for the core function. The key word 'import triton' is not found."}, "island": 1}, "artifacts_json": null, "artifact_dir": null}