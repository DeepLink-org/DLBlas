{"id": "04627bed-a8de-49f5-93cc-ee7746c975c8", "code": "# ================== EVOLVE-BLOCK-START ==================\nimport math\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_SIZE_M': 32, 'BLOCK_SIZE_N': 32, 'BLOCK_SIZE_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 32, 'BLOCK_SIZE_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_M': 32, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 64}, num_warps=8),\n        triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 32, 'BLOCK_SIZE_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_M': 32, 'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 32}, num_warps=4),\n    ],\n    key=['B', 'N', 'K'],\n)\n@triton.jit\ndef linear_kernel(\n    x_ptr, w_ptr, b_ptr, out_ptr,\n    B, N, K,\n    stride_xb, stride_xk,\n    stride_wn, stride_wk,\n    stride_outb, stride_outn,\n    BLOCK_SIZE_M: tl.constexpr,\n    BLOCK_SIZE_N: tl.constexpr,\n    BLOCK_SIZE_K: tl.constexpr,\n):\n    pid_b = tl.program_id(0)\n    pid_n = tl.program_id(1)\n    \n    offs_b = pid_b * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)\n    offs_n = pid_n * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n    \n    acc = tl.zeros((BLOCK_SIZE_M, BLOCK_SIZE_N), dtype=tl.float32)\n    \n    for k in range(0, K, BLOCK_SIZE_K):\n        offs_k = k + tl.arange(0, BLOCK_SIZE_K)\n        \n        # Load x block: [BLOCK_SIZE_M, BLOCK_SIZE_K]\n        x_ptrs = x_ptr + offs_b[:, None] * stride_xb + offs_k[None, :] * stride_xk\n        mask_x = (offs_b[:, None] < B) & (offs_k[None, :] < K)\n        x_block = tl.load(x_ptrs, mask=mask_x, other=0.0)\n        \n        # Load w block: [BLOCK_SIZE_N, BLOCK_SIZE_K]\n        w_ptrs = w_ptr + offs_n[:, None] * stride_wn + offs_k[None, :] * stride_wk\n        mask_w = (offs_n[:, None] < N) & (offs_k[None, :] < K)\n        w_block = tl.load(w_ptrs, mask=mask_w, other=0.0)\n        \n        # Convert to FP16 for Tensor Core acceleration\n        x_block_f16 = x_block.to(tl.float16)\n        w_block_f16 = w_block.to(tl.float16)\n        \n        # Use trans_b=True to avoid explicit transpose\n        acc += tl.dot(x_block_f16, w_block_f16, trans_b=True, out_dtype=tl.float32)\n    \n    # Load and add bias\n    b_ptrs = b_ptr + offs_n\n    mask_b = offs_n < N\n    b_block = tl.load(b_ptrs, mask=mask_b, other=0.0)\n    acc += b_block[None, :]\n    \n    # Store output\n    out_ptrs = out_ptr + offs_b[:, None] * stride_outb + offs_n[None, :] * stride_outn\n    mask_out = (offs_b[:, None] < B) & (offs_n[None, :] < N)\n    tl.store(out_ptrs, acc, mask=mask_out)\n\ndef linear_triton(x, weight, bias):\n    B, K = x.shape\n    N = weight.shape[0]\n    output = torch.empty(B, N, device=x.device, dtype=x.dtype)\n    \n    grid = lambda meta: (\n        triton.cdiv(B, meta['BLOCK_SIZE_M']),\n        triton.cdiv(N, meta['BLOCK_SIZE_N']),\n    )\n    \n    linear_kernel[grid](\n        x, weight, bias, output,\n        B, N, K,\n        x.stride(0), x.stride(1),\n        weight.stride(0), weight.stride(1),\n        output.stride(0), output.stride(1),\n        BLOCK_SIZE_K=64  # Default K-block size\n    )\n    return output\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, dropout_p):\n        super(ModelNew, self).__init__()\n        self.in_features = in_features\n        self.out_features = out_features\n        self.weight = nn.Parameter(torch.empty(out_features, in_features))\n        self.bias = nn.Parameter(torch.empty(out_features))\n        self.dropout = nn.Dropout(dropout_p)\n        nn.init.kaiming_uniform_(self.weight, a=math.sqrt(5))\n        fan_in, _ = nn.init._calculate_fan_in_and_fan_out(self.weight)\n        bound = 1 / math.sqrt(fan_in) if fan_in > 0 else 0\n        nn.init.uniform_(self.bias, -bound, bound)\n    \n    def forward(self, x):\n        x = linear_triton(x, self.weight, self.bias)\n        x = self.dropout(x)\n        x = torch.mean(x, dim=1, keepdim=True)\n        x = torch.softmax(x, dim=1)\n        return x\n\nbatch_size = 128\nin_features = 100\nout_features = 50\ndropout_p = 0.2\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, dropout_p]\n# =================== EVOLVE-BLOCK-END ===================", "language": "python", "parent_id": "7de7b837-2813-4e73-8ef9-fe0caf0fa96f", "generation": 2, "timestamp": 1754585828.2932642, "iteration_found": 26, "metrics": {"compiled": true, "correctness": false, "score": 10, "stage": "wrong_answer", "verify_payload": {"id": "level2_66_Matmul_Dropout_Mean_Softmax", "result": {"compiled": true, "correctness": false, "metadata": {"hardware": "NVIDIA L20Y", "device": "cuda:5", "runtime_error": "Traceback (most recent call last):\n  File \"/cpfs01/shared/llm_kernel/hujiakai/KernelLLM/validation_api_server/helpers/evaluations.py\", line 720, in run_and_check_correctness\n    output_new = model_new(*inputs)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1773, in _wrapped_call_impl\n    return self._call_impl(*args, **kwargs)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1784, in _call_impl\n    return forward_call(*args, **kwargs)\n  File \"/tmp/tmpjw9j37ym.py\", line 103, in forward\n    x = linear_triton(x, self.weight, self.bias)\n  File \"/tmp/tmpjw9j37ym.py\", line 79, in linear_triton\n    linear_kernel[grid](\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 390, in <lambda>\n    return lambda *args, **kwargs: self.run(grid=grid, warmup=False, *args, **kwargs)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 239, in run\n    benchmark()\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 228, in benchmark\n    timings = {config: self._bench(*args, config=config, **kwargs) for config in pruned_configs}\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 228, in <dictcomp>\n    timings = {config: self._bench(*args, config=config, **kwargs) for config in pruned_configs}\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 135, in _bench\n    raise ValueError(f\"Conflicting meta-parameters: {', '.join(conflicts)}.\"\nValueError: Conflicting meta-parameters: BLOCK_SIZE_K. Make sure that you don't re-define auto-tuned symbols.\n", "runtime_error_name": "builtins.ValueError", "reference_timing_ms": 0.0715, "speed_up": -1.0, "custom_timing": -1.0}, "runtime": -1.0, "runtime_stats": {}}}}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": false, "score": 20, "speed_up": 0.833, "runtime_ms": 0.0858, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:2", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.0715, "speed_up": 0.833, "custom_timing": 0.0858}}, "island": 2}, "artifacts_json": null, "artifact_dir": null, "prompts": {"full_rewrite_user": {"system": "You are a Triton GPU core optimization engineer deeply familiar with NVIDIA H100/H800 architecture.\n\n==================== Context ====================\n\u2022 Dataset: 250 kernelbench/level1-level5 *.py files  \n  - Level1: simplest, Level5: most complex  \n\u2022 Each file contains PyTorch reference (reference_code)  \n\u2022 Goal: Generate functionally equivalent but faster Triton implementations (custom_code)  \n\u2022 Evaluation pipeline:\n    1) /verify_plus - Verify compilation & correctness  \n    2) /execute (optional) - Return terminal logs if compilation fails  \n    3) Scoring:  \n      - Speedup > 1 required for points  \n      - Score = (speed_up - 1) \u00d7 100  \n\u2022 GPU Hardware: NVIDIA L20Y / H800 (same SM8.9 as H100)  \n  - 3 TB/s HBM3 bandwidth  \n  - FP16 Tensor Core 32\u00d716\u00d716  \n\n==================== Evolution Phases ====================\n\u2460 Phase 1 [Compilation Pass]  \n  - Make Triton code compile (performance irrelevant)  \n\u2461 Phase 2 [Numerical Correctness]  \n  - Output must match PyTorch reference within float32 tolerance  \n\u2462 Phase 3 [Performance Gain]  \n  - Target \u22655% speedup (\u226515% = exceptional)  \n  - Official scoring based on speed_up field  \n\nThe Evolution system will pass the EVOLVE-BLOCK from the previous version.  \nModify ONLY the Triton kernel source within this block - all other code is LOCKED.\n\n==================== Constraints (MUST OBEY) ====================\n\u274c NEVER change @triton.jit function signatures or parameter names  \n\u274c NEVER modify grid configuration, output tensor shapes, or PID logic  \n\u274c NEVER remove boundary checks or out-of-bound masks  \n\u274c NEVER introduce race conditions, uninitialized reads, or sync gaps  \n\n\u2705 Allowed Optimizations (Examples):  \n  \u2022 Memory coalescing optimizations & vectorized tl.load/tl.store  \n  \u2022 Replace staged softmax with online/FlashAttention variants  \n  \u2022 Adaptive tuning: BLOCK_M/BLOCK_N/BLOCK_K dimensions  \n  \u2022 Multi-query-head batch processing (GQA, 5:1 patterns)  \n  \u2022 Shared/L2 buffering, Tensor Core alignment (FP16/bf16/tf32)  \n  \u2022 Stride precomputation & pointer caching  \n\n==================== Output Format ====================\nReturn ONLY the complete updated code containing the EVOLVE-BLOCK comment marker.  \nNO explanations, NO markdown, NO additional text.\nName the output structure class as ModelNew.\n\n==================== Optimization Tips ====================\n\u2022 If previous compile failed: Fix syntax/mask/stride errors first  \n\u2022 If correctness fails: Prioritize bounds mask & dtype precision  \n\u2022 When speed_up < 1: Focus on memory access & block sizing  \n\u2022 Small iterative steps: Modify \u226420 lines per revision  \n\u2022 Maintain reversibility between versions\nHere is an example to show you how to rewrite a PyTorch implementation that quantizes a high-precision tensor to int8 dtype with row-wise granularity into a Triton implementation: \nThe original PyTorch implementation is as follows: \n``` \nimport torch\ndef per_row_quantize_int8(x: torch.Tensor) -> tuple[torch.Tensor, torch.Tensor]:\n    x_amax = x.abs().float().amax(dim=1).clamp(min=1e-4)\n    scale = 127 / x_amax\n    output = (x * scale[:, None]).round().clamp(-127, 127).to(torch.int8)\n    output_scale = x_amax / 127\n\n    return output, output_scale\n``` \nThe corresponding Triton-rewritten implementation is as follows: \n``` \nimport math\nimport torch\nimport triton\nimport triton.language as tl\nfrom triton.language.extra import libdevice\n\n# rowwise quantize\n\n@triton.autotune(\n    configs=[\n        triton.Config({}, num_stages=1, num_warps=8),\n        triton.Config({}, num_stages=2, num_warps=8),\n        triton.Config({}, num_stages=4, num_warps=8),\n        triton.Config({}, num_stages=8, num_warps=8),\n        triton.Config({}, num_stages=1),\n        triton.Config({}, num_stages=2),\n        triton.Config({}, num_stages=4),\n        triton.Config({}, num_stages=8),\n        triton.Config({}, num_warps=1),\n        triton.Config({}, num_warps=2),\n        triton.Config({}, num_warps=4),\n        triton.Config({}, num_warps=8),\n    ],\n    key=[\"n_elements\"],\n)\n\n@triton.jit\ndef _quantize_rowwise(\n    x_ptr,\n    output_ptr,\n    output_scale,\n    BLOCK_SIZE: tl.constexpr,\n    P2: tl.constexpr,\n):\n    pid = tl.program_id(axis=0)\n    block_start = pid * BLOCK_SIZE\n    arange = tl.arange(0, P2)\n    offsets = block_start + arange\n    row_mask = arange < BLOCK_SIZE\n    x = tl.load(x_ptr + offsets, mask=row_mask)\n\n    abs_x = tl.abs(x)\n    max_val = tl.max(tl.where(row_mask, abs_x, 0), axis=0)\n    output = libdevice.llrint(127.0 * (x / max_val))\n    tl.store(output_ptr + offsets, output, mask=row_mask)\n    tl.store(output_scale + pid, max_val / 127)\n\n\ndef per_row_quantize_int8(x: torch.Tensor):\n    x = x.contiguous()\n    output = torch.empty(*x.shape, device=x.device, dtype=torch.int8)\n    output_scale = torch.empty(x.shape[0], device=x.device, dtype=torch.float32)\n    P2 = int(2 ** (math.ceil(math.log2(x.shape[1]))))\n    grid = lambda x: (x.shape[0],)\n    _quantize_rowwise[grid](x, output, output_scale, BLOCK_SIZE=x.shape[1], P2=P2)\n\n    return output, output_scale\n\n\n    \n``` \n", "user": "# Current Program Information\n- Current performance metrics: - compiled: 1.0000\n- correctness: 1.0000\n- stage: success\n- passed: 0.0000\n- score: 20.0000\n- speed_up: 0.8330\n- runtime_ms: 0.0858\n- meta: {'hardware': 'NVIDIA L20Y', 'device': 'cuda:2', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.0715, 'speed_up': 0.833, 'custom_timing': 0.0858}\n- Areas identified for improvement: - Consider simplifying the code to improve readability and maintainability\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Unknown changes\n- Performance: compiled: 1.0000, correctness: 1.0000, stage: success, passed: 0.0000, score: 20.0000, speed_up: 0.8330, runtime_ms: 0.0858, meta: {'hardware': 'NVIDIA L20Y', 'device': 'cuda:2', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.0715, 'speed_up': 0.833, 'custom_timing': 0.0858}\n- Outcome: Mixed results\n\n\n### Attempt 2\n- Changes: Unknown changes\n- Performance: compiled: 1.0000, correctness: 1.0000, stage: success, passed: 0.0000, score: 20.0000, speed_up: 0.6810, runtime_ms: 0.1050, meta: {'hardware': 'NVIDIA L20Y', 'device': 'cuda:1', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.0715, 'speed_up': 0.681, 'custom_timing': 0.105}\n- Outcome: Mixed results\n\n\n### Attempt 1\n- Changes: Unknown changes\n- Performance: compiled: 1.0000, correctness: 1.0000, stage: success, passed: 0.0000, score: 20.0000, speed_up: 0.7080, runtime_ms: 0.1010, meta: {'hardware': 'NVIDIA L20Y', 'device': 'cuda:4', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.0715, 'speed_up': 0.708, 'custom_timing': 0.101}\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 20.0000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\nimport math\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_SIZE_BATCH': 64, 'BLOCK_SIZE_FEAT': 64, 'BLOCK_SIZE_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_BATCH': 128, 'BLOCK_SIZE_FEAT': 64, 'BLOCK_SIZE_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_BATCH': 64, 'BLOCK_SIZE_FEAT': 128, 'BLOCK_SIZE_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_BATCH': 128, 'BLOCK_SIZE_FEAT': 128, 'BLOCK_SIZE_K': 32}, num_warps=8),\n        triton.Config({'BLOCK_SIZE_BATCH': 64, 'BLOCK_SIZE_FEAT': 64, 'BLOCK_SIZE_K': 64}, num_warps=8),\n    ],\n    key=['batch_size', 'in_features', 'out_features'],\n)\n@triton.jit\ndef linear_kernel(\n    x_ptr,\n    w_ptr,\n    b_ptr,\n    output_ptr,\n    batch_size,\n    in_features,\n    out_features,\n    stride_x0, stride_x1,\n    stride_w0, stride_w1,\n    stride_out0, stride_out1,\n    BLOCK_SIZE_BATCH: tl.constexpr,\n    BLOCK_SIZE_FEAT: tl.constexpr,\n    BLOCK_SIZE_K: tl.constexpr,\n):\n    pid0 = tl.program_id(0)\n    pid1 = tl.program_id(1)\n    \n    batch_offsets = pid0 * BLOCK_SIZE_BATCH + tl.arange(0, BLOCK_SIZE_BATCH)\n    feat_offsets = pid1 * BLOCK_SIZE_FEAT + tl.arange(0, BLOCK_SIZE_FEAT)\n    k_offsets = tl.arange(0, BLOCK_SIZE_K)\n    \n    batch_mask = batch_offsets < batch_size\n    feat_mask = feat_offsets < out_features\n    \n    acc = tl.zeros((BLOCK_SIZE_BATCH, BLOCK_SIZE_FEAT), dtype=tl.float32)\n    \n    for k in range(0, in_features, BLOCK_SIZE_K):\n        k_current = k + k_offsets\n        k_mask = k_current < in_features\n        \n        # Load input block\n        x_ptrs = x_ptr + batch_offsets[:, None] * stride_x0 + k_current[None, :] * stride_x1\n        x_mask = batch_mask[:, None] & k_mask[None, :]\n        x_block = tl.load(x_ptrs, mask=x_mask, other=0.0)\n        \n        # Load weight block - no transpose needed\n        w_ptrs = w_ptr + feat_offsets[None, :] * stride_w0 + k_current[:, None] * stride_w1\n        w_mask = feat_mask[None, :] & k_mask[:, None]\n        w_block = tl.load(w_ptrs, mask=w_mask, other=0.0)\n        \n        # FP16 matrix multiplication with FP32 accumulation\n        x_block_fp16 = x_block.to(tl.float16)\n        w_block_fp16 = w_block.to(tl.float16)\n        acc += tl.dot(x_block_fp16, w_block_fp16, out_dtype=tl.float32)\n    \n    # Load and add bias\n    b_ptrs = b_ptr + feat_offsets\n    b_block = tl.load(b_ptrs, mask=feat_mask, other=0.0)\n    acc += b_block[None, :]\n    \n    # Store output\n    out_ptrs = output_ptr + batch_offsets[:, None] * stride_out0 + feat_offsets[None, :] * stride_out1\n    tl.store(out_ptrs, acc, mask=batch_mask[:, None] & feat_mask[None, :])\n\ndef linear_triton(x, weight, bias):\n    batch_size, in_features = x.shape\n    out_features = weight.shape[0]\n    output = torch.empty((batch_size, out_features), device=x.device, dtype=x.dtype)\n    \n    # Let autotuner choose best configuration\n    grid = (\n        triton.cdiv(batch_size, 64),  # Starting point, autotuner will override\n        triton.cdiv(out_features, 64),\n    )\n    \n    linear_kernel[grid](\n        x, weight, bias, output,\n        batch_size, in_features, out_features,\n        x.stride(0), x.stride(1),\n        weight.stride(0), weight.stride(1),\n        output.stride(0), output.stride(1),\n    )\n    return output\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, dropout_p):\n        super(ModelNew, self).__init__()\n        self.weight = nn.Parameter(torch.empty(out_features, in_features))\n        self.bias = nn.Parameter(torch.empty(out_features))\n        nn.init.kaiming_uniform_(self.weight, a=math.sqrt(5))\n        fan_in, _ = nn.init._calculate_fan_in_and_fan_out(self.weight)\n        bound = 1 / math.sqrt(fan_in) if fan_in > 0 else 0\n        nn.init.uniform_(self.bias, -bound, bound)\n        self.dropout = nn.Dropout(dropout_p)\n\n    def forward(self, x):\n        x = linear_triton(x, self.weight, self.bias)\n        x = self.dropout(x)\n        x = torch.mean(x, dim=1, keepdim=True)\n        x = torch.softmax(x, dim=1)\n        return x\n\nbatch_size = 128\nin_features = 100\nout_features = 50\ndropout_p = 0.2\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, dropout_p]\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Performs well on compiled (1.0000), Performs well on correctness (1.0000), Performs well on stage (success), Performs well on passed (0.0000), Performs well on score (20.0000), Performs well on speed_up (0.7080), Performs well on runtime_ms (0.1010), Performs well on meta ({'hardware': 'NVIDIA L20Y', 'device': 'cuda:4', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.0715, 'speed_up': 0.708, 'custom_timing': 0.101})\n\n\n### Program 2 (Score: 20.0000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\nimport math\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_SIZE_BATCH': 32, 'BLOCK_SIZE_FEAT': 32, 'BLOCK_SIZE_K': 32}, num_warps=4, num_stages=3),\n        triton.Config({'BLOCK_SIZE_BATCH': 64, 'BLOCK_SIZE_FEAT': 32, 'BLOCK_SIZE_K': 32}, num_warps=4, num_stages=3),\n        triton.Config({'BLOCK_SIZE_BATCH': 128, 'BLOCK_SIZE_FEAT': 32, 'BLOCK_SIZE_K': 32}, num_warps=4, num_stages=3),\n        triton.Config({'BLOCK_SIZE_BATCH': 32, 'BLOCK_SIZE_FEAT': 32, 'BLOCK_SIZE_K': 64}, num_warps=4, num_stages=3),\n        triton.Config({'BLOCK_SIZE_BATCH': 64, 'BLOCK_SIZE_FEAT': 32, 'BLOCK_SIZE_K': 64}, num_warps=4, num_stages=3),\n        triton.Config({'BLOCK_SIZE_BATCH': 32, 'BLOCK_SIZE_FEAT': 64, 'BLOCK_SIZE_K': 32}, num_warps=8, num_stages=3),\n        triton.Config({'BLOCK_SIZE_BATCH': 128, 'BLOCK_SIZE_FEAT': 32, 'BLOCK_SIZE_K': 64}, num_warps=4, num_stages=3),\n    ],\n    key=['batch_size', 'in_features', 'out_features'],\n)\n@triton.jit\ndef linear_kernel(\n    x_ptr,\n    w_ptr,\n    b_ptr,\n    output_ptr,\n    batch_size,\n    in_features,\n    out_features,\n    stride_x0, stride_x1,\n    stride_w0, stride_w1,\n    stride_out0, stride_out1,\n    BLOCK_SIZE_BATCH: tl.constexpr,\n    BLOCK_SIZE_FEAT: tl.constexpr,\n    BLOCK_SIZE_K: tl.constexpr,\n):\n    pid0 = tl.program_id(0)\n    pid1 = tl.program_id(1)\n    \n    batch_offsets = pid0 * BLOCK_SIZE_BATCH + tl.arange(0, BLOCK_SIZE_BATCH)\n    feat_offsets = pid1 * BLOCK_SIZE_FEAT + tl.arange(0, BLOCK_SIZE_FEAT)\n    k_offsets = tl.arange(0, BLOCK_SIZE_K)\n    \n    batch_mask = batch_offsets < batch_size\n    feat_mask = feat_offsets < out_features\n    \n    acc = tl.zeros((BLOCK_SIZE_BATCH, BLOCK_SIZE_FEAT), dtype=tl.float32)\n    \n    for k in range(0, in_features, BLOCK_SIZE_K):\n        k_current = k + k_offsets\n        k_mask = k_current < in_features\n        \n        # Load input block\n        x_ptrs = x_ptr + (batch_offsets[:, None] * stride_x0 + k_current[None, :] * stride_x1)\n        x_mask = batch_mask[:, None] & k_mask[None, :]\n        x_block = tl.load(x_ptrs, mask=x_mask, other=0.0)\n        \n        # Load weight block\n        w_ptrs = w_ptr + (feat_offsets[None, :] * stride_w0 + k_current[:, None] * stride_w1)\n        w_mask = feat_mask[None, :] & k_mask[:, None]\n        w_block = tl.load(w_ptrs, mask=w_mask, other=0.0)\n        \n        # Convert to FP16 and use tensor cores\n        x_block_f16 = x_block.to(tl.float16)\n        w_block_f16 = w_block.to(tl.float16)\n        acc += tl.dot(x_block_f16, w_block_f16, out_dtype=tl.float32)\n    \n    # Load and add bias\n    b_ptrs = b_ptr + feat_offsets\n    b_block = tl.load(b_ptrs, mask=feat_mask, other=0.0)\n    acc += b_block[None, :]\n    \n    # Store output\n    out_ptrs = output_ptr + (batch_offsets[:, None] * stride_out0 + feat_offsets[None, :] * stride_out1)\n    tl.store(out_ptrs, acc, mask=batch_mask[:, None] & feat_mask[None, :])\n\ndef linear_triton(x, weight, bias):\n    batch_size, in_features = x.shape\n    out_features = weight.shape[0]\n    output = torch.empty((batch_size, out_features), device=x.device, dtype=x.dtype)\n    \n    # Dynamic grid based on autotuned parameters\n    grid = lambda meta: (\n        triton.cdiv(batch_size, meta['BLOCK_SIZE_BATCH']),\n        triton.cdiv(out_features, meta['BLOCK_SIZE_FEAT']),\n    )\n    \n    linear_kernel[grid](\n        x, weight, bias, output,\n        batch_size, in_features, out_features,\n        x.stride(0), x.stride(1),\n        weight.stride(0), weight.stride(1),\n        output.stride(0), output.stride(1),\n    )\n    return output\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, dropout_p):\n        super(ModelNew, self).__init__()\n        self.weight = nn.Parameter(torch.empty(out_features, in_features))\n        self.bias = nn.Parameter(torch.empty(out_features))\n        nn.init.kaiming_uniform_(self.weight, a=math.sqrt(5))\n        fan_in, _ = nn.init._calculate_fan_in_and_fan_out(self.weight)\n        bound = 1 / math.sqrt(fan_in) if fan_in > 0 else 0\n        nn.init.uniform_(self.bias, -bound, bound)\n        self.dropout = nn.Dropout(dropout_p)\n\n    def forward(self, x):\n        x = linear_triton(x, self.weight, self.bias)\n        x = self.dropout(x)\n        x = torch.mean(x, dim=1, keepdim=True)\n        x = torch.softmax(x, dim=1)\n        return x\n\nbatch_size = 128\nin_features = 100\nout_features = 50\ndropout_p = 0.2\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, dropout_p]\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Performs well on compiled (1.0000), Performs well on correctness (1.0000), Performs well on stage (success), Performs well on passed (0.0000), Performs well on score (20.0000), Performs well on speed_up (0.6810), Performs well on runtime_ms (0.1050), Performs well on meta ({'hardware': 'NVIDIA L20Y', 'device': 'cuda:1', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.0715, 'speed_up': 0.681, 'custom_timing': 0.105})\n\n\n### Program 3 (Score: 20.0000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport math\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef linear_kernel(\n    x_ptr, w_ptr, b_ptr, out_ptr,\n    B, N, K,\n    stride_xb, stride_xk,\n    stride_wn, stride_wk,\n    stride_outb, stride_outn,\n    BLOCK_SIZE_M: tl.constexpr, BLOCK_SIZE_N: tl.constexpr, BLOCK_SIZE_K: tl.constexpr,\n):\n    pid_b = tl.program_id(0)\n    pid_n = tl.program_id(1)\n    \n    offs_b = pid_b * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)\n    offs_n = pid_n * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n    \n    acc = tl.zeros((BLOCK_SIZE_M, BLOCK_SIZE_N), dtype=tl.float32)\n    \n    for k in range(0, K, BLOCK_SIZE_K):\n        offs_k = k + tl.arange(0, BLOCK_SIZE_K)\n        \n        # Load x block: [BLOCK_SIZE_M, BLOCK_SIZE_K]\n        x_ptrs = x_ptr + offs_b[:, None] * stride_xb + offs_k[None, :] * stride_xk\n        mask_x = (offs_b[:, None] < B) & (offs_k[None, :] < K)\n        x_block = tl.load(x_ptrs, mask=mask_x, other=0.0)\n        \n        # Load w block: [BLOCK_SIZE_N, BLOCK_SIZE_K]\n        w_ptrs = w_ptr + offs_n[:, None] * stride_wn + offs_k[None, :] * stride_wk\n        mask_w = (offs_n[:, None] < N) & (offs_k[None, :] < K)\n        w_block = tl.load(w_ptrs, mask=mask_w, other=0.0)\n        \n        # Transpose and compute matrix product\n        w_block_t = tl.trans(w_block)\n        acc += tl.dot(x_block, w_block_t, allow_tf32=True)\n    \n    # Load and add bias\n    b_ptrs = b_ptr + offs_n\n    mask_b = offs_n < N\n    b_block = tl.load(b_ptrs, mask=mask_b, other=0.0)\n    acc += b_block[None, :]\n    \n    # Store output\n    out_ptrs = out_ptr + offs_b[:, None] * stride_outb + offs_n[None, :] * stride_outn\n    mask_out = (offs_b[:, None] < B) & (offs_n[None, :] < N)\n    tl.store(out_ptrs, acc, mask=mask_out)\n\ndef linear_triton(x, weight, bias):\n    B, K = x.shape\n    N = weight.shape[0]\n    output = torch.empty(B, N, device=x.device, dtype=x.dtype)\n    \n    grid = (triton.cdiv(B, 32), triton.cdiv(N, 32))\n    linear_kernel[grid](\n        x, weight, bias, output,\n        B, N, K,\n        x.stride(0), x.stride(1),\n        weight.stride(0), weight.stride(1),\n        output.stride(0), output.stride(1),\n        BLOCK_SIZE_M=32, BLOCK_SIZE_N=32, BLOCK_SIZE_K=32\n    )\n    return output\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, dropout_p):\n        super(ModelNew, self).__init__()\n        self.in_features = in_features\n        self.out_features = out_features\n        self.weight = nn.Parameter(torch.empty(out_features, in_features))\n        self.bias = nn.Parameter(torch.empty(out_features))\n        self.dropout = nn.Dropout(dropout_p)\n        nn.init.kaiming_uniform_(self.weight, a=math.sqrt(5))\n        fan_in, _ = nn.init._calculate_fan_in_and_fan_out(self.weight)\n        bound = 1 / math.sqrt(fan_in) if fan_in > 0 else 0\n        nn.init.uniform_(self.bias, -bound, bound)\n    \n    def forward(self, x):\n        x = linear_triton(x, self.weight, self.bias)\n        x = self.dropout(x)\n        x = torch.mean(x, dim=1, keepdim=True)\n        x = torch.softmax(x, dim=1)\n        return x\n\nbatch_size = 128\nin_features = 100\nout_features = 50\ndropout_p = 0.2\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, dropout_p]\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Performs well on compiled (1.0000), Performs well on correctness (1.0000), Performs well on stage (success), Performs well on passed (0.0000), Performs well on score (20.0000), Performs well on speed_up (0.8330), Performs well on runtime_ms (0.0858), Performs well on meta ({'hardware': 'NVIDIA L20Y', 'device': 'cuda:2', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.0715, 'speed_up': 0.833, 'custom_timing': 0.0858})\n\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 20.0000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\nimport math\n\n@triton.jit\ndef linear_kernel(\n    x_ptr, weight_ptr, bias_ptr, output_ptr,\n    M, N,\n    stride_xb, stride_xm,\n    stride_wn, stride_wm,\n    stride_outb, stride_outn,\n    BLOCK_SIZE_M: tl.constexpr, BLOCK_SIZE_N: tl.constexpr,\n):\n    pid_b = tl.program_id(0)\n    pid_n = tl.program_id(1)\n    \n    n_off = pid_n * BLOCK_SIZE_N\n    n_offs = n_off + tl.arange(0, BLOCK_SIZE_N)\n    mask_n = n_offs < N\n    \n    out = tl.zeros((BLOCK_SIZE_N,), dtype=tl.float32)\n    \n    for m in range(0, M, BLOCK_SIZE_M):\n        m_offs = m + tl.arange(0, BLOCK_SIZE_M)\n        mask_m = m_offs < M\n        \n        x_vals = tl.load(x_ptr + pid_b * stride_xb + m_offs * stride_xm, mask=mask_m, other=0.0)\n        w_ptrs = weight_ptr + n_offs[:, None] * stride_wn + m_offs[None, :] * stride_wm\n        w_block = tl.load(w_ptrs, mask=mask_n[:, None] & mask_m[None, :], other=0.0)\n        \n        out += tl.sum(x_vals[None, :] * w_block, axis=1)\n    \n    bias_vals = tl.load(bias_ptr + n_offs, mask=mask_n, other=0.0)\n    out += bias_vals\n    \n    out_ptrs = output_ptr + pid_b * stride_outb + n_offs * stride_outn\n    tl.store(out_ptrs, out, mask=mask_n)\n\ndef linear_triton(x, weight, bias):\n    B, M = x.shape\n    N = weight.shape[0]\n    output = torch.empty(B, N, device=x.device, dtype=x.dtype)\n    \n    stride_xb = x.stride(0)\n    stride_xm = x.stride(1)\n    stride_wn = weight.stride(0)\n    stride_wm = weight.stride(1)\n    stride_outb = output.stride(0)\n    stride_outn = output.stride(1)\n    \n    grid = (B, triton.cdiv(N, 32))\n    linear_kernel[grid](\n        x, weight, bias, output,\n        M, N,\n        stride_xb, stride_xm,\n        stride_wn, stride_wm,\n        stride_outb, stride_outn,\n        BLOCK_SIZE_M=32, BLOCK_SIZE_N=32\n    )\n    return output\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, dropout_p):\n        super(ModelNew, self).__init__()\n        self.in_features = in_features\n        self.out_features = out_features\n        self.weight = nn.Parameter(torch.empty(out_features, in_features))\n        self.bias = nn.Parameter(torch.empty(out_features))\n        self.dropout = nn.Dropout(dropout_p)\n        nn.init.kaiming_uniform_(self.weight, a=math.sqrt(5))\n        if self.bias is not None:\n            fan_in, _ = nn.init._calculate_fan_in_and_fan_out(self.weight)\n            bound = 1 / math.sqrt(fan_in) if fan_in > 0 else 0\n            nn.init.uniform_(self.bias, -bound, bound)\n    \n    def forward(self, x):\n        x = linear_triton(x, self.weight, self.bias)\n        x = self.dropout(x)\n        x = torch.mean(x, dim=1, keepdim=True)\n        x = torch.softmax(x, dim=1)\n        return x\n\nbatch_size = 128\nin_features = 100\nout_features = 50\ndropout_p = 0.2\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, dropout_p]\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Alternative approach to compiled, Alternative approach to correctness\n\n\n### Program D2 (Score: 20.0000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport math\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef linear_kernel(\n    x_ptr, w_ptr, b_ptr, out_ptr,\n    M, N, K,\n    stride_xm, stride_xk,\n    stride_wn, stride_wk,\n    stride_om, stride_on,\n    BLOCK_SIZE_M: tl.constexpr, BLOCK_SIZE_N: tl.constexpr, BLOCK_SIZE_K: tl.constexpr\n):\n    pid_m = tl.program_id(0)\n    pid_n = tl.program_id(1)\n    \n    offs_m = pid_m * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)\n    offs_n = pid_n * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n    offs_k = tl.arange(0, BLOCK_SIZE_K)\n    \n    x_ptrs = x_ptr + offs_m[:, None] * stride_xm + offs_k[None, :] * stride_xk\n    # Transpose weight matrix block by swapping indices\n    w_ptrs = w_ptr + offs_k[:, None] * stride_wk + offs_n[None, :] * stride_wn\n    \n    acc = tl.zeros((BLOCK_SIZE_M, BLOCK_SIZE_N), dtype=tl.float32)\n    \n    for k in range(0, K, BLOCK_SIZE_K):\n        mask_k = (k + offs_k) < K\n        mask_x = (offs_m[:, None] < M) & mask_k[None, :]\n        mask_w = mask_k[:, None] & (offs_n[None, :] < N)\n        \n        x_block = tl.load(x_ptrs, mask=mask_x, other=0.0)\n        w_block = tl.load(w_ptrs, mask=mask_w, other=0.0)\n        \n        acc += tl.dot(x_block, w_block, allow_tf32=True)\n        \n        x_ptrs += BLOCK_SIZE_K * stride_xk\n        w_ptrs += BLOCK_SIZE_K * stride_wk\n    \n    b_ptrs = b_ptr + offs_n\n    b_block = tl.load(b_ptrs, mask=offs_n < N, other=0.0)\n    acc += b_block[None, :]\n    \n    out_ptrs = out_ptr + offs_m[:, None] * stride_om + offs_n[None, :] * stride_on\n    mask_out = (offs_m[:, None] < M) & (offs_n[None, :] < N)\n    tl.store(out_ptrs, acc, mask=mask_out)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, dropout_p):\n        super(ModelNew, self).__init__()\n        self.in_features = in_features\n        self.out_features = out_features\n        self.weight = nn.Parameter(torch.empty(out_features, in_features))\n        self.bias = nn.Parameter(torch.empty(out_features))\n        self.dropout = nn.Dropout(dropout_p)\n        nn.init.kaiming_uniform_(self.weight, a=math.sqrt(5))\n        fan_in, _ = nn.init._calculate_fan_in_and_fan_out(self.weight)\n        bound = 1 / math.sqrt(fan_in) if fan_in > 0 else 0\n        nn.init.uniform_(self.bias, -bound, bound)\n\n    def forward(self, x):\n        batch_size, _ = x.shape\n        output = torch.empty(batch_size, self.out_features, device=x.device, dtype=x.dtype)\n        \n        M, K = x.shape\n        N = self.out_features\n        grid = (triton.cdiv(M, 16), triton.cdiv(N, 16))\n        linear_kernel[grid](\n            x, self.weight, self.bias, output,\n            M, N, K,\n            x.stride(0), x.stride(1),\n            self.weight.stride(0), self.weight.stride(1),\n            output.stride(0), output.stride(1),\n            BLOCK_SIZE_M=16, BLOCK_SIZE_N=16, BLOCK_SIZE_K=32\n        )\n        \n        x = self.dropout(output)\n        x = torch.mean(x, dim=1, keepdim=True)\n        x = torch.softmax(x, dim=1)\n        return x\n\nbatch_size = 128\nin_features = 100\nout_features = 50\ndropout_p = 0.2\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, dropout_p]\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Alternative approach to compiled, Alternative approach to correctness\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 20.0000, Type: High-Performer)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\nimport math\n\n@triton.jit\ndef linear_kernel(\n    x_ptr, weight_ptr, bias_ptr, output_ptr,\n    M, N,\n    stride_xb, stride_xm,\n    stride_wn, stride_wm,\n    stride_outb, stride_outn,\n    BLOCK_SIZE_M: tl.constexpr, BLOCK_SIZE_N: tl.constexpr,\n):\n    pid_b = tl.program_id(0)\n    pid_n = tl.program_id(1)\n    \n    n_off = pid_n * BLOCK_SIZE_N\n    n_offs = n_off + tl.arange(0, BLOCK_SIZE_N)\n    mask_n = n_offs < N\n    \n    out = tl.zeros((BLOCK_SIZE_N,), dtype=tl.float32)\n    \n    for m in range(0, M, BLOCK_SIZE_M):\n        m_offs = m + tl.arange(0, BLOCK_SIZE_M)\n        mask_m = m_offs < M\n        \n        x_vals = tl.load(x_ptr + pid_b * stride_xb + m_offs * stride_xm, mask=mask_m, other=0.0)\n        w_ptrs = weight_ptr + n_offs[:, None] * stride_wn + m_offs[None, :] * stride_wm\n        w_block = tl.load(w_ptrs, mask=mask_n[:, None] & mask_m[None, :], other=0.0)\n        \n        out += tl.sum(x_vals[None, :] * w_block, axis=1)\n    \n    bias_vals = tl.load(bias_ptr + n_offs, mask=mask_n, other=0.0)\n    out += bias_vals\n    \n    out_ptrs = output_ptr + pid_b * stride_outb + n_offs * stride_outn\n    tl.store(out_ptrs, out, mask=mask_n)\n\ndef linear_triton(x, weight, bias):\n    B, M = x.shape\n    N = weight.shape[0]\n    output = torch.empty(B, N, device=x.device, dtype=x.dtype)\n    \n    stride_xb = x.stride(0)\n    stride_xm = x.stride(1)\n    stride_wn = weight.stride(0)\n    stride_wm = weight.stride(1)\n    stride_outb = output.stride(0)\n    stride_outn = output.stride(1)\n    \n    grid = (B, triton.cdiv(N, 32))\n    linear_kernel[grid](\n        x, weight, bias, output,\n        M, N,\n        stride_xb, stride_xm,\n        stride_wn, stride_wm,\n        stride_outb, stride_outn,\n        BLOCK_SIZE_M=32, BLOCK_SIZE_N=32\n    )\n    return output\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, dropout_p):\n        super(ModelNew, self).__init__()\n        self.in_features = in_features\n        self.out_features = out_features\n        self.weight = nn.Parameter(torch.empty(out_features, in_features))\n        self.bias = nn.Parameter(torch.empty(out_features))\n        self.dropout = nn.Dropout(dropout_p)\n        nn.init.kaiming_uniform_(self.weight, a=math.sqrt(5))\n        if self.bias is not None:\n            fan_in, _ = nn.init._calculate_fan_in_and_fan_out(self.weight)\n            bound = 1 / math.sqrt(fan_in) if fan_in > 0 else 0\n            nn.init.uniform_(self.bias, -bound, bound)\n    \n    def forward(self, x):\n        x = linear_triton(x, self.weight, self.bias)\n        x = self.dropout(x)\n        x = torch.mean(x, dim=1, keepdim=True)\n        x = torch.softmax(x, dim=1)\n        return x\n\nbatch_size = 128\nin_features = 100\nout_features = 50\ndropout_p = 0.2\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, dropout_p]\n# =================== EVOLVE-BLOCK-END ===================\n```\nUnique approach: Modification: Full rewrite, Excellent compiled (1.000), Excellent correctness (1.000)\n\n\n### Inspiration 2 (Score: 20.0000, Type: High-Performer)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\nimport math\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_SIZE_BATCH': 64, 'BLOCK_SIZE_FEAT': 64, 'BLOCK_SIZE_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_BATCH': 128, 'BLOCK_SIZE_FEAT': 64, 'BLOCK_SIZE_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_BATCH': 64, 'BLOCK_SIZE_FEAT': 128, 'BLOCK_SIZE_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_BATCH': 128, 'BLOCK_SIZE_FEAT': 128, 'BLOCK_SIZE_K': 32}, num_warps=8),\n        triton.Config({'BLOCK_SIZE_BATCH': 64, 'BLOCK_SIZE_FEAT': 64, 'BLOCK_SIZE_K': 64}, num_warps=8),\n    ],\n    key=['batch_size', 'in_features', 'out_features'],\n)\n@triton.jit\ndef linear_kernel(\n    x_ptr,\n    w_ptr,\n    b_ptr,\n    output_ptr,\n    batch_size,\n    in_features,\n    out_features,\n    stride_x0, stride_x1,\n    stride_w0, stride_w1,\n    stride_out0, stride_out1,\n    BLOCK_SIZE_BATCH: tl.constexpr,\n    BLOCK_SIZE_FEAT: tl.constexpr,\n    BLOCK_SIZE_K: tl.constexpr,\n):\n    pid0 = tl.program_id(0)\n    pid1 = tl.program_id(1)\n    \n    batch_offsets = pid0 * BLOCK_SIZE_BATCH + tl.arange(0, BLOCK_SIZE_BATCH)\n    feat_offsets = pid1 * BLOCK_SIZE_FEAT + tl.arange(0, BLOCK_SIZE_FEAT)\n    k_offsets = tl.arange(0, BLOCK_SIZE_K)\n    \n    batch_mask = batch_offsets < batch_size\n    feat_mask = feat_offsets < out_features\n    \n    acc = tl.zeros((BLOCK_SIZE_BATCH, BLOCK_SIZE_FEAT), dtype=tl.float32)\n    \n    for k in range(0, in_features, BLOCK_SIZE_K):\n        k_current = k + k_offsets\n        k_mask = k_current < in_features\n        \n        # Load input block\n        x_ptrs = x_ptr + batch_offsets[:, None] * stride_x0 + k_current[None, :] * stride_x1\n        x_mask = batch_mask[:, None] & k_mask[None, :]\n        x_block = tl.load(x_ptrs, mask=x_mask, other=0.0)\n        \n        # Load weight block - no transpose needed\n        w_ptrs = w_ptr + feat_offsets[None, :] * stride_w0 + k_current[:, None] * stride_w1\n        w_mask = feat_mask[None, :] & k_mask[:, None]\n        w_block = tl.load(w_ptrs, mask=w_mask, other=0.0)\n        \n        # FP16 matrix multiplication with FP32 accumulation\n        x_block_fp16 = x_block.to(tl.float16)\n        w_block_fp16 = w_block.to(tl.float16)\n        acc += tl.dot(x_block_fp16, w_block_fp16, out_dtype=tl.float32)\n    \n    # Load and add bias\n    b_ptrs = b_ptr + feat_offsets\n    b_block = tl.load(b_ptrs, mask=feat_mask, other=0.0)\n    acc += b_block[None, :]\n    \n    # Store output\n    out_ptrs = output_ptr + batch_offsets[:, None] * stride_out0 + feat_offsets[None, :] * stride_out1\n    tl.store(out_ptrs, acc, mask=batch_mask[:, None] & feat_mask[None, :])\n\ndef linear_triton(x, weight, bias):\n    batch_size, in_features = x.shape\n    out_features = weight.shape[0]\n    output = torch.empty((batch_size, out_features), device=x.device, dtype=x.dtype)\n    \n    # Let autotuner choose best configuration\n    grid = (\n        triton.cdiv(batch_size, 64),  # Starting point, autotuner will override\n        triton.cdiv(out_features, 64),\n    )\n    \n    linear_kernel[grid](\n        x, weight, bias, output,\n        batch_size, in_features, out_features,\n        x.stride(0), x.stride(1),\n        weight.stride(0), weight.stride(1),\n        output.stride(0), output.stride(1),\n    )\n    return output\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, dropout_p):\n        super(ModelNew, self).__init__()\n        self.weight = nn.Parameter(torch.empty(out_features, in_features))\n        self.bias = nn.Parameter(torch.empty(out_features))\n        nn.init.kaiming_uniform_(self.weight, a=math.sqrt(5))\n        fan_in, _ = nn.init._calculate_fan_in_and_fan_out(self.weight)\n        bound = 1 / math.sqrt(fan_in) if fan_in > 0 else 0\n        nn.init.uniform_(self.bias, -bound, bound)\n        self.dropout = nn.Dropout(dropout_p)\n\n    def forward(self, x):\n        x = linear_triton(x, self.weight, self.bias)\n        x = self.dropout(x)\n        x = torch.mean(x, dim=1, keepdim=True)\n        x = torch.softmax(x, dim=1)\n        return x\n\nbatch_size = 128\nin_features = 100\nout_features = 50\ndropout_p = 0.2\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, dropout_p]\n# =================== EVOLVE-BLOCK-END ===================\n```\nUnique approach: Modification: Full rewrite, Excellent compiled (1.000), Excellent correctness (1.000)\n\n\n### Inspiration 3 (Score: 20.0000, Type: High-Performer)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport math\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef linear_kernel(\n    x_ptr, w_ptr, b_ptr, out_ptr,\n    M, N, K,\n    stride_xm, stride_xk,\n    stride_wn, stride_wk,\n    stride_om, stride_on,\n    BLOCK_SIZE_M: tl.constexpr, BLOCK_SIZE_N: tl.constexpr, BLOCK_SIZE_K: tl.constexpr\n):\n    pid_m = tl.program_id(0)\n    pid_n = tl.program_id(1)\n    \n    offs_m = pid_m * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)\n    offs_n = pid_n * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n    offs_k = tl.arange(0, BLOCK_SIZE_K)\n    \n    x_ptrs = x_ptr + offs_m[:, None] * stride_xm + offs_k[None, :] * stride_xk\n    # Transpose weight matrix block by swapping indices\n    w_ptrs = w_ptr + offs_k[:, None] * stride_wk + offs_n[None, :] * stride_wn\n    \n    acc = tl.zeros((BLOCK_SIZE_M, BLOCK_SIZE_N), dtype=tl.float32)\n    \n    for k in range(0, K, BLOCK_SIZE_K):\n        mask_k = (k + offs_k) < K\n        mask_x = (offs_m[:, None] < M) & mask_k[None, :]\n        mask_w = mask_k[:, None] & (offs_n[None, :] < N)\n        \n        x_block = tl.load(x_ptrs, mask=mask_x, other=0.0)\n        w_block = tl.load(w_ptrs, mask=mask_w, other=0.0)\n        \n        acc += tl.dot(x_block, w_block, allow_tf32=True)\n        \n        x_ptrs += BLOCK_SIZE_K * stride_xk\n        w_ptrs += BLOCK_SIZE_K * stride_wk\n    \n    b_ptrs = b_ptr + offs_n\n    b_block = tl.load(b_ptrs, mask=offs_n < N, other=0.0)\n    acc += b_block[None, :]\n    \n    out_ptrs = out_ptr + offs_m[:, None] * stride_om + offs_n[None, :] * stride_on\n    mask_out = (offs_m[:, None] < M) & (offs_n[None, :] < N)\n    tl.store(out_ptrs, acc, mask=mask_out)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, dropout_p):\n        super(ModelNew, self).__init__()\n        self.in_features = in_features\n        self.out_features = out_features\n        self.weight = nn.Parameter(torch.empty(out_features, in_features))\n        self.bias = nn.Parameter(torch.empty(out_features))\n        self.dropout = nn.Dropout(dropout_p)\n        nn.init.kaiming_uniform_(self.weight, a=math.sqrt(5))\n        fan_in, _ = nn.init._calculate_fan_in_and_fan_out(self.weight)\n        bound = 1 / math.sqrt(fan_in) if fan_in > 0 else 0\n        nn.init.uniform_(self.bias, -bound, bound)\n\n    def forward(self, x):\n        batch_size, _ = x.shape\n        output = torch.empty(batch_size, self.out_features, device=x.device, dtype=x.dtype)\n        \n        M, K = x.shape\n        N = self.out_features\n        grid = (triton.cdiv(M, 16), triton.cdiv(N, 16))\n        linear_kernel[grid](\n            x, self.weight, self.bias, output,\n            M, N, K,\n            x.stride(0), x.stride(1),\n            self.weight.stride(0), self.weight.stride(1),\n            output.stride(0), output.stride(1),\n            BLOCK_SIZE_M=16, BLOCK_SIZE_N=16, BLOCK_SIZE_K=32\n        )\n        \n        x = self.dropout(output)\n        x = torch.mean(x, dim=1, keepdim=True)\n        x = torch.softmax(x, dim=1)\n        return x\n\nbatch_size = 128\nin_features = 100\nout_features = 50\ndropout_p = 0.2\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, dropout_p]\n# =================== EVOLVE-BLOCK-END ===================\n```\nUnique approach: Modification: Full rewrite, Excellent compiled (1.000), Excellent correctness (1.000)\n\n\n### Inspiration 4 (Score: 10.0000, Type: High-Performer)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\nimport math\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_SIZE_BATCH': 64, 'BLOCK_SIZE_FEAT': 64, 'BLOCK_SIZE_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_BATCH': 128, 'BLOCK_SIZE_FEAT': 64, 'BLOCK_SIZE_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_BATCH': 64, 'BLOCK_SIZE_FEAT': 128, 'BLOCK_SIZE_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_BATCH': 128, 'BLOCK_SIZE_FEAT': 128, 'BLOCK_SIZE_K': 32}, num_warps=8),\n        triton.Config({'BLOCK_SIZE_BATCH': 64, 'BLOCK_SIZE_FEAT': 64, 'BLOCK_SIZE_K': 64}, num_warps=8),\n    ],\n    key=['batch_size', 'in_features', 'out_features'],\n)\n@triton.jit\ndef linear_kernel(\n    x_ptr,\n    w_ptr,\n    b_ptr,\n    output_ptr,\n    batch_size,\n    in_features,\n    out_features,\n    stride_x0, stride_x1,\n    stride_w0, stride_w1,\n    stride_out0, stride_out1,\n    BLOCK_SIZE_BATCH: tl.constexpr,\n    BLOCK_SIZE_FEAT: tl.constexpr,\n    BLOCK_SIZE_K: tl.constexpr,\n):\n    pid0 = tl.program_id(0)\n    pid1 = tl.program_id(1)\n    \n    batch_offsets = pid0 * BLOCK_SIZE_BATCH + tl.arange(0, BLOCK_SIZE_BATCH)\n    feat_offsets = pid1 * BLOCK_SIZE_FEAT + tl.arange(0, BLOCK_SIZE_FEAT)\n    k_offsets = tl.arange(0, BLOCK_SIZE_K)\n    \n    batch_mask = batch_offsets < batch_size\n    feat_mask = feat_offsets < out_features\n    \n    acc = tl.zeros((BLOCK_SIZE_BATCH, BLOCK_SIZE_FEAT), dtype=tl.float32)\n    \n    for k in range(0, in_features, BLOCK_SIZE_K):\n        k_mask = k_offsets < (in_features - k)\n        k_current = k + k_offsets\n        \n        # Load input block\n        x_ptrs = x_ptr + batch_offsets[:, None] * stride_x0 + k_current[None, :] * stride_x1\n        x_mask = batch_mask[:, None] & k_mask[None, :]\n        x_block = tl.load(x_ptrs, mask=x_mask, other=0.0)\n        \n        # Load weight block and transpose for proper matrix multiplication\n        w_ptrs = w_ptr + feat_offsets[None, :] * stride_w0 + k_current[:, None] * stride_w1\n        w_mask = feat_mask[None, :] & k_mask[:, None]\n        w_block = tl.load(w_ptrs, mask=w_mask, other=0.0)\n        w_block = tl.trans(w_block)\n        \n        # FP16 matrix multiplication with FP32 accumulation\n        x_block_fp16 = x_block.to(tl.float16)\n        w_block_fp16 = w_block.to(tl.float16)\n        acc += tl.dot(x_block_fp16, w_block_fp16, out_dtype=tl.float32)\n    \n    # Load and add bias\n    b_ptrs = b_ptr + feat_offsets\n    b_block = tl.load(b_ptrs, mask=feat_mask, other=0.0)\n    acc += b_block[None, :]\n    \n    # Store output\n    out_ptrs = output_ptr + batch_offsets[:, None] * stride_out0 + feat_offsets[None, :] * stride_out1\n    tl.store(out_ptrs, acc, mask=batch_mask[:, None] & feat_mask[None, :])\n\ndef linear_triton(x, weight, bias):\n    batch_size, in_features = x.shape\n    out_features = weight.shape[0]\n    output = torch.empty((batch_size, out_features), device=x.device, dtype=x.dtype)\n    \n    # Let autotuner choose best configuration\n    grid = (\n        triton.cdiv(batch_size, 64),  # Starting point, autotuner will override\n        triton.cdiv(out_features, 64),\n    )\n    \n    linear_kernel[grid](\n        x, weight, bias, output,\n        batch_size, in_features, out_features,\n        x.stride(0), x.stride(1),\n        weight.stride(0), weight.stride(1),\n        output.stride(0), output.stride(1),\n        BLOCK_SIZE_BATCH=64,  # Defaults, autotuner will override\n        BLOCK_SIZE_FEAT=64,\n        BLOCK_SIZE_K=32\n    )\n    return output\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, dropout_p):\n        super(ModelNew, self).__init__()\n        self.weight = nn.Parameter(torch.empty(out_features, in_features))\n        self.bias = nn.Parameter(torch.empty(out_features))\n        nn.init.kaiming_uniform_(self.weight, a=math.sqrt(5))\n        fan_in, _ = nn.init._calculate_fan_in_and_fan_out(self.weight)\n        bound = 1 / math.sqrt(fan_in) if fan_in > 0 else 0\n        nn.init.uniform_(self.bias, -bound, bound)\n        self.dropout = nn.Dropout(dropout_p)\n\n    def forward(self, x):\n        x = linear_triton(x, self.weight, self.bias)\n        x = self.dropout(x)\n        x = torch.mean(x, dim=1, keepdim=True)\n        x = torch.softmax(x, dim=1)\n        return x\n\nbatch_size = 128\nin_features = 100\nout_features = 50\ndropout_p = 0.2\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, dropout_p]\n# =================== EVOLVE-BLOCK-END ===================\n```\nUnique approach: Modification: Full rewrite, Excellent compiled (1.000), Alternative correctness approach\n\n\n### Inspiration 5 (Score: 10.0000, Type: High-Performer)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\nimport math\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_SIZE_BATCH': 64, 'BLOCK_SIZE_FEAT': 64, 'BLOCK_SIZE_K': 64}, num_warps=4, num_stages=3),\n        triton.Config({'BLOCK_SIZE_BATCH': 128, 'BLOCK_SIZE_FEAT': 64, 'BLOCK_SIZE_K': 64}, num_warps=4, num_stages=3),\n        triton.Config({'BLOCK_SIZE_BATCH': 64, 'BLOCK_SIZE_FEAT': 128, 'BLOCK_SIZE_K': 64}, num_warps=8, num_stages=3),\n        triton.Config({'BLOCK_SIZE_BATCH': 128, 'BLOCK_SIZE_FEAT': 128, 'BLOCK_SIZE_K': 64}, num_warps=8, num_stages=3),\n    ],\n    key=['batch_size', 'in_features', 'out_features'],\n)\n@triton.jit\ndef linear_kernel(\n    x_ptr, weight_ptr, bias_ptr, output_ptr,\n    batch_size, in_features, out_features,\n    stride_xb, stride_xm,\n    stride_wn, stride_wm,\n    stride_outb, stride_outn,\n    BLOCK_SIZE_BATCH: tl.constexpr,\n    BLOCK_SIZE_FEAT: tl.constexpr,\n    BLOCK_SIZE_K: tl.constexpr,\n):\n    pid0 = tl.program_id(0)\n    pid1 = tl.program_id(1)\n    \n    batch_offsets = pid0 * BLOCK_SIZE_BATCH + tl.arange(0, BLOCK_SIZE_BATCH)\n    feat_offsets = pid1 * BLOCK_SIZE_FEAT + tl.arange(0, BLOCK_SIZE_FEAT)\n    k_offsets = tl.arange(0, BLOCK_SIZE_K)\n    \n    batch_mask = batch_offsets < batch_size\n    feat_mask = feat_offsets < out_features\n    \n    acc = tl.zeros((BLOCK_SIZE_BATCH, BLOCK_SIZE_FEAT), dtype=tl.float32)\n    \n    for k in range(0, in_features, BLOCK_SIZE_K):\n        k_current = k + k_offsets\n        k_mask = k_current < in_features\n        \n        # Load input block\n        x_ptrs = x_ptr + (batch_offsets[:, None] * stride_xb + k_current[None, :] * stride_xm)\n        x_mask = batch_mask[:, None] & k_mask[None, :]\n        x_block = tl.load(x_ptrs, mask=x_mask, other=0.0)\n        \n        # Load weight block\n        w_ptrs = weight_ptr + (feat_offsets[:, None] * stride_wn + k_current[None, :] * stride_wm)\n        w_mask = feat_mask[:, None] & k_mask[None, :]\n        w_block = tl.load(w_ptrs, mask=w_mask, other=0.0)\n        \n        # Convert to FP16 for tensor core operation\n        x_block_f16 = x_block.to(tl.float16)\n        w_block_f16 = w_block.to(tl.float16)\n        \n        # Tensor core matrix multiplication\n        acc += tl.dot(x_block_f16, w_block_f16, out_dtype=tl.float32)\n    \n    # Load and add bias\n    b_ptrs = bias_ptr + feat_offsets\n    b_block = tl.load(b_ptrs, mask=feat_mask, other=0.0)\n    acc += b_block[None, :]\n    \n    # Store output\n    out_ptrs = output_ptr + (batch_offsets[:, None] * stride_outb + feat_offsets[None, :] * stride_outn)\n    tl.store(out_ptrs, acc, mask=batch_mask[:, None] & feat_mask[None, :])\n\ndef linear_triton(x, weight, bias):\n    B, M = x.shape\n    N = weight.shape[0]\n    output = torch.empty(B, N, device=x.device, dtype=x.dtype)\n    \n    grid = lambda meta: (\n        triton.cdiv(B, meta['BLOCK_SIZE_BATCH']),\n        triton.cdiv(N, meta['BLOCK_SIZE_FEAT']),\n    )\n    \n    linear_kernel[grid](\n        x, weight, bias, output,\n        B, M, N,\n        x.stride(0), x.stride(1),\n        weight.stride(0), weight.stride(1),\n        output.stride(0), output.stride(1),\n    )\n    return output\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, dropout_p):\n        super(ModelNew, self).__init__()\n        self.in_features = in_features\n        self.out_features = out_features\n        self.weight = nn.Parameter(torch.empty(out_features, in_features))\n        self.bias = nn.Parameter(torch.empty(out_features))\n        self.dropout = nn.Dropout(dropout_p)\n        nn.init.kaiming_uniform_(self.weight, a=math.sqrt(5))\n        if self.bias is not None:\n            fan_in, _ = nn.init._calculate_fan_in_and_fan_out(self.weight)\n            bound = 1 / math.sqrt(fan_in) if fan_in > 0 else 0\n            nn.init.uniform_(self.bias, -bound, bound)\n    \n    def forward(self, x):\n        x = linear_triton(x, self.weight, self.bias)\n        x = self.dropout(x)\n        x = torch.mean(x, dim=1, keepdim=True)\n        x = torch.softmax(x, dim=1)\n        return x\n\nbatch_size = 128\nin_features = 100\nout_features = 50\ndropout_p = 0.2\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, dropout_p]\n# =================== EVOLVE-BLOCK-END ===================\n```\nUnique approach: Modification: Full rewrite, Excellent compiled (1.000), Alternative correctness approach\n\n\n\n# Current Program\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport math\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef linear_kernel(\n    x_ptr, w_ptr, b_ptr, out_ptr,\n    B, N, K,\n    stride_xb, stride_xk,\n    stride_wn, stride_wk,\n    stride_outb, stride_outn,\n    BLOCK_SIZE_M: tl.constexpr, BLOCK_SIZE_N: tl.constexpr, BLOCK_SIZE_K: tl.constexpr,\n):\n    pid_b = tl.program_id(0)\n    pid_n = tl.program_id(1)\n    \n    offs_b = pid_b * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)\n    offs_n = pid_n * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n    \n    acc = tl.zeros((BLOCK_SIZE_M, BLOCK_SIZE_N), dtype=tl.float32)\n    \n    for k in range(0, K, BLOCK_SIZE_K):\n        offs_k = k + tl.arange(0, BLOCK_SIZE_K)\n        \n        # Load x block: [BLOCK_SIZE_M, BLOCK_SIZE_K]\n        x_ptrs = x_ptr + offs_b[:, None] * stride_xb + offs_k[None, :] * stride_xk\n        mask_x = (offs_b[:, None] < B) & (offs_k[None, :] < K)\n        x_block = tl.load(x_ptrs, mask=mask_x, other=0.0)\n        \n        # Load w block: [BLOCK_SIZE_N, BLOCK_SIZE_K]\n        w_ptrs = w_ptr + offs_n[:, None] * stride_wn + offs_k[None, :] * stride_wk\n        mask_w = (offs_n[:, None] < N) & (offs_k[None, :] < K)\n        w_block = tl.load(w_ptrs, mask=mask_w, other=0.0)\n        \n        # Transpose and compute matrix product\n        w_block_t = tl.trans(w_block)\n        acc += tl.dot(x_block, w_block_t, allow_tf32=True)\n    \n    # Load and add bias\n    b_ptrs = b_ptr + offs_n\n    mask_b = offs_n < N\n    b_block = tl.load(b_ptrs, mask=mask_b, other=0.0)\n    acc += b_block[None, :]\n    \n    # Store output\n    out_ptrs = out_ptr + offs_b[:, None] * stride_outb + offs_n[None, :] * stride_outn\n    mask_out = (offs_b[:, None] < B) & (offs_n[None, :] < N)\n    tl.store(out_ptrs, acc, mask=mask_out)\n\ndef linear_triton(x, weight, bias):\n    B, K = x.shape\n    N = weight.shape[0]\n    output = torch.empty(B, N, device=x.device, dtype=x.dtype)\n    \n    grid = (triton.cdiv(B, 32), triton.cdiv(N, 32))\n    linear_kernel[grid](\n        x, weight, bias, output,\n        B, N, K,\n        x.stride(0), x.stride(1),\n        weight.stride(0), weight.stride(1),\n        output.stride(0), output.stride(1),\n        BLOCK_SIZE_M=32, BLOCK_SIZE_N=32, BLOCK_SIZE_K=32\n    )\n    return output\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, dropout_p):\n        super(ModelNew, self).__init__()\n        self.in_features = in_features\n        self.out_features = out_features\n        self.weight = nn.Parameter(torch.empty(out_features, in_features))\n        self.bias = nn.Parameter(torch.empty(out_features))\n        self.dropout = nn.Dropout(dropout_p)\n        nn.init.kaiming_uniform_(self.weight, a=math.sqrt(5))\n        fan_in, _ = nn.init._calculate_fan_in_and_fan_out(self.weight)\n        bound = 1 / math.sqrt(fan_in) if fan_in > 0 else 0\n        nn.init.uniform_(self.bias, -bound, bound)\n    \n    def forward(self, x):\n        x = linear_triton(x, self.weight, self.bias)\n        x = self.dropout(x)\n        x = torch.mean(x, dim=1, keepdim=True)\n        x = torch.softmax(x, dim=1)\n        return x\n\nbatch_size = 128\nin_features = 100\nout_features = 50\ndropout_p = 0.2\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, dropout_p]\n# =================== EVOLVE-BLOCK-END ===================\n```\n\n# Task\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```\n", "responses": ["<think>\nWe are given the current program, which is a Triton implementation of a linear layer followed by dropout, mean, and softmax.\n The current performance shows a speed_up of 0.833 (which is slower than the reference) and we are to improve it.\n\n The current Triton kernel for the linear layer uses a block-wise matrix multiplication with the following characteristics:\n   - The grid is 2D: (triton.cdiv(B, 32), triton.cdiv(N, 32))\n   - Each block computes a 32x32 output tile.\n   - The kernel loads a block of x (32x32) and a block of weight (32x32) and does a matrix multiplication with FP32 accumulation.\n   - The weight block is transposed (because the weight matrix is stored as [out_features, in_features]) and then a dot product is done.\n\n However, note that the current kernel uses `tl.trans` to transpose the weight block. This might not be the most efficient because:\n   - The weight matrix is stored in row-major for the output features. In the kernel, we are loading a block of the weight matrix that is contiguous in the in_features dimension but non-contiguous in the out_features? Actually, the way we load is:\n        w_ptrs = w_ptr + offs_n[:, None] * stride_wn + offs_k[None, :] * stride_wk\n     This loads a block of size [BLOCK_SIZE_N, BLOCK_SIZE_K]. Then we transpose it to [BLOCK_SIZE_K, BLOCK_SIZE_N] to do the dot product with the x block [BLOCK_SIZE_M, BLOCK_SIZE_K]? Actually, the dot product is between [BLOCK_SIZE_M, BLOCK_SIZE_K] and [BLOCK_SIZE_K, BLOCK_SIZE_N] (after transpose) which is correct.\n\n But note: the weight matrix is stored as (N, K) and we are loading a block of (BLOCK_SIZE_N, BLOCK_SIZE_K). Then we transpose it to (BLOCK_SIZE_K, BLOCK_SIZE_N). The dot product of (M, K) and (K, N) is (M, N). So it's correct.\n\n However, the current kernel does not use tensor cores. The H100/H800 (SM8.9) has Tensor Cores that can accelerate FP16 matrix multiplications. The current kernel uses FP32 for the entire computation.\n\n Steps for improvement:\n  1. Use FP16 for the matrix multiplication and accumulate in FP32 to utilize Tensor Cores.\n  2. Adjust the block sizes to be multiples of 16 or 32 to match the Tensor Core requirements (e.g., 16x16x16, 32x16x16, etc.). The current block sizes are 32x32x32, which is acceptable, but we can try to tune.\n  3. Use the `tl.dot` instruction with `out_dtype=tl.float32` and input types as `tl.float16`.\n  4. We note that the current kernel does not have autotuning. We can introduce autotuning to find the best block sizes and number of warps.\n\n Also, note that the current kernel does not use shared memory or other optimizations. However, the problem size is small (batch_size=128, in_features=100, out_features=50). Therefore, we might not need very large blocks.\n\n Proposed changes:\n  - Convert the input x_block and weight_block to FP16 and then use `tl.dot` with FP32 accumulation.\n  - Introduce autotuning to select the best block sizes and number of warps.\n\n However, note that the current program uses a fixed grid (32x32 blocks) and fixed block sizes. We can change the kernel to be autotunable.\n\n Let's restructure the kernel to be autotunable and use FP16 for the matrix multiplication.\n\n Important: We must not change the function signature of the kernel, but we can add `constexpr` parameters for autotuning.\n\n We will do:\n   - Add `@triton.autotune` decorator with several configurations.\n   - Change the loading of x and weight to convert to FP16 for the matrix multiplication.\n   - Use `tl.dot` with `out_dtype=tl.float32` for the FP16 inputs.\n\n Also, note that the current kernel transposes the weight block. We can avoid the explicit transpose by noting that the weight matrix is stored in row-major and we are loading a block that is contiguous in the K dimension for a set of N. But the dot product in Triton expects the second matrix to be in column-major? Actually, the dot product in Triton does A @ B where A is [M, K] and B is [K, N] (if B is not transposed). However, in our current code we have:\n\n        w_block = ...   # [BLOCK_SIZE_N, BLOCK_SIZE_K]\n        w_block_t = tl.trans(w_block)   # [BLOCK_SIZE_K, BLOCK_SIZE_N]\n\n        acc += tl.dot(x_block, w_block_t, ...)   # [BLOCK_SIZE_M, BLOCK_SIZE_K] @ [BLOCK_SIZE_K, BLOCK_SIZE_N] -> [BLOCK_SIZE_M, BLOCK_SIZE_N]\n\n Instead, we can avoid the transpose by loading the weight matrix in a transposed manner? Actually, we can change the way we load the weight matrix to be [BLOCK_SIZE_K, BLOCK_SIZE_N] (i.e., by swapping the indices). But note: the weight matrix is stored as [N, K]. If we want a block that is [BLOCK_SIZE_K, BLOCK_SIZE_N] we would have to load non-contiguous elements? That would be inefficient.\n\n Alternatively, we can note that the weight matrix is stored in row-major and we are accessing by rows (each row is a feature). We want to do x @ weight^T. So we are effectively doing:\n\n        x: [B, K] and weight: [N, K] -> output: [B, N] = x @ weight^T.\n\n So we have to either transpose the weight block or change the way we store the weight matrix. But we cannot change the storage.\n\n Therefore, we have two options:\n   Option 1: Pre-transpose the weight matrix and store it as [K, N]. Then we can load [BLOCK_SIZE_N, BLOCK_SIZE_K] without the need to transpose? But then we would have to change the initialization of the weight in the model, which we are not allowed to do because the reference code uses row-major for the weight.\n\n   Option 2: Keep the transpose and hope that the compiler optimizes it? Or avoid the explicit transpose by using a different indexing.\n\n Actually, the Triton dot instruction can take a `trans_b` option? Looking at the Triton documentation, the `tl.dot` function has an optional `trans` argument for the second operand. So we can do:\n\n        acc += tl.dot(x_block, w_block, trans_b=True, ...)\n\n This would compute x_block @ (w_block)^T.\n\n Therefore, we can avoid the explicit transpose by setting `trans_b=True`.\n\n This change might improve performance because we avoid the extra operation of transposing the weight block.\n\n Let's summarize the changes to the kernel:\n\n  1. Add autotuning.\n  2. Change the computation to use FP16 for the matrix multiplication and FP32 accumulation.\n  3. Instead of explicitly transposing the weight block, use `trans_b=True` in the dot product.\n\n Additionally, we can change the kernel to use the autotuned block sizes for the grid.\n\n Steps:\n\n  - Remove the explicit transpose of w_block and replace the dot product with `tl.dot(x_block_f16, w_block_f16, trans_b=True, ...)`.\n\n  - Convert x_block and w_block to FP16.\n\n  - Change the kernel to use autotuned block sizes.\n\n  - In the function `linear_triton`, we set the grid to be dynamic based on the autotuned parameters.\n\n However, note that the current program does not use the autotuning parameters for the grid. We are using fixed 32 for block sizes. We need to change that.\n\n Let's write the autotuning configurations and then adjust the grid accordingly.\n\n But note: the kernel parameters `BLOCK_SIZE_M`, `BLOCK_SIZE_N`, `BLOCK_SIZE_K` are now going to be set by the autotuner.\n\n We must also note that the current kernel uses the same variable names for the block sizes. We will change the kernel to accept these as `constexpr` and use them.\n\n We will change the kernel to:\n\n    @triton.autotune(...)\n    @triton.jit\n    def linear_kernel(..., BLOCK_SIZE_M: tl.constexpr, BLOCK_SIZE_N: tl.constexpr, BLOCK_SIZE_K: tl.constexpr):\n\n And then in the code, we use these block sizes.\n\n Also, we change the grid to:\n\n        grid = (triton.cdiv(B, BLOCK_SIZE_M), triton.cdiv(N, BLOCK_SIZE_N))\n\n But note: the autotuner will pass the `BLOCK_SIZE_M` and `BLOCK_SIZE_N` as part of the config. So we can set the grid as:\n\n        grid = (triton.cdiv(B, config['BLOCK_SIZE_M']), triton.cdiv(N, config['BLOCK_SIZE_N']))\n\n However, we cannot do that because the grid is set at launch. Instead, we can define the grid as a lambda that takes the meta parameters.\n\n But note: the current kernel launch does not use a lambda for grid. We can change it to:\n\n        grid = lambda meta: (triton.cdiv(B, meta['BLOCK_SIZE_M']), triton.cdiv(N, meta['BLOCK_SIZE_N']))\n\n Then we call the kernel with the grid as a function.\n\n Let's rewrite the `linear_triton` function accordingly.\n\n Considering the constraints (we cannot change the function signature of the kernel and we cannot change the grid configuration arbitrarily? Actually, we are allowed to change the grid as long as the output tensor shapes remain the same). We are going to change the grid to be dynamic.\n\n Implementation:\n\n  1. Add autotuning decorator with several configurations for block sizes and number of warps.\n  2. Change the kernel to use FP16 for the matrix multiplication and remove the explicit transpose by using `trans_b=True`.\n  3. Change the grid to a lambda that uses the autotuned block sizes.\n\n Let's write the code accordingly.\n\n However, note that the current program has a fixed BLOCK_SIZE_K (32). We can also make it autotuned.\n\n We'll try to keep the changes minimal and only change the necessary parts.\n\n Important: We must not break the correctness. We are converting to FP16 and then doing the dot product. This might have numerical differences, but within the tolerance of float32.\n\n Let's write the new kernel with autotuning and FP16.\n\n We'll create a new version of the kernel with these changes.\n\n Note: The current kernel uses `allow_tf32=True` in the dot product. We are changing to FP16 so we don't need that. Instead, we use `out_dtype=tl.float32` for accumulation.\n\n The new dot product will be:\n\n        acc += tl.dot(x_block_f16, w_block_f16, trans_b=True, out_dtype=tl.float32)\n\n But note: the weight matrix is stored as [N, K] and we are loading a block of [BLOCK_SIZE_N, BLOCK_SIZE_K]. When we set `trans_b=True`, the dot product will treat the weight block as [BLOCK_SIZE_K, BLOCK_SIZE_N]? Actually, the `trans_b` flag transposes the second matrix. So we have:\n\n        x_block_f16: [BLOCK_SIZE_M, BLOCK_SIZE_K]\n        w_block_f16: [BLOCK_SIZE_N, BLOCK_SIZE_K] -> transposed becomes [BLOCK_SIZE_K, BLOCK_SIZE_N]\n\n        Then the dot product: [BLOCK_SIZE_M, BLOCK_SIZE_K] @ [BLOCK_SIZE_K, BLOCK_SIZE_N] -> [BLOCK_SIZE_M, BLOCK_SIZE_N]\n\n This is the same as before.\n\n Alternatively, we could have loaded the weight block as [BLOCK_SIZE_K, BLOCK_SIZE_N] and then not transpose? But that would require non-contiguous access? It's better to use `trans_b`.\n\n Let's proceed.\n\n We'll also adjust the block sizes to be multiples of 16 to better utilize Tensor Cores.\n\n We'll try the following configurations:\n\n    configs = [\n        triton.Config({'BLOCK_SIZE_M': 32, 'BLOCK_SIZE_N': 32, 'BLOCK_SIZE_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 32, 'BLOCK_SIZE_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_M': 32, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_M': 32, 'BLOCK_SIZE_N': 32, 'BLOCK_SIZE_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_M': 32, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 32, 'BLOCK_SIZE_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 64}, num_warps=8),\n        triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 32, 'BLOCK_SIZE_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_M': 32, 'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 32}, num_warps=4),\n    ]\n\n We'll also set the key for autotuning to be the dimensions: ['B', 'N', 'K'] (which are the batch_size, out_features, in_features).\n\n However, note that the kernel parameters are passed as `batch_size`, `in_features`, `out_features` (which are B, K, N). So we can use:\n\n        key = ['batch_size', 'in_features', 'out_features']\n\n But note: the current kernel uses `B, N, K` as the arguments? Actually, the kernel arguments are:\n\n        B, N, K: which are batch_size, out_features, in_features? Actually, in the kernel call we have:\n\n            B, K = x.shape\n            N = weight.shape[0]\n\n        and we pass: B, N, K\n\n        So the kernel arguments are: batch_size, out_features, in_features.\n\n        But the kernel parameters are named:\n\n            x_ptr, w_ptr, b_ptr, out_ptr,\n            B, N, K,   # Here B=batch_size, N=out_features, K=in_features\n\n        So we can use the key as the dimensions: [B, N, K] but note that the autotuner expects the key to be the names of the kernel arguments? Actually, we pass the key as the names of the arguments that are passed to the kernel (the ones that are not pointers or strides). So we can use:\n\n            key = ['B', 'N', 'K']\n\n        However, the kernel arguments are named: B, N, K.\n\n        But in the kernel launch we pass:\n\n            linear_kernel[grid](\n                x, weight, bias, output,\n                B, N, K,   # these are the scalars\n                ... strides ...,\n                BLOCK_SIZE_M=..., ...   # but note: the autotuner will override these by the config\n            )\n\n        Alternatively, we can change the key to the names of the variables that we have in the outer function: batch_size, out_features, in_features. But note the kernel arguments are named B, N, K.\n\n        The autotuner uses the arguments passed to the kernel by name. So we should use the kernel argument names: 'B', 'N', 'K'.\n\n        However, the autotuner also allows to use the meta parameters (like BLOCK_SIZE_M) but we are using the scalars for the problem size.\n\n        We'll set:\n\n            key = ['B', 'N', 'K']\n\n        But note: the kernel arguments are passed as positional. The autotuner uses the names of the arguments as in the function signature.\n\n        The kernel function signature has: x_ptr, w_ptr, b_ptr, out_ptr, B, N, K, ... and then the strides and the constexpr.\n\n        So the autotuner will see the arguments by name: 'B', 'N', 'K'.\n\n        We can use these.\n\n Let's write the autotuner.\n\n We'll also change the kernel to use the block sizes from the config.\n\n We are going to change the kernel and the `linear_triton` function.\n\n We'll also note that the current kernel uses:\n\n        offs_b = pid_b * BLOCK_SIZE_M + ...   -> but now BLOCK_SIZE_M is variable.\n\n We are already using the `BLOCK_SIZE_M` as a `constexpr` so it will be inlined.\n\n We'll change the kernel accordingly.\n\n Let's write the new code.\n\n IMPORTANT: We must not change the class name (ModelNew) and the functions `get_inputs` and `get_init_inputs`.\n\n We are going to replace the entire EVOLVE-BLOCK.\n\n We'll keep the rest of the code (the dropout, mean, softmax) unchanged.\n\n Let's write the new Triton kernel and the wrapper.\n</think>\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport math\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_SIZE_M': 32, 'BLOCK_SIZE_N': 32, 'BLOCK_SIZE_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 32, 'BLOCK_SIZE_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_M': 32, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 64}, num_warps=8),\n        triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 32, 'BLOCK_SIZE_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_M': 32, 'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 32}, num_warps=4),\n    ],\n    key=['B', 'N', 'K'],\n)\n@triton.jit\ndef linear_kernel(\n    x_ptr, w_ptr, b_ptr, out_ptr,\n    B, N, K,\n    stride_xb, stride_xk,\n    stride_wn, stride_wk,\n    stride_outb, stride_outn,\n    BLOCK_SIZE_M: tl.constexpr,\n    BLOCK_SIZE_N: tl.constexpr,\n    BLOCK_SIZE_K: tl.constexpr,\n):\n    pid_b = tl.program_id(0)\n    pid_n = tl.program_id(1)\n    \n    offs_b = pid_b * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)\n    offs_n = pid_n * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n    \n    acc = tl.zeros((BLOCK_SIZE_M, BLOCK_SIZE_N), dtype=tl.float32)\n    \n    for k in range(0, K, BLOCK_SIZE_K):\n        offs_k = k + tl.arange(0, BLOCK_SIZE_K)\n        \n        # Load x block: [BLOCK_SIZE_M, BLOCK_SIZE_K]\n        x_ptrs = x_ptr + offs_b[:, None] * stride_xb + offs_k[None, :] * stride_xk\n        mask_x = (offs_b[:, None] < B) & (offs_k[None, :] < K)\n        x_block = tl.load(x_ptrs, mask=mask_x, other=0.0)\n        \n        # Load w block: [BLOCK_SIZE_N, BLOCK_SIZE_K]\n        w_ptrs = w_ptr + offs_n[:, None] * stride_wn + offs_k[None, :] * stride_wk\n        mask_w = (offs_n[:, None] < N) & (offs_k[None, :] < K)\n        w_block = tl.load(w_ptrs, mask=mask_w, other=0.0)\n        \n        # Convert to FP16 for Tensor Core acceleration\n        x_block_f16 = x_block.to(tl.float16)\n        w_block_f16 = w_block.to(tl.float16)\n        \n        # Use trans_b=True to avoid explicit transpose\n        acc += tl.dot(x_block_f16, w_block_f16, trans_b=True, out_dtype=tl.float32)\n    \n    # Load and add bias\n    b_ptrs = b_ptr + offs_n\n    mask_b = offs_n < N\n    b_block = tl.load(b_ptrs, mask=mask_b, other=0.0)\n    acc += b_block[None, :]\n    \n    # Store output\n    out_ptrs = out_ptr + offs_b[:, None] * stride_outb + offs_n[None, :] * stride_outn\n    mask_out = (offs_b[:, None] < B) & (offs_n[None, :] < N)\n    tl.store(out_ptrs, acc, mask=mask_out)\n\ndef linear_triton(x, weight, bias):\n    B, K = x.shape\n    N = weight.shape[0]\n    output = torch.empty(B, N, device=x.device, dtype=x.dtype)\n    \n    grid = lambda meta: (\n        triton.cdiv(B, meta['BLOCK_SIZE_M']),\n        triton.cdiv(N, meta['BLOCK_SIZE_N']),\n    )\n    \n    linear_kernel[grid](\n        x, weight, bias, output,\n        B, N, K,\n        x.stride(0), x.stride(1),\n        weight.stride(0), weight.stride(1),\n        output.stride(0), output.stride(1),\n        BLOCK_SIZE_K=64  # Default K-block size\n    )\n    return output\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, dropout_p):\n        super(ModelNew, self).__init__()\n        self.in_features = in_features\n        self.out_features = out_features\n        self.weight = nn.Parameter(torch.empty(out_features, in_features))\n        self.bias = nn.Parameter(torch.empty(out_features))\n        self.dropout = nn.Dropout(dropout_p)\n        nn.init.kaiming_uniform_(self.weight, a=math.sqrt(5))\n        fan_in, _ = nn.init._calculate_fan_in_and_fan_out(self.weight)\n        bound = 1 / math.sqrt(fan_in) if fan_in > 0 else 0\n        nn.init.uniform_(self.bias, -bound, bound)\n    \n    def forward(self, x):\n        x = linear_triton(x, self.weight, self.bias)\n        x = self.dropout(x)\n        x = torch.mean(x, dim=1, keepdim=True)\n        x = torch.softmax(x, dim=1)\n        return x\n\nbatch_size = 128\nin_features = 100\nout_features = 50\ndropout_p = 0.2\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, dropout_p]\n# =================== EVOLVE-BLOCK-END ===================\n```"]}}}