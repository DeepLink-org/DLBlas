{"id": "8740e7d9-fd78-46fe-8259-72620c2dee47", "code": "# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\nimport math\n\n# Fused GroupNorm + Hardtanh kernel\n@triton.jit\ndef group_norm_hardtanh_kernel(\n    x_ptr, y_ptr, weight_ptr, bias_ptr,\n    M, N, num_groups, eps, min_val, max_val,\n    stride_xm, stride_xn,\n    stride_ym, stride_yn,\n    BLOCK_SIZE: tl.constexpr\n):\n    row = tl.program_id(0)\n    group_id = tl.program_id(1)\n    group_size = N // num_groups\n    start_col = group_id * group_size\n    cols = start_col + tl.arange(0, BLOCK_SIZE)\n    \n    x_ptrs = x_ptr + row * stride_xm + cols * stride_xn\n    mask = cols < (start_col + group_size)\n    x = tl.load(x_ptrs, mask=mask, other=0.0)\n    \n    # Compute mean and variance\n    mean = tl.sum(x, axis=0) / group_size\n    x_centered = tl.where(mask, x - mean, 0.0)\n    var = tl.sum(x_centered * x_centered, axis=0) / group_size + eps\n    rstd = 1.0 / tl.sqrt(var)\n    \n    # Normalize and apply affine transformation\n    w = tl.load(weight_ptr + cols, mask=mask, other=0.0)\n    b = tl.load(bias_ptr + cols, mask=mask, other=0.0)\n    y = (x_centered * rstd) * w + b\n    \n    # Apply Hardtanh\n    y = tl.minimum(tl.maximum(y, min_val), max_val)\n    \n    # Store results\n    y_ptrs = y_ptr + row * stride_ym + cols * stride_yn\n    tl.store(y_ptrs, y, mask=mask)\n\n# Autotuned GEMM kernel\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 256, 'BLOCK_SIZE_K': 64}, num_warps=8),\n        triton.Config({'BLOCK_SIZE_M': 256, 'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 64}, num_warps=8),\n    ],\n    key=['M', 'N', 'K'],\n)\n@triton.jit\ndef gemm_kernel(\n    a_ptr, b_ptr, c_ptr, bias_ptr,\n    M, N, K,\n    stride_am, stride_ak,\n    stride_bk, stride_bn,\n    stride_cm, stride_cn,\n    BLOCK_SIZE_M: tl.constexpr,\n    BLOCK_SIZE_N: tl.constexpr,\n    BLOCK_SIZE_K: tl.constexpr,\n    GROUP_SIZE_M: tl.constexpr,\n    has_bias: tl.constexpr,\n):\n    pid = tl.program_id(0)\n    num_pid_m = tl.cdiv(M, BLOCK_SIZE_M)\n    num_pid_n = tl.cdiv(N, BLOCK_SIZE_N)\n    num_pid_in_group = GROUP_SIZE_M * num_pid_n\n    group_id = pid // num_pid_in_group\n    first_pid_m = group_id * GROUP_SIZE_M\n    group_size_m = min(num_pid_m - first_pid_m, GROUP_SIZE_M)\n    pid_m = first_pid_m + (pid % group_size_m)\n    pid_n = (pid % num_pid_in_group) // group_size_m\n\n    offs_m = pid_m * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)\n    offs_n = pid_n * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n    offs_k = tl.arange(0, BLOCK_SIZE_K)\n    a_ptrs = a_ptr + (offs_m[:, None] * stride_am + offs_k[None, :] * stride_ak)\n    b_ptrs = b_ptr + (offs_k[:, None] * stride_bk + offs_n[None, :] * stride_bn)\n    \n    accumulator = tl.zeros((BLOCK_SIZE_M, BLOCK_SIZE_N), dtype=tl.float32)\n    for k in range(0, tl.cdiv(K, BLOCK_SIZE_K)):\n        k_remaining = K - k * BLOCK_SIZE_K\n        k_mask = offs_k < k_remaining\n        a = tl.load(a_ptrs, mask=k_mask[None, :], other=0.0)\n        b = tl.load(b_ptrs, mask=k_mask[:, None], other=0.0)\n        accumulator = tl.dot(a, b, acc=accumulator, allow_tf32=True)\n        a_ptrs += BLOCK_SIZE_K * stride_ak\n        b_ptrs += BLOCK_SIZE_K * stride_bk\n\n    if has_bias:\n        bias_ptrs = bias_ptr + offs_n\n        bias = tl.load(bias_ptrs, mask=offs_n < N, other=0.0)\n        accumulator += bias[None, :]\n    \n    offs_cm = pid_m * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)\n    offs_cn = pid_n * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n    c_ptrs = c_ptr + (offs_cm[:, None] * stride_cm + offs_cn[None, :] * stride_cn)\n    mask = (offs_cm[:, None] < M) & (offs_cn[None, :] < N)\n    tl.store(c_ptrs, accumulator, mask=mask)\n\ndef triton_gemm(a, b, bias=None):\n    M, K = a.shape\n    K, N = b.shape\n    c = torch.empty((M, N), device=a.device, dtype=a.dtype)\n    \n    grid = lambda META: (triton.cdiv(M, META['BLOCK_SIZE_M']) * triton.cdiv(N, META['BLOCK_SIZE_N']),)\n    \n    gemm_kernel[grid](\n        a, b, c, bias,\n        M, N, K,\n        a.stride(0), a.stride(1),\n        b.stride(0), b.stride(1),\n        c.stride(0), c.stride(1),\n        GROUP_SIZE_M=8,\n        has_bias=bias is not None\n    )\n    return c\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, num_groups, hardtanh_min, hardtanh_max):\n        super(ModelNew, self).__init__()\n        self.in_features = in_features\n        self.out_features = out_features\n        self.num_groups = num_groups\n        self.hardtanh_min = hardtanh_min\n        self.hardtanh_max = hardtanh_max\n        \n        self.weight = nn.Parameter(torch.empty(out_features, in_features))\n        self.bias = nn.Parameter(torch.empty(out_features))\n        self.gn_weight = nn.Parameter(torch.ones(out_features))\n        self.gn_bias = nn.Parameter(torch.zeros(out_features))\n        \n        nn.init.kaiming_uniform_(self.weight, a=math.sqrt(5))\n        fan_in, _ = nn.init._calculate_fan_in_and_fan_out(self.weight)\n        bound = 1 / math.sqrt(fan_in) if fan_in > 0 else 0\n        nn.init.uniform_(self.bias, -bound, bound)\n\n    def forward(self, x):\n        gemm_output = triton_gemm(x, self.weight.t(), self.bias)\n        M, N = gemm_output.shape\n        output = torch.empty_like(gemm_output)\n        group_size = N // self.num_groups\n        BLOCK_SIZE = triton.next_power_of_2(group_size)\n        grid = (M, self.num_groups)\n        \n        group_norm_hardtanh_kernel[grid](\n            gemm_output, output, self.gn_weight, self.gn_bias,\n            M, N, self.num_groups, 1e-5,\n            self.hardtanh_min, self.hardtanh_max,\n            gemm_output.stride(0), gemm_output.stride(1),\n            output.stride(0), output.stride(1),\n            BLOCK_SIZE=BLOCK_SIZE\n        )\n        return output\n\nbatch_size = 128\nin_features = 1024\nout_features = 512\nnum_groups = 8\nhardtanh_min = -2.0\nhardtanh_max = 2.0\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, num_groups, hardtanh_min, hardtanh_max]\n# =================== EVOLVE-BLOCK-END ===================", "language": "python", "parent_id": "f158957b-44fb-4534-9659-61d1700a1c59", "generation": 3, "timestamp": 1754569034.6608937, "iteration_found": 18, "metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": false, "score": 20, "speed_up": 0.655, "runtime_ms": 0.122, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:1", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.0799, "speed_up": 0.655, "custom_timing": 0.122}}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": false, "score": 20, "speed_up": 0.701, "runtime_ms": 0.114, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:2", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.0799, "speed_up": 0.701, "custom_timing": 0.114}}, "island": 2}, "artifacts_json": null, "artifact_dir": null, "prompts": {"full_rewrite_user": {"system": "You are a Triton GPU core optimization engineer deeply familiar with NVIDIA H100/H800 architecture.\n\n==================== Context ====================\n\u2022 Dataset: 250 kernelbench/level1-level5 *.py files  \n  - Level1: simplest, Level5: most complex  \n\u2022 Each file contains PyTorch reference (reference_code)  \n\u2022 Goal: Generate functionally equivalent but faster Triton implementations (custom_code)  \n\u2022 Evaluation pipeline:\n    1) /verify_plus - Verify compilation & correctness  \n    2) /execute (optional) - Return terminal logs if compilation fails  \n    3) Scoring:  \n      - Speedup > 1 required for points  \n      - Score = (speed_up - 1) \u00d7 100  \n\u2022 GPU Hardware: NVIDIA L20Y / H800 (same SM8.9 as H100)  \n  - 3 TB/s HBM3 bandwidth  \n  - FP16 Tensor Core 32\u00d716\u00d716  \n\n==================== Evolution Phases ====================\n\u2460 Phase 1 [Compilation Pass]  \n  - Make Triton code compile (performance irrelevant)  \n\u2461 Phase 2 [Numerical Correctness]  \n  - Output must match PyTorch reference within float32 tolerance  \n\u2462 Phase 3 [Performance Gain]  \n  - Target \u22655% speedup (\u226515% = exceptional)  \n  - Official scoring based on speed_up field  \n\nThe Evolution system will pass the EVOLVE-BLOCK from the previous version.  \nModify ONLY the Triton kernel source within this block - all other code is LOCKED.\n\n==================== Constraints (MUST OBEY) ====================\n\u274c NEVER change @triton.jit function signatures or parameter names  \n\u274c NEVER modify grid configuration, output tensor shapes, or PID logic  \n\u274c NEVER remove boundary checks or out-of-bound masks  \n\u274c NEVER introduce race conditions, uninitialized reads, or sync gaps  \n\n\u2705 Allowed Optimizations (Examples):  \n  \u2022 Memory coalescing optimizations & vectorized tl.load/tl.store  \n  \u2022 Replace staged softmax with online/FlashAttention variants  \n  \u2022 Adaptive tuning: BLOCK_M/BLOCK_N/BLOCK_K dimensions  \n  \u2022 Multi-query-head batch processing (GQA, 5:1 patterns)  \n  \u2022 Shared/L2 buffering, Tensor Core alignment (FP16/bf16/tf32)  \n  \u2022 Stride precomputation & pointer caching  \n\n==================== Output Format ====================\nReturn ONLY the complete updated code containing the EVOLVE-BLOCK comment marker.  \nNO explanations, NO markdown, NO additional text.\nName the output structure class as ModelNew.\n\n==================== Optimization Tips ====================\n\u2022 If previous compile failed: Fix syntax/mask/stride errors first  \n\u2022 If correctness fails: Prioritize bounds mask & dtype precision  \n\u2022 When speed_up < 1: Focus on memory access & block sizing  \n\u2022 Small iterative steps: Modify \u226420 lines per revision  \n\u2022 Maintain reversibility between versions\nHere is an example to show you how to rewrite a PyTorch implementation that quantizes a high-precision tensor to int8 dtype with row-wise granularity into a Triton implementation: \nThe original PyTorch implementation is as follows: \n``` \nimport torch\ndef per_row_quantize_int8(x: torch.Tensor) -> tuple[torch.Tensor, torch.Tensor]:\n    x_amax = x.abs().float().amax(dim=1).clamp(min=1e-4)\n    scale = 127 / x_amax\n    output = (x * scale[:, None]).round().clamp(-127, 127).to(torch.int8)\n    output_scale = x_amax / 127\n\n    return output, output_scale\n``` \nThe corresponding Triton-rewritten implementation is as follows: \n``` \nimport math\nimport torch\nimport triton\nimport triton.language as tl\nfrom triton.language.extra import libdevice\n\n# rowwise quantize\n\n@triton.autotune(\n    configs=[\n        triton.Config({}, num_stages=1, num_warps=8),\n        triton.Config({}, num_stages=2, num_warps=8),\n        triton.Config({}, num_stages=4, num_warps=8),\n        triton.Config({}, num_stages=8, num_warps=8),\n        triton.Config({}, num_stages=1),\n        triton.Config({}, num_stages=2),\n        triton.Config({}, num_stages=4),\n        triton.Config({}, num_stages=8),\n        triton.Config({}, num_warps=1),\n        triton.Config({}, num_warps=2),\n        triton.Config({}, num_warps=4),\n        triton.Config({}, num_warps=8),\n    ],\n    key=[\"n_elements\"],\n)\n\n@triton.jit\ndef _quantize_rowwise(\n    x_ptr,\n    output_ptr,\n    output_scale,\n    BLOCK_SIZE: tl.constexpr,\n    P2: tl.constexpr,\n):\n    pid = tl.program_id(axis=0)\n    block_start = pid * BLOCK_SIZE\n    arange = tl.arange(0, P2)\n    offsets = block_start + arange\n    row_mask = arange < BLOCK_SIZE\n    x = tl.load(x_ptr + offsets, mask=row_mask)\n\n    abs_x = tl.abs(x)\n    max_val = tl.max(tl.where(row_mask, abs_x, 0), axis=0)\n    output = libdevice.llrint(127.0 * (x / max_val))\n    tl.store(output_ptr + offsets, output, mask=row_mask)\n    tl.store(output_scale + pid, max_val / 127)\n\n\ndef per_row_quantize_int8(x: torch.Tensor):\n    x = x.contiguous()\n    output = torch.empty(*x.shape, device=x.device, dtype=torch.int8)\n    output_scale = torch.empty(x.shape[0], device=x.device, dtype=torch.float32)\n    P2 = int(2 ** (math.ceil(math.log2(x.shape[1]))))\n    grid = lambda x: (x.shape[0],)\n    _quantize_rowwise[grid](x, output, output_scale, BLOCK_SIZE=x.shape[1], P2=P2)\n\n    return output, output_scale\n\n\n    \n``` \n", "user": "# Current Program Information\n- Current performance metrics: - compiled: 1.0000\n- correctness: 1.0000\n- stage: success\n- passed: 0.0000\n- score: 20.0000\n- speed_up: 0.7010\n- runtime_ms: 0.1140\n- meta: {'hardware': 'NVIDIA L20Y', 'device': 'cuda:2', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.0799, 'speed_up': 0.701, 'custom_timing': 0.114}\n- Areas identified for improvement: - Consider simplifying the code to improve readability and maintainability\n- Metrics showing improvement: speed_up. Consider continuing with similar changes.\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Unknown changes\n- Performance: compiled: 1.0000, correctness: 0.0000, score: 10.0000, stage: wrong_answer, verify_payload: {'id': 'level2_30_Gemm_GroupNorm_Hardtanh', 'result': {'compiled': True, 'correctness': False, 'metadata': {'hardware': 'NVIDIA L20Y', 'device': 'cuda:3', 'max_difference': ['4.000000', '4.000000', '4.000000', '4.000000', '4.000000'], 'avg_difference': ['1.281136', '1.280133', '1.279754', '1.279154', '1.277905'], 'correctness_issue': 'Output mismatch', 'correctness_trials': '(0 / 5)', 'reference_timing_ms': 0.0799, 'speed_up': -1.0, 'custom_timing': -1.0}, 'runtime': -1.0, 'runtime_stats': {}}}\n- Outcome: Mixed results\n\n\n### Attempt 2\n- Changes: Unknown changes\n- Performance: compiled: 1.0000, correctness: 1.0000, stage: success, passed: 0.0000, score: 20.0000, speed_up: 0.6010, runtime_ms: 0.1330, meta: {'hardware': 'NVIDIA L20Y', 'device': 'cuda:3', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.0799, 'speed_up': 0.601, 'custom_timing': 0.133}\n- Outcome: Mixed results\n\n\n### Attempt 1\n- Changes: Unknown changes\n- Performance: compiled: 1.0000, correctness: 1.0000, stage: success, passed: 0.0000, score: 20.0000, speed_up: 0.7010, runtime_ms: 0.1140, meta: {'hardware': 'NVIDIA L20Y', 'device': 'cuda:2', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.0799, 'speed_up': 0.701, 'custom_timing': 0.114}\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 20.0000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\nimport math\n\n@triton.jit\ndef _gemm_kernel(\n    a_ptr, b_ptr, c_ptr, bias_ptr,\n    M, N, K,\n    stride_am, stride_ak,\n    stride_bk, stride_bn,\n    stride_cm, stride_cn,\n    BLOCK_SIZE_M: tl.constexpr,\n    BLOCK_SIZE_N: tl.constexpr,\n    BLOCK_SIZE_K: tl.constexpr,\n    GROUP_SIZE_M: tl.constexpr,\n    has_bias: tl.constexpr,\n):\n    pid = tl.program_id(0)\n    num_pid_m = tl.cdiv(M, BLOCK_SIZE_M)\n    num_pid_n = tl.cdiv(N, BLOCK_SIZE_N)\n    num_pid_in_group = GROUP_SIZE_M * num_pid_n\n    group_id = pid // num_pid_in_group\n    first_pid_m = group_id * GROUP_SIZE_M\n    group_size_m = min(num_pid_m - first_pid_m, GROUP_SIZE_M)\n    pid_m = first_pid_m + (pid % group_size_m)\n    pid_n = (pid % num_pid_in_group) // group_size_m\n\n    offs_m = pid_m * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)\n    offs_n = pid_n * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n    offs_k = tl.arange(0, BLOCK_SIZE_K)\n    a_ptrs = a_ptr + (offs_m[:, None] * stride_am + offs_k[None, :] * stride_ak)\n    b_ptrs = b_ptr + (offs_k[:, None] * stride_bk + offs_n[None, :] * stride_bn)\n    \n    accumulator = tl.zeros((BLOCK_SIZE_M, BLOCK_SIZE_N), dtype=tl.float32)\n    for k in range(0, tl.cdiv(K, BLOCK_SIZE_K)):\n        k_remaining = K - k * BLOCK_SIZE_K\n        k_mask = offs_k < k_remaining\n        a = tl.load(a_ptrs, mask=k_mask[None, :], other=0.0)\n        b = tl.load(b_ptrs, mask=k_mask[:, None], other=0.0)\n        accumulator = tl.dot(a, b, acc=accumulator, allow_tf32=True)\n        a_ptrs += BLOCK_SIZE_K * stride_ak\n        b_ptrs += BLOCK_SIZE_K * stride_bk\n\n    if has_bias:\n        bias_ptrs = bias_ptr + offs_n\n        bias = tl.load(bias_ptrs, mask=offs_n < N, other=0.0)\n        accumulator += bias[None, :]\n    \n    offs_cm = pid_m * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)\n    offs_cn = pid_n * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n    c_ptrs = c_ptr + (offs_cm[:, None] * stride_cm + offs_cn[None, :] * stride_cn)\n    mask = (offs_cm[:, None] < M) & (offs_cn[None, :] < N)\n    tl.store(c_ptrs, accumulator, mask=mask)\n\ndef triton_gemm(a, b, bias=None):\n    M, K = a.shape\n    K, N = b.shape\n    c = torch.empty((M, N), device=a.device, dtype=a.dtype)\n    \n    grid = lambda META: (triton.cdiv(M, META['BLOCK_SIZE_M']) * triton.cdiv(N, META['BLOCK_SIZE_N']),)\n    \n    _gemm_kernel[grid](\n        a, b, c, bias,\n        M, N, K,\n        a.stride(0), a.stride(1),\n        b.stride(0), b.stride(1),\n        c.stride(0), c.stride(1),\n        GROUP_SIZE_M=8,\n        BLOCK_SIZE_M=64,\n        BLOCK_SIZE_N=128,\n        BLOCK_SIZE_K=64,\n        has_bias=bias is not None\n    )\n    return c\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, num_groups, hardtanh_min, hardtanh_max):\n        super(ModelNew, self).__init__()\n        self.weight = nn.Parameter(torch.empty(out_features, in_features))\n        self.bias = nn.Parameter(torch.empty(out_features))\n        nn.init.kaiming_uniform_(self.weight, a=math.sqrt(5))\n        fan_in, _ = nn.init._calculate_fan_in_and_fan_out(self.weight)\n        bound = 1 / math.sqrt(fan_in) if fan_in > 0 else 0\n        nn.init.uniform_(self.bias, -bound, bound)\n        self.group_norm = nn.GroupNorm(num_groups, out_features)\n        self.hardtanh = nn.Hardtanh(min_val=hardtanh_min, max_val=hardtanh_max)\n\n    def forward(self, x):\n        x = triton_gemm(x, self.weight.t(), self.bias)\n        x = self.group_norm(x)\n        x = self.hardtanh(x)\n        return x\n\nbatch_size = 128\nin_features = 1024\nout_features = 512\nnum_groups = 8\nhardtanh_min = -2.0\nhardtanh_max = 2.0\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, num_groups, hardtanh_min, hardtanh_max]\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Performs well on compiled (1.0000), Performs well on correctness (1.0000), Performs well on stage (success), Performs well on passed (0.0000), Performs well on score (20.0000), Performs well on speed_up (0.7010), Performs well on runtime_ms (0.1140), Performs well on meta ({'hardware': 'NVIDIA L20Y', 'device': 'cuda:2', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.0799, 'speed_up': 0.701, 'custom_timing': 0.114})\n\n\n### Program 2 (Score: 20.0000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\nimport math\n\n# Triton kernel for fused Linear + Bias operation\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 256, 'BLOCK_SIZE_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 256, 'BLOCK_SIZE_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 32, 'BLOCK_SIZE_K': 32}, num_warps=4),\n    ],\n    key=['M', 'N', 'K'],\n)\n@triton.jit\ndef linear_kernel(\n    a_ptr, b_ptr, c_ptr, bias_ptr,\n    M, N, K,\n    stride_am, stride_ak,\n    stride_bn, stride_bk,\n    stride_cm, stride_cn,\n    BLOCK_SIZE_M: tl.constexpr,\n    BLOCK_SIZE_N: tl.constexpr,\n    BLOCK_SIZE_K: tl.constexpr,\n):\n    pid = tl.program_id(0)\n    num_pid_m = tl.cdiv(M, BLOCK_SIZE_M)\n    num_pid_n = tl.cdiv(N, BLOCK_SIZE_N)\n    pid_m = pid // num_pid_n\n    pid_n = pid % num_pid_n\n\n    offs_m = pid_m * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)\n    offs_n = pid_n * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n    offs_k = tl.arange(0, BLOCK_SIZE_K)\n    \n    a_ptrs = a_ptr + (offs_m[:, None] * stride_am + offs_k[None, :] * stride_ak)\n    b_ptrs = b_ptr + (offs_k[:, None] * stride_bk + offs_n[None, :] * stride_bn)\n    \n    accumulator = tl.zeros((BLOCK_SIZE_M, BLOCK_SIZE_N), dtype=tl.float32)\n    for k in range(0, tl.cdiv(K, BLOCK_SIZE_K)):\n        mask_a = (offs_m[:, None] < M) & (offs_k[None, :] < K - k * BLOCK_SIZE_K)\n        mask_b = (offs_k[:, None] < K - k * BLOCK_SIZE_K) & (offs_n[None, :] < N)\n        a = tl.load(a_ptrs, mask=mask_a, other=0.0)\n        b = tl.load(b_ptrs, mask=mask_b, other=0.0)\n        accumulator += tl.dot(a, b, allow_tf32=True)\n        a_ptrs += BLOCK_SIZE_K * stride_ak\n        b_ptrs += BLOCK_SIZE_K * stride_bk\n    \n    if bias_ptr is not None:\n        bias_ptrs = bias_ptr + offs_n\n        bias = tl.load(bias_ptrs, mask=offs_n < N, other=0.0)\n        accumulator += bias[None, :]\n    \n    offs_m = pid_m * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)\n    offs_n = pid_n * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n    c_ptrs = c_ptr + (offs_m[:, None] * stride_cm + offs_n[None, :] * stride_cn)\n    mask_c = (offs_m[:, None] < M) & (offs_n[None, :] < N)\n    tl.store(c_ptrs, accumulator, mask=mask_c)\n\n# Triton kernel for fused GroupNorm + HardTanh\n@triton.jit\ndef group_norm_hardtanh_kernel(\n    x_ptr, y_ptr, weight_ptr, bias_ptr,\n    M, N, num_groups, eps, min_val, max_val,\n    stride_xm, stride_xn,\n    stride_ym, stride_yn,\n    BLOCK_SIZE: tl.constexpr\n):\n    row = tl.program_id(0)\n    group_id = tl.program_id(1)\n    group_size = N // num_groups\n    start_col = group_id * group_size\n    cols = start_col + tl.arange(0, BLOCK_SIZE)\n    \n    x_ptrs = x_ptr + row * stride_xm + cols * stride_xn\n    mask = cols < (start_col + group_size)\n    x = tl.load(x_ptrs, mask=mask, other=0.0)\n    \n    # Compute mean and variance\n    mean = tl.sum(x, axis=0) / group_size\n    x_centered = tl.where(mask, x - mean, 0.0)\n    var = tl.sum(x_centered * x_centered, axis=0) / group_size + eps\n    rstd = 1.0 / tl.sqrt(var)\n    \n    # Normalize and apply affine transformation\n    w = tl.load(weight_ptr + cols, mask=mask, other=0.0)\n    b = tl.load(bias_ptr + cols, mask=mask, other=0.0)\n    y = (x_centered * rstd) * w + b\n    \n    # Apply HardTanh\n    y = tl.minimum(tl.maximum(y, min_val), max_val)\n    \n    # Store results\n    y_ptrs = y_ptr + row * stride_ym + cols * stride_yn\n    tl.store(y_ptrs, y, mask=mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, num_groups, hardtanh_min, hardtanh_max):\n        super().__init__()\n        self.in_features = in_features\n        self.out_features = out_features\n        self.num_groups = num_groups\n        self.hardtanh_min = hardtanh_min\n        self.hardtanh_max = hardtanh_max\n        \n        # Initialize parameters\n        self.weight = nn.Parameter(torch.empty(out_features, in_features))\n        self.bias = nn.Parameter(torch.empty(out_features))\n        self.gn_weight = nn.Parameter(torch.ones(out_features))\n        self.gn_bias = nn.Parameter(torch.zeros(out_features))\n        \n        # Reset parameters\n        nn.init.kaiming_uniform_(self.weight, a=math.sqrt(5))\n        fan_in, _ = nn.init._calculate_fan_in_and_fan_out(self.weight)\n        bound = 1 / math.sqrt(fan_in) if fan_in > 0 else 0\n        nn.init.uniform_(self.bias, -bound, bound)\n\n    def forward(self, x):\n        M, K = x.shape\n        N = self.out_features\n        \n        # Allocate output in float32 for kernel compatibility\n        output = torch.empty((M, N), device=x.device, dtype=torch.float32)\n        \n        # Use dictionary access for autotuner configuration\n        grid = lambda opt: (triton.cdiv(M, opt['BLOCK_SIZE_M']) * triton.cdiv(N, opt['BLOCK_SIZE_N']),)\n        linear_kernel[grid](\n            x, self.weight, output, self.bias,\n            M, N, K,\n            x.stride(0), x.stride(1),\n            self.weight.stride(0), self.weight.stride(1),\n            output.stride(0), output.stride(1),\n        )\n        \n        # Prepare for group norm\n        x_norm = torch.empty_like(output)\n        group_size = N // self.num_groups\n        BLOCK_SIZE = triton.next_power_of_2(group_size)\n        grid_norm = (M, self.num_groups)\n        \n        # Launch fused GroupNorm + HardTanh kernel\n        group_norm_hardtanh_kernel[grid_norm](\n            output, x_norm, self.gn_weight, self.gn_bias,\n            M, N, self.num_groups, 1e-5, self.hardtanh_min, self.hardtanh_max,\n            output.stride(0), output.stride(1),\n            x_norm.stride(0), x_norm.stride(1),\n            BLOCK_SIZE=BLOCK_SIZE\n        )\n        \n        return x_norm\n\nbatch_size = 128\nin_features = 1024\nout_features = 512\nnum_groups = 8\nhardtanh_min = -2.0\nhardtanh_max = 2.0\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, num_groups, hardtanh_min, hardtanh_max]\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Performs well on compiled (1.0000), Performs well on correctness (1.0000), Performs well on stage (success), Performs well on passed (0.0000), Performs well on score (20.0000), Performs well on speed_up (0.6010), Performs well on runtime_ms (0.1330), Performs well on meta ({'hardware': 'NVIDIA L20Y', 'device': 'cuda:3', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.0799, 'speed_up': 0.601, 'custom_timing': 0.133})\n\n\n### Program 3 (Score: 10.0000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n# Triton kernel for optimized linear layer\n@triton.jit\ndef linear_kernel(\n    x_ptr, \n    w_ptr, \n    b_ptr, \n    output_ptr,\n    in_features,\n    out_features,\n    stride_x,\n    stride_w,\n    stride_out,\n    BLOCK_SIZE: tl.constexpr,\n    BLOCK_K: tl.constexpr,\n):\n    pid_batch = tl.program_id(0)\n    pid_feature = tl.program_id(1)\n    \n    # Create ranges for vectorized operations\n    feature_offsets = pid_feature * BLOCK_SIZE + tl.arange(0, BLOCK_SIZE)\n    k_offsets = tl.arange(0, BLOCK_K)\n    \n    # Compute pointers for current batch\n    x_ptr += pid_batch * stride_x\n    output_ptr += pid_batch * stride_out\n    \n    # Initialize accumulator\n    acc = tl.zeros((BLOCK_SIZE,), dtype=tl.float32)\n    \n    # Blocked matrix multiplication\n    for k in range(0, in_features, BLOCK_K):\n        k_mask = k_offsets < (in_features - k)\n        w_mask = feature_offsets < out_features\n        \n        # Load input vector with coalesced access\n        x_vals = tl.load(x_ptr + k + k_offsets, mask=k_mask, other=0.0)\n        \n        # Load weight matrix with vectorization\n        w_vals = tl.load(\n            w_ptr + (k + k_offsets[:, None]) * stride_w + feature_offsets[None, :], \n            mask=k_mask[:, None] & w_mask[None, :], \n            other=0.0\n        )\n        \n        # Accumulate using tensor cores\n        acc += tl.sum(w_vals * x_vals[:, None], axis=0)\n    \n    # Add bias\n    b_vals = tl.load(b_ptr + feature_offsets, mask=feature_offsets < out_features, other=0.0)\n    acc += b_vals\n    \n    # Store output with coalesced access\n    tl.store(output_ptr + feature_offsets, acc, mask=feature_offsets < out_features)\n\n# Triton kernel for optimized group normalization\n@triton.jit\ndef group_norm_kernel(\n    x_ptr,\n    weight_ptr,\n    bias_ptr,\n    output_ptr,\n    num_groups,\n    group_size,\n    eps,\n    stride_x,\n    stride_out,\n    BLOCK_SIZE: tl.constexpr,\n):\n    pid = tl.program_id(0)\n    batch_id = pid // num_groups\n    group_id = pid % num_groups\n    \n    # Compute base pointers\n    base = batch_id * stride_x + group_id * group_size\n    offsets = tl.arange(0, BLOCK_SIZE)\n    mask = offsets < group_size\n    \n    # Load input with vectorization\n    x_vals = tl.load(x_ptr + base + offsets, mask=mask, other=0.0)\n    \n    # Compute mean and variance using online reduction\n    mean = tl.sum(x_vals, axis=0) / group_size\n    x_vals_centered = x_vals - mean\n    var = tl.sum(x_vals_centered * x_vals_centered, axis=0) / group_size\n    \n    # Normalize using fused operations\n    inv_std = 1.0 / tl.sqrt(var + eps)\n    normalized = x_vals_centered * inv_std\n    \n    # Apply affine transformation\n    weight = tl.load(weight_ptr + group_id * group_size + offsets, mask=mask, other=1.0)\n    bias = tl.load(bias_ptr + group_id * group_size + offsets, mask=mask, other=0.0)\n    out_vals = normalized * weight + bias\n    \n    # Store output with coalesced access\n    tl.store(output_ptr + base + offsets, out_vals, mask=mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, num_groups, hardtanh_min, hardtanh_max):\n        super(ModelNew, self).__init__()\n        self.in_features = in_features\n        self.out_features = out_features\n        self.num_groups = num_groups\n        self.group_size = out_features // num_groups\n        \n        # Initialize parameters\n        self.weight = nn.Parameter(torch.randn(out_features, in_features))\n        self.bias = nn.Parameter(torch.zeros(out_features))\n        self.gn_weight = nn.Parameter(torch.ones(out_features))\n        self.gn_bias = nn.Parameter(torch.zeros(out_features))\n        \n        # HardTanh activation\n        self.hardtanh = nn.Hardtanh(min_val=hardtanh_min, max_val=hardtanh_max)\n        \n        # Ensure tensor memory layout optimization\n        self.weight_t = None\n\n    def forward(self, x):\n        # Precompute transposed weight for efficient access\n        if self.weight_t is None or self.weight_t.shape != self.weight.t().shape:\n            self.weight_t = self.weight.t().contiguous()\n        \n        # Allocate output tensor\n        output_linear = torch.empty(x.shape[0], self.out_features, device=x.device, dtype=x.dtype)\n        \n        # Launch linear kernel with optimized grid\n        grid_linear = (x.shape[0], triton.cdiv(self.out_features, 128))\n        linear_kernel[grid_linear](\n            x, self.weight_t, self.bias, output_linear,\n            self.in_features, self.out_features,\n            x.stride(0), self.weight_t.stride(0), output_linear.stride(0),\n            BLOCK_SIZE=128, BLOCK_K=64\n        )\n        \n        # Allocate group norm output\n        output_gn = torch.empty_like(output_linear)\n        \n        # Launch group norm kernel\n        grid_gn = (x.shape[0] * self.num_groups,)\n        group_norm_kernel[grid_gn](\n            output_linear, self.gn_weight, self.gn_bias, output_gn,\n            self.num_groups, self.group_size, 1e-5,\n            output_linear.stride(0), output_gn.stride(0),\n            BLOCK_SIZE=triton.next_power_of_2(self.group_size)\n        )\n        \n        # Apply HardTanh activation\n        return self.hardtanh(output_gn)\n\nbatch_size = 128\nin_features = 1024\nout_features = 512\nnum_groups = 8\nhardtanh_min = -2.0\nhardtanh_max = 2.0\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features, device='cuda')]\n\ndef get_init_inputs():\n    return [in_features, out_features, num_groups, hardtanh_min, hardtanh_max]\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Performs well on compiled (1.0000), Performs well on correctness (0.0000), Performs well on score (10.0000), Performs well on stage (wrong_answer), Performs well on verify_payload ({'id': 'level2_30_Gemm_GroupNorm_Hardtanh', 'result': {'compiled': True, 'correctness': False, 'metadata': {'hardware': 'NVIDIA L20Y', 'device': 'cuda:3', 'max_difference': ['4.000000', '4.000000', '4.000000', '4.000000', '4.000000'], 'avg_difference': ['1.281136', '1.280133', '1.279754', '1.279154', '1.277905'], 'correctness_issue': 'Output mismatch', 'correctness_trials': '(0 / 5)', 'reference_timing_ms': 0.0799, 'speed_up': -1.0, 'custom_timing': -1.0}, 'runtime': -1.0, 'runtime_stats': {}}})\n\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 10.0000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport math\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n# Optimized Triton GEMM kernel with fixed bias handling\n@triton.jit\ndef gemm_kernel(\n    a_ptr, b_ptr, c_ptr, bias_ptr,\n    M, N, K,\n    stride_am, stride_ak,\n    stride_bk, stride_bn,\n    stride_cm, stride_cn,\n    BLOCK_SIZE_M: tl.constexpr,\n    BLOCK_SIZE_N: tl.constexpr,\n    BLOCK_SIZE_K: tl.constexpr,\n    GROUP_SIZE_M: tl.constexpr,\n):\n    pid = tl.program_id(axis=0)\n    num_pid_n = tl.cdiv(N, BLOCK_SIZE_N)\n    num_pid_m = tl.cdiv(M, BLOCK_SIZE_M)\n    num_pid_in_group = GROUP_SIZE_M * num_pid_n\n    group_id = pid // num_pid_in_group\n    first_pid_m = group_id * GROUP_SIZE_M\n    group_size_m = min(num_pid_m - first_pid_m, GROUP_SIZE_M)\n    pid_m = first_pid_m + (pid % group_size_m)\n    pid_n = (pid % num_pid_in_group) // group_size_m\n\n    offs_am = pid_m * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)\n    offs_bn = pid_n * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n    offs_k = tl.arange(0, BLOCK_SIZE_K)\n    a_ptrs = a_ptr + (offs_am[:, None] * stride_am + offs_k[None, :] * stride_ak)\n    b_ptrs = b_ptr + (offs_k[:, None] * stride_bk + offs_bn[None, :] * stride_bn)\n\n    acc = tl.zeros((BLOCK_SIZE_M, BLOCK_SIZE_N), dtype=tl.float32)\n    for k in range(0, tl.cdiv(K, BLOCK_SIZE_K)):\n        k_remaining = K - k * BLOCK_SIZE_K\n        k_mask = offs_k < k_remaining\n        a = tl.load(a_ptrs, mask=k_mask[None, :], other=0.0)\n        b = tl.load(b_ptrs, mask=k_mask[:, None], other=0.0)\n        acc += tl.dot(a, b, allow_tf32=True)\n        a_ptrs += BLOCK_SIZE_K * stride_ak\n        b_ptrs += BLOCK_SIZE_K * stride_bk\n\n    # Always add bias (model always has bias)\n    bias = tl.load(bias_ptr + offs_bn, mask=offs_bn < N, other=0.0)\n    acc += bias[None, :]\n\n    offs_cm = pid_m * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)\n    offs_cn = pid_n * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n    c_ptrs = c_ptr + stride_cm * offs_cm[:, None] + stride_cn * offs_cn[None, :]\n    mask = (offs_cm[:, None] < M) & (offs_cn[None, :] < N)\n    tl.store(c_ptrs, acc, mask=mask)\n\n# Corrected fused GroupNorm + HardTanh kernel\n@triton.jit\ndef group_norm_hardtanh_kernel(\n    x_ptr, y_ptr, weight_ptr, bias_ptr,\n    num_rows, num_cols, num_groups,\n    min_val, max_val, eps,\n    stride_xr, stride_xc,\n    stride_yr, stride_yc,\n    BLOCK_SIZE: tl.constexpr,\n):\n    row_idx = tl.program_id(0)\n    group_idx = tl.program_id(1)\n    \n    group_size = num_cols // num_groups\n    start_col = group_idx * group_size\n    col_offsets = start_col + tl.arange(0, BLOCK_SIZE)\n    col_mask = col_offsets < (start_col + group_size)\n    mask = col_offsets < num_cols\n    \n    x_ptrs = x_ptr + row_idx * stride_xr + col_offsets * stride_xc\n    x_vals = tl.load(x_ptrs, mask=col_mask, other=0.0)\n    \n    # Compute mean and variance for the group\n    mean = tl.sum(x_vals, axis=0) / group_size\n    x_centered = x_vals - mean\n    var = tl.sum(x_centered * x_centered, axis=0) / group_size\n    inv_std = 1.0 / tl.sqrt(var + eps)\n    \n    # Load normalization parameters\n    w_vals = tl.load(weight_ptr + col_offsets, mask=col_mask, other=0.0)\n    b_vals = tl.load(bias_ptr + col_offsets, mask=col_mask, other=0.0)\n    \n    # Apply normalization and affine transformation\n    normalized = x_centered * inv_std\n    affine = normalized * w_vals + b_vals\n    \n    # Apply HardTanh activation\n    clamped = tl.minimum(tl.maximum(affine, min_val), max_val)\n    \n    # Store results\n    y_ptrs = y_ptr + row_idx * stride_yr + col_offsets * stride_yc\n    tl.store(y_ptrs, clamped, mask=mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, num_groups, hardtanh_min, hardtanh_max):\n        super(ModelNew, self).__init__()\n        self.in_features = in_features\n        self.out_features = out_features\n        self.num_groups = num_groups\n        self.hardtanh_min = hardtanh_min\n        self.hardtanh_max = hardtanh_max\n        \n        self.weight = nn.Parameter(torch.empty(out_features, in_features))\n        self.bias = nn.Parameter(torch.empty(out_features))\n        self.weight_gn = nn.Parameter(torch.ones(out_features))\n        self.bias_gn = nn.Parameter(torch.zeros(out_features))\n        \n        nn.init.kaiming_uniform_(self.weight, a=math.sqrt(5))\n        fan_in, _ = nn.init._calculate_fan_in_and_fan_out(self.weight)\n        bound = 1 / math.sqrt(fan_in) if fan_in > 0 else 0\n        nn.init.uniform_(self.bias, -bound, bound)\n\n    def forward(self, x):\n        batch_size, _ = x.shape\n        gemm_output = torch.empty((batch_size, self.out_features), device=x.device, dtype=torch.float32)\n        \n        # Launch optimized GEMM kernel\n        M, N, K = batch_size, self.out_features, self.in_features\n        grid = lambda META: (triton.cdiv(M, META['BLOCK_SIZE_M']) * triton.cdiv(N, META['BLOCK_SIZE_N']),)\n        gemm_kernel[grid](\n            x, self.weight, gemm_output, self.bias,\n            M, N, K,\n            x.stride(0), x.stride(1),\n            self.weight.stride(0), self.weight.stride(1),\n            gemm_output.stride(0), gemm_output.stride(1),\n            BLOCK_SIZE_M=64, \n            BLOCK_SIZE_N=128,\n            BLOCK_SIZE_K=32,\n            GROUP_SIZE_M=8\n        )\n        \n        # Launch fused kernel\n        output = torch.empty_like(gemm_output)\n        group_size = self.out_features // self.num_groups\n        grid_gn = (batch_size, self.num_groups)\n        \n        group_norm_hardtanh_kernel[grid_gn](\n            gemm_output, output, self.weight_gn, self.bias_gn,\n            batch_size, self.out_features, self.num_groups,\n            self.hardtanh_min, self.hardtanh_max, 1e-5,\n            gemm_output.stride(0), gemm_output.stride(1),\n            output.stride(0), output.stride(1),\n            BLOCK_SIZE=group_size\n        )\n        \n        return output\n\nbatch_size = 128\nin_features = 1024\nout_features = 512\nnum_groups = 8\nhardtanh_min = -2.0\nhardtanh_max = 2.0\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, num_groups, hardtanh_min, hardtanh_max]\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Alternative approach to compiled, Alternative approach to correctness\n\n\n\n\n# Current Program\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\nimport math\n\n@triton.jit\ndef _gemm_kernel(\n    a_ptr, b_ptr, c_ptr, bias_ptr,\n    M, N, K,\n    stride_am, stride_ak,\n    stride_bk, stride_bn,\n    stride_cm, stride_cn,\n    BLOCK_SIZE_M: tl.constexpr,\n    BLOCK_SIZE_N: tl.constexpr,\n    BLOCK_SIZE_K: tl.constexpr,\n    GROUP_SIZE_M: tl.constexpr,\n    has_bias: tl.constexpr,\n):\n    pid = tl.program_id(0)\n    num_pid_m = tl.cdiv(M, BLOCK_SIZE_M)\n    num_pid_n = tl.cdiv(N, BLOCK_SIZE_N)\n    num_pid_in_group = GROUP_SIZE_M * num_pid_n\n    group_id = pid // num_pid_in_group\n    first_pid_m = group_id * GROUP_SIZE_M\n    group_size_m = min(num_pid_m - first_pid_m, GROUP_SIZE_M)\n    pid_m = first_pid_m + (pid % group_size_m)\n    pid_n = (pid % num_pid_in_group) // group_size_m\n\n    offs_m = pid_m * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)\n    offs_n = pid_n * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n    offs_k = tl.arange(0, BLOCK_SIZE_K)\n    a_ptrs = a_ptr + (offs_m[:, None] * stride_am + offs_k[None, :] * stride_ak)\n    b_ptrs = b_ptr + (offs_k[:, None] * stride_bk + offs_n[None, :] * stride_bn)\n    \n    accumulator = tl.zeros((BLOCK_SIZE_M, BLOCK_SIZE_N), dtype=tl.float32)\n    for k in range(0, tl.cdiv(K, BLOCK_SIZE_K)):\n        k_remaining = K - k * BLOCK_SIZE_K\n        k_mask = offs_k < k_remaining\n        a = tl.load(a_ptrs, mask=k_mask[None, :], other=0.0)\n        b = tl.load(b_ptrs, mask=k_mask[:, None], other=0.0)\n        accumulator = tl.dot(a, b, acc=accumulator, allow_tf32=True)\n        a_ptrs += BLOCK_SIZE_K * stride_ak\n        b_ptrs += BLOCK_SIZE_K * stride_bk\n\n    if has_bias:\n        bias_ptrs = bias_ptr + offs_n\n        bias = tl.load(bias_ptrs, mask=offs_n < N, other=0.0)\n        accumulator += bias[None, :]\n    \n    offs_cm = pid_m * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)\n    offs_cn = pid_n * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n    c_ptrs = c_ptr + (offs_cm[:, None] * stride_cm + offs_cn[None, :] * stride_cn)\n    mask = (offs_cm[:, None] < M) & (offs_cn[None, :] < N)\n    tl.store(c_ptrs, accumulator, mask=mask)\n\ndef triton_gemm(a, b, bias=None):\n    M, K = a.shape\n    K, N = b.shape\n    c = torch.empty((M, N), device=a.device, dtype=a.dtype)\n    \n    grid = lambda META: (triton.cdiv(M, META['BLOCK_SIZE_M']) * triton.cdiv(N, META['BLOCK_SIZE_N']),)\n    \n    _gemm_kernel[grid](\n        a, b, c, bias,\n        M, N, K,\n        a.stride(0), a.stride(1),\n        b.stride(0), b.stride(1),\n        c.stride(0), c.stride(1),\n        GROUP_SIZE_M=8,\n        BLOCK_SIZE_M=64,\n        BLOCK_SIZE_N=128,\n        BLOCK_SIZE_K=64,\n        has_bias=bias is not None\n    )\n    return c\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, num_groups, hardtanh_min, hardtanh_max):\n        super(ModelNew, self).__init__()\n        self.weight = nn.Parameter(torch.empty(out_features, in_features))\n        self.bias = nn.Parameter(torch.empty(out_features))\n        nn.init.kaiming_uniform_(self.weight, a=math.sqrt(5))\n        fan_in, _ = nn.init._calculate_fan_in_and_fan_out(self.weight)\n        bound = 1 / math.sqrt(fan_in) if fan_in > 0 else 0\n        nn.init.uniform_(self.bias, -bound, bound)\n        self.group_norm = nn.GroupNorm(num_groups, out_features)\n        self.hardtanh = nn.Hardtanh(min_val=hardtanh_min, max_val=hardtanh_max)\n\n    def forward(self, x):\n        x = triton_gemm(x, self.weight.t(), self.bias)\n        x = self.group_norm(x)\n        x = self.hardtanh(x)\n        return x\n\nbatch_size = 128\nin_features = 1024\nout_features = 512\nnum_groups = 8\nhardtanh_min = -2.0\nhardtanh_max = 2.0\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, num_groups, hardtanh_min, hardtanh_max]\n# =================== EVOLVE-BLOCK-END ===================\n```\n\n# Task\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```\n", "responses": ["<think>\nWe are given a program that currently has a speedup of 0.701 (which is less than 1, meaning slower than the reference). The goal is to improve the speedup to at least 1.05 (5% faster) and ideally more.\n\nThe current program uses a Triton GEMM kernel for the linear layer and then uses PyTorch's built-in GroupNorm and Hardtanh. The main bottleneck is likely that the GroupNorm and Hardtanh are not fused and are implemented in PyTorch, which may involve multiple passes over the data.\n\nTo improve performance, we can:\n1. Fuse the GroupNorm and Hardtanh into a single Triton kernel to reduce memory passes and leverage kernel fusion.\n2. Optimize the GEMM kernel further by tuning the block sizes and using autotuning.\n\nHowever, note that the current GEMM kernel is already using a block tiling strategy and allows for Tensor Core usage (via `allow_tf32=True`). We might improve it by using autotuning to find the best block sizes for the given problem on the target hardware.\n\nBut the bigger win is likely in fusing the GroupNorm and Hardtanh. The current program does:\n   x = triton_gemm(...)  # outputs a tensor\n   x = self.group_norm(x)  # PyTorch GroupNorm (not fused, and might involve multiple kernels)\n   x = self.hardtanh(x)   # PyTorch Hardtanh (another kernel)\n\nWe can replace the last two steps with a single Triton kernel that does:\n   - Loads the output of GEMM\n   - Performs group normalization (per group: compute mean and variance, then normalize)\n   - Applies Hardtanh activation\n\nThis fusion avoids writing the intermediate GEMM result to global memory and then reading it back for normalization and activation.\n\nPlan:\n1. We'll create a new Triton kernel for fused GroupNorm + Hardtanh.\n2. We'll replace the PyTorch GroupNorm and Hardtanh with a call to this fused kernel.\n3. We'll adjust the ModelNew.forward method accordingly.\n\nAdditionally, we note that the current GEMM kernel does not use autotuning. We can add autotuning to the GEMM kernel to pick the best configuration for the given M, N, K.\n\nHowever, note that the problem size is fixed (batch_size=128, in_features=1024, out_features=512). We can hardcode the best configuration for this size, but using autotuning is more flexible.\n\nGiven the constraints (only change the EVOLVE-BLOCK), we will:\n\nStep 1: Fuse GroupNorm and Hardtanh\n   - Write a Triton kernel `group_norm_hardtanh_kernel` that does:\n        For each row and each group in that row:\n            - Load the data for the group\n            - Compute mean and variance\n            - Normalize: (x - mean) / sqrt(var + eps)\n            - Apply affine transformation: weight * x + bias\n            - Apply Hardtanh: clamp between min_val and max_val\n            - Store the result\n\nStep 2: Modify the forward function to use the fused kernel for GroupNorm and Hardtanh.\n\nStep 3: Since the current GEMM kernel does not use autotuning, we will add autotuning to it. We can define several configurations and let Triton choose the best.\n\nBut note: the current GEMM kernel is called with fixed block sizes (64, 128, 64). We can replace the `_gemm_kernel` with an autotuned version.\n\nHowever, to keep the changes within the allowed constraints and to avoid making the code too long, we might focus on the fusion first because that is likely the main bottleneck.\n\nWe note that the current GEMM kernel is slow (0.7x) and the fused kernel might help, but also the GEMM kernel might need tuning.\n\nBut the problem size (M=128, N=512, K=1024) is small enough that autotuning might be crucial.\n\nWe will do:\n   - Add autotuning to the GEMM kernel.\n   - Fuse the GroupNorm and Hardtanh.\n\nLet's break down the changes:\n\n1. GEMM Kernel with Autotuning:\n   - We will define multiple configurations for BLOCK_SIZE_M, BLOCK_SIZE_N, BLOCK_SIZE_K, and num_warps.\n   - We will wrap the GEMM kernel with `@triton.autotune`.\n\n2. Fused GroupNorm and Hardtanh Kernel:\n   - We will write a kernel that takes the output of GEMM and applies group normalization and Hardtanh in one go.\n\nImportant: The current program uses the PyTorch GroupNorm and Hardtanh, which are in float32. Our fused kernel must be numerically equivalent.\n\nWe'll design the fused kernel as:\n\n   @triton.jit\n   def group_norm_hardtanh_fused(\n        x_ptr,          // input tensor (output of GEMM)\n        y_ptr,          // output tensor\n        weight_ptr,     // weight for group norm (of size out_features)\n        bias_ptr,       // bias for group norm (of size out_features)\n        M,              // number of rows (batch_size)\n        N,              // number of columns (out_features)\n        num_groups,     // number of groups\n        eps,            // epsilon for stability\n        min_val,        // hardtanh_min\n        max_val,        // hardtanh_max\n        stride_x,       // stride for x (in terms of elements)\n        stride_y,       // stride for y\n        BLOCK_SIZE: tl.constexpr,  // the block size (must be >= group_size? actually group_size = N // num_groups)\n   ):\n        # We use 2D grid: [M, num_groups]\n        row_idx = tl.program_id(0)\n        group_idx = tl.program_id(1)\n\n        group_size = N // num_groups\n        start_col = group_idx * group_size\n        col_offsets = tl.arange(0, BLOCK_SIZE)\n        mask = col_offsets < group_size\n\n        # Pointers to the current row and group\n        x_row_ptr = x_ptr + row_idx * stride_x\n        y_row_ptr = y_ptr + row_idx * stride_y\n\n        # Load the current group's data\n        x_ptrs = x_row_ptr + start_col + col_offsets\n        x_vals = tl.load(x_ptrs, mask=mask, other=0.0)\n\n        # Compute mean and variance\n        mean = tl.sum(x_vals, axis=0) / group_size\n        x_centered = x_vals - mean\n        var = tl.sum(x_centered * x_centered, axis=0) / group_size\n        inv_std = 1.0 / tl.sqrt(var + eps)\n\n        # Normalize\n        normalized = x_centered * inv_std\n\n        # Affine transformation: load weight and bias for the group\n        w_ptrs = weight_ptr + start_col + col_offsets\n        b_ptrs = bias_ptr + start_col + col_offsets\n        w = tl.load(w_ptrs, mask=mask, other=0.0)\n        b = tl.load(b_ptrs, mask=mask, other=0.0)\n        out = normalized * w + b\n\n        # Apply Hardtanh\n        out = tl.minimum(tl.maximum(out, min_val), max_val)\n\n        # Store\n        y_ptrs = y_row_ptr + start_col + col_offsets\n        tl.store(y_ptrs, out, mask=mask)\n\n3. In the forward function of ModelNew:\n   - Instead of:\n        x = triton_gemm(...)\n        x = self.group_norm(x)\n        x = self.hardtanh(x)\n   - We will do:\n        gemm_output = triton_gemm(...)   # This is the output of the GEMM (with bias added)\n        # Now apply fused groupnorm and hardtanh\n        # We need to allocate output tensor for the fused kernel\n        output = torch.empty_like(gemm_output)\n        # The group norm parameters are stored in the model as self.gn_weight and self.gn_bias? \n        # But note: the current ModelNew uses nn.GroupNorm, which we are removing.\n\n   However, the current ModelNew does not have separate parameters for group norm. We are using the built-in GroupNorm module. We need to replace that with our own parameters.\n\n   So we will change the model:\n        Remove: \n            self.group_norm = nn.GroupNorm(...)\n            self.hardtanh = nn.Hardtanh(...)\n        Instead, we will create:\n            self.gn_weight = nn.Parameter(torch.ones(out_features))\n            self.gn_bias = nn.Parameter(torch.zeros(out_features))\n\n   And then in the forward function, we call the fused kernel with:\n        group_norm_hardtanh_fused[grid](gemm_output, output, self.gn_weight, self.gn_bias, ...)\n\n   The grid should be (M, num_groups) and we set BLOCK_SIZE to the group_size (which must be a power of two? We can use triton.next_power_of_2 and then mask).\n\n   But note: the group_size is out_features // num_groups, and we are given that num_groups=8 and out_features=512, so group_size=64.\n\n   We can set BLOCK_SIZE = 64 (which is a power of two) and then we don't need masking for the group? Actually we do because the group might not be contiguous in memory? But it is. However, we are using a 1D block per group.\n\n   Alternatively, we can set BLOCK_SIZE to the group_size and it must be a power of two? Actually Triton requires that the block size is a power of two. So we can set BLOCK_SIZE = triton.next_power_of_2(group_size). Since group_size=64, which is a power of two, we can use 64.\n\n   Steps for the forward function:\n        M, N = gemm_output.shape   # M = batch_size, N = out_features\n        group_size = N // self.num_groups\n        # We require that N is divisible by num_groups? Yes, by GroupNorm.\n        BLOCK_SIZE = triton.next_power_of_2(group_size)   # 64 in this case\n        grid = (M, self.num_groups)\n        group_norm_hardtanh_fused[grid](\n            gemm_output, output, self.gn_weight, self.gn_bias,\n            M, N, self.num_groups,\n            1e-5, self.hardtanh_min, self.hardtanh_max,\n            gemm_output.stride(0), output.stride(0),\n            BLOCK_SIZE=BLOCK_SIZE\n        )\n\n   And then return output.\n\nBut note: the current ModelNew uses the built-in GroupNorm which has its own weight and bias. We are replacing it with our own parameters (gn_weight and gn_bias). We must initialize them appropriately.\n\nIn the __init__:\n   Instead of:\n        self.group_norm = nn.GroupNorm(num_groups, out_features)\n        self.hardtanh = nn.Hardtanh(...)\n\n   We do:\n        self.gn_weight = nn.Parameter(torch.ones(out_features))\n        self.gn_bias = nn.Parameter(torch.zeros(out_features))\n\n   And remove the old modules.\n\nAlso, note: the built-in GroupNorm has learnable affine parameters. Our approach also uses learnable affine parameters.\n\nBut note: the built-in GroupNorm uses per-channel scale and bias, which is what we are doing.\n\nSo the plan is:\n\n   We will completely remove the use of PyTorch's GroupNorm and Hardtanh and replace them with a fused Triton kernel and our own parameters.\n\nGiven the above, we will rewrite the entire EVOLVE-BLOCK.\n\nHowever, note that the problem is fixed: batch_size=128, in_features=1024, out_features=512, num_groups=8, hardtanh_min=-2.0, hardtanh_max=2.0.\n\nWe will now write the code accordingly.\n\nBut note: the current GEMM kernel is also slow. We will add autotuning to it.\n\nWe will define an autotuned GEMM kernel. We can take inspiration from the top-performing programs in the history.\n\nLet's combine:\n\n   - Autotuned GEMM kernel (with multiple configurations)\n   - Fused GroupNorm + Hardtanh kernel\n\nWe must be cautious because the EVOLVE-BLOCK must contain the entire code for the new model.\n\nWe'll structure the code:\n\n   import ... (same as before)\n\n   # Autotuned GEMM kernel\n   @triton.autotune(...)\n   @triton.jit\n   def gemm_kernel(...): ...   [with the same functionality as the current _gemm_kernel but autotuned]\n\n   # Fused GroupNorm + Hardtanh kernel\n   @triton.jit\n   def group_norm_hardtanh_fused(...): ...\n\n   Then the function that calls the GEMM kernel (like triton_gemm) and the ModelNew.\n\nWe note that the current triton_gemm function is defined and then used. We'll keep that function but with the autotuned kernel.\n\nWe are going to change the ModelNew class to have our own parameters for group norm and remove the built-in modules.\n\nLet's write the code accordingly.\n\nNote: We must not change the function signatures of the ModelNew's __init__ and forward.\n\nWe are allowed to change the internal implementation.\n\nWe'll do:\n\n   class ModelNew(nn.Module):\n        def __init__(self, in_features, out_features, num_groups, hardtanh_min, hardtanh_max):\n            ... same as before for weight and bias of the linear layer.\n            Then:\n                self.gn_weight = nn.Parameter(torch.ones(out_features))\n                self.gn_bias = nn.Parameter(torch.zeros(out_features))\n                # We store the hardtanh parameters as scalars (they are not learnable)\n                self.hardtanh_min = hardtanh_min\n                self.hardtanh_max = hardtanh_max\n\n        def forward(self, x):\n            gemm_output = triton_gemm(x, self.weight.t(), self.bias)   # same as before\n            # Now apply fused kernel\n            M, N = gemm_output.shape\n            output = torch.empty_like(gemm_output)\n            group_size = N // self.num_groups\n            BLOCK_SIZE = triton.next_power_of_2(group_size)\n            grid = (M, self.num_groups)\n            group_norm_hardtanh_fused[grid](\n                gemm_output, output, self.gn_weight, self.gn_bias,\n                M, N, self.num_groups,\n                1e-5, self.hardtanh_min, self.hardtanh_max,\n                gemm_output.stride(0), output.stride(0),\n                BLOCK_SIZE=BLOCK_SIZE\n            )\n            return output\n\nWe must be cautious with the strides: the kernel uses row-major contiguous tensors? We assume they are contiguous. We can enforce contiguous in the kernel call if necessary.\n\nNow, let's write the entire code block.\n\nNote: We are replacing the entire EVOLVE-BLOCK.\n\nWe'll base the GEMM kernel on the current one but add autotuning.\n\nWe'll define several configurations for the GEMM kernel. We choose block sizes that are powers of two and that are known to work well on H100.\n\nExample configurations for GEMM (for M=128, N=512, K=1024) might include:\n   BLOCK_SIZE_M = 64, BLOCK_SIZE_N = 64, BLOCK_SIZE_K = 64\n   BLOCK_SIZE_M = 128, BLOCK_SIZE_N = 128, BLOCK_SIZE_K = 32\n   ... etc.\n\nWe'll define a list of configurations.\n\nGiven the above, we write the code.\n\nIMPORTANT: The current program has a speedup of 0.7. We hope to achieve at least 1.05.\n\nLet's code accordingly.\n</think>\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\nimport math\n\n# Fused GroupNorm + Hardtanh kernel\n@triton.jit\ndef group_norm_hardtanh_kernel(\n    x_ptr, y_ptr, weight_ptr, bias_ptr,\n    M, N, num_groups, eps, min_val, max_val,\n    stride_xm, stride_xn,\n    stride_ym, stride_yn,\n    BLOCK_SIZE: tl.constexpr\n):\n    row = tl.program_id(0)\n    group_id = tl.program_id(1)\n    group_size = N // num_groups\n    start_col = group_id * group_size\n    cols = start_col + tl.arange(0, BLOCK_SIZE)\n    \n    x_ptrs = x_ptr + row * stride_xm + cols * stride_xn\n    mask = cols < (start_col + group_size)\n    x = tl.load(x_ptrs, mask=mask, other=0.0)\n    \n    # Compute mean and variance\n    mean = tl.sum(x, axis=0) / group_size\n    x_centered = tl.where(mask, x - mean, 0.0)\n    var = tl.sum(x_centered * x_centered, axis=0) / group_size + eps\n    rstd = 1.0 / tl.sqrt(var)\n    \n    # Normalize and apply affine transformation\n    w = tl.load(weight_ptr + cols, mask=mask, other=0.0)\n    b = tl.load(bias_ptr + cols, mask=mask, other=0.0)\n    y = (x_centered * rstd) * w + b\n    \n    # Apply Hardtanh\n    y = tl.minimum(tl.maximum(y, min_val), max_val)\n    \n    # Store results\n    y_ptrs = y_ptr + row * stride_ym + cols * stride_yn\n    tl.store(y_ptrs, y, mask=mask)\n\n# Autotuned GEMM kernel\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 256, 'BLOCK_SIZE_K': 64}, num_warps=8),\n        triton.Config({'BLOCK_SIZE_M': 256, 'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 64}, num_warps=8),\n    ],\n    key=['M', 'N', 'K'],\n)\n@triton.jit\ndef gemm_kernel(\n    a_ptr, b_ptr, c_ptr, bias_ptr,\n    M, N, K,\n    stride_am, stride_ak,\n    stride_bk, stride_bn,\n    stride_cm, stride_cn,\n    BLOCK_SIZE_M: tl.constexpr,\n    BLOCK_SIZE_N: tl.constexpr,\n    BLOCK_SIZE_K: tl.constexpr,\n    GROUP_SIZE_M: tl.constexpr,\n    has_bias: tl.constexpr,\n):\n    pid = tl.program_id(0)\n    num_pid_m = tl.cdiv(M, BLOCK_SIZE_M)\n    num_pid_n = tl.cdiv(N, BLOCK_SIZE_N)\n    num_pid_in_group = GROUP_SIZE_M * num_pid_n\n    group_id = pid // num_pid_in_group\n    first_pid_m = group_id * GROUP_SIZE_M\n    group_size_m = min(num_pid_m - first_pid_m, GROUP_SIZE_M)\n    pid_m = first_pid_m + (pid % group_size_m)\n    pid_n = (pid % num_pid_in_group) // group_size_m\n\n    offs_m = pid_m * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)\n    offs_n = pid_n * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n    offs_k = tl.arange(0, BLOCK_SIZE_K)\n    a_ptrs = a_ptr + (offs_m[:, None] * stride_am + offs_k[None, :] * stride_ak)\n    b_ptrs = b_ptr + (offs_k[:, None] * stride_bk + offs_n[None, :] * stride_bn)\n    \n    accumulator = tl.zeros((BLOCK_SIZE_M, BLOCK_SIZE_N), dtype=tl.float32)\n    for k in range(0, tl.cdiv(K, BLOCK_SIZE_K)):\n        k_remaining = K - k * BLOCK_SIZE_K\n        k_mask = offs_k < k_remaining\n        a = tl.load(a_ptrs, mask=k_mask[None, :], other=0.0)\n        b = tl.load(b_ptrs, mask=k_mask[:, None], other=0.0)\n        accumulator = tl.dot(a, b, acc=accumulator, allow_tf32=True)\n        a_ptrs += BLOCK_SIZE_K * stride_ak\n        b_ptrs += BLOCK_SIZE_K * stride_bk\n\n    if has_bias:\n        bias_ptrs = bias_ptr + offs_n\n        bias = tl.load(bias_ptrs, mask=offs_n < N, other=0.0)\n        accumulator += bias[None, :]\n    \n    offs_cm = pid_m * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)\n    offs_cn = pid_n * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n    c_ptrs = c_ptr + (offs_cm[:, None] * stride_cm + offs_cn[None, :] * stride_cn)\n    mask = (offs_cm[:, None] < M) & (offs_cn[None, :] < N)\n    tl.store(c_ptrs, accumulator, mask=mask)\n\ndef triton_gemm(a, b, bias=None):\n    M, K = a.shape\n    K, N = b.shape\n    c = torch.empty((M, N), device=a.device, dtype=a.dtype)\n    \n    grid = lambda META: (triton.cdiv(M, META['BLOCK_SIZE_M']) * triton.cdiv(N, META['BLOCK_SIZE_N']),)\n    \n    gemm_kernel[grid](\n        a, b, c, bias,\n        M, N, K,\n        a.stride(0), a.stride(1),\n        b.stride(0), b.stride(1),\n        c.stride(0), c.stride(1),\n        GROUP_SIZE_M=8,\n        has_bias=bias is not None\n    )\n    return c\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, num_groups, hardtanh_min, hardtanh_max):\n        super(ModelNew, self).__init__()\n        self.in_features = in_features\n        self.out_features = out_features\n        self.num_groups = num_groups\n        self.hardtanh_min = hardtanh_min\n        self.hardtanh_max = hardtanh_max\n        \n        self.weight = nn.Parameter(torch.empty(out_features, in_features))\n        self.bias = nn.Parameter(torch.empty(out_features))\n        self.gn_weight = nn.Parameter(torch.ones(out_features))\n        self.gn_bias = nn.Parameter(torch.zeros(out_features))\n        \n        nn.init.kaiming_uniform_(self.weight, a=math.sqrt(5))\n        fan_in, _ = nn.init._calculate_fan_in_and_fan_out(self.weight)\n        bound = 1 / math.sqrt(fan_in) if fan_in > 0 else 0\n        nn.init.uniform_(self.bias, -bound, bound)\n\n    def forward(self, x):\n        gemm_output = triton_gemm(x, self.weight.t(), self.bias)\n        M, N = gemm_output.shape\n        output = torch.empty_like(gemm_output)\n        group_size = N // self.num_groups\n        BLOCK_SIZE = triton.next_power_of_2(group_size)\n        grid = (M, self.num_groups)\n        \n        group_norm_hardtanh_kernel[grid](\n            gemm_output, output, self.gn_weight, self.gn_bias,\n            M, N, self.num_groups, 1e-5,\n            self.hardtanh_min, self.hardtanh_max,\n            gemm_output.stride(0), gemm_output.stride(1),\n            output.stride(0), output.stride(1),\n            BLOCK_SIZE=BLOCK_SIZE\n        )\n        return output\n\nbatch_size = 128\nin_features = 1024\nout_features = 512\nnum_groups = 8\nhardtanh_min = -2.0\nhardtanh_max = 2.0\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, num_groups, hardtanh_min, hardtanh_max]\n# =================== EVOLVE-BLOCK-END ===================\n```"]}}}