{"id": "4c658be5-7d71-4760-966f-007020008e65", "code": "# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef _adaptive_avg_pool2d_kernel(\n    x_ptr,\n    output_ptr,\n    stride_b,\n    stride_c,\n    height,\n    width,\n    output_stride_b,\n    output_stride_c,\n    CHANNELS_PER_BLOCK: tl.constexpr,\n    BLOCK_SPATIAL: tl.constexpr,\n):\n    pid_batch = tl.program_id(0)\n    pid_channel_block = tl.program_id(1)\n    spatial_size = height * width\n    \n    # Compute channel indices for this block\n    channel_start = pid_channel_block * CHANNELS_PER_BLOCK\n    channel_ids = channel_start + tl.arange(0, CHANNELS_PER_BLOCK)\n    channel_mask = channel_ids < stride_c  # stride_c = num_channels\n    \n    # Base offset for this batch\n    batch_offset = pid_batch * stride_b\n    \n    # Initialize accumulator\n    accumulator = tl.zeros((CHANNELS_PER_BLOCK,), dtype=tl.float32)\n    \n    # Process spatial dimension in blocks\n    for spatial_start in range(0, spatial_size, BLOCK_SPATIAL):\n        spatial_idx = spatial_start + tl.arange(0, BLOCK_SPATIAL)\n        spatial_mask = spatial_idx < spatial_size\n        \n        # Compute offsets and load data\n        offsets = batch_offset + channel_ids * stride_c + spatial_idx[:, None]\n        mask = spatial_mask[:, None] & channel_mask[None, :]\n        data = tl.load(x_ptr + offsets, mask=mask, other=0.0)\n        \n        # Accumulate sum\n        accumulator += tl.sum(data, axis=0)\n    \n    # Compute average\n    avg = accumulator / spatial_size\n    \n    # Store results\n    output_offsets = pid_batch * output_stride_b + channel_ids * output_stride_c\n    tl.store(output_ptr + output_offsets, avg, mask=channel_mask)\n\ndef adaptive_avg_pool2d_1x1(x):\n    batch, channels, height, width = x.shape\n    output = torch.empty((batch, channels), device=x.device, dtype=x.dtype)\n    spatial_size = height * width\n    \n    # Configure kernel launch parameters\n    CHANNELS_PER_BLOCK = 128\n    BLOCK_SPATIAL = 64\n    grid = (batch, triton.cdiv(channels, CHANNELS_PER_BLOCK))\n    \n    _adaptive_avg_pool2d_kernel[grid](\n        x, output,\n        x.stride(0), channels,  # Use channels for boundary check\n        height, width,\n        output.stride(0), output.stride(1),\n        CHANNELS_PER_BLOCK=CHANNELS_PER_BLOCK,\n        BLOCK_SPATIAL=BLOCK_SPATIAL,\n        num_warps=4\n    )\n    return output\n\nclass DenseBlock(nn.Module):\n    def __init__(self, num_layers: int, num_input_features:\u6781 int, growth_rate: int):\n        \"\"\"\n        :param num_layers: The number of layers in the dense block\n        :param num_input_features: The number of input feature maps\n        :param growth_rate: The growth rate for the dense block (new features added per layer)\n        \"\"\"\n        super(DenseBlock, self).__init__()\n        layers = []\n        for i in range(num_layers):\n            layers.append(self._make_layer(num_input_features + i * growth_rate, growth_rate))\n        self.layers = nn.ModuleList(layers)\n\n    def _make_layer(self, in_features: int, growth_rate: int):\n        \"\"\"\n        Creates a single layer with BatchNorm, ReLU, Conv2D, and Dropout.\n        \"\"\"\n        return nn.Sequential(\n            nn.BatchNorm2d(in_features),\n            nn.ReLU(inplace=True),\n            nn.Conv2d(in_features, growth_rate, kernel_size=3, padding=1, bias=False),\n            nn.Dropout(0.0)\n        )\n\n    def forward(self, x):\n        \"\"\"\n        :param x: Input tensor of shape (batch_size, num_input_features, height, width)\n        :return: Concatenated output tensor with shape (batch_size, num_output_features, height, width)\n        \"\"\"\n        features = [x]\n        for layer in self.layers:\n            new_feature = layer(x)\n            features.append(new_feature)\n            x = torch.cat(f\u6781atures, 1)  # Concatenate along channel axis\n        return x\n\nclass TransitionLayer(nn.Module):\n    def __init__(self, num_input_features: int, num_output_features: int):\n        \"\"\"\n        :param num_input_features: The number of input feature maps\n        :param num_output_features: The number of output feature maps\n        \"\"\"\n        super(TransitionLayer, self).__init__()\n        self.transition = nn.Sequential(\n            nn.BatchNorm2d(num_input_features),\n            nn.ReLU(inplace=True),\n            nn.Conv2d(num_input_features, num_output_features, kernel_size=1, bias=False),\n            nn.AvgPool2d(kernel_size=2, stride=2)\n        )\n\n    def forward(self, x):\n        \"\"\"\n        :param x: Input tensor of shape (batch_size, num_input_features, height, width)\n        :return: Downsampled tensor with reduced number of feature maps\n        \"\"\"\n        return self.transition(x)\n\nclass ModelNew(nn.Module):\n    def __init__(self, growth_rate: int = 32, num_classes: int = 1000):\n        \"\"\"\n        :param growth_rate: The growth rate of the DenseNet (new features added per layer)\n        :param num_classes: The number of output classes for classification\n        \"\"\"\n        super(ModelNew, self).__init__()\n\n        # Initial convolution and pooling\n        self.features = nn.Sequential(\n            nn.Conv2d(3, 64, kernel_size=7, stride=2, padding=3, bias=False),\n            nn.BatchNorm2d(64),\n            nn.ReLU(inplace=True),\n            nn.MaxPool2d(kernel_size=3, stride=2, padding=1)\n        )\n\n        # Each dense block is followed by a transition layer, except the last one\n        num_features = 64\n        block_layers = [6, 12, 24, 16]  # Corresponding layers in DenseNet121\n\n        self.dense_blocks = nn.ModuleList()\n        self.transition_layers = nn.ModuleList()\n\n        for i, num_layers in enumerate(block_layers):\n            block = DenseBlock(num_layers=num_layers, num_input_features=num_features, growth_rate=growth_rate)\n            self.dense_blocks.append(block)\n            num_features = num_features + num_layers * growth_rate\n\n            if i != len(block_layers) - 1:\n                transition = TransitionLayer(num_input_features=num_features, num_output_features=num_features // 2)\n                self.transition_layers.append(transition)\n                num_features = num_features // 2\n\n        # Final batch norm and classifier\n        self.final_bn = nn.BatchNorm2d(num_features)\n        self.classifier = nn.Linear(num_features, num_classes)\n\n    def forward(self, x: torch.Tensor) -> torch.Tensor:\n        \"\"\"\n        :param x: Input tensor of shape (batch_size, 3, height, width)\n        :return: Output tensor of shape (batch_size, num_classes)\n        \"\"\"\n        # Convert input to channels-last format for optimized convolution performance\n        x = x.contiguous(memory_format=torch.channels_last)\n        x = self.features(x)\n\n        for i, block in enumerate(self.dense_blocks):\n            x = block(x)\n            if i != len(self.dense_blocks) - 1:\n                x = self.transition_layers[i](x)\n\n        x = self.final_bn(x)\n        x = F.relu(x, inplace=True)\n        \n        # Convert to contiguous format for Triton kernel\n        x = x.contiguous(memory_format=torch.contiguous_format)\n        x = adaptive_avg_pool2d_1x1(x)\n        x = self.classifier(x)\n        return x\n\n# Testing the DenseNet121 model\nbatch_size = 10\nnum_classes = 10\nheight, width = 224, 224  # Standard input size for DenseNet\n\ndef get_inputs():\n    return [torch.randn(batch_size, 3, height, width)]\n\ndef get_init_inputs():\n    return [32, num_classes]\n\n# =================== EVOLVE-BLOCK-END ===================", "language": "python", "parent_id": "37cbc183-dcb7-48c9-ba15-d2f242ebd33d", "generation": 3, "timestamp": 1754593384.2357516, "iteration_found": 23, "metrics": {"compiled": false, "correctness": false, "score": 1, "stage": "compile_error", "compile_log": "", "exec_log": "[Child] \u7ed1\u5b9a GPU 4, torch sees 1 device(s)\n\n[Exception]\nTraceback (most recent call last):\n  File \"/cpfs01/shared/llm_kernel/hujiakai/KernelLLM/validation_api_server/code_executor.py\", line 71, in _exec_worker\n    exec(textwrap.dedent(code_src), mod.__dict__)\n  File \"<string>\", line 78\n    def __init__(self, num_layers: int, num_input_features:\u6781 int, growth_rate: int):\n                                                           ^^^^^\nSyntaxError: invalid syntax. Perhaps you forgot a comma?\n", "exit_code": "1"}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": false, "score": 20, "speed_up": 0.909, "runtime_ms": 6.45, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:5", "correctness_trials": "(5 / 5)", "reference_timing_ms": 5.86, "speed_up": 0.909, "custom_timing": 6.45}}, "island": 0}, "artifacts_json": null, "artifact_dir": null}