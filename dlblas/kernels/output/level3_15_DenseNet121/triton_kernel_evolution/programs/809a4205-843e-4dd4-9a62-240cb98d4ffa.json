{"id": "809a4205-843e-4dd4-9a62-240cb98d4ffa", "code": "# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef _adaptive_avg_pool2d_kernel(\n    x_ptr,\n    output_ptr,\n    stride_b,\n    stride_c,\n    spatial_size,\n    output_stride_b,\n    output_stride_c,\n    BLOCK_CHANNELS: tl.constexpr,\n    BLOCK_SPATIAL: tl.constexpr,\n):\n    pid_batch = tl.program_id(0)\n    pid_channel_block = tl.program_id(1)\n    \n    # Channel indices for this block\n    channel_offset = pid_channel_block * BLOCK_CHANNELS\n    channel_indices = tl.arange(0, BLOCK_CHANNELS)\n    global_channel = channel_offset + channel_indices\n    channel_mask = global_channel < output_ptr.shape[1]  # Channels in output\n    \n    # Batch base pointer\n    base_batch = pid_batch * stride_b\n    \n    # Initialize accumulators\n    accumulators = tl.zeros((BLOCK_CHANNELS,), dtype=tl.float32)\n    \n    # Process spatial dimension in chunks\n    for spatial_start in range(0, spatial_size, BLOCK_SPATIAL):\n        spatial_idx = spatial_start + tl.arange(0, BLOCK_SPATIAL)\n        spatial_mask = spatial_idx < spatial_size\n        \n        # Compute pointers for vectorized load\n        ptrs = base_batch + (global_channel[:, None] * stride_c) + spatial_idx[None, :]\n        mask_2d = channel_mask[:, None] & spatial_mask[None, :]\n        \n        # Vectorized load and reduction\n        values = tl.load(x_ptr + ptrs, mask=mask_2d, other=0.0)\n        accumulators += tl.sum(values, axis=1)\n    \n    # Compute average and store\n    avg = accumulators / spatial_size\n    output_ptrs = output_ptr + pid_batch * output_stride_b + global_channel * output_stride_c\n    tl.store(output_ptrs, avg, mask=channel_mask)\n\ndef adaptive_avg_pool2d_1x1(x):\n    batch, channels, height, width = x.shape\n    output = torch.empty((batch, channels), device=x.device, dtype=x.dtype)\n    spatial_size = height * width\n    \n    # Configure kernel blocks\n    BLOCK_CHANNELS = 128\n    BLOCK_SPATIAL = 128\n    grid = (batch, triton.cdiv(channels, BLOCK_CHANNELS))\n    \n    # Launch kernel\n    _adaptive_avg_pool2d_kernel[grid](\n        x, output,\n        x.stride(0), x.stride(1),\n        spatial_size,\n        output.stride(0), output.stride(1),\n        BLOCK_CHANNELS=BLOCK_CHANNELS,\n        BLOCK_SPATIAL=BLOCK_SPATIAL,\n        num_warps=4\n    )\n    return output\n\nclass DenseBlock(nn.Module):\n    def __init__(self, num_layers: int, num_input_features: int, growth_rate: int):\n        \"\"\"\n        :param num_layers: The number of layers in the dense block\n        :param num_input_features: The number of input feature maps\n        :param growth_rate: The growth rate for the dense block (new features added per layer)\n        \"\"\"\n        super(DenseBlock, self).__init__()\n        layers = []\n        for i in range(num_layers):\n            layers.append(self._make_layer(num_input_features + i * growth_rate, growth_rate))\n        self.layers = nn.ModuleList(layers)\n\n    def _make_layer(self, in_features: int, growth_rate: int):\n        \"\"\"\n        Creates a single layer with BatchNorm, ReLU, Conv2D, and Dropout.\n        \"\"\"\n        return nn.Sequential(\n            nn.BatchNorm2d(in_features),\n            nn.ReLU(inplace=True),\n            nn.Conv2d(in_features, growth_rate, kernel_size=3, padding=1, bias=False),\n            nn.Dropout(0.0)\n        )\n\n    def forward(self, x):\n        \"\"\"\n        :param x: Input tensor of shape (batch_size, num_input_features, height, width)\n        :return: Concatenated output tensor with shape (batch_size, num_output_features, height, width)\n        \"\"\"\n        features = [x]\n        for layer in self.layers:\n            new_feature = layer(x)\n            features.append(new_feature)\n            x = torch.cat(features, 1)  # Concatenate along channel axis\n        return x\n\nclass TransitionLayer(nn.Module):\n    def __init__(self, num_input_features: int, num_output_features: int):\n        \"\"\"\n        :param num_input_features: The number of input feature maps\n        :param num_output_features: The number of output feature maps\n        \"\"\"\n        super(TransitionLayer, self).__init__()\n        self.transition = nn.Sequential(\n            nn.BatchNorm2d(num_input_features),\n            nn.ReLU(inplace=True),\n            nn.Conv2d(num_input_features, num_output_features, kernel_size=1, bias=False),\n            nn.AvgPool2d(kernel_size=2, stride=2)\n        )\n\n    def forward(self, x):\n        \"\"\"\n        :param x: Input tensor of shape (batch_size, num_input_features, height, width)\n        :return: Downsampled tensor with reduced number of feature maps\n        \"\"\"\n        return self.transition(x)\n\nclass ModelNew(nn.Module):\n    def __init__(self, growth_rate: int = 32, num_classes: int = 1000):\n        \"\"\"\n        :param growth_rate: The growth rate of the DenseNet (new features added per layer)\n        :param num_classes: The number of output classes for classification\n        \"\"\"\n        super(ModelNew, self).__init__()\n\n        # Initial convolution and pooling\n        self.features = nn.Sequential(\n            nn.Conv2d(3, 64, kernel_size=7, stride=2, padding=3, bias=False),\n            nn.BatchNorm2d(64),\n            nn.ReLU(inplace=True),\n            nn.MaxPool2d(kernel_size=3, stride=2, padding=1)\n        )\n\n        # Each dense block is followed by a transition layer, except the last one\n        num_features = 64\n        block_layers = [6, 12, 24, 16]  # Corresponding layers in DenseNet121\n\n        self.dense_blocks = nn.ModuleList()\n        self.transition_layers = nn.ModuleList()\n\n        for i, num_layers in enumerate(block_layers):\n            block = DenseBlock(num_layers=num_layers, num_input_features=num_features, growth_rate=growth_rate)\n            self.dense_blocks.append(block)\n            num_features = num_features + num_layers * growth_rate\n\n            if i != len(block_layers) - 1:\n                transition = TransitionLayer(num_input_features=num_features, num_output_features=num_features // 2)\n                self.transition_layers.append(transition)\n                num_features = num_features // 2\n\n        # Final batch norm and classifier\n        self.final_bn = nn.BatchNorm2d(num_features)\n        self.classifier = nn.Linear(num_features, num_classes)\n\n    def forward(self, x: torch.Tensor) -> torch.Tensor:\n        \"\"\"\n        :param x: Input tensor of shape (batch_size, 3, height, width)\n        :return: Output tensor of shape (batch_size, num_classes)\n        \"\"\"\n        # Convert input to channels-last format for optimized convolution performance\n        x = x.contiguous(memory_format=torch.channels_last)\n        x = self.features(x)\n\n        for i, block in enumerate(self.dense_blocks):\n            x = block(x)\n            if i != len(self.dense_blocks) - 1:\n                x = self.transition_layers[i](x)\n\n        x = self.final_bn(x)\n        x = F.relu(x, inplace=True)\n        \n        # Convert to contiguous format for Triton kernel\n        x = x.contiguous(memory_format=torch.contiguous_format)\n        x = adaptive_avg_pool2d_1x1(x)\n        x = self.classifier(x)\n        return x\n\n# Testing the DenseNet121 model\nbatch_size = 10\nnum_classes = 10\nheight, width = 224, 224  # Standard input size for DenseNet\n\ndef get_inputs():\n    return [torch.randn(batch_size, 3, height, width)]\n\ndef get_init_inputs():\n    return [32, num_classes]\n\n# =================== EVOLVE-BLOCK-END ===================", "language": "python", "parent_id": "37cbc183-dcb7-48c9-ba15-d2f242ebd33d", "generation": 3, "timestamp": 1754593290.585983, "iteration_found": 20, "metrics": {"compiled": true, "correctness": false, "score": 10, "stage": "wrong_answer", "verify_payload": {"id": "level3_15_DenseNet121", "result": {"compiled": true, "correctness": false, "metadata": {"hardware": "NVIDIA L20Y", "device": "cuda:0", "runtime_error": "Traceback (most recent call last):\n  File \"/cpfs01/shared/llm_kernel/hujiakai/KernelLLM/validation_api_server/helpers/evaluations.py\", line 720, in run_and_check_correctness\n    output_new = model_new(*inputs)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1773, in _wrapped_call_impl\n    return self._call_impl(*args, **kwargs)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1784, in _call_impl\n    return forward_call(*args, **kwargs)\n  File \"/tmp/tmp0hdpmlr0.py\", line 188, in forward\n    x = adaptive_avg_pool2d_1x1(x)\n  File \"/tmp/tmp0hdpmlr0.py\", line 64, in adaptive_avg_pool2d_1x1\n    _adaptive_avg_pool2d_kernel[grid](\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 390, in <lambda>\n    return lambda *args, **kwargs: self.run(grid=grid, warmup=False, *args, **kwargs)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 594, in run\n    kernel = self.compile(src, target=target, options=options.__dict__)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/compiler/compiler.py\", line 339, in compile\n    module = src.make_ir(options, codegen_fns, module_map, context)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/compiler/compiler.py\", line 83, in make_ir\n    return ast_to_ttir(self.fn, self, context=context, options=options, codegen_fns=codegen_fns,\ntriton.compiler.errors.CompilationError: at 19:36:\n    output_stride_c,\n    BLOCK_CHANNELS: tl.constexpr,\n    BLOCK_SPATIAL: tl.constexpr,\n):\n    pid_batch = tl.program_id(0)\n    pid_channel_block = tl.program_id(1)\n\n    # Channel indices for this block\n    channel_offset = pid_channel_block * BLOCK_CHANNELS\n    channel_indices = tl.arange(0, BLOCK_CHANNELS)\n    global_channel = channel_offset + channel_indices\n    channel_mask = global_channel < output_ptr.shape[1]  # Channels in output\n                                    ^\nIndexError('list index out of range')\n\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/language/core.py\", line 1289, in __getitem__\n    return self.values[idx]\nIndexError: list index out of range\n", "runtime_error_name": "triton.compiler.errors.CompilationError", "reference_timing_ms": 5.86, "speed_up": -1.0, "custom_timing": -1.0}, "runtime": -1.0, "runtime_stats": {}}}}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": false, "score": 20, "speed_up": 0.909, "runtime_ms": 6.45, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:5", "correctness_trials": "(5 / 5)", "reference_timing_ms": 5.86, "speed_up": 0.909, "custom_timing": 6.45}}, "island": 2}, "artifacts_json": null, "artifact_dir": null}