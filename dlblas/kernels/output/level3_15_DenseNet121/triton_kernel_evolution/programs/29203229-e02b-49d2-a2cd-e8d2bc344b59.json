{"id": "29203229-e02b-49d2-a2cd-e8d2bc344b59", "code": "# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef adaptive_avg_pool2d_kernel(\n    input_ptr,\n    output_ptr,\n    input_batch_stride,\n    input_channel_stride,\n    input_height_stride,\n    input_width_stride,\n    output_batch_stride,\n    output_channel_stride,\n    height,\n    width,\n    BLOCK_SIZE: tl.constexpr,\n):\n    # Parallelize across spatial dimensions\n    pid_b = tl.program_id(0)\n    pid_c = tl.program_id(1)\n    pid_h = tl.program_id(2)\n    \n    input_offset = pid_b * input_batch_stride + pid_c * input_channel_stride\n    num_blocks_h = tl.cdiv(height, BLOCK_SIZE)\n    \n    # Initialize accumulator\n    acc = tl.zeros((), tl.float32)\n    h_start = pid_h * BLOCK_SIZE\n    h_end = tl.minimum((pid_h + 1) * BLOCK_SIZE, height)\n    \n    # Process horizontal blocks in parallel\n    for h in range(h_start, h_end):\n        h_offset = h * input_height_stride\n        for w in range(0, width):\n            offset = input_offset + h_offset + w * input_width_stride\n            val = tl.load(input_ptr + offset)\n            acc += val\n    \n    # Store partial sum\n    partial_sum_ptr = output_ptr + pid_b * output_batch_stride + pid_c * output_channel_stride + pid_h\n    tl.store(partial_sum_ptr, acc)\n\ndef adaptive_avg_pool2d_triton(x: torch.Tensor) -> torch.Tensor:\n    B, C, H, W = x.shape\n    output = torch.empty((B, C, 1, 1), device=x.device, dtype=x.dtype)\n    \n    # Determine optimal block size\n    BLOCK_SIZE = 32\n    num_blocks_h = (H + BLOCK_SIZE - 1) // BLOCK_SIZE\n    grid = (B, C, num_blocks_h)\n    \n    # First kernel: compute partial sums\n    partial_sums = torch.empty((B, C, num_blocks_h), device=x.device, dtype=torch.float32)\n    adaptive_avg_pool2d_kernel[grid](\n        x,\n        partial_sums,\n        x.stride(0),\n        x.stride(1),\n        x.stride(2),\n        x.stride(3),\n        partial_sums.stride(0),\n        partial_sums.stride(1),\n        H,\n        W,\n        BLOCK_SIZE=BLOCK_SIZE\n    )\n    \n    # Second kernel: reduce partial sums\n    @triton.jit\n    def reduce_kernel(partial_ptr, output_ptr, \n                      partial_batch_stride, partial_channel_stride,\n                      output_batch_stride, output_channel_stride,\n                      num_blocks: tl.constexpr):\n        pid_b = tl.program_id(0)\n        pid_c = tl.program_id(1)\n        \n        partial_offset = pid_b * partial_batch_stride + pid_c * partial_channel_stride\n        acc = tl.zeros((), tl.float32)\n        \n        for i in range(0, num_blocks):\n            val = tl.load(partial_ptr + partial_offset + i)\n            acc += val\n        \n        avg = acc / (H * W)\n        output_offset = pid_b * output_batch_stride + pid_c * output_channel_stride\n        tl.store(output_ptr + output_offset, avg)\n    \n    reduce_kernel[(B, C)](\n        partial_sums,\n        output,\n        partial_sums.stride(0),\n        partial_sums.stride(1),\n        output.stride(0),\n        output.stride(1),\n        num_blocks=num_blocks_h\n    )\n    \n    return output\n\nclass DenseBlock(nn.Module):\n    def __init__(self, num_layers: int, num_input_features: int, growth_rate: int):\n        super(DenseBlock, self).__init__()\n        layers = []\n        for i in range(num_layers):\n            layers.append(self._make_layer(num_input_features + i * growth_rate, growth_rate))\n        self.layers = nn.ModuleList(layers)\n\n    def _make_layer(self, in_features: int, growth_rate: int):\n        return nn.Sequential(\n            nn.BatchNorm2d(in_features),\n            nn.ReLU(inplace=True),\n            nn.Conv2d(in_features, growth_rate, kernel_size=3, padding=1, bias=False),\n            nn.Dropout(0.0)\n        )\n\n    def forward(self, x):\n        features = [x]\n        for layer in self.layers:\n            new_feature = layer(x)\n            features.append(new_feature)\n            x = torch.cat(features, 1)\n        return x\n\nclass TransitionLayer(nn.Module):\n    def __init__(self, num_input_features: int, num_output_features: int):\n        super(TransitionLayer, self).__init__()\n        self.transition = nn.Sequential(\n            nn.BatchNorm2d(num_input_features),\n            nn.ReLU(inplace=True),\n            nn.Conv2d(num_input_features, num_output_features, kernel_size=1, bias=False),\n            nn.AvgPool2d(kernel_size=2, stride=2)\n        )\n\n    def forward(self, x):\n        return self.transition(x)\n\nclass ModelNew(nn.Module):\n    def __init__(self, growth_rate: int = 32, num_classes: int = 1000):\n        super(ModelNew, self).__init__()\n        self.features = nn.Sequential(\n            nn.Conv2d(3, 64, kernel_size=7, stride=2, padding=3, bias=False),\n            nn.BatchNorm2d(64),\n            nn.ReLU(inplace=True),\n            nn.MaxPool2d(kernel_size=3, stride=2, padding=1)\n        )\n\n        num_features = 64\n        block_layers = [6, 12, 24, 16]\n\n        self.dense_blocks = nn.ModuleList()\n        self.transition_layers = nn.ModuleList()\n\n        for i, num_layers in enumerate(block_layers):\n            block = DenseBlock(num_layers=num_layers, num_input_features=num_features, growth_rate=growth_rate)\n            self.dense_blocks.append(block)\n            num_features = num_features + num_layers * growth_rate\n\n            if i != len(block_layers) - 1:\n                transition = TransitionLayer(num_input_features=num_features, num_output_features=num_features // 2)\n                self.transition_layers.append(transition)\n                num_features = num_features // 2\n\n        self.final_bn = nn.BatchNorm2d(num_features)\n        self.classifier = nn.Linear(num_features, num_classes)\n\n    def forward(self, x: torch.Tensor) -> torch.Tensor:\n        x = x.contiguous(memory_format=torch.channels_last)\n        x = self.features(x)\n\n        for i, block in enumerate(self.dense_blocks):\n            x = block(x)\n            if i != len(self.dense_blocks) - 1:\n                x = self.transition_layers[i](x)\n\n        x = self.final_bn(x)\n        x = F.relu(x, inplace=True)\n        x = adaptive_avg_pool2d_triton(x)\n        x = x.view(x.size(0), -1)\n        x = self.classifier(x)\n        return x\n\n# Testing the DenseNet121 model\nbatch_size = 10\nnum_classes = 10\nheight, width = 224, 224\n\ndef get_inputs():\n    return [torch.randn(batch_size, 3, height, width)]\n\ndef get_init_inputs():\n    return [32, num_classes]\n\n# =================== EVOLVE-BLOCK-END ===================", "language": "python", "parent_id": "7b90a1a3-acf2-42c3-a966-5c79799ca89b", "generation": 5, "timestamp": 1754593596.6807687, "iteration_found": 24, "metrics": {"compiled": true, "correctness": false, "score": 10, "stage": "wrong_answer", "verify_payload": {"id": "level3_15_DenseNet121", "result": {"compiled": true, "correctness": false, "metadata": {"hardware": "NVIDIA L20Y", "device": "cuda:0", "runtime_error": "Traceback (most recent call last):\n  File \"/cpfs01/shared/llm_kernel/hujiakai/KernelLLM/validation_api_server/helpers/evaluations.py\", line 720, in run_and_check_correctness\n    output_new = model_new(*inputs)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1773, in _wrapped_call_impl\n    return self._call_impl(*args, **kwargs)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1784, in _call_impl\n    return forward_call(*args, **kwargs)\n  File \"/tmp/tmpjvhduvbk.py\", line 181, in forward\n    x = adaptive_avg_pool2d_triton(x)\n  File \"/tmp/tmpjvhduvbk.py\", line 92, in adaptive_avg_pool2d_triton\n    reduce_kernel[(B, C)](\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 390, in <lambda>\n    return lambda *args, **kwargs: self.run(grid=grid, warmup=False, *args, **kwargs)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 594, in run\n    kernel = self.compile(src, target=target, options=options.__dict__)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/compiler/compiler.py\", line 339, in compile\n    module = src.make_ir(options, codegen_fns, module_map, context)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/compiler/compiler.py\", line 83, in make_ir\n    return ast_to_ttir(self.fn, self, context=context, options=options, codegen_fns=codegen_fns,\ntriton.compiler.errors.CompilationError: at 15:17:\n                  num_blocks: tl.constexpr):\n    pid_b = tl.program_id(0)\n    pid_c = tl.program_id(1)\n\n    partial_offset = pid_b * partial_batch_stride + pid_c * partial_channel_stride\n    acc = tl.zeros((), tl.float32)\n\n    for i in range(0, num_blocks):\n        val = tl.load(partial_ptr + partial_offset + i)\n        acc += val\n\n    avg = acc / (H * W)\n                 ^\nNameError(\"Cannot access global variable H from within @jit'ed function. Triton kernels can only access global variables that are instanstiated as constexpr (`x = triton.language.constexpr(42)`). Note that this is different from annotating a variable as constexpr (`x: triton.language.constexpr = 42`), which is not supported.  Alternatively, set the envvar TRITON_ALLOW_NON_CONSTEXPR_GLOBALS=1, but we do not promise to support this forever.\")\n\n\nThe above exception was the direct cause of the following exception:\n\nNameError: Cannot access global variable H from within @jit'ed function. Triton kernels can only access global variables that are instanstiated as constexpr (`x = triton.language.constexpr(42)`). Note that this is different from annotating a variable as constexpr (`x: triton.language.constexpr = 42`), which is not supported.  Alternatively, set the envvar TRITON_ALLOW_NON_CONSTEXPR_GLOBALS=1, but we do not promise to support this forever.\n", "runtime_error_name": "triton.compiler.errors.CompilationError", "reference_timing_ms": 5.86, "speed_up": -1.0, "custom_timing": -1.0}, "runtime": -1.0, "runtime_stats": {}}}}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": false, "score": 20, "speed_up": 0.913, "runtime_ms": 6.42, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:0", "correctness_trials": "(5 / 5)", "reference_timing_ms": 5.86, "speed_up": 0.913, "custom_timing": 6.42}}, "island": 1}, "artifacts_json": null, "artifact_dir": null}