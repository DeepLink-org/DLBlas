{"id": "4bb26511-b913-4706-bbc3-16e51f37446e", "code": "import triton\nimport triton.language as tl\n\n@triton.jit\ndef softmax_kernel(\n    output_ptr, input_ptr, input_row_stride, output_row_stride, n_cols, \n    BLOCK_SIZE: tl.constexpr\n):\n    row_idx = tl.program_id(0)\n    row_start = row_idx * input_row_stride\n    row_start_output = row_idx * output_row_stride\n    \n    row_max = tl.full((), -float('inf'), dtype=tl.float32)\n    row_sum = tl.full((), 0.0, dtype=tl.float32)\n    \n    # First pass: online computation of max and sum\n    for col_offset in range(0, n_cols, BLOCK_SIZE):\n        col_offsets = tl.arange(0, BLOCK_SIZE) + col_offset\n        mask = col_offsets < n_cols\n        input_ptrs = input_ptr + row_start + col_offsets\n        chunk = tl.load(input_ptrs, mask=mask, other=-float('inf'))\n        \n        local_max = tl.max(chunk, axis=0)\n        new_max = tl.maximum(row_max, local_max)\n        \n        scale = tl.exp(row_max - new_max)\n        row_sum = row_sum * scale\n        \n        exp_vals = tl.exp(chunk - new_max)\n        chunk_sum = tl.sum(exp_vals, axis=0)\n        row_sum += chunk_sum\n        row_max = new_max\n    \n    # Second pass: compute and store softmax\n    for col_offset in range(0, n_cols, BLOCK_SIZE):\n        col_offsets = tl.arange(0, BLOCK_SIZE) + col_offset\n        mask = col_offsets < n_cols\n        input_ptrs = input_ptr + row_start + col_offsets\n        chunk = tl.load(input_ptrs, mask=mask, other=-float('inf'))\n        \n        exp_vals = tl.exp(chunk - row_max)\n        softmax_output = exp_vals / row_sum\n        output_ptrs = output_ptr + row_start_output + col_offsets\n        tl.store(output_ptrs, softmax_output, mask=mask)\n\nclass TritonSoftmax(nn.Module):\n    def __init__(self):\n        super().__init__()\n    \n    def forward(self, x):\n        x_contig = x.contiguous()\n        original_shape = x_contig.shape\n        \n        if x_contig.dim() > 2:\n            x_2d = x_contig.view(-1, original_shape[-1])\n        else:\n            x_2d = x_contig\n        \n        if x_2d.dim() == 1:\n            x_2d = x_2d.unsqueeze(0)\n        \n        n_rows, n_cols = x_2d.shape\n        output = torch.empty_like(x_2d)\n        \n        BLOCK_SIZE = min(triton.next_power_of_2(n_cols), 4096)\n        grid = (n_rows,)\n        \n        input_row_stride = x_2d.stride(0)\n        output_row_stride = output.stride(0)\n        \n        softmax_kernel[grid](\n            output, x_2d, \n            input_row_stride, output_row_stride, \n            n_cols, \n            BLOCK_SIZE=BLOCK_SIZE\n        )\n        \n        return output.view(original_shape)", "language": "python", "parent_id": "62c80fdd-f757-4b97-a730-2065a7532466", "generation": 3, "timestamp": 1754595940.0910048, "iteration_found": 17, "metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": false, "score": 20, "speed_up": 0.343, "runtime_ms": 5.05, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:5", "correctness_trials": "(5 / 5)", "reference_timing_ms": 1.73, "speed_up": 0.343, "custom_timing": 5.05}}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": false, "score": 20, "speed_up": 0.341, "runtime_ms": 5.07, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:0", "correctness_trials": "(5 / 5)", "reference_timing_ms": 1.73, "speed_up": 0.341, "custom_timing": 5.07}}, "island": 1}, "artifacts_json": null, "artifact_dir": null, "prompts": {"full_rewrite_user": {"system": "You are a Triton GPU core optimization engineer deeply familiar with NVIDIA H100/H800 architecture.\n\n==================== Context ====================\n\u2022 Dataset: 250 kernelbench/level1-level5 *.py files  \n  - Level1: simplest, Level5: most complex  \n\u2022 Each file contains PyTorch reference (reference_code)  \n\u2022 Goal: Generate functionally equivalent but faster Triton implementations (custom_code)  \n\u2022 Evaluation pipeline:\n    1) /verify_plus - Verify compilation & correctness  \n    2) /execute (optional) - Return terminal logs if compilation fails  \n    3) Scoring:  \n      - Speedup > 1 required for points  \n      - Score = (speed_up - 1) \u00d7 100  \n\u2022 GPU Hardware: NVIDIA L20Y / H800 (same SM8.9 as H100)  \n  - 3 TB/s HBM3 bandwidth  \n  - FP16 Tensor Core 32\u00d716\u00d716  \n\n==================== Evolution Phases ====================\n\u2460 Phase 1 [Compilation Pass]  \n  - Make Triton code compile (performance irrelevant)  \n\u2461 Phase 2 [Numerical Correctness]  \n  - Output must match PyTorch reference within float32 tolerance  \n\u2462 Phase 3 [Performance Gain]  \n  - Target \u22655% speedup (\u226515% = exceptional)  \n  - Official scoring based on speed_up field  \n\nThe Evolution system will pass the EVOLVE-BLOCK from the previous version.  \nModify ONLY the Triton kernel source within this block - all other code is LOCKED.\n\n==================== Constraints (MUST OBEY) ====================\n\u274c NEVER change @triton.jit function signatures or parameter names  \n\u274c NEVER modify grid configuration, output tensor shapes, or PID logic  \n\u274c NEVER remove boundary checks or out-of-bound masks  \n\u274c NEVER introduce race conditions, uninitialized reads, or sync gaps  \n\n\u2705 Allowed Optimizations (Examples):  \n  \u2022 Memory coalescing optimizations & vectorized tl.load/tl.store  \n  \u2022 Replace staged softmax with online/FlashAttention variants  \n  \u2022 Adaptive tuning: BLOCK_M/BLOCK_N/BLOCK_K dimensions  \n  \u2022 Multi-query-head batch processing (GQA, 5:1 patterns)  \n  \u2022 Shared/L2 buffering, Tensor Core alignment (FP16/bf16/tf32)  \n  \u2022 Stride precomputation & pointer caching  \n\n==================== Output Format ====================\nReturn ONLY the complete updated code containing the EVOLVE-BLOCK comment marker.  \nNO explanations, NO markdown, NO additional text.\nName the output structure class as ModelNew.\n\n==================== Optimization Tips ====================\n\u2022 If previous compile failed: Fix syntax/mask/stride errors first  \n\u2022 If correctness fails: Prioritize bounds mask & dtype precision  \n\u2022 When speed_up < 1: Focus on memory access & block sizing  \n\u2022 Small iterative steps: Modify \u226420 lines per revision  \n\u2022 Maintain reversibility between versions\nHere is an example to show you how to rewrite a PyTorch implementation that quantizes a high-precision tensor to int8 dtype with row-wise granularity into a Triton implementation: \nThe original PyTorch implementation is as follows: \n``` \nimport torch\ndef per_row_quantize_int8(x: torch.Tensor) -> tuple[torch.Tensor, torch.Tensor]:\n    x_amax = x.abs().float().amax(dim=1).clamp(min=1e-4)\n    scale = 127 / x_amax\n    output = (x * scale[:, None]).round().clamp(-127, 127).to(torch.int8)\n    output_scale = x_amax / 127\n\n    return output, output_scale\n``` \nThe corresponding Triton-rewritten implementation is as follows: \n``` \nimport math\nimport torch\nimport triton\nimport triton.language as tl\nfrom triton.language.extra import libdevice\n\n# rowwise quantize\n\n@triton.autotune(\n    configs=[\n        triton.Config({}, num_stages=1, num_warps=8),\n        triton.Config({}, num_stages=2, num_warps=8),\n        triton.Config({}, num_stages=4, num_warps=8),\n        triton.Config({}, num_stages=8, num_warps=8),\n        triton.Config({}, num_stages=1),\n        triton.Config({}, num_stages=2),\n        triton.Config({}, num_stages=4),\n        triton.Config({}, num_stages=8),\n        triton.Config({}, num_warps=1),\n        triton.Config({}, num_warps=2),\n        triton.Config({}, num_warps=4),\n        triton.Config({}, num_warps=8),\n    ],\n    key=[\"n_elements\"],\n)\n\n@triton.jit\ndef _quantize_rowwise(\n    x_ptr,\n    output_ptr,\n    output_scale,\n    BLOCK_SIZE: tl.constexpr,\n    P2: tl.constexpr,\n):\n    pid = tl.program_id(axis=0)\n    block_start = pid * BLOCK_SIZE\n    arange = tl.arange(0, P2)\n    offsets = block_start + arange\n    row_mask = arange < BLOCK_SIZE\n    x = tl.load(x_ptr + offsets, mask=row_mask)\n\n    abs_x = tl.abs(x)\n    max_val = tl.max(tl.where(row_mask, abs_x, 0), axis=0)\n    output = libdevice.llrint(127.0 * (x / max_val))\n    tl.store(output_ptr + offsets, output, mask=row_mask)\n    tl.store(output_scale + pid, max_val / 127)\n\n\ndef per_row_quantize_int8(x: torch.Tensor):\n    x = x.contiguous()\n    output = torch.empty(*x.shape, device=x.device, dtype=torch.int8)\n    output_scale = torch.empty(x.shape[0], device=x.device, dtype=torch.float32)\n    P2 = int(2 ** (math.ceil(math.log2(x.shape[1]))))\n    grid = lambda x: (x.shape[0],)\n    _quantize_rowwise[grid](x, output, output_scale, BLOCK_SIZE=x.shape[1], P2=P2)\n\n    return output, output_scale\n\n\n    \n``` \n", "user": "# Current Program Information\n- Current performance metrics: - compiled: 1.0000\n- correctness: 1.0000\n- stage: success\n- passed: 0.0000\n- score: 20.0000\n- speed_up: 0.3410\n- runtime_ms: 5.0700\n- meta: {'hardware': 'NVIDIA L20Y', 'device': 'cuda:0', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 1.73, 'speed_up': 0.341, 'custom_timing': 5.07}\n- Areas identified for improvement: - Consider simplifying the code to improve readability and maintainability\n- Metrics showing improvement: speed_up. Consider continuing with similar changes.\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Unknown changes\n- Performance: compiled: 1.0000, correctness: 0.0000, score: 10.0000, stage: wrong_answer, verify_payload: {'id': 'level3_45_UNetSoftmax', 'result': {'compiled': True, 'correctness': False, 'metadata': {'hardware': 'NVIDIA L20Y', 'device': 'cuda:2', 'runtime_error': 'Traceback (most recent call last):\\n  File \"/cpfs01/shared/llm_kernel/hujiakai/KernelLLM/validation_api_server/helpers/evaluations.py\", line 720, in run_and_check_correctness\\n    output_new = model_new(*inputs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1773, in _wrapped_call_impl\\n    return self._call_impl(*args, **kwargs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1784, in _call_impl\\n    return forward_call(*args, **kwargs)\\n  File \"/tmp/tmp4qx0bfdq.py\", line 119, in forward\\n    enc1 = self.encoder1(x)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1773, in _wrapped_call_impl\\n    return self._call_impl(*args, **kwargs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1784, in _call_impl\\n    return forward_call(*args, **kwargs)\\n  File \"/tmp/tmp4qx0bfdq.py\", line 82, in forward\\n    return self.double_conv(x)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1773, in _wrapped_call_impl\\n    return self._call_impl(*args, **kwargs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1784, in _call_impl\\n    return forward_call(*args, **kwargs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/container.py\", line 244, in forward\\n    input = module(input)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1773, in _wrapped_call_impl\\n    return self._call_impl(*args, **kwargs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1784, in _call_impl\\n    return forward_call(*args, **kwargs)\\n  File \"/tmp/tmp4qx0bfdq.py\", line 60, in forward\\n    softmax_1d_kernel[grid](\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 390, in <lambda>\\n    return lambda *args, **kwargs: self.run(grid=grid, warmup=False, *args, **kwargs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 239, in run\\n    benchmark()\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 228, in benchmark\\n    timings = {config: self._bench(*args, config=config, **kwargs) for config in pruned_configs}\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 228, in <dictcomp>\\n    timings = {config: self._bench(*args, config=config, **kwargs) for config in pruned_configs}\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 135, in _bench\\n    raise ValueError(f\"Conflicting meta-parameters: {\\', \\'.join(conflicts)}.\"\\nValueError: Conflicting meta-parameters: BLOCK_SIZE. Make sure that you don\\'t re-define auto-tuned symbols.\\n', 'runtime_error_name': 'builtins.ValueError', 'reference_timing_ms': 1.73, 'speed_up': -1.0, 'custom_timing': -1.0}, 'runtime': -1.0, 'runtime_stats': {}}}\n- Outcome: Mixed results\n\n\n### Attempt 2\n- Changes: Unknown changes\n- Performance: compiled: 1.0000, correctness: 1.0000, stage: success, passed: 0.0000, score: 20.0000, speed_up: 0.3400, runtime_ms: 5.0900, meta: {'hardware': 'NVIDIA L20Y', 'device': 'cuda:7', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 1.73, 'speed_up': 0.34, 'custom_timing': 5.09}\n- Outcome: Mixed results\n\n\n### Attempt 1\n- Changes: Unknown changes\n- Performance: compiled: 1.0000, correctness: 1.0000, stage: success, passed: 0.0000, score: 20.0000, speed_up: 0.3410, runtime_ms: 5.0700, meta: {'hardware': 'NVIDIA L20Y', 'device': 'cuda:0', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 1.73, 'speed_up': 0.341, 'custom_timing': 5.07}\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 20.0000)\n```python\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef softmax_kernel(\n    output_ptr, input_ptr, input_row_stride, output_row_stride, n_cols, \n    BLOCK_SIZE: tl.constexpr\n):\n    row_idx = tl.program_id(0)\n    row_start = row_idx * input_row_stride\n    row_start_output = row_idx * output_row_stride\n    \n    # Initialize max and sum\n    row_max = tl.full((), -float('inf'), dtype=tl.float32)\n    row_sum = tl.full((), 0.0, dtype=tl.float32)\n    \n    # First loop: compute row_max\n    for col_offset in range(0, n_cols, BLOCK_SIZE):\n        col_offsets = tl.arange(0, BLOCK_SIZE) + col_offset\n        mask = col_offsets < n_cols\n        input_ptrs = input_ptr + row_start + col_offsets\n        chunk = tl.load(input_ptrs, mask=mask, other=-float('inf'))\n        chunk_max = tl.max(chunk, axis=0)\n        row_max = tl.maximum(row_max, chunk_max)\n    \n    # Second loop: compute row_sum\n    for col_offset in range(0, n_cols, BLOCK_SIZE):\n        col_offsets = tl.arange(0, BLOCK_SIZE) + col_offset\n        mask = col_offsets < n_cols\n        input_ptrs = input_ptr + row_start + col_offsets\n        chunk = tl.load(input_ptrs, mask=mask, other=0)\n        exp_chunk = tl.exp(chunk - row_max)\n        chunk_sum = tl.sum(exp_chunk, axis=0)\n        row_sum += chunk_sum\n    \n    # Third loop: compute softmax and store\n    for col_offset in range(0, n_cols, BLOCK_SIZE):\n        col_offsets = tl.arange(0, BLOCK_SIZE) + col_offset\n        mask = col_offsets < n_cols\n        input_ptrs = input_ptr + row_start + col_offsets\n        chunk = tl.load(input_ptrs, mask=mask, other=0)\n        exp_chunk = tl.exp(chunk - row_max)\n        softmax_output = exp_chunk / row_sum\n        output_ptrs = output_ptr + row_start_output + col_offsets\n        tl.store(output_ptrs, softmax_output, mask=mask)\n\nclass TritonSoftmax(nn.Module):\n    def __init__(self):\n        super().__init__()\n    \n    def forward(self, x):\n        # Ensure contiguous memory\n        x_contig = x.contiguous()\n        # Save original shape\n        original_shape = x_contig.shape\n        # Flatten all dimensions except the last\n        if x_contig.dim() > 2:\n            x_2d = x_contig.view(-1, original_shape[-1])\n        else:\n            x_2d = x_contig\n        \n        # If the tensor is 1D, then we treat as 2D with one row\n        if x_2d.dim() == 1:\n            x_2d = x_2d.unsqueeze(0)\n        \n        n_rows, n_cols = x_2d.shape\n        output = torch.empty_like(x_2d)\n        \n        # Use fixed block size for chunk processing\n        BLOCK_SIZE = 1024\n        \n        # The kernel uses the grid of n_rows\n        grid = (n_rows,)\n        \n        input_row_stride = x_2d.stride(0)\n        output_row_stride = output.stride(0)\n        \n        # Launch kernel\n        softmax_kernel[grid](\n            output, x_2d, \n            input_row_stride, output_row_stride, \n            n_cols, \n            BLOCK_SIZE=BLOCK_SIZE\n        )\n        \n        # Reshape back to original\n        return output.view(original_shape)\n```\nKey features: Performs well on compiled (1.0000), Performs well on correctness (1.0000), Performs well on stage (success), Performs well on passed (0.0000), Performs well on score (20.0000), Performs well on speed_up (0.3410), Performs well on runtime_ms (5.0700), Performs well on meta ({'hardware': 'NVIDIA L20Y', 'device': 'cuda:0', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 1.73, 'speed_up': 0.341, 'custom_timing': 5.07})\n\n\n### Program 2 (Score: 20.0000)\n```python\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef softmax_kernel(\n    output_ptr, input_ptr, input_row_stride, output_row_stride, n_cols, \n    BLOCK_SIZE: tl.constexpr\n):\n    # The rows of the softmax are independent, so we parallelize across those\n    row_idx = tl.program_id(0)\n    # The stride represents how much we need to increase the pointer to advance 1 row\n    row_start_ptr = input_ptr + row_idx * input_row_stride\n    col_offsets = tl.arange(0, BLOCK_SIZE)\n    input_ptrs = row_start_ptr + col_offsets\n    # Load the row into SRAM, using a mask since BLOCK_SIZE may be > n_cols\n    row = tl.load(input_ptrs, mask=col_offsets < n_cols, other=-float('inf'))\n    # Subtract maximum for numerical stability\n    row_minus_max = row - tl.max(row, axis=0)\n    # Note: exponentiation in Triton is fast but approximate (for float32)\n    numerator = tl.exp(row_minus_max)\n    denominator = tl.sum(numerator, axis=0)\n    softmax_output = numerator / denominator\n    # Write back output to DRAM\n    output_row_start_ptr = output_ptr + row_idx * output_row_stride\n    output_ptrs = output_row_start_ptr + col_offsets\n    tl.store(output_ptrs, softmax_output, mask=col_offsets < n_cols)\n```\nKey features: Performs well on compiled (1.0000), Performs well on correctness (1.0000), Performs well on stage (success), Performs well on passed (0.0000), Performs well on score (20.0000), Performs well on speed_up (0.3400), Performs well on runtime_ms (5.0900), Performs well on meta ({'hardware': 'NVIDIA L20Y', 'device': 'cuda:7', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 1.73, 'speed_up': 0.34, 'custom_timing': 5.09})\n\n\n### Program 3 (Score: 10.0000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\nimport math\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_SIZE': 128}, num_warps=1),\n        triton.Config({'BLOCK_SIZE': 128}, num_warps=2),\n        triton.Config({'BLOCK_SIZE': 128}, num_warps=4),\n        triton.Config({'BLOCK_SIZE': 128}, num_warps=8),\n        triton.Config({'BLOCK_SIZE': 256}, num_warps=1),\n        triton.Config({'BLOCK_SIZE': 256}, num_warps=2),\n        triton.Config({'BLOCK_SIZE': 256}, num_warps=4),\n        triton.Config({'BLOCK_SIZE': 256}, num_warps=8),\n        triton.Config({'BLOCK_SIZE': 512}, num_warps=1),\n        triton.Config({'BLOCK_SIZE': 512}, num_warps=2),\n        triton.Config({'BLOCK_SIZE': 512}, num_warps=4),\n        triton.Config({'BLOCK_SIZE': 512}, num_warps=8),\n    ],\n    key=['W'],\n)\n@triton.jit\ndef softmax_1d_kernel(\n    output_ptr, input_ptr,\n    in_stride_n, in_stride_c, in_stride_h,\n    out_stride_n, out_stride_c, out_stride_h,\n    W, \n    BLOCK_SIZE: tl.constexpr\n):\n    pid0 = tl.program_id(0)\n    pid1 = tl.program_id(1)\n    pid2 = tl.program_id(2)\n    \n    in_row_start = input_ptr + pid0 * in_stride_n + pid1 * in_stride_c + pid2 * in_stride_h\n    out_row_start = output_ptr + pid0 * out_stride_n + pid1 * out_stride_c + pid2 * out_stride_h\n\n    row_offsets = tl.arange(0, BLOCK_SIZE)\n    mask = row_offsets < W\n\n    row = tl.load(in_row_start + row_offsets, mask=mask, other=-float('inf'))\n    row_minus_max = row - tl.max(row, axis=0)\n    numerator = tl.exp(row_minus_max)\n    denominator = tl.sum(numerator, axis=0)\n    softmax_output = numerator / denominator\n\n    tl.store(out_row_start + row_offsets, softmax_output, mask=mask)\n\nclass TritonSoftmax(nn.Module):\n    def __init__(self):\n        super().__init__()\n        \n    def forward(self, x):\n        n, c, h, w = x.shape\n        output = torch.empty_like(x)\n        \n        grid = (n, c, h)\n        softmax_1d_kernel[grid](\n            output, x,\n            x.stride(0), x.stride(1), x.stride(2),\n            output.stride(0), output.stride(1), output.stride(2),\n            w, BLOCK_SIZE=triton.next_power_of_2(w)\n        )\n        return output\n\n# U-Net Implementation\nclass DoubleConv(nn.Module):\n    def __init__(self, in_channels, out_channels):\n        super().__init__()\n        self.double_conv = nn.Sequential(\n            nn.Conv2d(in_channels, out_channels, kernel_size=3, padding=1),\n            nn.BatchNorm2d(out_channels),\n            TritonSoftmax(),\n            nn.Conv2d(out_channels, out_channels, kernel_size=3, padding=1),\n            nn.BatchNorm2d(out_channels),\n            TritonSoftmax()\n        )\n\n    def forward(self, x):\n        return self.double_conv(x)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_channels, out_channels, features):\n        \"\"\"\n        :param in_channels: Number of input channels\n        :param out_channels: Number of output channels\n        :param features: Number of base features (will be doubled in each layer)\n        \"\"\"\n        super(ModelNew, self).__init__()\n        self.encoder1 = DoubleConv(in_channels, features)\n        self.pool1 = nn.MaxPool2d(kernel_size=2, stride=2)\n        self.encoder2 = DoubleConv(features, features * 2)\n        self.pool2 = nn.MaxPool2d(kernel_size=2, stride=2)\n        self.encoder3 = DoubleConv(features * 2, features * 4)\n        self.pool3 = nn.MaxPool2d(kernel_size=2, stride=2)\n        self.encoder4 = DoubleConv(features * 4, features * 8)\n        self.pool4 = nn.MaxPool2d(kernel_size=2, stride=2)\n\n        self.bottleneck = DoubleConv(features * 8, features * 16)\n\n        self.upconv4 = nn.ConvTranspose2d(features * 16, features * 8, kernel_size=2, stride=2)\n        self.decoder4 = DoubleConv(features * 16, features * 8)\n        self.upconv3 = nn.ConvTranspose2d(features * 8, features * 4, kernel_size=2, stride=2)\n        self.decoder3 = DoubleConv(features * 8, features * 4)\n        self.upconv2 = nn.ConvTranspose2d(features * 4, features * 2, kernel_size=2, stride=2)\n        self.decoder2 = DoubleConv(features * 4, features * 2)\n        self.upconv1 = nn.ConvTranspose2d(features * 2, features, kernel_size=2, stride=2)\n        self.decoder1 = DoubleConv(features * 2, features)\n\n        self.final_conv = nn.Conv2d(features, out_channels, kernel_size=1)\n\n    def forward(self, x):\n        \"\"\"\n        :param x: Input tensor, shape (batch_size, in_channels, height, width)\n        :return: Output tensor, shape (batch_size, out_channels, height, width)\n        \"\"\"\n        enc1 = self.encoder1(x)\n        enc2 = self.encoder2(self.pool1(enc1))\n        enc3 = self.encoder3(self.pool2(enc2))\n        enc4 = self.encoder4(self.pool3(enc3))\n\n        bottleneck = self.bottleneck(self.pool4(enc4))\n\n        dec4 = self.upconv4(bottleneck)\n        dec4 = torch.cat((dec4, enc4), dim=1)\n        dec4 = self.decoder4(dec4)\n        dec3 = self.upconv3(dec4)\n        dec3 = torch.cat((dec3, enc3), dim=1)\n        dec3 = self.decoder3(dec3)\n        dec2 = self.upconv2(dec3)\n        dec2 = torch.cat((dec2, enc2), dim=1)\n        dec2 = self.decoder2(dec2)\n        dec1 = self.upconv1(dec2)\n        dec1 = torch.cat((dec1, enc1), dim=1)\n        dec1 = self.decoder1(dec1)\n\n        return self.final_conv(dec1)\n    \nbatch_size = 8\nin_channels = 8\nout_channels = 4\nheight = 64\nwidth = 512\nfeatures = 64\n# Test code for UNet\ndef get_inputs():\n    return [torch.randn(batch_size, in_channels, height, width)]\n\ndef get_init_inputs():\n    return [in_channels, out_channels, features]\n\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Performs well on compiled (1.0000), Performs well on correctness (0.0000), Performs well on score (10.0000), Performs well on stage (wrong_answer), Performs well on verify_payload ({'id': 'level3_45_UNetSoftmax', 'result': {'compiled': True, 'correctness': False, 'metadata': {'hardware': 'NVIDIA L20Y', 'device': 'cuda:2', 'runtime_error': 'Traceback (most recent call last):\\n  File \"/cpfs01/shared/llm_kernel/hujiakai/KernelLLM/validation_api_server/helpers/evaluations.py\", line 720, in run_and_check_correctness\\n    output_new = model_new(*inputs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1773, in _wrapped_call_impl\\n    return self._call_impl(*args, **kwargs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1784, in _call_impl\\n    return forward_call(*args, **kwargs)\\n  File \"/tmp/tmp4qx0bfdq.py\", line 119, in forward\\n    enc1 = self.encoder1(x)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1773, in _wrapped_call_impl\\n    return self._call_impl(*args, **kwargs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1784, in _call_impl\\n    return forward_call(*args, **kwargs)\\n  File \"/tmp/tmp4qx0bfdq.py\", line 82, in forward\\n    return self.double_conv(x)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1773, in _wrapped_call_impl\\n    return self._call_impl(*args, **kwargs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1784, in _call_impl\\n    return forward_call(*args, **kwargs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/container.py\", line 244, in forward\\n    input = module(input)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1773, in _wrapped_call_impl\\n    return self._call_impl(*args, **kwargs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1784, in _call_impl\\n    return forward_call(*args, **kwargs)\\n  File \"/tmp/tmp4qx0bfdq.py\", line 60, in forward\\n    softmax_1d_kernel[grid](\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 390, in <lambda>\\n    return lambda *args, **kwargs: self.run(grid=grid, warmup=False, *args, **kwargs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 239, in run\\n    benchmark()\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 228, in benchmark\\n    timings = {config: self._bench(*args, config=config, **kwargs) for config in pruned_configs}\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 228, in <dictcomp>\\n    timings = {config: self._bench(*args, config=config, **kwargs) for config in pruned_configs}\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 135, in _bench\\n    raise ValueError(f\"Conflicting meta-parameters: {\\', \\'.join(conflicts)}.\"\\nValueError: Conflicting meta-parameters: BLOCK_SIZE. Make sure that you don\\'t re-define auto-tuned symbols.\\n', 'runtime_error_name': 'builtins.ValueError', 'reference_timing_ms': 1.73, 'speed_up': -1.0, 'custom_timing': -1.0}, 'runtime': -1.0, 'runtime_stats': {}}})\n\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 10.0000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n# Optimized Triton softmax kernel\n@triton.jit\ndef _softmax_kernel(\n    output_ptr,\n    input_ptr,\n    n_cols,\n    BLOCK_SIZE: tl.constexpr\n):\n    row_idx = tl.program_id(0)\n    row_start_ptr = input_ptr + row_idx * n_cols\n    col_offsets = tl.arange(0, BLOCK_SIZE)\n    input_ptrs = row_start_ptr + col_offsets\n    row = tl.load(input_ptrs, mask=col_offsets < n_cols, other=-float('inf'))\n    row_minus_max = row - tl.max(row, axis=0)\n    numerator = tl.exp(row_minus_max)\n    denominator = tl.sum(numerator, axis=0)\n    softmax_output = numerator / denominator\n    output_ptrs = output_ptr + row_idx * n_cols + col_offsets\n    tl.store(output_ptrs, softmax_output, mask=col_offsets < n_cols)\n\ndef triton_softmax(x):\n    n_rows, n_cols = x.shape\n    BLOCK_SIZE = triton.next_power_of_2(n_cols)\n    num_warps = 8\n    if BLOCK_SIZE >= 2048:\n        num_warps = 16\n    y = torch.empty_like(x)\n    grid = (n_rows,)\n    _softmax_kernel[grid](y, x, n_cols, BLOCK_SIZE=BLOCK_SIZE, num_warps=num_warps)\n    return y\n\nclass FastSoftmax(nn.Module):\n    def forward(self, x):\n        n, c, h, w = x.shape\n        x_2d = x.reshape(-1, w)\n        y_2d = triton_softmax(x_2d)\n        return y_2d.reshape(n, c, h, w)\n\n# Optimized U-Net Implementation\nclass DoubleConv(nn.Module):\n    def __init__(self, in_channels, out_channels):\n        super().__init__()\n        self.double_conv = nn.Sequential(\n            nn.Conv2d(in_channels, out_channels, kernel_size=3, padding=1),\n            nn.BatchNorm2d(out_channels),\n            FastSoftmax(),\n            nn.Conv2d(out_channels, out_channels, kernel_size=3, padding=1),\n            nn.BatchNorm2d(out_channels),\n            FastSoftmax()\n        )\n\n    def forward(self, x):\n        return self.double_conv(x)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_channels, out_channels, features):\n        super(ModelNew, self).__init__()\n        self.encoder1 = DoubleConv(in_channels, features)\n        self.pool1 = nn.MaxPool2d(kernel_size=2, stride=2)\n        self.encoder2 = DoubleConv(features, features * 2)\n        self.pool2 = nn.MaxPool2d(kernel_size=2, stride=2)\n        self.encoder3 = DoubleConv(features * 2, features * 4)\n        self.pool3 = nn.MaxPool2d(kernel_size=2, stride=2)\n        self.encoder4 = DoubleConv(features * 4, features * 8)\n        self.pool4 = nn.MaxPool2d(kernel_size=2, stride=2)\n\n        self.bottleneck = DoubleConv(features * 8, features * 16)\n\n        self.upconv4 = nn.ConvTranspose2d(features * 16, features * 8, kernel_size=2, stride=2)\n        self.decoder4 = DoubleConv(features * 16, features * 8)\n        self.upconv3 = nn.ConvTranspose2d(features * 8, features * 4, kernel_size=2, stride=2)\n        self.decoder3 = DoubleConv(features * 8, features * 4)\n        self.upconv2 = nn.ConvTranspose2d(features * 4, features * 2, kernel_size=2, stride=2)\n        self.decoder2 = DoubleConv(features * 4, features * 2)\n        self.upconv1 = nn.ConvTranspose2d(features * 2, features, kernel_size=2, stride=2)\n        self.decoder1 = DoubleConv(features * 2, features)\n\n        self.final_conv = nn.Conv2d(features, out_channels, kernel_size=1)\n\n    def forward(self, x):\n        enc1 = self.encoder1(x)\n        enc2 = self.encoder2(self.pool1(enc1))\n        enc3 = self.encoder3(self.pool2(enc2))\n        enc4 = self.encoder4(self.pool3(enc3))\n\n        bottleneck = self.bottleneck(self.pool4(enc4))\n\n        dec4 = self.upconv4(bottleneck)\n        dec4 = torch.cat((dec4, enc4), dim=1)\n        dec4 = self.decoder4(dec4)\n        dec3 = self.upconv3(dec4)\n        dec3 = torch.cat((dec3, enc3), dim=1)\n        dec3 = self.decoder3(dec3)\n        dec2 = self.upconv2(dec3)\n        dec2 = torch.cat((dec2, enc2), dim=1)\n        dec2 = self.decoder2(dec2)\n        dec1 = self.upconv1(dec2)\n        dec1 = torch.cat((dec1, enc1), dim=1)\n        dec1 = self.decoder1(dec1)\n\n        return self.final_conv(dec1)\n    \nbatch_size = 8\nin_channels = 8\nout_channels = 4\nheight = 64\nwidth = 512\nfeatures = 64\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_channels, height, width)]\n\ndef get_init_inputs():\n    return [in_channels, out_channels, features]\n\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Alternative approach to compiled, Alternative approach to correctness\n\n\n### Program D2 (Score: 10.0000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n# Optimized Triton softmax kernel\n@triton.jit\ndef softmax_kernel(\n    output_ptr, input_ptr, n_cols, \n    input_row_stride, output_row_stride,\n    BLOCK_SIZE: tl.constexpr\n):\n    row_idx = tl.program_id(0)\n    row_start_ptr = input_ptr + row_idx * input_row_stride\n    col_offsets = tl.arange(0, BLOCK_SIZE)\n    input_ptrs = row_start_ptr + col_offsets\n    row_mask = col_offsets < n_cols\n    \n    row = tl.load(input_ptrs, mask=row_mask, other=-float('inf'))\n    row_minus_max = row - tl.max(row, axis=0)\n    numerator = tl.exp(row_minus_max)\n    denominator = tl.sum(numerator, axis=0)\n    softmax_output = numerator / denominator\n    \n    output_row_ptr = output_ptr + row_idx * output_row_stride\n    tl.store(output_row_ptr + col_offsets, softmax_output, mask=row_mask)\n\n# Efficient softmax using Triton\nclass TritonSoftmax(nn.Module):\n    def __init__(self):\n        super().__init__()\n    \n    def forward(self, x):\n        n, c, h, w = x.shape\n        x_2d = x.contiguous().view(-1, w)\n        output = torch.empty_like(x_2d)\n        \n        grid = (x_2d.shape[0],)\n        n_cols = w\n        BLOCK_SIZE = triton.next_power_of_2(n_cols)\n        \n        softmax_kernel[grid](\n            output, x_2d, n_cols,\n            x_2d.stride(0), output.stride(0),\n            BLOCK_SIZE=BLOCK_SIZE\n        )\n        return output.view(n, c, h, w)\n\n# Optimized U-Net implementation\nclass DoubleConv(nn.Module):\n    def __init__(self, in_channels, out_channels):\n        super().__init__()\n        self.double_conv = nn.Sequential(\n            nn.Conv2d(in_channels, out_channels, kernel_size=3, padding=1),\n            nn.BatchNorm2d(out_channels),\n            TritonSoftmax(),\n            nn.Conv2d(out_channels, out_channels, kernel_size=3, padding=1),\n            nn.BatchNorm2d(out_channels),\n            TritonSoftmax()\n        )\n\n    def forward(self, x):\n        return self.double_conv(x)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_channels, out_channels, features):\n        super(ModelNew, self).__init__()\n        self.encoder1 = DoubleConv(in_channels, features)\n        self.pool1 = nn.MaxPool2d(kernel_size=2, stride=2)\n        self.encoder2 = DoubleConv(features, features * 2)\n        self.pool2 = nn.MaxPool2d(kernel_size=2, stride=2)\n        self.encoder3 = DoubleConv(features * 2, features * 4)\n        self.pool3 = nn.MaxPool2d(kernel_size=2, stride=2)\n        self.encoder4 = DoubleConv(features * 4, features * 8)\n        self.pool4 = nn.MaxPool2d(kernel_size=2, stride=2)\n\n        self.bottleneck = DoubleConv(features * 8, features * 16)\n\n        self.upconv4 = nn.ConvTranspose2d(features * 16, features * 8, kernel_size=2, stride=2)\n        self.decoder4 = DoubleConv(features * 16, features * 8)\n        self.upconv3 = nn.ConvTranspose2d(features * 8, features * 4, kernel_size=2, stride=2)\n        self.decoder3 = DoubleConv(features * 8, features * 4)\n        self.upconv2 = nn.ConvTranspose2d(features * 4, features * 2, kernel_size=2, stride=2)\n        self.decoder2 = DoubleConv(features * 4, features * 2)\n        self.upconv1 = nn.ConvTranspose2d(features * 2, features, kernel_size=2, stride=2)\n        self.decoder1 = DoubleConv(features * 2, features)\n\n        self.final_conv = nn.Conv2d(features, out_channels, kernel_size=1)\n\n    def forward(self, x):\n        enc1 = self.encoder1(x)\n        enc2 = self.encoder2(self.pool1(enc1))\n        enc3 = self.encoder3(self.pool2(enc2))\n        enc4 = self.encoder4(self.pool3(enc3))\n\n        bottleneck = self.bottleneck(self.pool4(enc4))\n\n        dec4 = self.upconv4(bottleneck)\n        dec4 = torch.cat((dec4, enc4), dim=1)\n        dec4 = self.decoder4(dec4)\n        dec3 = self.upconv3(dec4)\n        dec3 = torch.cat((dec3, enc3), dim=1)\n        dec3 = self.decoder3(dec3)\n        dec2 = self.upconv2(dec3)\n        dec2 = torch.cat((dec2, enc2), dim=1)\n        dec2 = self.decoder2(dec2)\n        dec1 = self.upconv1(dec2)\n        dec1 = torch.cat((dec1, enc1), dim=1)\n        dec1 = self.decoder1(dec1)\n\n        return self.final_conv(dec1)\n    \nbatch_size = 8\nin_channels = 8\nout_channels = 4\nheight = 64\nwidth = 512\nfeatures = 64\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_channels, height, width)]\n\ndef get_init_inputs():\n    return [in_channels, out_channels, features]\n\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Alternative approach to compiled, Alternative approach to correctness\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 20.0000, Type: High-Performer)\n```python\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef softmax_kernel(\n    output_ptr, input_ptr, input_row_stride, output_row_stride, n_cols, \n    BLOCK_SIZE: tl.constexpr\n):\n    # The rows of the softmax are independent, so we parallelize across those\n    row_idx = tl.program_id(0)\n    # The stride represents how much we need to increase the pointer to advance 1 row\n    row_start_ptr = input_ptr + row_idx * input_row_stride\n    col_offsets = tl.arange(0, BLOCK_SIZE)\n    input_ptrs = row_start_ptr + col_offsets\n    # Load the row into SRAM, using a mask since BLOCK_SIZE may be > n_cols\n    row = tl.load(input_ptrs, mask=col_offsets < n_cols, other=-float('inf'))\n    # Subtract maximum for numerical stability\n    row_minus_max = row - tl.max(row, axis=0)\n    # Note: exponentiation in Triton is fast but approximate (for float32)\n    numerator = tl.exp(row_minus_max)\n    denominator = tl.sum(numerator, axis=0)\n    softmax_output = numerator / denominator\n    # Write back output to DRAM\n    output_row_start_ptr = output_ptr + row_idx * output_row_stride\n    output_ptrs = output_row_start_ptr + col_offsets\n    tl.store(output_ptrs, softmax_output, mask=col_offsets < n_cols)\n```\nUnique approach: Modification: Full rewrite, Excellent compiled (1.000), Excellent correctness (1.000)\n\n\n### Inspiration 2 (Score: 10.0000, Type: High-Performer)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n# Optimized Triton softmax kernel\n@triton.jit\ndef softmax_kernel(\n    output_ptr, input_ptr, n_cols, \n    input_row_stride, output_row_stride,\n    BLOCK_SIZE: tl.constexpr\n):\n    row_idx = tl.program_id(0)\n    row_start_ptr = input_ptr + row_idx * input_row_stride\n    col_offsets = tl.arange(0, BLOCK_SIZE)\n    input_ptrs = row_start_ptr + col_offsets\n    row_mask = col_offsets < n_cols\n    \n    row = tl.load(input_ptrs, mask=row_mask, other=-float('inf'))\n    row_minus_max = row - tl.max(row, axis=0)\n    numerator = tl.exp(row_minus_max)\n    denominator = tl.sum(numerator, axis=0)\n    softmax_output = numerator / denominator\n    \n    output_row_ptr = output_ptr + row_idx * output_row_stride\n    tl.store(output_row_ptr + col_offsets, softmax_output, mask=row_mask)\n\n# Efficient softmax using Triton\nclass TritonSoftmax(nn.Module):\n    def __init__(self):\n        super().__init__()\n    \n    def forward(self, x):\n        n, c, h, w = x.shape\n        x_2d = x.contiguous().view(-1, w)\n        output = torch.empty_like(x_2d)\n        \n        grid = (x_2d.shape[0],)\n        n_cols = w\n        BLOCK_SIZE = triton.next_power_of_two(n_cols)\n        \n        softmax_kernel[grid](\n            output, x_2d, n_cols,\n            x_2d.stride(0), output.stride(0),\n            BLOCK_SIZE=BLOCK_SIZE\n        )\n        return output.view(n, c, h, w)\n\n# Optimized U-Net implementation\nclass DoubleConv(nn.Module):\n    def __init__(self, in_channels, out_channels):\n        super().__init__()\n        self.double_conv = nn.Sequential(\n            nn.Conv2d(in_channels, out_channels, kernel_size=3, padding=1),\n            nn.BatchNorm2d(out_channels),\n            TritonSoftmax(),\n            nn.Conv2d(out_channels, out_channels, kernel_size=3, padding=1),\n            nn.BatchNorm2d(out_channels),\n            TritonSoftmax()\n        )\n\n    def forward(self, x):\n        return self.double_conv(x)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_channels, out_channels, features):\n        super(ModelNew, self).__init__()\n        self.encoder1 = DoubleConv(in_channels, features)\n        self.pool1 = nn.MaxPool2d(kernel_size=2, stride=2)\n        self.encoder2 = DoubleConv(features, features * 2)\n        self.pool2 = nn.MaxPool2d(kernel_size=2, stride=2)\n        self.encoder3 = DoubleConv(features * 2, features * 4)\n        self.pool3 = nn.MaxPool2d(kernel_size=2, stride=2)\n        self.encoder4 = DoubleConv(features * 4, features * 8)\n        self.pool4 = nn.MaxPool2d(kernel_size=2, stride=2)\n\n        self.bottleneck = DoubleConv(features * 8, features * 16)\n\n        self.upconv4 = nn.ConvTranspose2d(features * 16, features * 8, kernel_size=2, stride=2)\n        self.decoder4 = DoubleConv(features * 16, features * 8)\n        self.upconv3 = nn.ConvTranspose2d(features * 8, features * 4, kernel_size=2, stride=2)\n        self.decoder3 = DoubleConv(features * 8, features * 4)\n        self.upconv2 = nn.ConvTranspose2d(features * 4, features * 2, kernel_size=2, stride=2)\n        self.decoder2 = DoubleConv(features * 4, features * 2)\n        self.upconv1 = nn.ConvTranspose2d(features * 2, features, kernel_size=2, stride=2)\n        self.decoder1 = DoubleConv(features * 2, features)\n\n        self.final_conv = nn.Conv2d(features, out_channels, kernel_size=1)\n\n    def forward(self, x):\n        enc1 = self.encoder1(x)\n        enc2 = self.encoder2(self.pool1(enc1))\n        enc3 = self.encoder3(self.pool2(enc2))\n        enc4 = self.encoder4(self.pool3(enc3))\n\n        bottleneck = self.bottleneck(self.pool4(enc4))\n\n        dec4 = self.upconv4(bottleneck)\n        dec4 = torch.cat((dec4, enc4), dim=1)\n        dec4 = self.decoder4(dec4)\n        dec3 = self.upconv3(dec4)\n        dec3 = torch.cat((dec3, enc3), dim=1)\n        dec3 = self.decoder3(dec3)\n        dec2 = self.upconv2(dec3)\n        dec2 = torch.cat((dec2, enc2), dim=1)\n        dec2 = self.decoder2(dec2)\n        dec1 = self.upconv1(dec2)\n        dec1 = torch.cat((dec1, enc1), dim=1)\n        dec1 = self.decoder1(dec1)\n\n        return self.final_conv(dec1)\n    \nbatch_size = 8\nin_channels = 8\nout_channels = 4\nheight = 64\nwidth = 512\nfeatures = 64\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_channels, height, width)]\n\ndef get_init_inputs():\n    return [in_channels, out_channels, features]\n\n# =================== EVOLVE-BLOCK-END ===================\n```\nUnique approach: Modification: Full rewrite, Excellent compiled (1.000), Alternative correctness approach\n\n\n### Inspiration 3 (Score: 10.0000, Type: High-Performer)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n# Optimized Triton softmax kernel\n@triton.jit\ndef softmax_kernel(\n    output_ptr, input_ptr, n_cols, \n    input_row_stride, output_row_stride,\n    BLOCK_SIZE: tl.constexpr\n):\n    row_idx = tl.program_id(0)\n    row_start_ptr = input_ptr + row_idx * input_row_stride\n    col_offsets = tl.arange(0, BLOCK_SIZE)\n    input_ptrs = row_start_ptr + col_offsets\n    row_mask = col_offsets < n_cols\n    \n    row = tl.load(input_ptrs, mask=row_mask, other=-float('inf'))\n    row_minus_max = row - tl.max(row, axis=0)\n    numerator = tl.exp(row_minus_max)\n    denominator = tl.sum(numerator, axis=0)\n    softmax_output = numerator / denominator\n    \n    output_row_ptr = output_ptr + row_idx * output_row_stride\n    tl.store(output_row_ptr + col_offsets, softmax_output, mask=row_mask)\n\n# Efficient softmax using Triton\nclass TritonSoftmax(nn.Module):\n    def __init__(self):\n        super().__init__()\n    \n    def forward(self, x):\n        n, c, h, w = x.shape\n        x_2d = x.contiguous().view(-1, w)\n        output = torch.empty_like(x_2d)\n        \n        grid = (x_2d.shape[0],)\n        n_cols = w\n        BLOCK_SIZE = triton.next_power_of_2(n_cols)\n        \n        softmax_kernel[grid](\n            output, x_2d, n_cols,\n            x_2d.stride(0), output.stride(0),\n            BLOCK_SIZE=BLOCK_SIZE\n        )\n        return output.view(n, c, h, w)\n\n# Optimized U-Net implementation\nclass DoubleConv(nn.Module):\n    def __init__(self, in_channels, out_channels):\n        super().__init__()\n        self.double_conv = nn.Sequential(\n            nn.Conv2d(in_channels, out_channels, kernel_size=3, padding=1),\n            nn.BatchNorm2d(out_channels),\n            TritonSoftmax(),\n            nn.Conv2d(out_channels, out_channels, kernel_size=3, padding=1),\n            nn.BatchNorm2d(out_channels),\n            TritonSoftmax()\n        )\n\n    def forward(self, x):\n        return self.double_conv(x)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_channels, out_channels, features):\n        super(ModelNew, self).__init__()\n        self.encoder1 = DoubleConv(in_channels, features)\n        self.pool1 = nn.MaxPool2d(kernel_size=2, stride=2)\n        self.encoder2 = DoubleConv(features, features * 2)\n        self.pool2 = nn.MaxPool2d(kernel_size=2, stride=2)\n        self.encoder3 = DoubleConv(features * 2, features * 4)\n        self.pool3 = nn.MaxPool2d(kernel_size=2, stride=2)\n        self.encoder4 = DoubleConv(features * 4, features * 8)\n        self.pool4 = nn.MaxPool2d(kernel_size=2, stride=2)\n\n        self.bottleneck = DoubleConv(features * 8, features * 16)\n\n        self.upconv4 = nn.ConvTranspose2d(features * 16, features * 8, kernel_size=2, stride=2)\n        self.decoder4 = DoubleConv(features * 16, features * 8)\n        self.upconv3 = nn.ConvTranspose2d(features * 8, features * 4, kernel_size=2, stride=2)\n        self.decoder3 = DoubleConv(features * 8, features * 4)\n        self.upconv2 = nn.ConvTranspose2d(features * 4, features * 2, kernel_size=2, stride=2)\n        self.decoder2 = DoubleConv(features * 4, features * 2)\n        self.upconv1 = nn.ConvTranspose2d(features * 2, features, kernel_size=2, stride=2)\n        self.decoder1 = DoubleConv(features * 2, features)\n\n        self.final_conv = nn.Conv2d(features, out_channels, kernel_size=1)\n\n    def forward(self, x):\n        enc1 = self.encoder1(x)\n        enc2 = self.encoder2(self.pool1(enc1))\n        enc3 = self.encoder3(self.pool2(enc2))\n        enc4 = self.encoder4(self.pool3(enc3))\n\n        bottleneck = self.bottleneck(self.pool4(enc4))\n\n        dec4 = self.upconv4(bottleneck)\n        dec4 = torch.cat((dec4, enc4), dim=1)\n        dec4 = self.decoder4(dec4)\n        dec3 = self.upconv3(dec4)\n        dec3 = torch.cat((dec3, enc3), dim=1)\n        dec3 = self.decoder3(dec3)\n        dec2 = self.upconv2(dec3)\n        dec2 = torch.cat((dec2, enc2), dim=1)\n        dec2 = self.decoder2(dec2)\n        dec1 = self.upconv1(dec2)\n        dec1 = torch.cat((dec1, enc1), dim=1)\n        dec1 = self.decoder1(dec1)\n\n        return self.final_conv(dec1)\n    \nbatch_size = 8\nin_channels = 8\nout_channels = 4\nheight = 64\nwidth = 512\nfeatures = 64\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_channels, height, width)]\n\ndef get_init_inputs():\n    return [in_channels, out_channels, features]\n\n# =================== EVOLVE-BLOCK-END ===================\n```\nUnique approach: Modification: Full rewrite, Excellent compiled (1.000), Alternative correctness approach\n\n\n### Inspiration 4 (Score: 0.0000, Type: Exploratory)\n```python\n\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\n\n# U-Net Implementation\nclass DoubleConv(nn.Module):\n    def __init__(self, in_channels, out_channels):\n        super().__init__()\n        self.double_conv = nn.Sequential(\n            nn.Conv2d(in_channels, out_channels, kernel_size=3, padding=1),\n            nn.BatchNorm2d(out_channels),\n            nn.Softmax(dim=-1),\n            nn.Conv2d(out_channels, out_channels, kernel_size=3, padding=1),\n            nn.BatchNorm2d(out_channels),\n            nn.Softmax(dim=-1)\n        )\n\n    def forward(self, x):\n        return self.double_conv(x)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_channels, out_channels, features):\n        \"\"\"\n        :param in_channels: Number of input channels\n        :param out_channels: Number of output channels\n        :param features: Number of base features (will be doubled in each layer)\n        \"\"\"\n        super(ModelNew, self).__init__()\n        self.encoder1 = DoubleConv(in_channels, features)\n        self.pool1 = nn.MaxPool2d(kernel_size=2, stride=2)\n        self.encoder2 = DoubleConv(features, features * 2)\n        self.pool2 = nn.MaxPool2d(kernel_size=2, stride=2)\n        self.encoder3 = DoubleConv(features * 2, features * 4)\n        self.pool3 = nn.MaxPool2d(kernel_size=2, stride=2)\n        self.encoder4 = DoubleConv(features * 4, features * 8)\n        self.pool4 = nn.MaxPool2d(kernel_size=2, stride=2)\n\n        self.bottleneck = DoubleConv(features * 8, features * 16)\n\n        self.upconv4 = nn.ConvTranspose2d(features * 16, features * 8, kernel_size=2, stride=2)\n        self.decoder4 = DoubleConv(features * 16, features * 8)\n        self.upconv3 = nn.ConvTranspose2d(features * 8, features * 4, kernel_size=2, stride=2)\n        self.decoder3 = DoubleConv(features * 8, features * 4)\n        self.upconv2 = nn.ConvTranspose2d(features * 4, features * 2, kernel_size=2, stride=2)\n        self.decoder2 = DoubleConv(features * 4, features * 2)\n        self.upconv1 = nn.ConvTranspose2d(features * 2, features, kernel_size=2, stride=2)\n        self.decoder1 = DoubleConv(features * 2, features)\n\n        self.final_conv = nn.Conv2d(features, out_channels, kernel_size=1)\n\n    def forward(self, x):\n        \"\"\"\n        :param x: Input tensor, shape (batch_size, in_channels, height, width)\n        :return: Output tensor, shape (batch_size, out_channels, height, width)\n        \"\"\"\n        enc1 = self.encoder1(x)\n        enc2 = self.encoder2(self.pool1(enc1))\n        enc3 = self.encoder3(self.pool2(enc2))\n        enc4 = self.encoder4(self.pool3(enc3))\n\n        bottleneck = self.bottleneck(self.pool4(enc4))\n\n        dec4 = self.upconv4(bottleneck)\n        dec4 = torch.cat((dec4, enc4), dim=1)\n        dec4 = self.decoder4(dec4)\n        dec3 = self.upconv3(dec4)\n        dec3 = torch.cat((dec3, enc3), dim=1)\n        dec3 = self.decoder3(dec3)\n        dec2 = self.upconv2(dec3)\n        dec2 = torch.cat((dec2, enc2), dim=1)\n        dec2 = self.decoder2(dec2)\n        dec1 = self.upconv1(dec2)\n        dec1 = torch.cat((dec1, enc1), dim=1)\n        dec1 = self.decoder1(dec1)\n\n        return self.final_conv(dec1)\n    \nbatch_size = 8\nin_channels = 8\nout_channels = 4\nheight = 64\nwidth = 512\nfeatures = 64\n# Test code for UNet\ndef get_inputs():\n    return [torch.randn(batch_size, in_channels, height, width)]\n\ndef get_init_inputs():\n    return [in_channels, out_channels, features]\n\n# =================== EVOLVE-BLOCK-END ===================\n\n```\nUnique approach: Excellent compiled (1.000), Excellent correctness (1.000), Alternative passed approach\n\n\n### Inspiration 5 (Score: 10.0000, Type: High-Performer)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n# Optimized Triton softmax kernel\n@triton.jit\ndef _softmax_kernel(\n    output_ptr,\n    input_ptr,\n    n_cols,\n    BLOCK_SIZE: tl.constexpr\n):\n    row_idx = tl.program_id(0)\n    row_start_ptr = input_ptr + row_idx * n_cols\n    col_offsets = tl.arange(0, BLOCK_SIZE)\n    input_ptrs = row_start_ptr + col_offsets\n    row = tl.load(input_ptrs, mask=col_offsets < n_cols, other=-float('inf'))\n    row_minus_max = row - tl.max(row, axis=0)\n    numerator = tl.exp(row_minus_max)\n    denominator = tl.sum(numerator, axis=0)\n    softmax_output = numerator / denominator\n    output_ptrs = output_ptr + row_idx * n_cols + col_offsets\n    tl.store(output_ptrs, softmax_output, mask=col_offsets < n_cols)\n\ndef triton_softmax(x):\n    n_rows, n_cols = x.shape\n    BLOCK_SIZE = triton.next_power_of_2(n_cols)\n    num_warps = 8\n    if BLOCK_SIZE >= 2048:\n        num_warps = 16\n    y = torch.empty_like(x)\n    grid = (n_rows,)\n    _softmax_kernel[grid](y, x, n_cols, BLOCK_SIZE=BLOCK_SIZE, num_warps=num_warps)\n    return y\n\nclass FastSoftmax(nn.Module):\n    def forward(self, x):\n        n, c, h, w = x.shape\n        x_2d = x.reshape(-1, w)\n        y_2d = triton_softmax(x_2d)\n        return y_2d.reshape(n, c, h, w)\n\n# Optimized U-Net Implementation\nclass DoubleConv(nn.Module):\n    def __init__(self, in_channels, out_channels):\n        super().__init__()\n        self.double_conv = nn.Sequential(\n            nn.Conv2d(in_channels, out_channels, kernel_size=3, padding=1),\n            nn.BatchNorm2d(out_channels),\n            FastSoftmax(),\n            nn.Conv2d(out_channels, out_channels, kernel_size=3, padding=1),\n            nn.BatchNorm2d(out_channels),\n            FastSoftmax()\n        )\n\n    def forward(self, x):\n        return self.double_conv(x)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_channels, out_channels, features):\n        super(ModelNew, self).__init__()\n        self.encoder1 = DoubleConv(in_channels, features)\n        self.pool1 = nn.MaxPool2d(kernel_size=2, stride=2)\n        self.encoder2 = DoubleConv(features, features * 2)\n        self.pool2 = nn.MaxPool2d(kernel_size=2, stride=2)\n        self.encoder3 = DoubleConv(features * 2, features * 4)\n        self.pool3 = nn.MaxPool2d(kernel_size=2, stride=2)\n        self.encoder4 = DoubleConv(features * 4, features * 8)\n        self.pool4 = nn.MaxPool2d(kernel_size=2, stride=2)\n\n        self.bottleneck = DoubleConv(features * 8, features * 16)\n\n        self.upconv4 = nn.ConvTranspose2d(features * 16, features * 8, kernel_size=2, stride=2)\n        self.decoder4 = DoubleConv(features * 16, features * 8)\n        self.upconv3 = nn.ConvTranspose2d(features * 8, features * 4, kernel_size=2, stride=2)\n        self.decoder3 = DoubleConv(features * 8, features * 4)\n        self.upconv2 = nn.ConvTranspose2d(features * 4, features * 2, kernel_size=2, stride=2)\n        self.decoder2 = DoubleConv(features * 4, features * 2)\n        self.upconv1 = nn.ConvTranspose2d(features * 2, features, kernel_size=2, stride=2)\n        self.decoder1 = DoubleConv(features * 2, features)\n\n        self.final_conv = nn.Conv2d(features, out_channels, kernel_size=1)\n\n    def forward(self, x):\n        enc1 = self.encoder1(x)\n        enc2 = self.encoder2(self.pool1(enc1))\n        enc3 = self.encoder3(self.pool2(enc2))\n        enc4 = self.encoder4(self.pool3(enc3))\n\n        bottleneck = self.bottleneck(self.pool4(enc4))\n\n        dec4 = self.upconv4(bottleneck)\n        dec4 = torch.cat((dec4, enc4), dim=1)\n        dec4 = self.decoder4(dec4)\n        dec3 = self.upconv3(dec4)\n        dec3 = torch.cat((dec3, enc3), dim=1)\n        dec3 = self.decoder3(dec3)\n        dec2 = self.upconv2(dec3)\n        dec2 = torch.cat((dec2, enc2), dim=1)\n        dec2 = self.decoder2(dec2)\n        dec1 = self.upconv1(dec2)\n        dec1 = torch.cat((dec1, enc1), dim=1)\n        dec1 = self.decoder1(dec1)\n\n        return self.final_conv(dec1)\n    \nbatch_size = 8\nin_channels = 8\nout_channels = 4\nheight = 64\nwidth = 512\nfeatures = 64\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_channels, height, width)]\n\ndef get_init_inputs():\n    return [in_channels, out_channels, features]\n\n# =================== EVOLVE-BLOCK-END ===================\n```\nUnique approach: Modification: Full rewrite, Excellent compiled (1.000), Alternative correctness approach\n\n\n\n# Current Program\n```python\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef softmax_kernel(\n    output_ptr, input_ptr, input_row_stride, output_row_stride, n_cols, \n    BLOCK_SIZE: tl.constexpr\n):\n    row_idx = tl.program_id(0)\n    row_start = row_idx * input_row_stride\n    row_start_output = row_idx * output_row_stride\n    \n    # Initialize max and sum\n    row_max = tl.full((), -float('inf'), dtype=tl.float32)\n    row_sum = tl.full((), 0.0, dtype=tl.float32)\n    \n    # First loop: compute row_max\n    for col_offset in range(0, n_cols, BLOCK_SIZE):\n        col_offsets = tl.arange(0, BLOCK_SIZE) + col_offset\n        mask = col_offsets < n_cols\n        input_ptrs = input_ptr + row_start + col_offsets\n        chunk = tl.load(input_ptrs, mask=mask, other=-float('inf'))\n        chunk_max = tl.max(chunk, axis=0)\n        row_max = tl.maximum(row_max, chunk_max)\n    \n    # Second loop: compute row_sum\n    for col_offset in range(0, n_cols, BLOCK_SIZE):\n        col_offsets = tl.arange(0, BLOCK_SIZE) + col_offset\n        mask = col_offsets < n_cols\n        input_ptrs = input_ptr + row_start + col_offsets\n        chunk = tl.load(input_ptrs, mask=mask, other=0)\n        exp_chunk = tl.exp(chunk - row_max)\n        chunk_sum = tl.sum(exp_chunk, axis=0)\n        row_sum += chunk_sum\n    \n    # Third loop: compute softmax and store\n    for col_offset in range(0, n_cols, BLOCK_SIZE):\n        col_offsets = tl.arange(0, BLOCK_SIZE) + col_offset\n        mask = col_offsets < n_cols\n        input_ptrs = input_ptr + row_start + col_offsets\n        chunk = tl.load(input_ptrs, mask=mask, other=0)\n        exp_chunk = tl.exp(chunk - row_max)\n        softmax_output = exp_chunk / row_sum\n        output_ptrs = output_ptr + row_start_output + col_offsets\n        tl.store(output_ptrs, softmax_output, mask=mask)\n\nclass TritonSoftmax(nn.Module):\n    def __init__(self):\n        super().__init__()\n    \n    def forward(self, x):\n        # Ensure contiguous memory\n        x_contig = x.contiguous()\n        # Save original shape\n        original_shape = x_contig.shape\n        # Flatten all dimensions except the last\n        if x_contig.dim() > 2:\n            x_2d = x_contig.view(-1, original_shape[-1])\n        else:\n            x_2d = x_contig\n        \n        # If the tensor is 1D, then we treat as 2D with one row\n        if x_2d.dim() == 1:\n            x_2d = x_2d.unsqueeze(0)\n        \n        n_rows, n_cols = x_2d.shape\n        output = torch.empty_like(x_2d)\n        \n        # Use fixed block size for chunk processing\n        BLOCK_SIZE = 1024\n        \n        # The kernel uses the grid of n_rows\n        grid = (n_rows,)\n        \n        input_row_stride = x_2d.stride(0)\n        output_row_stride = output.stride(0)\n        \n        # Launch kernel\n        softmax_kernel[grid](\n            output, x_2d, \n            input_row_stride, output_row_stride, \n            n_cols, \n            BLOCK_SIZE=BLOCK_SIZE\n        )\n        \n        # Reshape back to original\n        return output.view(original_shape)\n```\n\n# Task\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```\n", "responses": ["<think>\nWe are given a Triton softmax kernel that uses three loops (for max, sum, and then softmax) and a fixed BLOCK_SIZE of 1024.\n The current performance shows a speed_up of 0.341 (which is slower than the reference) and we are asked to improve it.\n\n Observations:\n 1. The current implementation uses a fixed BLOCK_SIZE (1024) and processes the row in chunks. This might not be optimal for all input sizes.\n 2. The kernel does three passes over the data (for max, for sum, for softmax) which might be improved by using a two-pass kernel (max and then sum and softmax in one pass) or even a one-pass online algorithm? \n    However, note that the online softmax algorithm is more complex and might not be necessary if we can fuse the second and third passes.\n 3. The current implementation uses a fixed BLOCK_SIZE. We can instead use a tunable BLOCK_SIZE and also adjust the number of warps.\n\n However, note from the top-performing programs that a single-pass kernel (like in Inspiration 1) is simpler and faster for the same problem? \n But our current kernel is designed for large rows that cannot fit in a single block? \n\n Let's check the input: \n   The test input is of shape (batch_size=8, in_channels=8, height=64, width=512). \n   The softmax is applied along the last dimension (width=512). \n   So each row has 512 elements.\n\n Since 512 is less than 1024, the current fixed BLOCK_SIZE (1024) would process the entire row in one chunk. \n Therefore, the three loops would each run only once. \n\n But why is it slow? \n   The kernel does three separate passes (each with a loop that runs once) and each pass loads the data again.\n\n We can try to fuse the second and third passes? Actually, we cannot because the row_sum is needed for the entire row before we can compute the softmax.\n\n However, note that in the case of a row that fits in one block, we can do everything in one block without the loops? \n\n Let's restructure the kernel to handle two cases:\n   Case 1: n_cols <= BLOCK_SIZE: we can load the entire row and do the standard softmax in one pass.\n   Case 2: n_cols > BLOCK_SIZE: we break the row into chunks and do the three-pass method.\n\n But note: the current problem has n_cols=512, which is less than 1024. So we are in Case 1.\n\n Why not write a kernel that does the entire row in one block when possible? \n\n We can try to write a kernel that uses a single block per row and does the softmax in one go (like the simpler kernel in Inspiration 1) for rows that fit in the block.\n\n However, the current kernel already uses a block size of 1024 and 512 < 1024, so it should be processing the entire row in one block. \n But note: the current kernel does three loops (each loop runs once) and each loop does a load. So we are loading the same row three times.\n\n We can combine the three loops into one? Actually, we cannot because the row_max must be known for the entire row before we can compute the exponentials and the row_sum.\n\n However, we can do:\n   First pass: compute the row_max (one loop, one load)\n   Then, in a second loop we can:\n        load the chunk again, compute exponential and add to row_sum (as we do now) and then also compute the softmax and store? \n        But wait: we need the row_sum to compute the softmax for the entire row. So we cannot do the softmax in the same loop as the row_sum.\n\n Therefore, we are stuck with at least two passes (one for max, one for sum and then one for softmax) unless we use a two-pass kernel that first computes the max and then the sum and then the softmax.\n\n But note: we can fuse the second and third loops? \n   In the second loop we compute the row_sum. In the third loop we compute the softmax. \n   However, the third loop requires the row_sum which is computed in the second loop. So we cannot fuse them.\n\n Alternatively, we can use a two-pass kernel:\n   Pass 1: compute row_max and row_sum (by loading the data once, then compute exp(row - row_max) and accumulate the sum). But note: the row_max we get in the first pass is the max of the entire row? \n   Actually, we cannot compute the row_sum in the first pass because we don't have the row_max until the end of the first pass.\n\n So we are stuck with three passes? \n\n However, there is an online algorithm for softmax that can compute the max and the sum in one pass and then we can do the softmax in a second pass? \n   We can do:\n      row_max = -inf\n      row_sum = 0\n      for each chunk:\n          load chunk\n          local_max = max(chunk)\n          new_max = max(row_max, local_max)\n          # Now adjust the current row_sum: row_sum = row_sum * exp(row_max - new_max) + sum(exp(chunk - new_max))\n          row_sum = row_sum * tl.exp(row_max - new_max) + tl.sum(tl.exp(chunk - new_max), axis=0)\n          row_max = new_max\n\n   Then we have the row_max and row_sum for the entire row. Then we can do the third pass to compute the softmax.\n\n   But this algorithm requires two passes (one for the online max and sum, and one for the softmax). \n\n   However, note that the current kernel does three passes (each with a loop over chunks). The online algorithm would do two passes? \n        Actually, the online algorithm does one pass for the max and sum (with adjustments) and then a second pass for the softmax.\n\n   So we can reduce from three passes to two.\n\n Let's try to implement the two-pass softmax:\n\n   Pass 1: online computation of max and sum (with adjustments)\n   Pass 2: compute softmax and store.\n\n Steps for Pass 1:\n   row_max = -inf\n   row_sum = 0.0\n   for col_offset in range(0, n_cols, BLOCK_SIZE):\n        load the chunk\n        local_max = tl.max(chunk, axis=0)   # but note: we are loading a chunk, so we need the max of the chunk? Actually, we are processing by chunks, so we can compute the max of the chunk and then update the global max?\n        new_max = tl.maximum(row_max, local_max)\n        # Now adjust the existing row_sum: multiply by exp(row_max - new_max) and then add the sum of exp(chunk - new_max)\n        # But note: the existing row_sum was computed relative to row_max, so we need to adjust it to the new_max.\n        row_sum = row_sum * tl.exp(row_max - new_max) + tl.sum(tl.exp(chunk - new_max), axis=0)\n        row_max = new_max\n\n   Then we have the row_max and row_sum.\n\n   Pass 2: \n        for col_offset in range(0, n_cols, BLOCK_SIZE):\n            load the chunk\n            exp_chunk = tl.exp(chunk - row_max)\n            softmax_output = exp_chunk / row_sum\n            store\n\n   This reduces the number of passes from three to two.\n\n   However, note that the online algorithm for the sum requires more operations per chunk (including an exponentiation and a multiplication for the entire existing row_sum) and then a reduction for the new chunk.\n\n   But we are reducing the number of times we load the data from 3 to 2.\n\n   Given that memory access is expensive, this might be a win.\n\n   Also, note that in the current three-pass kernel, the first pass (max) does a load and a reduction (max), the second pass (sum) does a load, an exponential, and a reduction (sum), and the third pass does a load, an exponential, and a store.\n\n   The two-pass kernel:\n        Pass1: load, reduction (max of the chunk) and then an exponential and a reduction (sum) for the chunk and also an adjustment of the previous sum (which is a scalar operation).\n        Pass2: load, exponential, and store.\n\n   So we are saving one entire load of the data.\n\n   Since the row is 512 elements (and we are using one block of 1024, so one chunk) then the current kernel does 3*512 loads. The new kernel would do 2*512 loads.\n\n   This could be a 33% reduction in memory traffic.\n\n   However, note that the online algorithm for the sum adjustment requires:\n        row_sum = row_sum * tl.exp(row_max - new_max)   [a scalar operation] \n        plus the sum of the exponentials of the current chunk (relative to new_max).\n\n   This is acceptable.\n\n   Also note: we must be cautious about numerical stability. The online algorithm is known to be stable.\n\n Let's change the kernel to the two-pass online algorithm.\n\n Steps:\n\n   row_max = -inf\n   row_sum = 0.0\n\n   for col_offset in range(0, n_cols, BLOCK_SIZE):\n        col_offsets = tl.arange(0, BLOCK_SIZE) + col_offset\n        mask = col_offsets < n_cols\n        input_ptrs = input_ptr + row_start + col_offsets\n        chunk = tl.load(input_ptrs, mask=mask, other=-float('inf'))\n        # Compute local max of the chunk (ignore out-of-bound values? we set to -inf so they won't affect)\n        local_max = tl.max(chunk, axis=0)\n        new_max = tl.maximum(row_max, local_max)\n        # Adjust the current row_sum: \n        #   The current row_sum is for the previous chunks relative to the old row_max. We want to express it relative to new_max.\n        scale = tl.exp(row_max - new_max)\n        row_sum = row_sum * scale\n        # Now add the exponentials of the current chunk relative to new_max (only the valid ones)\n        exp_vals = tl.exp(chunk - new_max)\n        # But note: we must set the out-of-bound values to 0 so they don't contribute to the sum?\n        # Actually, we set the chunk to -inf for out-of-bound, but then we masked the load? So the out-of-bound are set to -inf? \n        # We set the other=-float('inf') in the load, so for out-of-bound we have -inf -> exp(-inf)=0. So it's safe.\n        chunk_sum = tl.sum(exp_vals, axis=0)\n        row_sum += chunk_sum\n        row_max = new_max\n\n   Then the second loop (for the softmax) remains the same.\n\n   We are doing two passes: one for the online max/sum and one for the softmax.\n\n   This should be faster because we are doing one less pass.\n\n   Also, we can tune the BLOCK_SIZE. Currently it is fixed to 1024. But for the given row of 512, we are using one chunk. \n   However, we can set BLOCK_SIZE to 512 (or to the next power of two of the row length) and then use one chunk.\n\n   But note: the kernel must handle rows of any length. So we keep the loop.\n\n   We can also use autotuning for BLOCK_SIZE and num_warps.\n\n   Since the current program does not use autotuning, we can add it.\n\n   However, note the constraints: \n        \u274c NEVER change @triton.jit function signatures or parameter names\n\n   We are allowed to change the kernel body and add autotuning? \n\n   The signature of the kernel function must remain the same? Actually, the problem says: \"NEVER change @triton.jit function signatures or parameter names\"\n\n   So we cannot change the parameters. But we can change the body and we can add an autotuner decorator? \n\n   The current kernel has parameters: \n        output_ptr, input_ptr, input_row_stride, output_row_stride, n_cols, BLOCK_SIZE: tl.constexpr\n\n   We can add an autotuner that configures BLOCK_SIZE and num_warps? \n\n   Also, note that the grid is set as (n_rows,). \n\n   We are going to:\n        - Change the kernel to the two-pass online algorithm.\n        - Add an autotuner to select BLOCK_SIZE and num_warps.\n\n   But note: the problem says to change only the Triton kernel source within the EVOLVE-BLOCK. And the current program includes a class TritonSoftmax and the kernel.\n\n   We are going to rewrite the kernel and also change the launch to use autotuning.\n\n   However, the current kernel launch uses a fixed BLOCK_SIZE (1024). We want to make BLOCK_SIZE configurable by the autotuner.\n\n   How autotuning works in Triton: \n        We wrap the kernel with @triton.autotune and provide a list of configs.\n\n   We can do:\n\n        @triton.autotune(\n            configs=[\n                triton.Config({'BLOCK_SIZE': 128}, num_warps=1),\n                triton.Config({'BLOCK_SIZE': 128}, num_warps=2),\n                triton.Config({'BLOCK_SIZE': 128}, num_warps=4),\n                triton.Config({'BLOCK_SIZE': 128}, num_warps=8),\n                triton.Config({'BLOCK_SIZE': 256}, num_warps=1),\n                triton.Config({'BLOCK_SIZE': 256}, num_warps=2),\n                triton.Config({'BLOCK_SIZE': 256}, num_warps=4),\n                triton.Config({'BLOCK_SIZE': 256}, num_warps=8),\n                triton.Config({'BLOCK_SIZE': 512}, num_warps=1),\n                triton.Config({'BLOCK_SIZE': 512}, num_warps=2),\n                triton.Config({'BLOCK_SIZE': 512}, num_warps=4),\n                triton.Config({'BLOCK_SIZE': 512}, num_warps=8),\n                triton.Config({'BLOCK_SIZE': 1024}, num_warps=1),\n                triton.Config({'BLOCK_SIZE': 1024}, num_warps=2),\n                triton.Config({'BLOCK_SIZE': 1024}, num_warps=4),\n                triton.Config({'BLOCK_SIZE': 1024}, num_warps=8),\n            ],\n            key=['n_cols'],\n        )\n        @triton.jit\n        def softmax_kernel(...)\n\n   Then when launching, we remove the BLOCK_SIZE from the kernel call and let the autotuner set it.\n\n   But note: the kernel must be called with the same parameters. We are now adding an autotuner decorator and changing the way we call the kernel? \n\n   Actually, we are allowed to change the kernel and the way it is called as long as the function signature (the parameters) of the @triton.jit function remains the same.\n\n   The autotuner will generate multiple versions of the kernel and select the best one at runtime.\n\n   We must also remove the fixed BLOCK_SIZE in the kernel launch and instead use the config.\n\n   How do we do that?\n        We remove the BLOCK_SIZE from the kernel launch and let the autotuner set it.\n\n        But note: the kernel requires BLOCK_SIZE as a tl.constexpr. So we must pass it. However, the autotuner will set it via the config.\n\n        We change the kernel call to:\n            softmax_kernel[grid](\n                output, x_2d, \n                input_row_stride, output_row_stride, \n                n_cols, \n                # BLOCK_SIZE=BLOCK_SIZE   # we remove this because the autotuner will set it\n            )\n\n        But wait: the autotuner sets the BLOCK_SIZE via the config. We don't pass it as an argument? \n\n        Actually, we do not pass it as an argument. The autotuner will set it as a kernel parameter (like a constant) for each version.\n\n        However, note that the kernel signature has BLOCK_SIZE as a tl.constexpr. The autotuner will set it per configuration.\n\n        So we remove the BLOCK_SIZE argument in the kernel launch.\n\n   But then how does the kernel know BLOCK_SIZE? \n        It becomes a constant in the kernel for that particular configuration.\n\n   Therefore, we must remove the BLOCK_SIZE from the kernel call.\n\n   However, the current kernel signature is:\n\n        def softmax_kernel(\n            output_ptr, input_ptr, input_row_stride, output_row_stride, n_cols, \n            BLOCK_SIZE: tl.constexpr\n        ):\n\n   And we are calling it with 6 arguments (including BLOCK_SIZE). \n\n   If we remove the BLOCK_SIZE from the call, then we are passing 5 arguments and the kernel expects 6? \n\n   We must remove the BLOCK_SIZE from the kernel parameters? \n\n   But note: the autotuner sets the BLOCK_SIZE as a constant. So we can remove it from the kernel parameters? \n\n   Actually, no. The autotuner sets the constants that are in the config, but they must be present as kernel parameters (with the same name) and of type tl.constexpr.\n\n   How do we reconcile? \n\n   We keep the BLOCK_SIZE in the kernel parameters and then we do not pass it in the call? \n\n   But Triton requires that every tl.constexpr parameter must be provided at launch? \n\n   Alternatively, we can use the autotuner to set the BLOCK_SIZE and then not pass it? \n\n   Actually, in the autotuner example, the kernel parameters that are tuned are passed as constants and are not included in the call.\n\n   So we change the kernel signature to remove the BLOCK_SIZE from the argument list? \n\n   But note the constraint: \"NEVER change @triton.jit function signatures or parameter names\"\n\n   We are going to change the signature? \n\n   Alternatively, we can leave the BLOCK_SIZE in the signature and then in the autotuner we set it by the config and then we pass it as an argument? \n\n   But that would be redundant. \n\n   Actually, the autotuner will override the value of BLOCK_SIZE that we pass? \n\n   We can try to pass it as an argument and also have it in the config? That would cause an error (as seen in one of the previous attempts: \"Conflicting meta-parameters: BLOCK_SIZE\").\n\n   Therefore, we must remove the BLOCK_SIZE from the kernel parameters? \n\n   But note: the constraint says we cannot change the function signature. \n\n   How about we change the kernel to have BLOCK_SIZE as a config parameter and not an argument? \n\n   We can do:\n\n        @triton.autotune(...)\n        @triton.jit\n        def softmax_kernel(\n            output_ptr, input_ptr, input_row_stride, output_row_stride, n_cols\n        ):\n            # and then inside we use BLOCK_SIZE as a constant that is set by the autotuner.\n\n   But then we remove the BLOCK_SIZE from the parameters? \n\n   That changes the signature. \n\n   Alternatively, we can leave the BLOCK_SIZE in the parameters and not pass it in the call? That would cause an error because we are missing an argument.\n\n   We must pass the same number of arguments as the kernel expects.\n\n   This is a dilemma.\n\n   Let me look at the Inspiration 1 program: \n        It does not use autotuning and has a fixed BLOCK_SIZE as a kernel parameter.\n\n   How about we do not use autotuning and instead set BLOCK_SIZE to the next power of two of the row length? \n\n   We can do:\n\n        BLOCK_SIZE = triton.next_power_of_2(n_cols)\n\n   and then if BLOCK_SIZE is too big (say > 4096) we cap it? \n\n   But note: the row length is 512, so BLOCK_SIZE would be 512.\n\n   Then we would have one chunk? \n\n   Then the two-pass kernel would do two passes (each with one chunk) and that is two loads.\n\n   This is better than the current three loads.\n\n   We can try:\n\n        Step 1: change the kernel to the two-pass online algorithm.\n        Step 2: set BLOCK_SIZE to triton.next_power_of_2(n_cols) in the launch.\n\n   Why is that better than autotuning? \n        Because we avoid the autotuning complexity and the constraint on the signature.\n\n   Also, note that the autotuning might try many configurations and that has overhead. Since the row length is fixed per call (n_cols) we can set BLOCK_SIZE accordingly.\n\n   We choose BLOCK_SIZE as the next power of two of n_cols, but at least 128? and at most 4096? \n\n   Actually, we can set:\n\n        BLOCK_SIZE = triton.next_power_of_2(n_cols)\n\n   and then if BLOCK_SIZE is too large (e.g., > 4096) we can clamp it? \n\n   But note: the kernel must work for any n_cols. So if n_cols is very large, we break it into chunks.\n\n   The two-pass kernel already handles chunking. So we can set BLOCK_SIZE to a fixed value (like 1024) or to the next power of two? \n\n   The advantage of setting it to the next power of two of n_cols is that if the row fits in one block, we use one block. Otherwise, we break it into chunks of size BLOCK_SIZE.\n\n   But note: the two-pass kernel does chunking. So we can set BLOCK_SIZE to 1024 and then it would break rows longer than 1024? \n\n   For our problem (n_cols=512) we want BLOCK_SIZE>=512. We set it to 512.\n\n   So we do:\n\n        BLOCK_SIZE = min(triton.next_power_of_2(n_cols), 4096)\n\n   But note: triton.next_power_of_2(512) is 512.\n\n   We'll set BLOCK_SIZE = 512.\n\n   Then the kernel will do:\n        Pass1: one chunk -> one load\n        Pass2: one chunk -> one load\n\n   Total: 2 loads.\n\n   The current kernel (with fixed 1024) did 3 loads.\n\n   So we are saving one load per row.\n\n   This should be faster.\n\n   Let's change the kernel to the two-pass online algorithm and set BLOCK_SIZE to the next power of two of n_cols (capped at 4096).\n\n   We also note that we are not changing the function signature.\n\n   However, we are changing the body and the way we set BLOCK_SIZE.\n\n   Implementation:\n\n        We remove the three loops and replace with:\n\n        # Two-pass online algorithm for softmax\n        # Pass 1: online max and sum\n        row_max = -float('inf')\n        row_sum = 0.0\n        for col_offset in range(0, n_cols, BLOCK_SIZE):\n            col_offsets = tl.arange(0, BLOCK_SIZE) + col_offset\n            mask = col_offsets < n_cols\n            input_ptrs = input_ptr + row_start + col_offsets\n            chunk = tl.load(input_ptrs, mask=mask, other=-float('inf'))\n            # Compute local max of the chunk\n            local_max = tl.max(chunk, axis=0)\n            new_max = tl.maximum(row_max, local_max)\n            # Adjust the current row_sum: row_sum = row_sum * exp(row_max - new_max) + sum(exp(chunk - new_max))\n            scale = tl.exp(row_max - new_max)\n            row_sum = row_sum * scale\n            # Compute the exponentials for the current chunk (with the new_max) and sum them\n            exp_vals = tl.exp(chunk - new_max)\n            # We need to set the out-of-bound values to 0? Actually, the load set them to -inf and exp(-inf)=0, but let's mask to be safe?\n            # Instead, we can use the mask to set invalid to 0? But the load already set them to -inf -> exp(-inf)=0. So it's safe.\n            chunk_sum = tl.sum(exp_vals, axis=0)\n            row_sum += chunk_sum\n            row_max = new_max\n\n        # Pass 2: compute softmax and store\n        for col_offset in range(0, n_cols, BLOCK_SIZE):\n            col_offsets = tl.arange(0, BLOCK_SIZE) + col_offset\n            mask = col_offsets < n_cols\n            input_ptrs = input_ptr + row_start + col_offsets\n            chunk = tl.load(input_ptrs, mask=mask, other=0)   # set out-of-bound to 0? but we are going to mask the store anyway. But note: we are doing exp(chunk - row_max) and then dividing by row_sum. If we set to 0, then it becomes exp(-row_max) which is not zero. So we must set to -inf? Or we can set to 0 and then mask the exponential? \n\n            # Actually, we want the out-of-bound to be 0 in the output? \n            # We set the load other=0? But then note: the exponentiation: if we set to 0 then we get exp(0 - row_max) which is a finite number. But we don't want to include it.\n\n            # We should set the out-of-bound to a value that when exponentiated becomes 0? So -inf. But note: we set the mask for the store, so we won't store them. But the problem is that we are doing an exponential and then dividing by row_sum for the entire chunk? \n\n            # We can set the out-of-bound to 0 and then mask the exponential? \n\n            # Alternatively, we can set the load to -inf for out-of-bound and then the exponential will be 0. And then we mask the store? \n\n            # We change the load to set other=-float('inf')? \n\n            # But note: in the first pass we set other=-float('inf') and that worked. So we do the same here.\n\n            # Let me change the load in the second pass to set other=-float('inf').\n\n            # Then we do:\n            exp_vals = tl.exp(chunk - row_max)\n            softmax_output = exp_vals / row_sum\n            output_ptrs = output_ptr + row_start_output + col_offsets\n            tl.store(output_ptrs, softmax_output, mask=mask)\n\n   We must change the second load to set other=-float('inf') so that the out-of-bound become 0 after exponentiation? \n        But note: we are masking the store. So even if we set the out-of-bound to 0, we won't store them. However, the computation for the out-of-bound would be exp(0 - row_max) and that is not zero. \n\n        We want the out-of-bound to be 0 in the output? \n\n        Actually, the output for out-of-bound should not be written (because of the mask) so it doesn't matter. But we are doing unnecessary computation for the out-of-bound? \n\n        We can avoid that by masking the computation? \n\n        Alternatively, we can set the out-of-bound to -inf so that exp(-inf)=0 and then the computation is 0. Then when we store we set the mask to false so we don't write. \n\n        But the computation for the out-of-bound is cheap? \n\n        Given that we are already loading the out-of-bound and then doing two operations (subtract and exp) and then a division, we might as well set the load to -inf to get 0.\n\n        So we change the second load to:\n            chunk = tl.load(input_ptrs, mask=mask, other=-float('inf'))\n\n   But note: the first load in the first pass already uses other=-float('inf'). \n\n   We are consistent.\n\n   Now, let's change the kernel accordingly.\n\n   Also, we change the launch to set BLOCK_SIZE to the next power of two of n_cols (but capped at 4096?).\n\n        BLOCK_SIZE = min(triton.next_power_of_2(n_cols), 4096)\n\n   But note: if n_cols is 0, then we skip. We assume n_cols>=1.\n\n   We also note that the kernel must work for any n_cols, even if it is not a power of two.\n\n   We are using a loop that steps by BLOCK_SIZE and then uses a mask for the last chunk.\n\n   This is safe.\n\n   Let's code accordingly.\n\n   We'll also set the number of warps? \n        We can set num_warps based on BLOCK_SIZE? \n        For example, if BLOCK_SIZE <= 512, we set num_warps=4? \n        But we are not autotuning, so we can leave it to the default? \n\n   However, the current program does not set num_warps. We can try to set it to 4 or 8? \n\n   But note: the problem says we can change the kernel and the launch. \n\n   We can do:\n\n        num_warps = 4\n        if BLOCK_SIZE >= 2048:\n            num_warps = 8\n        elif BLOCK_SIZE >= 1024:\n            num_warps = 4\n        else:\n            num_warps = 2\n\n   But without autotuning, it's hard to know. \n\n   Alternatively, we can leave it out and let Triton choose? \n\n   The current program did not set num_warps. We can try without first and then if performance is not good, we can adjust.\n\n   Given the time, we will not set num_warps for now.\n\n   We change the kernel and the launch.\n\n   Summary of changes:\n\n        In the kernel:\n            Replace the three loops with two loops (online max/sum and then softmax).\n\n        In the launch:\n            Set BLOCK_SIZE = min(triton.next_power_of_2(n_cols), 4096)\n\n   We hope that this will reduce the number of loads from 3 to 2 per row and thus improve performance.\n\n   Since the row length is 512, the current kernel did 3*512 loads and the new kernel will do 2*512 loads.\n\n   This should give a speedup of 3/2 = 1.5x? But note there is also the computation. \n\n   We are also changing the computation in the first pass (which is more expensive: two exponentials and a multiplication of a scalar) but that is negligible compared to the memory access.\n\n   Let's code accordingly.\n\n   Note: We must be cautious about numerical stability. The online algorithm is standard.\n\n   We'll write the kernel accordingly.\n\n   We also note: the online algorithm for the sum adjustment:\n\n        row_sum = row_sum * tl.exp(row_max - new_max)   [this is a scalar]\n        then add the sum of exp(chunk - new_max)\n\n   This is correct.\n\n   Now, let's write the code.\n\n   IMPORTANT: The current program includes the entire module. We are only allowed to change the Triton kernel and the launch configuration.\n\n   We are going to output the entire code block with the changes.\n\n   But note: the problem says to output only the code within the EVOLVE-BLOCK. We are going to output the entire program as required.\n\n   However, note that the current program does not include the entire U-Net? It only includes the TritonSoftmax class and the kernel.\n\n   But the problem says: \"Provide the complete new program code.\"\n\n   And the example above (the current program) is just the Triton kernel and the module for softmax.\n\n   We will rewrite the Triton kernel and the forward method of TritonSoftmax.\n\n   We note that the current program does not have the U-Net. But the top-performing program in the history that was given as an example had the U-Net? \n\n   Actually, the current program is:\n\n        @triton.jit\n        def softmax_kernel(...)\n\n        class TritonSoftmax(nn.Module):\n            ...\n\n   So we output:\n\n        @triton.jit\n        def softmax_kernel(...)   [with the two-pass online algorithm]\n\n        class TritonSoftmax(nn.Module):\n            ... [with the BLOCK_SIZE set to min(triton.next_power_of_2(n_cols), 4096)]\n\n   We do not change the rest.\n\n   Let's write it.\n</think>\nThe new implementation optimizes the softmax kernel by reducing the number of memory passes from three to two using an online algorithm for max and sum computation. This minimizes memory accesses while maintaining numerical stability. The block size is dynamically set to the next power of two of the column size for efficient processing.\n\n```python\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef softmax_kernel(\n    output_ptr, input_ptr, input_row_stride, output_row_stride, n_cols, \n    BLOCK_SIZE: tl.constexpr\n):\n    row_idx = tl.program_id(0)\n    row_start = row_idx * input_row_stride\n    row_start_output = row_idx * output_row_stride\n    \n    row_max = tl.full((), -float('inf'), dtype=tl.float32)\n    row_sum = tl.full((), 0.0, dtype=tl.float32)\n    \n    # First pass: online computation of max and sum\n    for col_offset in range(0, n_cols, BLOCK_SIZE):\n        col_offsets = tl.arange(0, BLOCK_SIZE) + col_offset\n        mask = col_offsets < n_cols\n        input_ptrs = input_ptr + row_start + col_offsets\n        chunk = tl.load(input_ptrs, mask=mask, other=-float('inf'))\n        \n        local_max = tl.max(chunk, axis=0)\n        new_max = tl.maximum(row_max, local_max)\n        \n        scale = tl.exp(row_max - new_max)\n        row_sum = row_sum * scale\n        \n        exp_vals = tl.exp(chunk - new_max)\n        chunk_sum = tl.sum(exp_vals, axis=0)\n        row_sum += chunk_sum\n        row_max = new_max\n    \n    # Second pass: compute and store softmax\n    for col_offset in range(0, n_cols, BLOCK_SIZE):\n        col_offsets = tl.arange(0, BLOCK_SIZE) + col_offset\n        mask = col_offsets < n_cols\n        input_ptrs = input_ptr + row_start + col_offsets\n        chunk = tl.load(input_ptrs, mask=mask, other=-float('inf'))\n        \n        exp_vals = tl.exp(chunk - row_max)\n        softmax_output = exp_vals / row_sum\n        output_ptrs = output_ptr + row_start_output + col_offsets\n        tl.store(output_ptrs, softmax_output, mask=mask)\n\nclass TritonSoftmax(nn.Module):\n    def __init__(self):\n        super().__init__()\n    \n    def forward(self, x):\n        x_contig = x.contiguous()\n        original_shape = x_contig.shape\n        \n        if x_contig.dim() > 2:\n            x_2d = x_contig.view(-1, original_shape[-1])\n        else:\n            x_2d = x_contig\n        \n        if x_2d.dim() == 1:\n            x_2d = x_2d.unsqueeze(0)\n        \n        n_rows, n_cols = x_2d.shape\n        output = torch.empty_like(x_2d)\n        \n        BLOCK_SIZE = min(triton.next_power_of_2(n_cols), 4096)\n        grid = (n_rows,)\n        \n        input_row_stride = x_2d.stride(0)\n        output_row_stride = output.stride(0)\n        \n        softmax_kernel[grid](\n            output, x_2d, \n            input_row_stride, output_row_stride, \n            n_cols, \n            BLOCK_SIZE=BLOCK_SIZE\n        )\n        \n        return output.view(original_shape)\n```"]}}}