{"id": "7bf5841e-12c8-4ec0-93ab-2a4c98c36de1", "code": "# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 64}, num_warps=4, num_stages=4),\n        triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 64}, num_warps=4, num_stages=3),\n        triton.Config({'BLOCK_SIZE_M': 256, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 64}, num_warps=4, num_stages=3),\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 256, 'BLOCK_SIZE_K': 64}, num_warps=4, num_stages=3),\n        triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 128}, num_warps=8, num_stages=3),\n        triton.Config({'BLOCK_SIZE_M': 256, 'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 128}, num_warps=8, num_stages=3),\n        triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 256, 'BLOCK_SIZE_K': 128}, num_warps=8, num_stages=3),\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 128}, num_warps=4, num_stages=4),\n        triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 128}, num_warps=4, num_stages=4),\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 128}, num_warps=4, num_stages=4),\n    ],\n    key=['M', 'N', 'K'],\n)\n@triton.jit\ndef _matmul_kernel(\n    A_ptr, B_ptr, C_ptr,\n    M, N, K,\n    stride_am, stride_ak,\n    stride_bk, stride_bn,\n    stride_cm, stride_cn,\n    BLOCK_SIZE_M: tl.constexpr, BLOCK_SIZE_N: tl.constexpr, BLOCK_SIZE_K: tl.constexpr,\n):\n    pid = tl.program_id(0)\n    num_pid_n = tl.cdiv(N, BLOCK_SIZE_N)\n    pid_m = pid // num_pid_n\n    pid_n = pid % num_pid_n\n    \n    offs_m = pid_m * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)\n    offs_n = pid_n * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n    offs_k = tl.arange(0, BLOCK_SIZE_K)\n    \n    A_ptr += offs_m[:, None] * stride_am + offs_k[None, :] * stride_ak\n    B_ptr += offs_k[:, None] * stride_bk + offs_n[None, :] * stride_bn\n    \n    acc = tl.zeros((BLOCK_SIZE_M, BLOCK_SIZE_N), dtype=tl.float32)\n    for k in range(0, tl.cdiv(K, BLOCK_SIZE_K)):\n        k_remaining = K - k * BLOCK_SIZE_K\n        k_mask = offs_k[None, :] < k_remaining\n        a = tl.load(A_ptr, mask=(offs_m[:, None] < M) & k_mask, other=0.0)\n        b = tl.load(B_ptr, mask=k_mask & (offs_n[None, :] < N), other=0.0)\n        acc += tl.dot(a, b, allow_tf32=True)\n        A_ptr += BLOCK_SIZE_K * stride_ak\n        B_ptr += BLOCK_SIZE_K * stride_bk\n    \n    offs_cm = pid_m * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)\n    offs_cn = pid_n * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n    C_ptr += offs_cm[:, None] * stride_cm + offs_cn[None, :] * stride_cn\n    c_mask = (offs_cm[:, None] < M) & (offs_cn[None, :] < N)\n    tl.store(C_ptr, acc, mask=c_mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self):\n        super(ModelNew, self).__init__()\n    \n    def forward(self, A, B):\n        n, m, k = A.shape\n        l = B.shape[1]\n        A_flat = A.view(-1, k)\n        C_flat = torch.empty((n * m, l), device=A.device, dtype=A.dtype)\n        \n        grid = lambda meta: (triton.cdiv(n * m, meta['BLOCK_SIZE_M']) * triton.cdiv(l, meta['BLOCK_SIZE_N']),)\n        \n        _matmul_kernel[grid](\n            A_flat, B, C_flat,\n            n * m, l, k,\n            A_flat.stride(0), A_flat.stride(1),\n            B.stride(0), B.stride(1),\n            C_flat.stride(0), C_flat.stride(1),\n        )\n        \n        return C_flat.view(n, m, l)\n\nN = 16\nM = 1024\nK = 2048\nL = 768\n\ndef get_inputs():\n    A = torch.randn(N, M, K, device='cuda')\n    B = torch.randn(K, L, device='cuda')\n    return [A, B]\n\ndef get_init_inputs():\n    return []\n# =================== EVOLVE-BLOCK-END ===================", "language": "python", "parent_id": "5b73f60c-a1b9-4b8f-a29f-d7f2d4c87d97", "generation": 2, "timestamp": 1754635272.523412, "iteration_found": 6, "metrics": {"compiled": true, "correctness": false, "score": 10, "stage": "wrong_answer", "verify_payload": {"id": "level1_10_3D_tensor_matrix_multiplication", "result": {"compiled": true, "correctness": false, "metadata": {"hardware": "NVIDIA L20Y", "device": "cuda:7", "runtime_error": "Traceback (most recent call last):\n  File \"/cpfs01/shared/llm_kernel/hujiakai/KernelLLM/validation_api_server/helpers/evaluations.py\", line 720, in run_and_check_correctness\n    output_new = model_new(*inputs)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1773, in _wrapped_call_impl\n    return self._call_impl(*args, **kwargs)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1784, in _call_impl\n    return forward_call(*args, **kwargs)\n  File \"/tmp/tmpikn2s5os.py\", line 71, in forward\n    _matmul_kernel[grid](\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 390, in <lambda>\n    return lambda *args, **kwargs: self.run(grid=grid, warmup=False, *args, **kwargs)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 239, in run\n    benchmark()\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 228, in benchmark\n    timings = {config: self._bench(*args, config=config, **kwargs) for config in pruned_configs}\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 228, in <dictcomp>\n    timings = {config: self._bench(*args, config=config, **kwargs) for config in pruned_configs}\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 160, in _bench\n    return self.do_bench(kernel_call, quantiles=(0.5, 0.2, 0.8))\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/testing.py\", line 149, in do_bench\n    fn()\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 146, in kernel_call\n    self.fn.run(\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 594, in run\n    kernel = self.compile(src, target=target, options=options.__dict__)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/compiler/compiler.py\", line 339, in compile\n    module = src.make_ir(options, codegen_fns, module_map, context)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/compiler/compiler.py\", line 83, in make_ir\n    return ast_to_ttir(self.fn, self, context=context, options=options, codegen_fns=codegen_fns,\ntriton.compiler.errors.CompilationError: at 26:32:\n    offs_n = pid_n * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n    offs_k = tl.arange(0, BLOCK_SIZE_K)\n\n    A_ptr += offs_m[:, None] * stride_am + offs_k[None, :] * stride_ak\n    B_ptr += offs_k[:, None] * stride_bk + offs_n[None, :] * stride_bn\n\n    acc = tl.zeros((BLOCK_SIZE_M, BLOCK_SIZE_N), dtype=tl.float32)\n    for k in range(0, tl.cdiv(K, BLOCK_SIZE_K)):\n        k_remaining = K - k * BLOCK_SIZE_K\n        k_mask = offs_k[None, :] < k_remaining\n        a = tl.load(A_ptr, mask=(offs_m[:, None] < M) & k_mask, other=0.0)\n        b = tl.load(B_ptr, mask=k_mask & (offs_n[None, :] < N), other=0.0)\n                                ^\nValueError('Cannot make_shape_compatible: incompatible dimensions at index 1: 64 and 128')\n\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/language/core.py\", line 42, in wrapper\n    return fn(*args, **kwargs)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/language/core.py\", line 966, in __and__\n    return _semantic.and_(self, other)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/language/semantic.py\", line 420, in and_\n    input, other = self.bitwise_op_type_checking_impl(input, other)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/language/semantic.py\", line 407, in bitwise_op_type_checking_impl\n    input, other = self.binary_op_type_checking_impl(input, other)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/language/semantic.py\", line 203, in binary_op_type_checking_impl\n    lhs, rhs = self.broadcast_impl_value(lhs, rhs)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/language/semantic.py\", line 749, in broadcast_impl_value\n    raise ValueError(\"Cannot make_shape_compatible: incompatible dimensions \"\nValueError: Cannot make_shape_compatible: incompatible dimensions at index 1: 64 and 128\n", "runtime_error_name": "triton.compiler.errors.CompilationError", "reference_timing_ms": 0.0294, "speed_up": -1.0, "custom_timing": -1.0}, "runtime": -1.0, "runtime_stats": {}}}}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": false, "score": 20, "speed_up": 0.023, "runtime_ms": 1.26, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:0", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.0294, "speed_up": 0.023, "custom_timing": 1.26}}, "island": 1}, "artifacts_json": null, "artifact_dir": null, "prompts": {"full_rewrite_user": {"system": "You are a Triton GPU core optimization engineer deeply familiar with NVIDIA H100/H800 architecture.\n\n==================== Context ====================\n\u2022 Dataset: 250 kernelbench/level1-level5 *.py files  \n  - Level1: simplest, Level5: most complex  \n\u2022 Each file contains PyTorch reference (reference_code)  \n\u2022 Goal: Generate functionally equivalent but faster Triton implementations (custom_code)  \n\u2022 Evaluation pipeline:\n    1) /verify_plus - Verify compilation & correctness  \n    2) /execute (optional) - Return terminal logs if compilation fails  \n    3) Scoring:  \n      - Speedup > 1 required for points  \n      - Score = (speed_up - 1) \u00d7 100  \n\u2022 GPU Hardware: NVIDIA L20Y / H800 (same SM8.9 as H100)  \n  - 3 TB/s HBM3 bandwidth  \n  - FP16 Tensor Core 32\u00d716\u00d716  \n\n==================== Evolution Phases ====================\n\u2460 Phase 1 [Compilation Pass]  \n  - Make Triton code compile (performance irrelevant)  \n\u2461 Phase 2 [Numerical Correctness]  \n  - Output must match PyTorch reference within float32 tolerance  \n\u2462 Phase 3 [Performance Gain]  \n  - Target \u22655% speedup (\u226515% = exceptional)  \n  - Official scoring based on speed_up field  \n\nThe Evolution system will pass the EVOLVE-BLOCK from the previous version.  \nModify ONLY the Triton kernel source within this block - all other code is LOCKED.\n\n==================== Constraints (MUST OBEY) ====================\n\u274c NEVER change @triton.jit function signatures or parameter names  \n\u274c NEVER modify grid configuration, output tensor shapes, or PID logic  \n\u274c NEVER remove boundary checks or out-of-bound masks  \n\u274c NEVER introduce race conditions, uninitialized reads, or sync gaps  \n\n\u2705 Allowed Optimizations (Examples):  \n  \u2022 Memory coalescing optimizations & vectorized tl.load/tl.store  \n  \u2022 Replace staged softmax with online/FlashAttention variants  \n  \u2022 Adaptive tuning: BLOCK_M/BLOCK_N/BLOCK_K dimensions  \n  \u2022 Multi-query-head batch processing (GQA, 5:1 patterns)  \n  \u2022 Shared/L2 buffering, Tensor Core alignment (FP16/bf16/tf32)  \n  \u2022 Stride precomputation & pointer caching  \n\n==================== Output Format ====================\nReturn ONLY the complete updated code containing the EVOLVE-BLOCK comment marker.  \nNO explanations, NO markdown, NO additional text.\nName the output structure class as ModelNew.\n\n==================== Optimization Tips ====================\n\u2022 If previous compile failed: Fix syntax/mask/stride errors first  \n\u2022 If correctness fails: Prioritize bounds mask & dtype precision  \n\u2022 When speed_up < 1: Focus on memory access & block sizing  \n\u2022 Small iterative steps: Modify \u226420 lines per revision  \n\u2022 Maintain reversibility between versions\nHere is an example to show you how to rewrite a PyTorch implementation that quantizes a high-precision tensor to int8 dtype with row-wise granularity into a Triton implementation: \nThe original PyTorch implementation is as follows: \n``` \nimport torch\ndef per_row_quantize_int8(x: torch.Tensor) -> tuple[torch.Tensor, torch.Tensor]:\n    x_amax = x.abs().float().amax(dim=1).clamp(min=1e-4)\n    scale = 127 / x_amax\n    output = (x * scale[:, None]).round().clamp(-127, 127).to(torch.int8)\n    output_scale = x_amax / 127\n\n    return output, output_scale\n``` \nThe corresponding Triton-rewritten implementation is as follows: \n``` \nimport math\nimport torch\nimport triton\nimport triton.language as tl\nfrom triton.language.extra import libdevice\n\n# rowwise quantize\n\n@triton.autotune(\n    configs=[\n        triton.Config({}, num_stages=1, num_warps=8),\n        triton.Config({}, num_stages=2, num_warps=8),\n        triton.Config({}, num_stages=4, num_warps=8),\n        triton.Config({}, num_stages=8, num_warps=8),\n        triton.Config({}, num_stages=1),\n        triton.Config({}, num_stages=2),\n        triton.Config({}, num_stages=4),\n        triton.Config({}, num_stages=8),\n        triton.Config({}, num_warps=1),\n        triton.Config({}, num_warps=2),\n        triton.Config({}, num_warps=4),\n        triton.Config({}, num_warps=8),\n    ],\n    key=[\"n_elements\"],\n)\n\n@triton.jit\ndef _quantize_rowwise(\n    x_ptr,\n    output_ptr,\n    output_scale,\n    BLOCK_SIZE: tl.constexpr,\n    P2: tl.constexpr,\n):\n    pid = tl.program_id(axis=0)\n    block_start = pid * BLOCK_SIZE\n    arange = tl.arange(0, P2)\n    offsets = block_start + arange\n    row_mask = arange < BLOCK_SIZE\n    x = tl.load(x_ptr + offsets, mask=row_mask)\n\n    abs_x = tl.abs(x)\n    max_val = tl.max(tl.where(row_mask, abs_x, 0), axis=0)\n    output = libdevice.llrint(127.0 * (x / max_val))\n    tl.store(output_ptr + offsets, output, mask=row_mask)\n    tl.store(output_scale + pid, max_val / 127)\n\n\ndef per_row_quantize_int8(x: torch.Tensor):\n    x = x.contiguous()\n    output = torch.empty(*x.shape, device=x.device, dtype=torch.int8)\n    output_scale = torch.empty(x.shape[0], device=x.device, dtype=torch.float32)\n    P2 = int(2 ** (math.ceil(math.log2(x.shape[1]))))\n    grid = lambda x: (x.shape[0],)\n    _quantize_rowwise[grid](x, output, output_scale, BLOCK_SIZE=x.shape[1], P2=P2)\n\n    return output, output_scale\n\n\n    \n``` \n", "user": "# Current Program Information\n- Current performance metrics: - compiled: 1.0000\n- correctness: 1.0000\n- stage: success\n- passed: 0.0000\n- score: 20.0000\n- speed_up: 0.0230\n- runtime_ms: 1.2600\n- meta: {'hardware': 'NVIDIA L20Y', 'device': 'cuda:0', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.0294, 'speed_up': 0.023, 'custom_timing': 1.26}\n- Areas identified for improvement: - Consider simplifying the code to improve readability and maintainability\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 1\n- Changes: Unknown changes\n- Performance: compiled: 1.0000, correctness: 1.0000, stage: success, passed: 0.0000, score: 20.0000, speed_up: 0.0230, runtime_ms: 1.2600, meta: {'hardware': 'NVIDIA L20Y', 'device': 'cuda:0', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.0294, 'speed_up': 0.023, 'custom_timing': 1.26}\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 20.0000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 32}, num_warps=4, num_stages=4),\n        triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 32}, num_warps=4, num_stages=3),\n        triton.Config({'BLOCK_SIZE_M': 256, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 32}, num_warps=4, num_stages=3),\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 256, 'BLOCK_SIZE_K': 32}, num_warps=4, num_stages=3),\n        triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 32}, num_warps=4, num_stages=4),\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 32}, num_warps=4, num_stages=4),\n        triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 32, 'BLOCK_SIZE_K': 32}, num_warps=4, num_stages=4),\n        triton.Config({'BLOCK_SIZE_M': 32, 'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 32}, num_warps=4, num_stages=4),\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 32, 'BLOCK_SIZE_K': 32}, num_warps=2, num_stages=4),\n        triton.Config({'BLOCK_SIZE_M': 32, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 32}, num_warps=2, num_stages=4),\n    ],\n    key=['M', 'N', 'K'],\n)\n@triton.jit\ndef _matmul_kernel(\n    A_ptr, B_ptr, C_ptr,\n    M, N, K,\n    stride_am, stride_ak,\n    stride_bk, stride_bn,\n    stride_cm, stride_cn,\n    BLOCK_SIZE_M: tl.constexpr, BLOCK_SIZE_N: tl.constexpr, BLOCK_SIZE_K: tl.constexpr,\n):\n    pid = tl.program_id(0)\n    pid_m = pid // tl.cdiv(N, BLOCK_SIZE_N)\n    pid_n = pid % tl.cdiv(N, BLOCK_SIZE_N)\n    \n    offs_m = pid_m * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)\n    offs_n = pid_n * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n    offs_k = tl.arange(0, BLOCK_SIZE_K)\n    \n    A_ptr += offs_m[:, None] * stride_am + offs_k[None, :] * stride_ak\n    B_ptr += offs_k[:, None] * stride_bk + offs_n[None, :] * stride_bn\n    \n    acc = tl.zeros((BLOCK_SIZE_M, BLOCK_SIZE_N), dtype=tl.float32)\n    for k in range(0, tl.cdiv(K, BLOCK_SIZE_K)):\n        a = tl.load(A_ptr, mask=(offs_m[:, None] < M) & (offs_k[None, :] < K - k * BLOCK_SIZE_K), other=0.0)\n        b = tl.load(B_ptr, mask=(offs_k[:, None] < K - k * BLOCK_SIZE_K) & (offs_n[None, :] < N), other=0.0)\n        acc += tl.dot(a, b, allow_tf32=False)\n        A_ptr += BLOCK_SIZE_K * stride_ak\n        B_ptr += BLOCK_SIZE_K * stride_bk\n    \n    offs_cm = pid_m * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)\n    offs_cn = pid_n * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n    C_ptr += offs_cm[:, None] * stride_cm + offs_cn[None, :] * stride_cn\n    c_mask = (offs_cm[:, None] < M) & (offs_cn[None, :] < N)\n    tl.store(C_ptr, acc, mask=c_mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self):\n        super(ModelNew, self).__init__()\n    \n    def forward(self, A, B):\n        n, m, k = A.shape\n        l = B.shape[1]\n        A_flat = A.view(-1, k)\n        C_flat = torch.empty((n * m, l), device=A.device, dtype=A.dtype)\n        \n        grid = lambda meta: (triton.cdiv(n * m, meta['BLOCK_SIZE_M']) * triton.cdiv(l, meta['BLOCK_SIZE_N']),)\n        \n        _matmul_kernel[grid](\n            A_flat, B, C_flat,\n            n * m, l, k,\n            A_flat.stride(0), A_flat.stride(1),\n            B.stride(0), B.stride(1),\n            C_flat.stride(0), C_flat.stride(1),\n        )\n        \n        return C_flat.view(n, m, l)\n\nN = 16\nM = 1024\nK = 2048\nL = 768\n\ndef get_inputs():\n    A = torch.randn(N, M, K, device='cuda')\n    B = torch.randn(K, L, device='cuda')\n    return [A, B]\n\ndef get_init_inputs():\n    return []\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Performs well on compiled (1.0000), Performs well on correctness (1.0000), Performs well on stage (success), Performs well on passed (0.0000), Performs well on score (20.0000), Performs well on speed_up (0.0230), Performs well on runtime_ms (1.2600), Performs well on meta ({'hardware': 'NVIDIA L20Y', 'device': 'cuda:0', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.0294, 'speed_up': 0.023, 'custom_timing': 1.26})\n\n\n\n\n# Current Program\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 32}, num_warps=4, num_stages=4),\n        triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 32}, num_warps=4, num_stages=3),\n        triton.Config({'BLOCK_SIZE_M': 256, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 32}, num_warps=4, num_stages=3),\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 256, 'BLOCK_SIZE_K': 32}, num_warps=4, num_stages=3),\n        triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 32}, num_warps=4, num_stages=4),\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 32}, num_warps=4, num_stages=4),\n        triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 32, 'BLOCK_SIZE_K': 32}, num_warps=4, num_stages=4),\n        triton.Config({'BLOCK_SIZE_M': 32, 'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 32}, num_warps=4, num_stages=4),\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 32, 'BLOCK_SIZE_K': 32}, num_warps=2, num_stages=4),\n        triton.Config({'BLOCK_SIZE_M': 32, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 32}, num_warps=2, num_stages=4),\n    ],\n    key=['M', 'N', 'K'],\n)\n@triton.jit\ndef _matmul_kernel(\n    A_ptr, B_ptr, C_ptr,\n    M, N, K,\n    stride_am, stride_ak,\n    stride_bk, stride_bn,\n    stride_cm, stride_cn,\n    BLOCK_SIZE_M: tl.constexpr, BLOCK_SIZE_N: tl.constexpr, BLOCK_SIZE_K: tl.constexpr,\n):\n    pid = tl.program_id(0)\n    pid_m = pid // tl.cdiv(N, BLOCK_SIZE_N)\n    pid_n = pid % tl.cdiv(N, BLOCK_SIZE_N)\n    \n    offs_m = pid_m * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)\n    offs_n = pid_n * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n    offs_k = tl.arange(0, BLOCK_SIZE_K)\n    \n    A_ptr += offs_m[:, None] * stride_am + offs_k[None, :] * stride_ak\n    B_ptr += offs_k[:, None] * stride_bk + offs_n[None, :] * stride_bn\n    \n    acc = tl.zeros((BLOCK_SIZE_M, BLOCK_SIZE_N), dtype=tl.float32)\n    for k in range(0, tl.cdiv(K, BLOCK_SIZE_K)):\n        a = tl.load(A_ptr, mask=(offs_m[:, None] < M) & (offs_k[None, :] < K - k * BLOCK_SIZE_K), other=0.0)\n        b = tl.load(B_ptr, mask=(offs_k[:, None] < K - k * BLOCK_SIZE_K) & (offs_n[None, :] < N), other=0.0)\n        acc += tl.dot(a, b, allow_tf32=False)\n        A_ptr += BLOCK_SIZE_K * stride_ak\n        B_ptr += BLOCK_SIZE_K * stride_bk\n    \n    offs_cm = pid_m * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)\n    offs_cn = pid_n * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n    C_ptr += offs_cm[:, None] * stride_cm + offs_cn[None, :] * stride_cn\n    c_mask = (offs_cm[:, None] < M) & (offs_cn[None, :] < N)\n    tl.store(C_ptr, acc, mask=c_mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self):\n        super(ModelNew, self).__init__()\n    \n    def forward(self, A, B):\n        n, m, k = A.shape\n        l = B.shape[1]\n        A_flat = A.view(-1, k)\n        C_flat = torch.empty((n * m, l), device=A.device, dtype=A.dtype)\n        \n        grid = lambda meta: (triton.cdiv(n * m, meta['BLOCK_SIZE_M']) * triton.cdiv(l, meta['BLOCK_SIZE_N']),)\n        \n        _matmul_kernel[grid](\n            A_flat, B, C_flat,\n            n * m, l, k,\n            A_flat.stride(0), A_flat.stride(1),\n            B.stride(0), B.stride(1),\n            C_flat.stride(0), C_flat.stride(1),\n        )\n        \n        return C_flat.view(n, m, l)\n\nN = 16\nM = 1024\nK = 2048\nL = 768\n\ndef get_inputs():\n    A = torch.randn(N, M, K, device='cuda')\n    B = torch.randn(K, L, device='cuda')\n    return [A, B]\n\ndef get_init_inputs():\n    return []\n# =================== EVOLVE-BLOCK-END ===================\n```\n\n# Task\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```\n", "responses": ["<think>\nWe are given a Triton kernel for matrix multiplication that is currently achieving a speedup of 0.023 (which is 2.3% of the reference speed, meaning it's actually much slower). The goal is to improve the performance.\n\n The current kernel has the following issues:\n 1. The loop over K dimension uses `tl.cdiv(K, BLOCK_SIZE_K)` and then checks the mask for each block. This is correct but may not be efficient.\n 2. The kernel does not use any shared memory (or Triton's `tl.dot` with tensor cores) in an optimized way. However, note that `tl.dot` is already used.\n 3. The kernel does not utilize Tensor Cores (H100 has FP16 Tensor Cores 32\u00d716\u00d716). The current kernel uses `allow_tf32=False` and accumulates in float32. We are not using FP16.\n\n Important note: The input tensors are of dtype `torch.float32` (since the reference code is in PyTorch and we are not told otherwise). However, the Triton kernel uses `tl.float32` for accumulation.\n\n Steps for improvement:\n\n 1. Consider using tensor cores by setting the input to FP16 and using FP16 accumulation? But note the input dtype is not specified. However, in the example, the inputs are generated by `torch.randn` which is float32. We cannot change the input dtype arbitrarily.\n\n 2. The kernel is currently accumulating in float32. We can try to use tensor cores by converting the input to FP16 (if the hardware supports it and if we can tolerate the precision) but note that the reference is in float32. However, the Triton kernel does not change the dtype of the output (it is the same as input, which is float32). So we have to be cautious.\n\n 3. Alternatively, we can use the tensor cores in TF32 mode. The H100 supports TF32. We can set `allow_tf32=True` in the `tl.dot` to use Tensor Cores for faster computation.\n\n 4. The current grid computation for `pid_m` and `pid_n` is:\n        pid_m = pid // tl.cdiv(N, BLOCK_SIZE_N)\n        pid_n = pid % tl.cdiv(N, BLOCK_SIZE_N)\n    This is because the grid is set as (triton.cdiv(n * m, meta['BLOCK_SIZE_M']) * triton.cdiv(l, meta['BLOCK_SIZE_N']),). However, note that the kernel uses:\n        offs_m = pid_m * BLOCK_SIZE_M + ...   [for rows of A and C]\n        offs_n = pid_n * BLOCK_SIZE_N + ...   [for columns of B and C]\n\n    But the matrix A_flat is of shape (n*m, k) and we are multiplying by B (shape (k, l)). So the output is (n*m, l). The kernel is using a 2D grid in a 1D launch. This is acceptable.\n\n 5. However, the current way of computing the program id for rows and columns might lead to inefficient memory access. We should consider a 2D grid to improve memory coalescing? But note the grid is 1D. We are limited by the grid configuration in the wrapper.\n\n 6. We can try to adjust the block sizes and the tiling to better fit the tensor core operations. The tensor core operation on H100 is 32x16x16 for FP16. Since we are in float32, we might use TF32 which has the same 16x16x16 tile? Actually, TF32 uses the same tensor cores as FP16 but with different precision. The tile size for TF32 is also 16x16x16.\n\n 7. We should set `BLOCK_SIZE_M` and `BLOCK_SIZE_N` to multiples of 16 and `BLOCK_SIZE_K` to multiples of 16 to allow the tensor cores to be used efficiently.\n\n 8. The current kernel loads a block of A and a block of B and then does a dot product. We can try to use a more efficient tiling strategy by splitting the K dimension and using shared memory? But Triton's `tl.dot` already uses the tensor cores if the input dtypes are appropriate and the sizes are aligned.\n\n 9. The mask in the load operations might be expensive. We can try to make the blocks multiples of the actual dimensions to avoid masking? But we cannot avoid masking if the dimensions are not multiples.\n\n 10. The kernel currently does not preload data into shared memory. Triton does not have explicit shared memory, but we can use the `tl.load` and then use the registers. The current approach is standard.\n\n 11. We note that the current performance is very poor (speedup of 0.023). This suggests that the kernel is not being optimized by the autotuner for the given problem size.\n\n 12. The problem sizes are: N=16, M=1024, K=2048, L=768. The matrix A is (16,1024,2048) and then flattened to (16*1024, 2048) and multiplied by B (2048,768) to get (16*1024,768). So the matrix multiplication is between a matrix of size (16384,2048) and (2048,768). This is a large matmul.\n\n 13. We should change the autotuner configurations to include larger block sizes and also set the `BLOCK_SIZE_K` to 128 or 256 to reduce the number of iterations? But note that the tensor core tile is 16x16x16, so we want the inner loop to be in chunks of 16.\n\n 14. We should also consider the number of warps. The current configs use 4 warps (which is 128 threads) and 2 warps. We can try 8 warps (256 threads) for larger blocks.\n\n 15. We must set `allow_tf32=True` to enable tensor cores for TF32. This is crucial for H100.\n\n 16. Another idea: we can split the program id into two dimensions? But the grid function returns a 1D grid. We cannot change the grid function arbitrarily because it would break the interface. However, note that in the kernel we are recomputing `pid_m` and `pid_n` from a 1D pid. That is acceptable.\n\n 17. We can try to use the following changes:\n        - Set `allow_tf32=True` in the `tl.dot` to use tensor cores.\n        - Adjust the autotuner configurations to have block sizes that are multiples of 16 for M, N, and K dimensions to allow tensor cores to be used without masking in the inner loop.\n\n 18. We also note that the kernel is accumulating in float32. This is correct because the reference is in float32.\n\n 19. We should also note that the current kernel does not use any vectorized loads. We can try to use vectorized loads to reduce the number of memory operations? But the `tl.dot` already does efficient loading.\n\n 20. We should change the autotuner configurations to include block sizes that are multiples of 16 and 32, and also include larger block sizes for K (like 64, 128, 256) to reduce the number of iterations.\n\n 21. The current kernel moves the pointers by `BLOCK_SIZE_K * stride_ak` and `BLOCK_SIZE_K * stride_bk` in the loop. This is standard.\n\n 22. We can also try to change the order of the loop to have better memory access? But the current order is standard.\n\n 23. We must be cautious: the problem is that the current kernel is 40x slower than the reference. So we are missing a major optimization.\n\n 24. Let's check the grid size: the grid is set as `(triton.cdiv(n * m, meta['BLOCK_SIZE_M']) * triton.cdiv(l, meta['BLOCK_SIZE_N']),)`. This is a 1D grid. The kernel then splits this 1D index into 2D indices. This is acceptable.\n\n 25. However, note that the kernel uses:\n        pid_m = pid // tl.cdiv(N, BLOCK_SIZE_N)\n        pid_n = pid % tl.cdiv(N, BLOCK_SIZE_N)\n    But note: `N` in the kernel is the number of columns of the output? Actually, the kernel's `M` is the number of rows of A_flat (which is n*m) and `N` is the number of columns of B (which is l). So the kernel uses:\n        pid_m = pid // (number of blocks in N dimension)   [which is the column dimension of the output?]\n        pid_n = pid % (number of blocks in N dimension)\n\n    Then the kernel computes the row offset for A and C as `pid_m * BLOCK_SIZE_M` and the column offset for B and C as `pid_n * BLOCK_SIZE_N`.\n\n    This is correct.\n\n 26. But note: the kernel uses `offs_m` to index the rows of A and `offs_n` to index the columns of B. Then in the inner loop, we are loading a block of A of size (BLOCK_SIZE_M, BLOCK_SIZE_K) and a block of B of size (BLOCK_SIZE_K, BLOCK_SIZE_N). Then we do a dot product.\n\n 27. The problem might be that the block sizes chosen by the autotuner are too small? We are not sure. We can try to force larger block sizes.\n\n 28. We must also note that the tensor core operation requires the inner dimension to be a multiple of 16? Actually, the Triton `tl.dot` will use tensor cores when the input dtypes are float16 and the sizes are multiples of 16, or for TF32 we also need multiples of 16? The Triton documentation says that for TF32 we set `allow_tf32=True` and then the operation will use tensor cores.\n\n 29. Since the current kernel is using float32 and we set `allow_tf32=False`, we are not using tensor cores. So the first step is to set `allow_tf32=True`.\n\n 30. We can also try to change the accumulation to float32 but that is already the case.\n\n 31. We will do two changes:\n        a) Change `allow_tf32=False` to `allow_tf32=True`.\n        b) Adjust the autotuner configurations to have block sizes that are multiples of 16 and 32, and also include larger K blocks.\n\n 32. We note that the current autotuner configurations for BLOCK_SIZE_K are all 32. We should include 64, 128, and 256.\n\n 33. We also note that the tensor core tile is 16x16x16, so we want BLOCK_SIZE_M and BLOCK_SIZE_N to be multiples of 16 and BLOCK_SIZE_K to be a multiple of 16.\n\n 34. We will change the autotuner configurations to include:\n        - BLOCK_SIZE_M: 64, 128, 256 (as before) but also 32, 48, 80? We stick to multiples of 16: 32, 64, 128, 256.\n        - BLOCK_SIZE_N: similarly 32, 64, 128, 256.\n        - BLOCK_SIZE_K: 16, 32, 64, 128, 256.\n\n 35. We will also increase the number of warps for larger blocks to 8.\n\n 36. We must be cautious: the kernel must compile and run correctly.\n\n 37. We will also note that the mask condition for the inner dimension might be simplified. Currently, it checks `(offs_k[None, :] < K - k * BLOCK_SIZE_K)`. We can precompute the remaining K and use that for both A and B.\n\n 38. We can try to reduce the number of mask computations by precomputing the mask for the inner dimension? But that might not be the bottleneck.\n\n 39. We change the kernel in two places: the `tl.dot` and the autotuner configs.\n\n Let's rewrite the kernel accordingly.\n\n Note: We must not change the function signature.\n\n Steps for the rewrite:\n  1. Change the `allow_tf32` to `True` in the `tl.dot` call.\n  2. Replace the autotuner configurations with new ones that have BLOCK_SIZE_K as multiples of 16 and include larger values, and also include multiples of 16 for M and N.\n\n We will also adjust the number of warps and stages accordingly.\n\n We note that the current performance is very bad, so we are hoping that enabling tensor cores and better block sizes will help.\n\n We are also going to add more autotuner configurations.\n\n However, note: the problem size for K is 2048, so having a BLOCK_SIZE_K of 128 would reduce the number of iterations to 2048/128 = 16.\n\n We create new configs:\n\n    configs = [\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 64}, num_warps=4, num_stages=4),\n        triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 64}, num_warps=4, num_stages=3),\n        triton.Config({'BLOCK_SIZE_M': 256, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 64}, num_warps=4, num_stages=3),\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 256, 'BLOCK_SIZE_K': 64}, num_warps=4, num_stages=3),\n        triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 64}, num_warps=4, num_stages=4),\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 64}, num_warps=4, num_stages=4),\n        triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 32, 'BLOCK_SIZE_K': 64}, num_warps=4, num_stages=4),\n        triton.Config({'BLOCK_SIZE_M': 32, 'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 64}, num_warps=4, num_stages=4),\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 32, 'BLOCK_SIZE_K': 64}, num_warps=2, num_stages=4),\n        triton.Config({'BLOCK_SIZE_M': 32, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 64}, num_warps=2, num_stages=4),\n        # Add more with larger K and multiples of 16\n        triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 128}, num_warps=8, num_stages=3),\n        triton.Config({'BLOCK_SIZE_M': 256, 'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 128}, num_warps=8, num_stages=3),\n        triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 256, 'BLOCK_SIZE_K': 128}, num_warps=8, num_stages=3),\n        triton.Config({'BLOCK_SIZE_M': 256, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 128}, num_warps=4, num_stages=3),\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 256, 'BLOCK_SIZE_K': 128}, num_warps=4, num_stages=3),\n        triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 128}, num_warps=4, num_stages=4),\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 128}, num_warps=4, num_stages=4),\n        triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 32, 'BLOCK_SIZE_K': 128}, num_warps=2, num_stages=4),\n        triton.Config({'BLOCK_SIZE_M': 32, 'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 128}, num_warps=2, num_stages=4),\n        # Also include 16 and 32 for K\n        triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 16}, num_warps=4, num_stages=4),\n        triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 32}, num_warps=4, num_stages=4),\n    ]\n\n 40. We change the kernel's dot product to use `allow_tf32=True`.\n\n 41. We leave the rest of the kernel unchanged.\n\n 42. We note that the kernel must still have the same function signature and the same grid computation.\n\n 43. We also note that the problem size for the output matrix is (16384,768). For BLOCK_SIZE_M=128 and BLOCK_SIZE_N=128, the grid would be (ceil(16384/128) * ceil(768/128)) = (128 * 6) = 768 blocks.\n\n 44. We hope that with tensor cores and better tiling, the performance will improve.\n\n Let's write the updated code.\n\n IMPORTANT: We are only allowed to change the Triton kernel and the autotuner configs. We cannot change the class ModelNew or the grid function.\n\n We output the entire code block as required.\n</think>\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 64}, num_warps=4, num_stages=4),\n        triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 64}, num_warps=4, num_stages=3),\n        triton.Config({'BLOCK_SIZE_M': 256, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 64}, num_warps=4, num_stages=3),\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 256, 'BLOCK_SIZE_K': 64}, num_warps=4, num_stages=3),\n        triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 128}, num_warps=8, num_stages=3),\n        triton.Config({'BLOCK_SIZE_M': 256, 'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 128}, num_warps=8, num_stages=3),\n        triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 256, 'BLOCK_SIZE_K': 128}, num_warps=8, num_stages=3),\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 128}, num_warps=4, num_stages=4),\n        triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 128}, num_warps=4, num_stages=4),\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 128}, num_warps=4, num_stages=4),\n    ],\n    key=['M', 'N', 'K'],\n)\n@triton.jit\ndef _matmul_kernel(\n    A_ptr, B_ptr, C_ptr,\n    M, N, K,\n    stride_am, stride_ak,\n    stride_bk, stride_bn,\n    stride_cm, stride_cn,\n    BLOCK_SIZE_M: tl.constexpr, BLOCK_SIZE_N: tl.constexpr, BLOCK_SIZE_K: tl.constexpr,\n):\n    pid = tl.program_id(0)\n    num_pid_n = tl.cdiv(N, BLOCK_SIZE_N)\n    pid_m = pid // num_pid_n\n    pid_n = pid % num_pid_n\n    \n    offs_m = pid_m * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)\n    offs_n = pid_n * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n    offs_k = tl.arange(0, BLOCK_SIZE_K)\n    \n    A_ptr += offs_m[:, None] * stride_am + offs_k[None, :] * stride_ak\n    B_ptr += offs_k[:, None] * stride_bk + offs_n[None, :] * stride_bn\n    \n    acc = tl.zeros((BLOCK_SIZE_M, BLOCK_SIZE_N), dtype=tl.float32)\n    for k in range(0, tl.cdiv(K, BLOCK_SIZE_K)):\n        k_remaining = K - k * BLOCK_SIZE_K\n        k_mask = offs_k[None, :] < k_remaining\n        a = tl.load(A_ptr, mask=(offs_m[:, None] < M) & k_mask, other=0.0)\n        b = tl.load(B_ptr, mask=k_mask & (offs_n[None, :] < N), other=0.0)\n        acc += tl.dot(a, b, allow_tf32=True)\n        A_ptr += BLOCK_SIZE_K * stride_ak\n        B_ptr += BLOCK_SIZE_K * stride_bk\n    \n    offs_cm = pid_m * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)\n    offs_cn = pid_n * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n    C_ptr += offs_cm[:, None] * stride_cm + offs_cn[None, :] * stride_cn\n    c_mask = (offs_cm[:, None] < M) & (offs_cn[None, :] < N)\n    tl.store(C_ptr, acc, mask=c_mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self):\n        super(ModelNew, self).__init__()\n    \n    def forward(self, A, B):\n        n, m, k = A.shape\n        l = B.shape[1]\n        A_flat = A.view(-1, k)\n        C_flat = torch.empty((n * m, l), device=A.device, dtype=A.dtype)\n        \n        grid = lambda meta: (triton.cdiv(n * m, meta['BLOCK_SIZE_M']) * triton.cdiv(l, meta['BLOCK_SIZE_N']),)\n        \n        _matmul_kernel[grid](\n            A_flat, B, C_flat,\n            n * m, l, k,\n            A_flat.stride(0), A_flat.stride(1),\n            B.stride(0), B.stride(1),\n            C_flat.stride(0), C_flat.stride(1),\n        )\n        \n        return C_flat.view(n, m, l)\n\nN = 16\nM = 1024\nK = 2048\nL = 768\n\ndef get_inputs():\n    A = torch.randn(N, M, K, device='cuda')\n    B = torch.randn(K, L, device='cuda')\n    return [A, B]\n\ndef get_init_inputs():\n    return []\n# =================== EVOLVE-BLOCK-END ===================\n```"]}}}