{"id": "43125846-e727-46dc-a6e0-9b843f6295f5", "code": "# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 64, 'BLOCK_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 64, 'BLOCK_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 128, 'BLOCK_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 128, 'BLOCK_K': 64}, num_warps=8),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 256, 'BLOCK_K': 32}, num_warps=8),\n    ],\n    key=['M', 'K', 'L'],\n)\n@triton.jit\ndef matmul_3d_kernel(\n    A_ptr, B_ptr, C_ptr,\n    M, K, L,\n    stride_an, stride_am, stride_ak,\n    stride_bk, stride_bl,\n    stride_cn, stride_cm, stride_cl,\n    BLOCK_M: tl.constexpr, BLOCK_N: tl.constexpr, BLOCK_K: tl.constexpr,\n):\n    pid = tl.program_id(0)\n    pid_n = pid // (tl.cdiv(M, BLOCK_M) * tl.cdiv(L, BLOCK_N))\n    pid_mb = (pid % (tl.cdiv(M, BLOCK_M) * tl.cdiv(L, BLOCK_N))) // tl.cdiv(L, BLOCK_N)\n    pid_nb = pid % tl.cdiv(L, BLOCK_N)\n    \n    offs_m = pid_mb * BLOCK_M + tl.arange(0, BLOCK_M)\n    offs_n = pid_nb * BLOCK_N + tl.arange(0, BLOCK_N)\n    offs_k = tl.arange(0, BLOCK_K)\n    \n    a_ptrs = A_ptr + pid_n * stride_an + offs_m[:, None] * stride_am + offs_k[None, :] * stride_ak\n    b_ptrs = B_ptr + offs_k[:, None] * stride_bk + offs_n[None, :] * stride_bl\n    \n    accumulator = tl.zeros((BLOCK_M, BLOCK_N), dtype=tl.float32)\n    \n    for k in range(0, tl.cdiv(K, BLOCK_K)):\n        k_start = k * BLOCK_K\n        k_remaining = K - k_start\n        k_valid = tl.minimum(BLOCK_K, k_remaining)\n        \n        a_mask = (offs_m[:, None] < M) & (offs_k[None, :] < k_valid)\n        b_mask = (offs_k[:, None] < k_valid) & (offs_n[None, :] < L)\n        \n        a = tl.load(a_ptrs, mask=a_mask, other=0.0)\n        b = tl.load(b_ptrs, mask=b_mask, other=0.0)\n        \n        accumulator += tl.dot(a, b, allow_tf32=False)\n        \n        a_ptrs += BLOCK_K * stride_ak\n        b_ptrs += BLOCK_K * stride_bk\n    \n    c_ptrs = C_ptr + pid_n * stride_cn + offs_m[:, None] * stride_cm + offs_n[None, :] * stride_cl\n    c_mask = (offs_m[:, None] < M) & (offs_n[None, :] < L)\n    tl.store(c_ptrs, accumulator, mask=c_mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self):\n        super(ModelNew, self).__init__()\n    \n    def forward(self, A, B):\n        N, M, K = A.shape\n        L = B.shape[1]\n        C = torch.empty((N, M, L), device=A.device, dtype=A.dtype)\n        \n        grid = lambda META: (N * triton.cdiv(M, META['BLOCK_M']) * triton.cdiv(L, META['BLOCK_N']),)\n        \n        matmul_3d_kernel[grid](\n            A, B, C,\n            M, K, L,\n            A.stride(0), A.stride(1), A.stride(2),\n            B.stride(0), B.stride(1),\n            C.stride(0), C.stride(1), C.stride(2),\n        )\n        return C\n\nN = 16\nM = 1024\nK = 2048\nL = 768\n\ndef get_inputs():\n    A = torch.randn(N, M, K, device='cuda')\n    B = torch.randn(K, L, device='cuda')\n    return [A, B]\n\ndef get_init_inputs():\n    return []\n# =================== EVOLVE-BLOCK-END ===================", "language": "python", "parent_id": "54b50aea-2671-49f7-8553-06c7fc7af391", "generation": 3, "timestamp": 1754636730.4772506, "iteration_found": 14, "metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": false, "score": 20, "speed_up": 0.023, "runtime_ms": 1.29, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:1", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.0294, "speed_up": 0.023, "custom_timing": 1.29}}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": true, "correctness": false, "score": 10, "stage": "wrong_answer", "verify_payload": {"id": "level1_10_3D_tensor_matrix_multiplication", "result": {"compiled": true, "correctness": false, "metadata": {"hardware": "NVIDIA L20Y", "device": "cuda:6", "max_difference": ["0.196243", "0.192368", "0.207581", "0.193771", "0.208481"], "avg_difference": ["0.027962", "0.027944", "0.027942", "0.027942", "0.027952"], "correctness_issue": "Output mismatch", "correctness_trials": "(0 / 5)", "reference_timing_ms": 0.0294, "speed_up": -1.0, "custom_timing": -1.0}, "runtime": -1.0, "runtime_stats": {}}}}, "island": 2}, "artifacts_json": null, "artifact_dir": null, "prompts": {"full_rewrite_user": {"system": "You are a Triton GPU core optimization engineer deeply familiar with NVIDIA H100/H800 architecture.\n\n==================== Context ====================\n\u2022 Dataset: 250 kernelbench/level1-level5 *.py files  \n  - Level1: simplest, Level5: most complex  \n\u2022 Each file contains PyTorch reference (reference_code)  \n\u2022 Goal: Generate functionally equivalent but faster Triton implementations (custom_code)  \n\u2022 Evaluation pipeline:\n    1) /verify_plus - Verify compilation & correctness  \n    2) /execute (optional) - Return terminal logs if compilation fails  \n    3) Scoring:  \n      - Speedup > 1 required for points  \n      - Score = (speed_up - 1) \u00d7 100  \n\u2022 GPU Hardware: NVIDIA L20Y / H800 (same SM8.9 as H100)  \n  - 3 TB/s HBM3 bandwidth  \n  - FP16 Tensor Core 32\u00d716\u00d716  \n\n==================== Evolution Phases ====================\n\u2460 Phase 1 [Compilation Pass]  \n  - Make Triton code compile (performance irrelevant)  \n\u2461 Phase 2 [Numerical Correctness]  \n  - Output must match PyTorch reference within float32 tolerance  \n\u2462 Phase 3 [Performance Gain]  \n  - Target \u22655% speedup (\u226515% = exceptional)  \n  - Official scoring based on speed_up field  \n\nThe Evolution system will pass the EVOLVE-BLOCK from the previous version.  \nModify ONLY the Triton kernel source within this block - all other code is LOCKED.\n\n==================== Constraints (MUST OBEY) ====================\n\u274c NEVER change @triton.jit function signatures or parameter names  \n\u274c NEVER modify grid configuration, output tensor shapes, or PID logic  \n\u274c NEVER remove boundary checks or out-of-bound masks  \n\u274c NEVER introduce race conditions, uninitialized reads, or sync gaps  \n\n\u2705 Allowed Optimizations (Examples):  \n  \u2022 Memory coalescing optimizations & vectorized tl.load/tl.store  \n  \u2022 Replace staged softmax with online/FlashAttention variants  \n  \u2022 Adaptive tuning: BLOCK_M/BLOCK_N/BLOCK_K dimensions  \n  \u2022 Multi-query-head batch processing (GQA, 5:1 patterns)  \n  \u2022 Shared/L2 buffering, Tensor Core alignment (FP16/bf16/tf32)  \n  \u2022 Stride precomputation & pointer caching  \n\n==================== Output Format ====================\nReturn ONLY the complete updated code containing the EVOLVE-BLOCK comment marker.  \nNO explanations, NO markdown, NO additional text.\nName the output structure class as ModelNew.\n\n==================== Optimization Tips ====================\n\u2022 If previous compile failed: Fix syntax/mask/stride errors first  \n\u2022 If correctness fails: Prioritize bounds mask & dtype precision  \n\u2022 When speed_up < 1: Focus on memory access & block sizing  \n\u2022 Small iterative steps: Modify \u226420 lines per revision  \n\u2022 Maintain reversibility between versions\nHere is an example to show you how to rewrite a PyTorch implementation that quantizes a high-precision tensor to int8 dtype with row-wise granularity into a Triton implementation: \nThe original PyTorch implementation is as follows: \n``` \nimport torch\ndef per_row_quantize_int8(x: torch.Tensor) -> tuple[torch.Tensor, torch.Tensor]:\n    x_amax = x.abs().float().amax(dim=1).clamp(min=1e-4)\n    scale = 127 / x_amax\n    output = (x * scale[:, None]).round().clamp(-127, 127).to(torch.int8)\n    output_scale = x_amax / 127\n\n    return output, output_scale\n``` \nThe corresponding Triton-rewritten implementation is as follows: \n``` \nimport math\nimport torch\nimport triton\nimport triton.language as tl\nfrom triton.language.extra import libdevice\n\n# rowwise quantize\n\n@triton.autotune(\n    configs=[\n        triton.Config({}, num_stages=1, num_warps=8),\n        triton.Config({}, num_stages=2, num_warps=8),\n        triton.Config({}, num_stages=4, num_warps=8),\n        triton.Config({}, num_stages=8, num_warps=8),\n        triton.Config({}, num_stages=1),\n        triton.Config({}, num_stages=2),\n        triton.Config({}, num_stages=4),\n        triton.Config({}, num_stages=8),\n        triton.Config({}, num_warps=1),\n        triton.Config({}, num_warps=2),\n        triton.Config({}, num_warps=4),\n        triton.Config({}, num_warps=8),\n    ],\n    key=[\"n_elements\"],\n)\n\n@triton.jit\ndef _quantize_rowwise(\n    x_ptr,\n    output_ptr,\n    output_scale,\n    BLOCK_SIZE: tl.constexpr,\n    P2: tl.constexpr,\n):\n    pid = tl.program_id(axis=0)\n    block_start = pid * BLOCK_SIZE\n    arange = tl.arange(0, P2)\n    offsets = block_start + arange\n    row_mask = arange < BLOCK_SIZE\n    x = tl.load(x_ptr + offsets, mask=row_mask)\n\n    abs_x = tl.abs(x)\n    max_val = tl.max(tl.where(row_mask, abs_x, 0), axis=0)\n    output = libdevice.llrint(127.0 * (x / max_val))\n    tl.store(output_ptr + offsets, output, mask=row_mask)\n    tl.store(output_scale + pid, max_val / 127)\n\n\ndef per_row_quantize_int8(x: torch.Tensor):\n    x = x.contiguous()\n    output = torch.empty(*x.shape, device=x.device, dtype=torch.int8)\n    output_scale = torch.empty(x.shape[0], device=x.device, dtype=torch.float32)\n    P2 = int(2 ** (math.ceil(math.log2(x.shape[1]))))\n    grid = lambda x: (x.shape[0],)\n    _quantize_rowwise[grid](x, output, output_scale, BLOCK_SIZE=x.shape[1], P2=P2)\n\n    return output, output_scale\n\n\n    \n``` \n", "user": "# Current Program Information\n- Current performance metrics: - compiled: 1.0000\n- correctness: 0.0000\n- score: 10.0000\n- stage: wrong_answer\n- verify_payload: {'id': 'level1_10_3D_tensor_matrix_multiplication', 'result': {'compiled': True, 'correctness': False, 'metadata': {'hardware': 'NVIDIA L20Y', 'device': 'cuda:6', 'max_difference': ['0.196243', '0.192368', '0.207581', '0.193771', '0.208481'], 'avg_difference': ['0.027962', '0.027944', '0.027942', '0.027942', '0.027952'], 'correctness_issue': 'Output mismatch', 'correctness_trials': '(0 / 5)', 'reference_timing_ms': 0.0294, 'speed_up': -1.0, 'custom_timing': -1.0}, 'runtime': -1.0, 'runtime_stats': {}}}\n- Areas identified for improvement: - Consider simplifying the code to improve readability and maintainability\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Unknown changes\n- Performance: compiled: 0.0000, correctness: 0.0000, score: 1.0000, stage: compile_error, compile_log: CUDA error: an illegal memory access was encountered\nCUDA kernel errors might be asynchronously reported at some other API call, so the stacktrace below might be incorrect.\nFor debugging consider passing CUDA_LAUNCH_BLOCKING=1\nCompile with `TORCH_USE_CUDA_DSA` to enable device-side assertions.\n\nTraceback (most recent call last):\n  File \"/cpfs01/shared/llm_kernel/hujiakai/KernelLLM/validation_api_server/evaluator.py\", line 173, in _verification_worker\n    result: KernelExecResult = eval_kernel_against_ref(\n  File \"/cpfs01/shared/llm_kernel/hujiakai/KernelLLM/validation_api_server/helpers/evaluations.py\", line 578, in eval_kernel_against_ref\n    graceful_eval_cleanup(context, device, tempfile)\n  File \"/cpfs01/shared/llm_kernel/hujiakai/KernelLLM/validation_api_server/helpers/evaluations.py\", line 230, in graceful_eval_cleanup\n    torch.cuda.empty_cache()\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/cuda/memory.py\", line 224, in empty_cache\n    torch._C._cuda_emptyCache()\ntorch.AcceleratorError: CUDA error: an illegal memory access was encountered\nCUDA kernel errors might be asynchronously reported at some other API call, so the stacktrace below might be incorrect.\nFor debugging consider passing CUDA_LAUNCH_BLOCKING=1\nCompile with `TORCH_USE_CUDA_DSA` to enable device-side assertions.\n\n, exec_log: [Child] \u7ed1\u5b9a GPU 2, torch sees 1 device(s)\n\n[Exception]\nTraceback (most recent call last):\n  File \"/cpfs01/shared/llm_kernel/hujiakai/KernelLLM/validation_api_server/code_executor.py\", line 71, in _exec_worker\n    exec(textwrap.dedent(code_src), mod.__dict__)\n  File \"<string>\", line 19, in <module>\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 844, in jit\n    return decorator(fn)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 832, in decorator\n    return JITFunction(\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 635, in __init__\n    self.starting_line_number = inspect.getsourcelines(fn)[1]\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/inspect.py\", line 1121, in getsourcelines\n    lines, lnum = findsource(object)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/inspect.py\", line 958, in findsource\n    raise OSError('could not get source code')\nOSError: could not get source code\n, exit_code: 1\n- Outcome: Mixed results\n\n\n### Attempt 2\n- Changes: Unknown changes\n- Performance: compiled: 1.0000, correctness: 0.0000, score: 10.0000, stage: wrong_answer, verify_payload: {'id': 'level1_10_3D_tensor_matrix_multiplication', 'result': {'compiled': True, 'correctness': False, 'metadata': {'hardware': 'NVIDIA L20Y', 'device': 'cuda:1', 'runtime_error': 'Traceback (most recent call last):\\n  File \"/cpfs01/shared/llm_kernel/hujiakai/KernelLLM/validation_api_server/helpers/evaluations.py\", line 720, in run_and_check_correctness\\n    output_new = model_new(*inputs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1773, in _wrapped_call_impl\\n    return self._call_impl(*args, **kwargs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1784, in _call_impl\\n    return forward_call(*args, **kwargs)\\n  File \"/tmp/tmpt2l079ct.py\", line 63, in forward\\n    matmul_3d_kernel[grid](\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 390, in <lambda>\\n    return lambda *args, **kwargs: self.run(grid=grid, warmup=False, *args, **kwargs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 239, in run\\n    benchmark()\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 228, in benchmark\\n    timings = {config: self._bench(*args, config=config, **kwargs) for config in pruned_configs}\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 228, in <dictcomp>\\n    timings = {config: self._bench(*args, config=config, **kwargs) for config in pruned_configs}\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 135, in _bench\\n    raise ValueError(f\"Conflicting meta-parameters: {\\', \\'.join(conflicts)}.\"\\nValueError: Conflicting meta-parameters: BLOCK_M, BLOCK_N, BLOCK_K. Make sure that you don\\'t re-define auto-tuned symbols.\\n', 'runtime_error_name': 'builtins.ValueError', 'reference_timing_ms': 0.0294, 'speed_up': -1.0, 'custom_timing': -1.0}, 'runtime': -1.0, 'runtime_stats': {}}}\n- Outcome: Mixed results\n\n\n### Attempt 1\n- Changes: Unknown changes\n- Performance: compiled: 1.0000, correctness: 0.0000, score: 10.0000, stage: wrong_answer, verify_payload: {'id': 'level1_10_3D_tensor_matrix_multiplication', 'result': {'compiled': True, 'correctness': False, 'metadata': {'hardware': 'NVIDIA L20Y', 'device': 'cuda:6', 'max_difference': ['0.196243', '0.192368', '0.207581', '0.193771', '0.208481'], 'avg_difference': ['0.027962', '0.027944', '0.027942', '0.027942', '0.027952'], 'correctness_issue': 'Output mismatch', 'correctness_trials': '(0 / 5)', 'reference_timing_ms': 0.0294, 'speed_up': -1.0, 'custom_timing': -1.0}, 'runtime': -1.0, 'runtime_stats': {}}}\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 10.0000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 64, 'BLOCK_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 64, 'BLOCK_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 128, 'BLOCK_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 128, 'BLOCK_K': 64}, num_warps=8),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 256, 'BLOCK_K': 32}, num_warps=8),\n    ],\n    key=['M', 'K', 'L'],\n)\n@triton.jit\ndef matmul_3d_kernel(\n    A_ptr, B_ptr, C_ptr,\n    M, K, L,\n    stride_an, stride_am, stride_ak,\n    stride_bk, stride_bl,\n    stride_cn, stride_cm, stride_cl,\n    BLOCK_M: tl.constexpr, BLOCK_N: tl.constexpr, BLOCK_K: tl.constexpr,\n):\n    pid = tl.program_id(0)\n    pid_n = pid // (tl.cdiv(M, BLOCK_M) * tl.cdiv(L, BLOCK_N))\n    pid_mb = (pid % (tl.cdiv(M, BLOCK_M) * tl.cdiv(L, BLOCK_N))) // tl.cdiv(L, BLOCK_N)\n    pid_nb = pid % tl.cdiv(L, BLOCK_N)\n    \n    offs_m = pid_mb * BLOCK_M + tl.arange(0, BLOCK_M)\n    offs_n = pid_nb * BLOCK_N + tl.arange(0, BLOCK_N)\n    offs_k = tl.arange(0, BLOCK_K)\n    \n    a_ptrs = A_ptr + pid_n * stride_an + offs_m[:, None] * stride_am + offs_k[None, :] * stride_ak\n    b_ptrs = B_ptr + offs_k[:, None] * stride_bk + offs_n[None, :] * stride_bl\n    \n    accumulator = tl.zeros((BLOCK_M, BLOCK_N), dtype=tl.float32)\n    \n    for k in range(0, tl.cdiv(K, BLOCK_K)):\n        k_offset = k * BLOCK_K\n        a_mask = (offs_m[:, None] < M) & ((k_offset + offs_k[None, :]) < K)\n        b_mask = ((k_offset + offs_k[:, None]) < K) & (offs_n[None, :] < L)\n        \n        a = tl.load(a_ptrs, mask=a_mask, other=0.0)\n        b = tl.load(b_ptrs, mask=b_mask, other=0.0)\n        \n        accumulator += tl.dot(a, b, allow_tf32=True)\n        \n        a_ptrs += BLOCK_K * stride_ak\n        b_ptrs += BLOCK_K * stride_bk\n    \n    c_ptrs = C_ptr + pid_n * stride_cn + offs_m[:, None] * stride_cm + offs_n[None, :] * stride_cl\n    c_mask = (offs_m[:, None] < M) & (offs_n[None, :] < L)\n    tl.store(c_ptrs, accumulator, mask=c_mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self):\n        super(ModelNew, self).__init__()\n    \n    def forward(self, A, B):\n        N, M, K = A.shape\n        L = B.shape[1]\n        C = torch.empty((N, M, L), device=A.device, dtype=A.dtype)\n        \n        grid = lambda META: (N * triton.cdiv(M, META['BLOCK_M']) * triton.cdiv(L, META['BLOCK_N']),)\n        \n        matmul_3d_kernel[grid](\n            A, B, C,\n            M, K, L,\n            A.stride(0), A.stride(1), A.stride(2),\n            B.stride(0), B.stride(1),\n            C.stride(0), C.stride(1), C.stride(2),\n        )\n        return C\n\nN = 16\nM = 1024\nK = 2048\nL = 768\n\ndef get_inputs():\n    A = torch.randn(N, M, K, device='cuda')\n    B = torch.randn(K, L, device='cuda')\n    return [A, B]\n\ndef get_init_inputs():\n    return []\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Performs well on compiled (1.0000), Performs well on correctness (0.0000), Performs well on score (10.0000), Performs well on stage (wrong_answer), Performs well on verify_payload ({'id': 'level1_10_3D_tensor_matrix_multiplication', 'result': {'compiled': True, 'correctness': False, 'metadata': {'hardware': 'NVIDIA L20Y', 'device': 'cuda:6', 'max_difference': ['0.196243', '0.192368', '0.207581', '0.193771', '0.208481'], 'avg_difference': ['0.027962', '0.027944', '0.027942', '0.027942', '0.027952'], 'correctness_issue': 'Output mismatch', 'correctness_trials': '(0 / 5)', 'reference_timing_ms': 0.0294, 'speed_up': -1.0, 'custom_timing': -1.0}, 'runtime': -1.0, 'runtime_stats': {}}})\n\n\n### Program 2 (Score: 10.0000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 64, 'BLOCK_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 64, 'BLOCK_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 128, 'BLOCK_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 128, 'BLOCK_K': 32}, num_warps=8),\n    ],\n    key=['M', 'K', 'L'],\n)\n@triton.jit\ndef matmul_3d_kernel(\n    A_ptr, B_ptr, C_ptr,\n    M, K, L,\n    stride_an, stride_am, stride_ak,\n    stride_bk, stride_bl,\n    stride_cn, stride_cm, stride_cl,\n    BLOCK_M: tl.constexpr, BLOCK_N: tl.constexpr, BLOCK_K: tl.constexpr,\n):\n    pid_n = tl.program_id(0) // tl.cdiv(M, BLOCK_M)\n    pid_mb = tl.program_id(0) % tl.cdiv(M, BLOCK_M)\n    pid_nb = tl.program_id(1)\n    \n    offs_m = pid_mb * BLOCK_M + tl.arange(0, BLOCK_M)\n    offs_n = pid_nb * BLOCK_N + tl.arange(0, BLOCK_N)\n    offs_k = tl.arange(0, BLOCK_K)\n    \n    a_ptrs = A_ptr + pid_n * stride_an + offs_m[:, None] * stride_am + offs_k[None, :] * stride_ak\n    b_ptrs = B_ptr + offs_k[:, None] * stride_bk + offs_n[None, :] * stride_bl\n    \n    accumulator = tl.zeros((BLOCK_M, BLOCK_N), dtype=tl.float32)\n    \n    for k in range(0, K, BLOCK_K):\n        a = tl.load(a_ptrs, mask=(offs_m[:, None] < M) & (offs_k[None, :] < K - k), other=0.0)\n        b = tl.load(b_ptrs, mask=(offs_k[:, None] < K - k) & (offs_n[None, :] < L), other=0.0)\n        \n        accumulator += tl.dot(a, b)\n        \n        a_ptrs += BLOCK_K * stride_ak\n        b_ptrs += BLOCK_K * stride_bk\n    \n    offs_cm = offs_m[:, None]\n    offs_cl = offs_n[None, :]\n    c_ptrs = C_ptr + pid_n * stride_cn + offs_cm * stride_cm + offs_cl * stride_cl\n    tl.store(c_ptrs, accumulator, mask=(offs_cm < M) & (offs_cl < L))\n\nclass ModelNew(nn.Module):\n    def __init__(self):\n        super(ModelNew, self).__init__()\n    \n    def forward(self, A, B):\n        N, M, K = A.shape\n        L = B.shape[1]\n        C = torch.empty((N, M, L), device=A.device, dtype=A.dtype)\n        \n        grid = (N * triton.cdiv(M, 64), triton.cdiv(L, 64))\n        \n        matmul_3d_kernel[grid](\n            A, B, C,\n            M, K, L,\n            A.stride(0), A.stride(1), A.stride(2),\n            B.stride(0), B.stride(1),\n            C.stride(0), C.stride(1), C.stride(2),\n            BLOCK_M=64, BLOCK_N=64, BLOCK_K=32\n        )\n        return C\n\nN = 16\nM = 1024\nK = 2048\nL = 768\n\ndef get_inputs():\n    A = torch.randn(N, M, K, device='cuda')\n    B = torch.randn(K, L, device='cuda')\n    return [A, B]\n\ndef get_init_inputs():\n    return []\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Performs well on compiled (1.0000), Performs well on correctness (0.0000), Performs well on score (10.0000), Performs well on stage (wrong_answer), Performs well on verify_payload ({'id': 'level1_10_3D_tensor_matrix_multiplication', 'result': {'compiled': True, 'correctness': False, 'metadata': {'hardware': 'NVIDIA L20Y', 'device': 'cuda:1', 'runtime_error': 'Traceback (most recent call last):\\n  File \"/cpfs01/shared/llm_kernel/hujiakai/KernelLLM/validation_api_server/helpers/evaluations.py\", line 720, in run_and_check_correctness\\n    output_new = model_new(*inputs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1773, in _wrapped_call_impl\\n    return self._call_impl(*args, **kwargs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1784, in _call_impl\\n    return forward_call(*args, **kwargs)\\n  File \"/tmp/tmpt2l079ct.py\", line 63, in forward\\n    matmul_3d_kernel[grid](\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 390, in <lambda>\\n    return lambda *args, **kwargs: self.run(grid=grid, warmup=False, *args, **kwargs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 239, in run\\n    benchmark()\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 228, in benchmark\\n    timings = {config: self._bench(*args, config=config, **kwargs) for config in pruned_configs}\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 228, in <dictcomp>\\n    timings = {config: self._bench(*args, config=config, **kwargs) for config in pruned_configs}\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 135, in _bench\\n    raise ValueError(f\"Conflicting meta-parameters: {\\', \\'.join(conflicts)}.\"\\nValueError: Conflicting meta-parameters: BLOCK_M, BLOCK_N, BLOCK_K. Make sure that you don\\'t re-define auto-tuned symbols.\\n', 'runtime_error_name': 'builtins.ValueError', 'reference_timing_ms': 0.0294, 'speed_up': -1.0, 'custom_timing': -1.0}, 'runtime': -1.0, 'runtime_stats': {}}})\n\n\n### Program 3 (Score: 1.0000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 64, 'BLOCK_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 128, 'BLOCK_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 128, 'BLOCK_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 64, 'BLOCK_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 32, 'BLOCK_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 32, 'BLOCK_K': 64}, num_warps=8),\n    ],\n    key=['M', 'N', 'K'],\n)\n@triton.jit\ndef matmul_3d_kernel(\n    a_ptr, b_ptr, c_ptr,\n    M, N, K,\n    stride_am, stride_ak,\n    stride_bk, stride_bn,\n    stride_cm, stride_cn,\n    stride_batch,\n    BLOCK_M: tl.constexpr, BLOCK_N: tl.constexpr, BLOCK_K: tl.constexpr,\n):\n    pid_batch = tl.program_id(0)\n    pid = tl.program_id(1)\n    num_pid_n = tl.cdiv(N, BLOCK_N)\n    pid_m = pid // num_pid_n\n    pid_n = pid % num_pid_n\n\n    offs_m = pid_m * BLOCK_M + tl.arange(0, BLOCK_M)\n    offs_n = pid_n * BLOCK_N + tl.arange(0, BLOCK_N)\n    offs_k = tl.arange(0, BLOCK_K)\n    \n    a_ptrs = a_ptr + pid_batch * stride_batch + offs_m[:, None] * stride_am + offs_k[None, :] * stride_ak\n    b_ptrs = b_ptr + offs_k[:, None] * stride_bk + offs_n[None, :] * stride_bn\n    \n    accumulator = tl.zeros((BLOCK_M, BLOCK_N), dtype=tl.float32)\n    \n    for k in range(0, tl.cdiv(K, BLOCK_K)):\n        a_mask = (offs_m[:, None] < M) & (offs_k[None, :] < K - k * BLOCK_K)\n        a = tl.load(a_ptrs, mask=a_mask, other=0.0)\n        \n        b_mask = (offs_k[:, None] < K - k * BLOCK_K) & (offs_n[None, :] < N)\n        b = tl.load(b_ptrs, mask=b_mask, other=0.0)\n        \n        a = a.to(tl.float16)\n        b = b.to(tl.float16)\n        accumulator += tl.dot(a, b, out_dtype=tl.float32)\n        \n        a_ptrs += BLOCK_K * stride_ak\n        b_ptrs += BLOCK_K * stride_bk\n    \n    offs_cm = pid_m * BLOCK_M + tl.arange(0, BLOCK_M)\n    offs_cn = pid_n * BLOCK_N + tl.arange(0, BLOCK_N)\n    c_ptrs = c_ptr + pid_batch * stride_batch + offs_cm[:, None] * stride_cm + offs_cn[None, :] * stride_cn\n    \n    c_mask = (offs_cm[:, None] < M) & (offs_cn[None, :] < N)\n    tl.store(c_ptrs, accumulator, mask=c_mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self):\n        super(ModelNew, self).__init__()\n    \n    def forward(self, A, B):\n        N, M, K = A.shape\n        L = B.shape[1]\n        \n        C = torch.empty((N, M, L), device=A.device, dtype=A.dtype)\n        \n        grid = lambda META: (\n            N,\n            triton.cdiv(M, META['BLOCK_M']) * triton.cdiv(L, META['BLOCK_N']),\n        )\n        \n        matmul_3d_kernel[grid](\n            A, B, C,\n            M, L, K,\n            A.stride(1), A.stride(2),\n            B.stride(0), B.stride(1),\n            C.stride(1), C.stride(2),\n            A.stride(0),\n        )\n        return C\n\nN = 16\nM = 1024\nK = 2048\nL = 768\n\ndef get_inputs():\n    A = torch.randn(N, M, K, device='cuda')\n    B = torch.randn(K, L, device='cuda')\n    return [A, B]\n\ndef get_init_inputs():\n    return []\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Performs well on compiled (0.0000), Performs well on correctness (0.0000), Performs well on score (1.0000), Performs well on stage (compile_error), Performs well on compile_log (CUDA error: an illegal memory access was encountered\nCUDA kernel errors might be asynchronously reported at some other API call, so the stacktrace below might be incorrect.\nFor debugging consider passing CUDA_LAUNCH_BLOCKING=1\nCompile with `TORCH_USE_CUDA_DSA` to enable device-side assertions.\n\nTraceback (most recent call last):\n  File \"/cpfs01/shared/llm_kernel/hujiakai/KernelLLM/validation_api_server/evaluator.py\", line 173, in _verification_worker\n    result: KernelExecResult = eval_kernel_against_ref(\n  File \"/cpfs01/shared/llm_kernel/hujiakai/KernelLLM/validation_api_server/helpers/evaluations.py\", line 578, in eval_kernel_against_ref\n    graceful_eval_cleanup(context, device, tempfile)\n  File \"/cpfs01/shared/llm_kernel/hujiakai/KernelLLM/validation_api_server/helpers/evaluations.py\", line 230, in graceful_eval_cleanup\n    torch.cuda.empty_cache()\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/cuda/memory.py\", line 224, in empty_cache\n    torch._C._cuda_emptyCache()\ntorch.AcceleratorError: CUDA error: an illegal memory access was encountered\nCUDA kernel errors might be asynchronously reported at some other API call, so the stacktrace below might be incorrect.\nFor debugging consider passing CUDA_LAUNCH_BLOCKING=1\nCompile with `TORCH_USE_CUDA_DSA` to enable device-side assertions.\n\n), Performs well on exec_log ([Child] \u7ed1\u5b9a GPU 2, torch sees 1 device(s)\n\n[Exception]\nTraceback (most recent call last):\n  File \"/cpfs01/shared/llm_kernel/hujiakai/KernelLLM/validation_api_server/code_executor.py\", line 71, in _exec_worker\n    exec(textwrap.dedent(code_src), mod.__dict__)\n  File \"<string>\", line 19, in <module>\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 844, in jit\n    return decorator(fn)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 832, in decorator\n    return JITFunction(\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 635, in __init__\n    self.starting_line_number = inspect.getsourcelines(fn)[1]\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/inspect.py\", line 1121, in getsourcelines\n    lines, lnum = findsource(object)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/inspect.py\", line 958, in findsource\n    raise OSError('could not get source code')\nOSError: could not get source code\n), Performs well on exit_code (1)\n\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.0000)\n```python\n\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\n\nclass ModelNew(nn.Module):\n    \"\"\"\n    Performs 3D tensor-matrix multiplication.\n    \"\"\"\n    def __init__(self):\n        super(ModelNew, self).__init__()\n    \n    def forward(self, A, B):\n        \"\"\"\n        Performs 3D tensor-matrix multiplication.\n\n        Args:\n            A (torch.Tensor): Input 3D tensor of shape (N, M, K).\n            B (torch.Tensor): Input matrix of shape (K, L).\n\n        Returns:\n            torch.Tensor: Output tensor of shape (N, M, L), resulting from the multiplication of A and B along the last dimension of A.\n        \"\"\"\n        return torch.matmul(A, B)\n\nN = 16\nM = 1024\nK = 2048\nL = 768\n\ndef get_inputs():\n    A = torch.randn(N, M, K)\n    B = torch.randn(K, L)\n    return [A, B]\n\ndef get_init_inputs():\n    return []  # No special initialization inputs needed\n# =================== EVOLVE-BLOCK-END ===================\n\n```\nKey features: Alternative approach to compiled, Alternative approach to correctness\n\n\n### Program D2 (Score: -100.0000)\n```python\n@triton.autotune(...)  # same as before\n@triton.jit\ndef _matmul_kernel(\n    A_ptr, B_ptr, C_ptr,\n    M, N, K,\n    stride_am, stride_ak,\n    stride_bk, stride_bn,\n    stride_cm, stride_cn,\n    BLOCK_SIZE_M: tl.constexpr, BLOCK_SIZE_N: tl.constexpr, BLOCK_SIZE_K: tl.constexpr,\n):\n    pid = tl.program_id(0)\n    num_pid_n = tl.cdiv(N, BLOCK_SIZE_N)\n    pid_m = pid // num_pid_n\n    pid_n = pid % num_pid_n\n\n    # Starting indices of the block in M and N\n    rm = pid_m * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)\n    rn = pid_n * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n    rk = tl.arange(0, BLOCK_SIZE_K)\n\n    # Pointers to the starting addresses of the blocks in A and B\n    A_block_ptr = A_ptr + (rm[:, None] * stride_am + rk[None, :] * stride_ak)\n    B_block_ptr = B_ptr + (rk[:, None] * stride_bk + rn[None, :] * stride_bn)\n\n    # Initialize accumulator\n    acc = tl.zeros((BLOCK_SIZE_M, BLOCK_SIZE_N), dtype=tl.float32)\n\n    # Loop over K\n    for k in range(0, K, BLOCK_SIZE_K):\n        # Load A tile and B tile\n        a = tl.load(A_block_ptr, mask=(rm[:, None] < M) & (rk[None, :] < K - k), other=0.0)\n        b = tl.load(B_block_ptr, mask=(rk[:, None] < K - k) & (rn[None, :] < N), other=0.0)\n        # Compute the dot product and accumulate\n        acc += tl.dot(a, b, allow_tf32=True, out_dtype=tl.float32)\n        # Advance pointers to next K block\n        A_block_ptr += BLOCK_SIZE_K * stride_ak\n        B_block_ptr += BLOCK_SIZE_K * stride_bk\n\n    # Store the result\n    offs_cm = pid_m * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)\n    offs_cn = pid_n * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n    C_block_ptr = C_ptr + (offs_cm[:, None] * stride_cm + offs_cn[None, :] * stride_cn)\n    c_mask = (offs_cm[:, None] < M) & (offs_cn[None, :] < N)\n    tl.store(C_block_ptr, acc, mask=c_mask)\n```\nKey features: Alternative approach to compiled, Alternative approach to correctness\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 10.0000, Type: High-Performer)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 64, 'BLOCK_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 64, 'BLOCK_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 128, 'BLOCK_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 128, 'BLOCK_K': 32}, num_warps=8),\n    ],\n    key=['M', 'K', 'L'],\n)\n@triton.jit\ndef matmul_3d_kernel(\n    A_ptr, B_ptr, C_ptr,\n    M, K, L,\n    stride_an, stride_am, stride_ak,\n    stride_bk, stride_bl,\n    stride_cn, stride_cm, stride_cl,\n    BLOCK_M: tl.constexpr, BLOCK_N: tl.constexpr, BLOCK_K: tl.constexpr,\n):\n    pid_n = tl.program_id(0) // tl.cdiv(M, BLOCK_M)\n    pid_mb = tl.program_id(0) % tl.cdiv(M, BLOCK_M)\n    pid_nb = tl.program_id(1)\n    \n    offs_m = pid_mb * BLOCK_M + tl.arange(0, BLOCK_M)\n    offs_n = pid_nb * BLOCK_N + tl.arange(0, BLOCK_N)\n    offs_k = tl.arange(0, BLOCK_K)\n    \n    a_ptrs = A_ptr + pid_n * stride_an + offs_m[:, None] * stride_am + offs_k[None, :] * stride_ak\n    b_ptrs = B_ptr + offs_k[:, None] * stride_bk + offs_n[None, :] * stride_bl\n    \n    accumulator = tl.zeros((BLOCK_M, BLOCK_N), dtype=tl.float32)\n    \n    for k in range(0, K, BLOCK_K):\n        a = tl.load(a_ptrs, mask=(offs_m[:, None] < M) & (offs_k[None, :] < K - k), other=0.0)\n        b = tl.load(b_ptrs, mask=(offs_k[:, None] < K - k) & (offs_n[None, :] < L), other=0.0)\n        \n        accumulator += tl.dot(a, b)\n        \n        a_ptrs += BLOCK_K * stride_ak\n        b_ptrs += BLOCK_K * stride_bk\n    \n    offs_cm = offs_m[:, None]\n    offs_cl = offs_n[None, :]\n    c_ptrs = C_ptr + pid_n * stride_cn + offs_cm * stride_cm + offs_cl * stride_cl\n    tl.store(c_ptrs, accumulator, mask=(offs_cm < M) & (offs_cl < L))\n\nclass ModelNew(nn.Module):\n    def __init__(self):\n        super(ModelNew, self).__init__()\n    \n    def forward(self, A, B):\n        N, M, K = A.shape\n        L = B.shape[1]\n        C = torch.empty((N, M, L), device=A.device, dtype=A.dtype)\n        \n        grid = (N * triton.cdiv(M, 64), triton.cdiv(L, 64))\n        \n        matmul_3d_kernel[grid](\n            A, B, C,\n            M, K, L,\n            A.stride(0), A.stride(1), A.stride(2),\n            B.stride(0), B.stride(1),\n            C.stride(0), C.stride(1), C.stride(2),\n            BLOCK_M=64, BLOCK_N=64, BLOCK_K=32\n        )\n        return C\n\nN = 16\nM = 1024\nK = 2048\nL = 768\n\ndef get_inputs():\n    A = torch.randn(N, M, K, device='cuda')\n    B = torch.randn(K, L, device='cuda')\n    return [A, B]\n\ndef get_init_inputs():\n    return []\n# =================== EVOLVE-BLOCK-END ===================\n```\nUnique approach: Modification: Full rewrite, Excellent compiled (1.000), Alternative correctness approach\n\n\n\n# Current Program\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 64, 'BLOCK_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 64, 'BLOCK_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 128, 'BLOCK_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 128, 'BLOCK_K': 64}, num_warps=8),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 256, 'BLOCK_K': 32}, num_warps=8),\n    ],\n    key=['M', 'K', 'L'],\n)\n@triton.jit\ndef matmul_3d_kernel(\n    A_ptr, B_ptr, C_ptr,\n    M, K, L,\n    stride_an, stride_am, stride_ak,\n    stride_bk, stride_bl,\n    stride_cn, stride_cm, stride_cl,\n    BLOCK_M: tl.constexpr, BLOCK_N: tl.constexpr, BLOCK_K: tl.constexpr,\n):\n    pid = tl.program_id(0)\n    pid_n = pid // (tl.cdiv(M, BLOCK_M) * tl.cdiv(L, BLOCK_N))\n    pid_mb = (pid % (tl.cdiv(M, BLOCK_M) * tl.cdiv(L, BLOCK_N))) // tl.cdiv(L, BLOCK_N)\n    pid_nb = pid % tl.cdiv(L, BLOCK_N)\n    \n    offs_m = pid_mb * BLOCK_M + tl.arange(0, BLOCK_M)\n    offs_n = pid_nb * BLOCK_N + tl.arange(0, BLOCK_N)\n    offs_k = tl.arange(0, BLOCK_K)\n    \n    a_ptrs = A_ptr + pid_n * stride_an + offs_m[:, None] * stride_am + offs_k[None, :] * stride_ak\n    b_ptrs = B_ptr + offs_k[:, None] * stride_bk + offs_n[None, :] * stride_bl\n    \n    accumulator = tl.zeros((BLOCK_M, BLOCK_N), dtype=tl.float32)\n    \n    for k in range(0, tl.cdiv(K, BLOCK_K)):\n        k_offset = k * BLOCK_K\n        a_mask = (offs_m[:, None] < M) & ((k_offset + offs_k[None, :]) < K)\n        b_mask = ((k_offset + offs_k[:, None]) < K) & (offs_n[None, :] < L)\n        \n        a = tl.load(a_ptrs, mask=a_mask, other=0.0)\n        b = tl.load(b_ptrs, mask=b_mask, other=0.0)\n        \n        accumulator += tl.dot(a, b, allow_tf32=True)\n        \n        a_ptrs += BLOCK_K * stride_ak\n        b_ptrs += BLOCK_K * stride_bk\n    \n    c_ptrs = C_ptr + pid_n * stride_cn + offs_m[:, None] * stride_cm + offs_n[None, :] * stride_cl\n    c_mask = (offs_m[:, None] < M) & (offs_n[None, :] < L)\n    tl.store(c_ptrs, accumulator, mask=c_mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self):\n        super(ModelNew, self).__init__()\n    \n    def forward(self, A, B):\n        N, M, K = A.shape\n        L = B.shape[1]\n        C = torch.empty((N, M, L), device=A.device, dtype=A.dtype)\n        \n        grid = lambda META: (N * triton.cdiv(M, META['BLOCK_M']) * triton.cdiv(L, META['BLOCK_N']),)\n        \n        matmul_3d_kernel[grid](\n            A, B, C,\n            M, K, L,\n            A.stride(0), A.stride(1), A.stride(2),\n            B.stride(0), B.stride(1),\n            C.stride(0), C.stride(1), C.stride(2),\n        )\n        return C\n\nN = 16\nM = 1024\nK = 2048\nL = 768\n\ndef get_inputs():\n    A = torch.randn(N, M, K, device='cuda')\n    B = torch.randn(K, L, device='cuda')\n    return [A, B]\n\ndef get_init_inputs():\n    return []\n# =================== EVOLVE-BLOCK-END ===================\n```\n\n# Task\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```\n", "responses": ["<think>\nWe are given a Triton kernel for 3D tensor-matrix multiplication that is currently failing correctness (output mismatch) and also has a low score (10.0) due to the correctness issue.\n\nThe current program uses a 3D tensor A (shape [N, M, K]) and a matrix B (shape [K, L]) to produce an output C (shape [N, M, L]).\n\nThe kernel uses a 1D grid of size (N * ceil(M / BLOCK_M) * ceil(L / BLOCK_N),). Each program computes a block of size BLOCK_M x BLOCK_N for one of the N batches.\n\nThe main issues that could cause correctness failure are:\n1. Incorrect indexing for the batch dimension (pid_n) and the block indices (pid_mb, pid_nb).\n2. Incorrect computation of the pointers and masks.\n3. The inner loop over K dimension might not be handling boundaries correctly.\n\nLooking at the current kernel:\n\n    pid = tl.program_id(0)\n    pid_n = pid // (tl.cdiv(M, BLOCK_M) * tl.cdiv(L, BLOCK_N))\n    pid_mb = (pid % (tl.cdiv(M, BLOCK_M) * tl.cdiv(L, BLOCK_N))) // tl.cdiv(L, BLOCK_N)\n    pid_nb = pid % tl.cdiv(L, BLOCK_N)\n\nThis computes:\n- `pid_n`: the batch index, which should be in [0, N-1].\n- `pid_mb`: the block index in the M dimension, which should be in [0, ceil(M/BLOCK_M)-1].\n- `pid_nb`: the block index in the N dimension (which is the L dimension for B), in [0, ceil(L/BLOCK_N)-1].\n\nHowever, note that the grid is 1D and the total number of blocks is `N * ceil(M/BLOCK_M) * ceil(L/BLOCK_N)`. The above computation seems to break the 1D index correctly.\n\nBut let me check the order of the blocks: The kernel iterates over batches (N) as the outermost, then over M blocks, then over L blocks? Actually, the way we break the 1D index is:\n\n    total_blocks_per_batch = (ceil(M/BLOCK_M) * ceil(L/BLOCK_N))\n    pid_n = pid // total_blocks_per_batch\n    pid_remaining = pid % total_blocks_per_batch\n    pid_mb = pid_remaining // ceil(L/BLOCK_N)\n    pid_nb = pid_remaining % ceil(L/BLOCK_N)\n\nThe current code for `pid_mb` is:\n\n    pid_mb = (pid % total_blocks_per_batch) // ceil(L/BLOCK_N)\n\nand `pid_nb` is `pid % ceil(L/BLOCK_N)`. This is correct.\n\nHowever, note that the grid function uses `META['BLOCK_M']` and `META['BLOCK_N']` to compute the grid size. This is acceptable because the autotuner will set the block sizes.\n\nThe main issue might be in the memory access patterns and the inner loop.\n\nIn the inner loop:\n\n    for k in range(0, tl.cdiv(K, BLOCK_K)):\n        k_offset = k * BLOCK_K\n        a_mask = (offs_m[:, None] < M) & ((k_offset + offs_k[None, :]) < K)\n        b_mask = ((k_offset + offs_k[:, None]) < K) & (offs_n[None, :] < L)\n\n        a = tl.load(a_ptrs, mask=a_mask, other=0.0)\n        b = tl.load(b_ptrs, mask=b_mask, other=0.0)\n\n        accumulator += tl.dot(a, b, allow_tf32=True)\n\n        a_ptrs += BLOCK_K * stride_ak\n        b_ptrs += BLOCK_K * stride_bk\n\nThe mask for `a` is for the current block in A: we are at batch `pid_n`, row block `pid_mb` (rows in [pid_mb*BLOCK_M, (pid_mb+1)*BLOCK_M) and column block starting at `k_offset` of size `BLOCK_K`. The mask for `a` should be:\n    (current row in the block is within M) AND (current column in the block, which is `k_offset + offs_k`, is within K)\n\nSimilarly for `b`: the matrix B has rows of size K and columns of size L. We are loading a block of B of size BLOCK_K x BLOCK_N. The mask for `b` should be:\n    (current row in the block (which is `k_offset + offs_k`) is within K) AND (current column in the block (which is `offs_n`) is within L)\n\nBut note: the `offs_n` is the column index in the output block (which is the same as the column index in B). So the mask for `b` is correct.\n\nHowever, there is a potential issue: the inner loop runs for `tl.cdiv(K, BLOCK_K)` steps, but in each step we are loading a block of size BLOCK_K. The mask condition for the column in A and row in B is `(k_offset + offs_k) < K`, which is correct.\n\nBut note: the `offs_k` is of length BLOCK_K, so the condition `(k_offset + offs_k) < K` for `a_mask` is applied to a vector of length BLOCK_K. Similarly for `b_mask`.\n\nAnother issue: the `a_ptrs` and `b_ptrs` are advanced by `BLOCK_K * stride_ak` and `BLOCK_K * stride_bk` respectively. This is correct.\n\nAfter the loop, we store the accumulator to C. The indices for C are:\n    c_ptrs = C_ptr + pid_n * stride_cn + offs_m[:, None] * stride_cm + offs_n[None, :] * stride_cl\n    c_mask = (offs_m[:, None] < M) & (offs_n[None, :] < L)\n\nThis is correct.\n\nBut why the output mismatch?\n\nOne possibility: the data type. The reference code uses the same dtype as A (which is by default float32 if we use `torch.randn`). The Triton kernel uses `tl.float32` for the accumulator and then stores it as the same dtype as A. However, note that the `tl.dot` product uses `allow_tf32=True` which might cause numerical differences. But the problem says the average difference is around 0.027, which is too high for tf32 vs fp32.\n\nAnother possibility: the strides. The kernel uses the strides provided by the tensors. The input tensor A is of shape [N, M, K] and the strides are given as:\n    stride_an = A.stride(0)  # stride between batches\n    stride_am = A.stride(1)  # stride between rows in a batch\n    stride_ak = A.stride(2)  # stride between columns in a row\n\nSimilarly for B: \n    stride_bk = B.stride(0)  # stride between rows\n    stride_bl = B.stride(1)  # stride between columns\n\nAnd for C:\n    stride_cn, stride_cm, stride_cl = C.stride(0), C.stride(1), C.stride(2)\n\nBut note: the tensor B is 2D (shape [K, L]), so when we pass it to the kernel, its stride(0) is L and stride(1) is 1 if it's row-major.\n\nHowever, the kernel uses `b_ptrs = B_ptr + offs_k[:, None] * stride_bk + offs_n[None, :] * stride_bl`. This is correct.\n\nBut wait: the kernel is written for a 3D tensor A and a 2D tensor B. The batch dimension for B is missing. Since we are doing a batched matmul, we are using the same B for every batch. So in the kernel, we do not index B by batch. This is correct.\n\nLet me check the dimensions of the pointers:\n\n    A_ptr: points to the start of the 3D tensor A.\n    B_ptr: points to the start of the 2D tensor B.\n\nIn the kernel, we access A as:\n    a_ptrs = A_ptr + pid_n * stride_an + ...   # which moves to the pid_n-th batch.\n\nBut for B, we don't have a batch dimension. So we use the same B for every batch. This is correct.\n\nAnother possibility: the inner loop might be accumulating incorrectly because the masks are not properly applied to the loaded values. The `tl.dot` operation might be using the entire block even where the mask is false? Actually, the `tl.load` sets the out-of-bound elements to 0.0. Then the dot product of two blocks with zeros in the out-of-bound parts should be safe.\n\nBut note: the dot product is between a block of A (size BLOCK_M x BLOCK_K) and a block of B (size BLOCK_K x BLOCK_N). The dot product will compute the product of the two blocks and then sum along the K dimension. The zeros in the out-of-bound parts will not contribute. So it should be safe.\n\nHowever, we are running into an output mismatch. Let me try to simplify the kernel to a non-tiled version in the inner loop? That might be too slow but for correctness we can try.\n\nAlternatively, we can try to remove the autotuner and fix the block sizes to see if that helps.\n\nBut note: the problem says that the previous attempt (Attempt 3) had a compilation error, and Attempt 2 had a runtime error (ValueError: Conflicting meta-parameters). The current program does not have that error because the autotuner is passed as a decorator and the kernel is called without specifying the block sizes (they are set by autotuner). So that error is avoided.\n\nWhat else? The grid function:\n\n    grid = lambda META: (N * triton.cdiv(M, META['BLOCK_M']) * triton.cdiv(L, META['BLOCK_N']),)\n\nThis is a 1D grid. The kernel uses a 1D program_id. That is consistent.\n\nAnother idea: the order of the blocks in the grid might be different from the reference. But the reference does a batched matmul, and the order of computation should not matter.\n\nGiven the complexity, let me try to rewrite the kernel with a simpler grid and indexing. We can use a 3D grid: [N, ceil(M/BLOCK_M), ceil(L/BLOCK_N)]. Then we don't have to break the 1D index. But the problem says we cannot change the grid configuration. However, note that the constraints say:\n\n    \u274c NEVER modify grid configuration, output tensor shapes, or PID logic\n\nBut wait: the grid function is defined in the `forward` method. We are allowed to change the Triton kernel source, but we cannot change the grid configuration? Actually, the constraint says \"NEVER modify grid configuration\", meaning we cannot change the way the grid is computed? But note the grid is computed by a lambda that uses META. We are allowed to change the Triton kernel, but the grid function is outside the kernel. However, the problem says: \"Modify ONLY the Triton kernel source within this block - all other code is LOCKED.\" So we cannot change the grid function.\n\nTherefore, we must keep the 1D grid.\n\nBut we can change the way we break the 1D index in the kernel. Alternatively, we can try to fix the inner loop by ensuring the masks are correctly applied.\n\nLet me reexamine the inner loop condition:\n\n    for k in range(0, tl.cdiv(K, BLOCK_K)):\n        k_offset = k * BLOCK_K\n        a_mask = (offs_m[:, None] < M) & ((k_offset + offs_k[None, :]) < K)\n        b_mask = ((k_offset + offs_k[:, None]) < K) & (offs_n[None, :] < L)\n\nThe problem is that `offs_k` is from 0 to BLOCK_K-1. So `k_offset + offs_k` goes from k*BLOCK_K to k*BLOCK_K + BLOCK_K-1. We want to mask any element beyond K.\n\nBut note: the condition `(k_offset + offs_k) < K` is not enough. It should be `(k_offset + offs_k) < K` and also `(k_offset + offs_k) >= 0`? But k_offset is nonnegative and offs_k is nonnegative.\n\nHowever, if K is not divisible by BLOCK_K, the last block might have less than BLOCK_K elements. We are masking the load to 0 for out-of-bound elements. That is correct.\n\nBut what if the entire block is out of bounds? Then we skip the computation? Actually, the mask will be all false and we load zeros. Then the dot product will be zero. That is acceptable.\n\nBut note: the condition for the row in A and column in B might be too restrictive? For example, the condition for `a_mask` requires that the row `offs_m` is within M and the column `k_offset+offs_k` is within K. Similarly for `b_mask`.\n\nI think the masks are correct.\n\nAnother possibility: the strides. The kernel uses the strides provided by the tensor. But what if the tensor is not contiguous? The problem does not say the tensors are contiguous. In the `forward` method, we do:\n\n    C = torch.empty((N, M, L), device=A.device, dtype=A.dtype)\n\nThis is contiguous by default? But what if A is non-contiguous? The kernel uses the strides. The kernel should work for non-contiguous tensors because it uses the strides.\n\nBut the reference code `torch.matmul` might return a contiguous tensor? We are comparing the Triton output with the reference. The Triton kernel writes to a contiguous tensor C? Actually, we create C as `torch.empty` which is contiguous. So the output is contiguous.\n\nBut the input A might be non-contiguous. The problem says the dataset has 250 kernelbench/level1-level5 *.py files. We don't know the exact input. However, the test uses:\n\n    def get_inputs():\n        A = torch.randn(N, M, K, device='cuda')\n        B = torch.randn(K, L, device='cuda')\n\nThese are contiguous. So the strides should be [M*K, K, 1] for A and [L, 1] for B? Actually, for A: \n    A = torch.randn(N, M, K) -> strides: [M*K, K, 1]\n    B = torch.randn(K, L) -> strides: [L, 1] if it's row-major? Actually, by default it's row-major so strides: [L, 1] for a 2D tensor? No, wait: for a 2D tensor of shape [K, L], the stride for the first dimension (k) is L, and the second dimension (l) is 1.\n\nBut in the kernel, for A:\n    a_ptrs = A_ptr + pid_n * (M*K) + offs_m[:, None] * K + offs_k[None, :] * 1\n\nFor B:\n    b_ptrs = B_ptr + offs_k[:, None] * L + offs_n[None, :] * 1\n\nBut wait: the kernel uses:\n    a_ptrs = A_ptr + pid_n * stride_an + offs_m[:, None] * stride_am + offs_k[None, :] * stride_ak\n    with stride_an = A.stride(0) = M*K, stride_am = A.stride(1)=K, stride_ak = A.stride(2)=1.\n\n    b_ptrs = B_ptr + offs_k[:, None] * stride_bk + offs_n[None, :] * stride_bl\n    with stride_bk = B.stride(0)=L, stride_bl = B.stride(1)=1.\n\nSo the indexing for A is correct: the element at (n, i, j) is at n*(M*K) + i*K + j.\n\nFor B: the element at (i, j) is at i*L + j.\n\nBut in the kernel, we are doing:\n    a_ptrs: points to a block of size BLOCK_M x BLOCK_K in the current batch, starting at row `offs_m` and column `k_offset` (which is added by the loop).\n    b_ptrs: points to a block of size BLOCK_K x BLOCK_N in B, starting at row `k_offset` and column `offs_n`.\n\nThen we do a dot product of the two blocks. This is standard.\n\nBut note: the matrix multiplication is defined as:\n    C[n, i, j] = sum_{k} A[n, i, k] * B[k, j]\n\nIn the kernel, for a fixed batch n and fixed block (i_block, j_block), we are iterating over k in chunks of size BLOCK_K. The dot product for a chunk multiplies a block of A (rows i in the block, columns k in the chunk) by a block of B (rows k in the chunk, columns j in the block). This is correct.\n\nGiven the above, it's hard to see the issue.\n\nAnother idea: the kernel uses `tl.cdiv(K, BLOCK_K)` for the loop. This might be an integer. But note: `tl.cdiv` returns an integer. So the loop is over integers.\n\nBut what if we have a very small K? The loop will run at least once even if K==0? But the test has K=2048, so it's not small.\n\nLet me try to change the kernel to use a simpler approach for the inner loop: without tiling in the K dimension? But that would be inefficient and might not be allowed by the problem (we are required to tile for performance). But for correctness, we can try a single block in K? But the problem says we are at level1, so the matrices are large.\n\nAlternatively, we can try to remove the autotuner and use fixed block sizes to see if that helps, but we cannot change the grid function.\n\nBut note: the autotuner might be causing the kernel to run with different block sizes, but the correctness should be independent of block size.\n\nGiven the complexity, I propose to rewrite the kernel with a different way of computing the masks and the inner loop, and also to use more comments for clarity.\n\nSpecifically, I will change the inner loop to:\n\n    for k in range(0, K, BLOCK_K):\n        k_remaining = K - k\n        k_valid = min(BLOCK_K, k_remaining)\n        a_mask = (offs_m[:, None] < M) & (offs_k[None, :] < k_valid)\n        b_mask = (offs_k[:, None] < k_valid) & (offs_n[None, :] < L)\n\n        a = tl.load(a_ptrs, mask=a_mask, other=0.0)\n        b = tl.load(b_ptrs, mask=b_mask, other=0.0)\n\n        accumulator += tl.dot(a, b, allow_tf32=True)\n\n        a_ptrs += BLOCK_K * stride_ak\n        b_ptrs += BLOCK_K * stride_bk\n\nBut note: the inner loop condition in the current kernel is `for k in range(0, tl.cdiv(K, BLOCK_K))` and we use `k_offset = k * BLOCK_K` and then check `k_offset + offs_k < K`. The new version uses a step of BLOCK_K and then checks the valid part for this block.\n\nBut the problem says: we cannot change the grid configuration, but we can change the Triton kernel. We are allowed to change the inner loop.\n\nLet me try this version. Also, I will change the loop to step by BLOCK_K and use `k` as the current offset.\n\nWe also note that the total number of iterations is `tl.cdiv(K, BLOCK_K)`, so we can write:\n\n    for k_idx in range(0, tl.cdiv(K, BLOCK_K)):\n        k_start = k_idx * BLOCK_K\n        k_end = tl.minimum(k_start + BLOCK_K, K)\n        k_valid = k_end - k_start\n\n        a_mask = (offs_m[:, None] < M) & (offs_k[None, :] < k_valid)\n        b_mask = (offs_k[:, None] < k_valid) & (offs_n[None, :] < L)\n\n        a = tl.load(a_ptrs, mask=a_mask, other=0.0)\n        b = tl.load(b_ptrs, mask=b_mask, other=0.0)\n\n        accumulator += tl.dot(a, b, allow_tf32=True)\n\n        a_ptrs += BLOCK_K * stride_ak\n        b_ptrs += BLOCK_K * stride_bk\n\nBut note: the `offs_k` is always of size BLOCK_K. The condition `offs_k < k_valid` will be true for the first `k_valid` elements and false for the rest. This is equivalent to the previous mask condition? Not exactly. Previously we did `(k_start + offs_k) < K`, which is the same as `offs_k < (K - k_start)`. And `k_valid = min(BLOCK_K, K - k_start)`. So the condition `offs_k < k_valid` is the same as `offs_k < (K - k_start)` because `offs_k` is in [0, BLOCK_K-1] and if `K - k_start` is less than BLOCK_K, then we only take the first `K - k_start` elements.\n\nSo the two are equivalent.\n\nBut the new version might be clearer.\n\nAlternatively, we can try to disable tf32 to see if that helps with numerical accuracy? The problem says the average difference is 0.027, which is not negligible. We can set `allow_tf32=False` to use full fp32.\n\nBut note: the H100 supports tf32, but the reference is in fp32. The tf32 might have less precision. However, the tolerance in the test might be for fp32. So let's try without tf32.\n\nBut the problem says: we are on H800 (same as H100) and we can use Tensor Core with FP16. But our inputs are in fp32? The test uses `torch.randn` which by default is fp32. So the kernel uses fp32. The `tl.dot` with `allow_tf32=True` uses tf32 which is 10 bits of mantissa. The reference uses fp32 (23 bits). So the difference might be due to that.\n\nBut the tolerance in the test is not specified. The problem says: \"Output must match PyTorch reference within float32 tolerance\". The tf32 is not float32. So we should use `allow_tf32=False` to get full fp32 precision.\n\nSo let's change:\n    accumulator += tl.dot(a, b, allow_tf32=False)\n\nBut note: the Triton documentation says that for fp32 inputs, the dot product uses tf32 by default. We want to avoid that.\n\nAlternatively, we can use `out_dtype=tl.float32` and `allow_tf32=False`? The `tl.dot` function has an `out_dtype` and `allow_tf32` parameter.\n\nSo we change the dot product to:\n    accumulator += tl.dot(a, b, allow_tf32=False)\n\nBut note: the inputs `a` and `b` are fp32? Yes, because A and B are fp32 (from torch.randn). The kernel loads them as the default which is fp32? Actually, the pointers are loaded without specifying a type, but the `tl.load` will load the data as the type of the pointer? The kernel does not specify the data type for the loads. The Triton kernel uses the `dtype` of the accumulator for the dot product? Not exactly, the `tl.dot` has the following behavior: for fp32 inputs, if `allow_tf32` is True, it uses tf32. We want full precision.\n\nGiven the above, I propose two changes:\n\n1. Change the inner loop to use the `k_valid` approach for clarity and to ensure we are not doing any out-of-bound loads.\n2. Change the dot product to use `allow_tf32=False`.\n\nWe'll also keep the rest of the kernel the same.\n\nLet me write the revised kernel.\n\nNote: We must not change the function signature.\n\nRevised kernel code:\n\n    @triton.autotune(...)  # same autotuner configs\n    @triton.jit\n    def matmul_3d_kernel(...):  # same parameters\n        ... # same pid computation\n\n        ... # same offs_m, offs_n, offs_k\n\n        a_ptrs = ... # same\n        b_ptrs = ... # same\n\n        accumulator = tl.zeros((BLOCK_M, BLOCK_N), dtype=tl.float32)\n\n        # Loop over K in steps of BLOCK_K\n        for k_idx in range(0, tl.cdiv(K, BLOCK_K)):\n            k_start = k_idx * BLOCK_K\n            k_end = tl.minimum(k_start + BLOCK_K, K)\n            k_valid = k_end - k_start\n\n            a_mask = (offs_m[:, None] < M) & (offs_k[None, :] < k_valid)\n            b_mask = (offs_k[:, None] < k_valid) & (offs_n[None, :] < L)\n\n            a = tl.load(a_ptrs, mask=a_mask, other=0.0)\n            b = tl.load(b_ptrs, mask=b_mask, other=0.0)\n\n            accumulator += tl.dot(a, b, allow_tf32=False)\n\n            a_ptrs += BLOCK_K * stride_ak\n            b_ptrs += BLOCK_K * stride_bk\n\n        ... # same store\n\nWe are also not changing the grid or the function signature.\n\nLet's hope this fixes the correctness.\n\nWe are also making the kernel a bit slower by disabling tf32, but for level1 we care about correctness first. We can try to enable tf32 later if we can get a speedup and if the test allows a higher tolerance.\n\nBut the problem says: \"Output must match PyTorch reference within float32 tolerance\". Using tf32 might break that. So we should use full fp32.\n\nNow, we output the entire code block with the revised kernel.\n\nNote: We are only allowed to change the Triton kernel within the EVOLVE-BLOCK. The rest (like the ModelNew class and the test setup) must remain unchanged.\n\nLet me write the code accordingly.\n</think>\nTo address the correctness issues in the Triton kernel for 3D tensor-matrix multiplication, we need to focus on two main aspects: numerical precision and boundary handling. The previous implementation used tf32 acceleration which can lead to precision differences compared to the PyTorch reference. Additionally, the boundary checks in the inner loop were slightly complex and could be simplified for better correctness.\n\nKey improvements made:\n1. Disabled tf32 acceleration to ensure full fp32 precision matching PyTorch\n2. Simplified inner loop boundary checks using min operations\n3. Maintained all other optimizations (coalesced memory access, tiling, etc.)\n\nHere's the complete solution:\n\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 64, 'BLOCK_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 64, 'BLOCK_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 128, 'BLOCK_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 128, 'BLOCK_K': 64}, num_warps=8),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 256, 'BLOCK_K': 32}, num_warps=8),\n    ],\n    key=['M', 'K', 'L'],\n)\n@triton.jit\ndef matmul_3d_kernel(\n    A_ptr, B_ptr, C_ptr,\n    M, K, L,\n    stride_an, stride_am, stride_ak,\n    stride_bk, stride_bl,\n    stride_cn, stride_cm, stride_cl,\n    BLOCK_M: tl.constexpr, BLOCK_N: tl.constexpr, BLOCK_K: tl.constexpr,\n):\n    pid = tl.program_id(0)\n    pid_n = pid // (tl.cdiv(M, BLOCK_M) * tl.cdiv(L, BLOCK_N))\n    pid_mb = (pid % (tl.cdiv(M, BLOCK_M) * tl.cdiv(L, BLOCK_N))) // tl.cdiv(L, BLOCK_N)\n    pid_nb = pid % tl.cdiv(L, BLOCK_N)\n    \n    offs_m = pid_mb * BLOCK_M + tl.arange(0, BLOCK_M)\n    offs_n = pid_nb * BLOCK_N + tl.arange(0, BLOCK_N)\n    offs_k = tl.arange(0, BLOCK_K)\n    \n    a_ptrs = A_ptr + pid_n * stride_an + offs_m[:, None] * stride_am + offs_k[None, :] * stride_ak\n    b_ptrs = B_ptr + offs_k[:, None] * stride_bk + offs_n[None, :] * stride_bl\n    \n    accumulator = tl.zeros((BLOCK_M, BLOCK_N), dtype=tl.float32)\n    \n    for k in range(0, tl.cdiv(K, BLOCK_K)):\n        k_start = k * BLOCK_K\n        k_remaining = K - k_start\n        k_valid = tl.minimum(BLOCK_K, k_remaining)\n        \n        a_mask = (offs_m[:, None] < M) & (offs_k[None, :] < k_valid)\n        b_mask = (offs_k[:, None] < k_valid) & (offs_n[None, :] < L)\n        \n        a = tl.load(a_ptrs, mask=a_mask, other=0.0)\n        b = tl.load(b_ptrs, mask=b_mask, other=0.0)\n        \n        accumulator += tl.dot(a, b, allow_tf32=False)\n        \n        a_ptrs += BLOCK_K * stride_ak\n        b_ptrs += BLOCK_K * stride_bk\n    \n    c_ptrs = C_ptr + pid_n * stride_cn + offs_m[:, None] * stride_cm + offs_n[None, :] * stride_cl\n    c_mask = (offs_m[:, None] < M) & (offs_n[None, :] < L)\n    tl.store(c_ptrs, accumulator, mask=c_mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self):\n        super(ModelNew, self).__init__()\n    \n    def forward(self, A, B):\n        N, M, K = A.shape\n        L = B.shape[1]\n        C = torch.empty((N, M, L), device=A.device, dtype=A.dtype)\n        \n        grid = lambda META: (N * triton.cdiv(M, META['BLOCK_M']) * triton.cdiv(L, META['BLOCK_N']),)\n        \n        matmul_3d_kernel[grid](\n            A, B, C,\n            M, K, L,\n            A.stride(0), A.stride(1), A.stride(2),\n            B.stride(0), B.stride(1),\n            C.stride(0), C.stride(1), C.stride(2),\n        )\n        return C\n\nN = 16\nM = 1024\nK = 2048\nL = 768\n\ndef get_inputs():\n    A = torch.randn(N, M, K, device='cuda')\n    B = torch.randn(K, L, device='cuda')\n    return [A, B]\n\ndef get_init_inputs():\n    return []\n# =================== EVOLVE-BLOCK-END ===================\n```"]}}}