{"id": "eef9ba0a-b43a-4a50-85d1-60a599f43ab7", "code": "# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef _fused_activations_kernel(\n    x_ptr,\n    add_ptr,\n    output_ptr,\n    n_rows,\n    n_cols,\n    BLOCK_SIZE_R: tl.constexpr,\n    BLOCK_SIZE_C: tl.constexpr,\n):\n    pid_row = tl.program_id(0)\n    pid_col = tl.program_id(1)\n    \n    row_start = pid_row * BLOCK_SIZE_R\n    col_start = pid_col * BLOCK_SIZE_C\n    \n    col_offsets = col_start + tl.arange(0, BLOCK_SIZE_C)\n    col_mask = col_offsets < n_cols\n    \n    # Preload add values for column block\n    add_vals = tl.load(add_ptr + col_offsets, mask=col_mask, other=0.0)\n    \n    for r in range(BLOCK_SIZE_R):\n        row_idx = row_start + r\n        if row_idx < n_rows:\n            # Load input values with vectorization\n            x_ptrs = x_ptr + row_idx * n_cols + col_offsets\n            x_vals = tl.load(x_ptrs, mask=col_mask, other=0.0)\n            \n            # Fused operations with optimized computation order\n            y = x_vals + add_vals\n            swish = y * tl.sigmoid(y)\n            tanh = 2 * tl.sigmoid(2 * swish) - 1  # tanh approximation\n            gelu = 0.5 * tanh * (1.0 + tl.erf(tanh * 0.7071067811865475))\n            hardtanh = tl.minimum(tl.maximum(gelu, -1.0), 1.0)\n            \n            # Store results with vectorization\n            out_ptrs = output_ptr + row_idx * n_cols + col_offsets\n            tl.store(out_ptrs, hardtanh, mask=col_mask)\n\ndef fused_activations(x, add_value):\n    output = torch.empty_like(x)\n    n_rows, n_cols = x.shape\n    \n    # Optimized block sizes for H100 architecture\n    BLOCK_SIZE_R = 4\n    BLOCK_SIZE_C = 128\n    \n    grid = (triton.cdiv(n_rows, BLOCK_SIZE_R), triton.cdiv(n_cols, BLOCK_SIZE_C))\n    num_warps = 4  # Fixed warps for better occupancy\n    \n    _fused_activations_kernel[grid](\n        x, add_value, output, n_rows, n_cols,\n        BLOCK_SIZE_R=BLOCK_SIZE_R, \n        BLOCK_SIZE_C=BLOCK_SIZE_C,\n        num_warps=num_warps\n    )\n    return output\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, add_value_shape):\n        super(ModelNew, self).__init__()\n        self.matmul = nn.Linear(in_features, out_features)\n        self.add_value = nn.Parameter(torch.randn(add_value_shape)) \n\n    def forward(self, x):\n        x = self.matmul(x)\n        x = fused_activations(x, self.add_value)\n        return x\n\nbatch_size = 128\nin_features = 1024\nout_features = 512\nadd_value_shape = (out_features,)\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, add_value_shape]\n# =================== EVOLVE-BLOCK-END ===================", "language": "python", "parent_id": "7df8b85d-9b95-45d3-a41f-3aeae46865c2", "generation": 3, "timestamp": 1754588617.8432577, "iteration_found": 21, "metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": true, "score": 23.89999999999999, "speed_up": 1.039, "runtime_ms": 0.0839, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:1", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.0872, "speed_up": 1.039, "custom_timing": 0.0839}}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": true, "score": 30.9, "speed_up": 1.109, "runtime_ms": 0.0786, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:6", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.0872, "speed_up": 1.109, "custom_timing": 0.0786}}, "island": 1}, "artifacts_json": null, "artifact_dir": null}