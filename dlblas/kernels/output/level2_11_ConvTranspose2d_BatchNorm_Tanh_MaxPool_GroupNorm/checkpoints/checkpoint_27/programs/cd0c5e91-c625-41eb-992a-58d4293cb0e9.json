{"id": "cd0c5e91-c625-41eb-992a-58d4293cb0e9", "code": "# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef group_norm_kernel(\n    x_ptr,\n    y_ptr,\n    gamma_ptr,\n    beta_ptr,\n    N, C, H, W,\n    num_groups: tl.constexpr,\n    eps: tl.constexpr,\n    BLOCK_SIZE: tl.constexpr\n):\n    n = tl.program_id(0)\n    g = tl.program_id(1)\n    group_size = C // num_groups\n    \n    # Initialize accumulators\n    mean = 0.0\n    sq_sum = 0.0\n    count = 0.0\n    \n    # Single-pass calculation for mean and variance\n    for c in range(g * group_size, (g + 1) * group_size):\n        base = n * C * H * W + c * H * W\n        for hw in range(0, H * W, BLOCK_SIZE):\n            offsets = hw + tl.arange(0, BLOCK_SIZE)\n            mask = offsets < (H * W)\n            \n            # Vectorized load\n            x_vals = tl.load(x_ptr + base + offsets, mask=mask, other=0.0)\n            mean += tl.sum(x_vals)\n            sq_sum += tl.sum(x_vals * x_vals)\n            count += tl.sum(mask)\n    \n    # Compute group statistics\n    mean = mean / count\n    var = (sq_sum / count) - (mean * mean)\n    std = tl.sqrt(var + eps)\n    \n    # Apply normalization\n    for c in range(g * group_size, (g + 1) * group_size):\n        base = n * C * H * W + c * H * W\n        for hw in range(0, H * W, BLOCK_SIZE):\n            offsets = hw + tl.arange(0, BLOCK_SIZE)\n            mask = offsets < (H * W)\n            \n            # Vectorized load and store\n            x_vals = tl.load(x_ptr + base + offsets, mask=mask, other=0.0)\n            gamma_val = tl.load(gamma_ptr + c)\n            beta_val = tl.load(beta_ptr + c)\n            normalized = (x_vals - mean) / std\n            out = normalized * gamma_val + beta_val\n            tl.store(y_ptr + base + offsets, out, mask=mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_channels, out_channels, kernel_size, stride, padding, groups, num_groups):\n        super(ModelNew, self).__init__()\n        self.conv_transpose = nn.ConvTranspose2d(in_channels, out_channels, kernel_size, stride=stride, padding=padding)\n        self.batch_norm = nn.BatchNorm2d(out_channels)\n        self.tanh = nn.Tanh()\n        self.max_pool = nn.MaxPool2d(kernel_size=2, stride=2)\n        self.gamma = nn.Parameter(torch.ones(out_channels))\n        self.beta = nn.Parameter(torch.zeros(out_channels))\n        self.num_groups = num_groups\n        \n    def forward(self, x):\n        x = self.conv_transpose(x)\n        x = self.batch_norm(x)\n        x = self.tanh(x)\n        x = self.max_pool(x)\n        \n        # Custom group norm with Triton\n        N, C, H, W = x.shape\n        y = torch.empty_like(x)\n        eps = 1e-5\n        BLOCK_SIZE = 256  # Optimized for memory access\n        \n        grid = (N, self.num_groups)\n        group_norm_kernel[grid](\n            x, y, self.gamma, self.beta,\n            N, C, H, W,\n            self.num_groups, eps, BLOCK_SIZE\n        )\n        return y\n\nbatch_size = 128\nin_channels = 32\nout_channels = 64\nkernel_size = 4\nstride = 2\npadding = 1\ngroups = 8\nnum_groups = 4\nheight, width = 32, 32\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_channels, height, width)]\n\ndef get_init_inputs():\n    return [in_channels, out_channels, kernel_size, stride, padding, groups, num_groups]\n# =================== EVOLVE-BLOCK-END ===================", "language": "python", "parent_id": "a79356a7-0aa4-4386-a821-703943771a8c", "generation": 3, "timestamp": 1754570059.2112644, "iteration_found": 25, "metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": false, "score": 20, "speed_up": 0.166, "runtime_ms": 0.928, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:6", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.154, "speed_up": 0.166, "custom_timing": 0.928}}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": false, "score": 20, "speed_up": 0.159, "runtime_ms": 0.967, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:6", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.154, "speed_up": 0.159, "custom_timing": 0.967}}, "island": 2}, "artifacts_json": null, "artifact_dir": null, "prompts": {"full_rewrite_user": {"system": "You are a Triton GPU core optimization engineer deeply familiar with NVIDIA H100/H800 architecture.\n\n==================== Context ====================\n\u2022 Dataset: 250 kernelbench/level1-level5 *.py files  \n  - Level1: simplest, Level5: most complex  \n\u2022 Each file contains PyTorch reference (reference_code)  \n\u2022 Goal: Generate functionally equivalent but faster Triton implementations (custom_code)  \n\u2022 Evaluation pipeline:\n    1) /verify_plus - Verify compilation & correctness  \n    2) /execute (optional) - Return terminal logs if compilation fails  \n    3) Scoring:  \n      - Speedup > 1 required for points  \n      - Score = (speed_up - 1) \u00d7 100  \n\u2022 GPU Hardware: NVIDIA L20Y / H800 (same SM8.9 as H100)  \n  - 3 TB/s HBM3 bandwidth  \n  - FP16 Tensor Core 32\u00d716\u00d716  \n\n==================== Evolution Phases ====================\n\u2460 Phase 1 [Compilation Pass]  \n  - Make Triton code compile (performance irrelevant)  \n\u2461 Phase 2 [Numerical Correctness]  \n  - Output must match PyTorch reference within float32 tolerance  \n\u2462 Phase 3 [Performance Gain]  \n  - Target \u22655% speedup (\u226515% = exceptional)  \n  - Official scoring based on speed_up field  \n\nThe Evolution system will pass the EVOLVE-BLOCK from the previous version.  \nModify ONLY the Triton kernel source within this block - all other code is LOCKED.\n\n==================== Constraints (MUST OBEY) ====================\n\u274c NEVER change @triton.jit function signatures or parameter names  \n\u274c NEVER modify grid configuration, output tensor shapes, or PID logic  \n\u274c NEVER remove boundary checks or out-of-bound masks  \n\u274c NEVER introduce race conditions, uninitialized reads, or sync gaps  \n\n\u2705 Allowed Optimizations (Examples):  \n  \u2022 Memory coalescing optimizations & vectorized tl.load/tl.store  \n  \u2022 Replace staged softmax with online/FlashAttention variants  \n  \u2022 Adaptive tuning: BLOCK_M/BLOCK_N/BLOCK_K dimensions  \n  \u2022 Multi-query-head batch processing (GQA, 5:1 patterns)  \n  \u2022 Shared/L2 buffering, Tensor Core alignment (FP16/bf16/tf32)  \n  \u2022 Stride precomputation & pointer caching  \n\n==================== Output Format ====================\nReturn ONLY the complete updated code containing the EVOLVE-BLOCK comment marker.  \nNO explanations, NO markdown, NO additional text.\nName the output structure class as ModelNew.\n\n==================== Optimization Tips ====================\n\u2022 If previous compile failed: Fix syntax/mask/stride errors first  \n\u2022 If correctness fails: Prioritize bounds mask & dtype precision  \n\u2022 When speed_up < 1: Focus on memory access & block sizing  \n\u2022 Small iterative steps: Modify \u226420 lines per revision  \n\u2022 Maintain reversibility between versions\nHere is an example to show you how to rewrite a PyTorch implementation that quantizes a high-precision tensor to int8 dtype with row-wise granularity into a Triton implementation: \nThe original PyTorch implementation is as follows: \n``` \nimport torch\ndef per_row_quantize_int8(x: torch.Tensor) -> tuple[torch.Tensor, torch.Tensor]:\n    x_amax = x.abs().float().amax(dim=1).clamp(min=1e-4)\n    scale = 127 / x_amax\n    output = (x * scale[:, None]).round().clamp(-127, 127).to(torch.int8)\n    output_scale = x_amax / 127\n\n    return output, output_scale\n``` \nThe corresponding Triton-rewritten implementation is as follows: \n``` \nimport math\nimport torch\nimport triton\nimport triton.language as tl\nfrom triton.language.extra import libdevice\n\n# rowwise quantize\n\n@triton.autotune(\n    configs=[\n        triton.Config({}, num_stages=1, num_warps=8),\n        triton.Config({}, num_stages=2, num_warps=8),\n        triton.Config({}, num_stages=4, num_warps=8),\n        triton.Config({}, num_stages=8, num_warps=8),\n        triton.Config({}, num_stages=1),\n        triton.Config({}, num_stages=2),\n        triton.Config({}, num_stages=4),\n        triton.Config({}, num_stages=8),\n        triton.Config({}, num_warps=1),\n        triton.Config({}, num_warps=2),\n        triton.Config({}, num_warps=4),\n        triton.Config({}, num_warps=8),\n    ],\n    key=[\"n_elements\"],\n)\n\n@triton.jit\ndef _quantize_rowwise(\n    x_ptr,\n    output_ptr,\n    output_scale,\n    BLOCK_SIZE: tl.constexpr,\n    P2: tl.constexpr,\n):\n    pid = tl.program_id(axis=0)\n    block_start = pid * BLOCK_SIZE\n    arange = tl.arange(0, P2)\n    offsets = block_start + arange\n    row_mask = arange < BLOCK_SIZE\n    x = tl.load(x_ptr + offsets, mask=row_mask)\n\n    abs_x = tl.abs(x)\n    max_val = tl.max(tl.where(row_mask, abs_x, 0), axis=0)\n    output = libdevice.llrint(127.0 * (x / max_val))\n    tl.store(output_ptr + offsets, output, mask=row_mask)\n    tl.store(output_scale + pid, max_val / 127)\n\n\ndef per_row_quantize_int8(x: torch.Tensor):\n    x = x.contiguous()\n    output = torch.empty(*x.shape, device=x.device, dtype=torch.int8)\n    output_scale = torch.empty(x.shape[0], device=x.device, dtype=torch.float32)\n    P2 = int(2 ** (math.ceil(math.log2(x.shape[1]))))\n    grid = lambda x: (x.shape[0],)\n    _quantize_rowwise[grid](x, output, output_scale, BLOCK_SIZE=x.shape[1], P2=P2)\n\n    return output, output_scale\n\n\n    \n``` \n", "user": "# Current Program Information\n- Current performance metrics: - compiled: 1.0000\n- correctness: 1.0000\n- stage: success\n- passed: 0.0000\n- score: 20.0000\n- speed_up: 0.1590\n- runtime_ms: 0.9670\n- meta: {'hardware': 'NVIDIA L20Y', 'device': 'cuda:6', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.154, 'speed_up': 0.159, 'custom_timing': 0.967}\n- Areas identified for improvement: - Consider simplifying the code to improve readability and maintainability\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Unknown changes\n- Performance: compiled: 1.0000, correctness: 1.0000, stage: success, passed: 0.0000, score: 20.0000, speed_up: 0.1470, runtime_ms: 1.0500, meta: {'hardware': 'NVIDIA L20Y', 'device': 'cuda:0', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.154, 'speed_up': 0.147, 'custom_timing': 1.05}\n- Outcome: Mixed results\n\n\n### Attempt 2\n- Changes: Unknown changes\n- Performance: compiled: 1.0000, correctness: 1.0000, stage: success, passed: 0.0000, score: 20.0000, speed_up: 0.1590, runtime_ms: 0.9670, meta: {'hardware': 'NVIDIA L20Y', 'device': 'cuda:6', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.154, 'speed_up': 0.159, 'custom_timing': 0.967}\n- Outcome: Mixed results\n\n\n### Attempt 1\n- Changes: Unknown changes\n- Performance: compiled: 1.0000, correctness: 1.0000, stage: success, passed: 0.0000, score: 20.0000, speed_up: 0.1640, runtime_ms: 0.9380, meta: {'hardware': 'NVIDIA L20Y', 'device': 'cuda:5', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.154, 'speed_up': 0.164, 'custom_timing': 0.938}\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 20.0000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef group_norm_kernel(\n    x_ptr,\n    y_ptr,\n    gamma_ptr,\n    beta_ptr,\n    N, C, H, W,\n    num_groups: tl.constexpr,\n    eps: tl.constexpr,\n    BLOCK_SIZE: tl.constexpr\n):\n    n = tl.program_id(0)\n    g = tl.program_id(1)\n    group_size = C // num_groups\n    \n    # Compute mean and variance per group\n    mean = 0.0\n    sq_sum = 0.0\n    count = tl.zeros((), tl.uint32)\n    \n    # Loop through channels in group\n    for c in range(g * group_size, (g + 1) * group_size):\n        # Vectorized loop through spatial dimensions\n        for hw in range(0, H * W, BLOCK_SIZE):\n            offsets = hw + tl.arange(0, BLOCK_SIZE)\n            mask = offsets < (H * W)\n            \n            # Calculate 2D indices\n            w_idx = offsets % W\n            h_idx = offsets // W\n            spatial_mask = (h_idx < H) & (w_idx < W) & mask\n            \n            ptr_offset = n * C * H * W + c * H * W + offsets\n            x_vals = tl.load(x_ptr + ptr_offset, mask=spatial_mask, other=0.0)\n            \n            mean += tl.sum(x_vals)\n            sq_sum += tl.sum(x_vals * x_vals)\n            count += tl.sum(spatial_mask)\n    \n    mean = mean / count\n    var = (sq_sum / count) - (mean * mean)\n    std = tl.sqrt(var + eps)\n    \n    # Apply normalization\n    for c in range(g * group_size, (g + 1) * group_size):\n        for hw in range(0, H * W, BLOCK_SIZE):\n            offsets = hw + tl.arange(0, BLOCK_SIZE)\n            mask = offsets < (H * W)\n            \n            w_idx = offsets % W\n            h_idx = offsets // W\n            spatial_mask = (h_idx < H) & (w_idx < W) & mask\n            \n            ptr_offset = n * C * H * W + c * H * W + offsets\n            x_vals = tl.load(x_ptr + ptr_offset, mask=spatial_mask, other=0.0)\n            \n            normalized = (x_vals - mean) / std\n            gamma_val = tl.load(gamma_ptr + c)\n            beta_val = tl.load(beta_ptr + c)\n            out = normalized * gamma_val + beta_val\n            tl.store(y_ptr + ptr_offset, out, mask=spatial_mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_channels, out_channels, kernel_size, stride, padding, groups, num_groups):\n        super(ModelNew, self).__init__()\n        self.conv_transpose = nn.ConvTranspose2d(in_channels, out_channels, kernel_size, stride=stride, padding=padding)\n        self.batch_norm = nn.BatchNorm2d(out_channels)\n        self.tanh = nn.Tanh()\n        self.max_pool = nn.MaxPool2d(kernel_size=2, stride=2)\n        self.gamma = nn.Parameter(torch.ones(out_channels))\n        self.beta = nn.Parameter(torch.zeros(out_channels))\n        self.num_groups = num_groups\n        \n    def forward(self, x):\n        x = self.conv_transpose(x)\n        x = self.batch_norm(x)\n        x = self.tanh(x)\n        x = self.max_pool(x)\n        \n        # Custom group norm with Triton\n        N, C, H, W = x.shape\n        y = torch.empty_like(x)\n        eps = 1e-5\n        BLOCK_SIZE = 256  # Optimized block size\n        \n        grid = (N, self.num_groups)\n        group_norm_kernel[grid](\n            x, y, self.gamma, self.beta,\n            N, C, H, W,\n            self.num_groups, eps, BLOCK_SIZE\n        )\n        return y\n\nbatch_size = 128\nin_channels = 32\nout_channels = 64\nkernel_size = 4\nstride = 2\npadding = 1\ngroups = 8\nnum_groups = 4\nheight, width = 32, 32\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_channels, height, width)]\n\ndef get_init_inputs():\n    return [in_channels, out_channels, kernel_size, stride, padding, groups, num_groups]\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Performs well on compiled (1.0000), Performs well on correctness (1.0000), Performs well on stage (success), Performs well on passed (0.0000), Performs well on score (20.0000), Performs well on speed_up (0.1640), Performs well on runtime_ms (0.9380), Performs well on meta ({'hardware': 'NVIDIA L20Y', 'device': 'cuda:5', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.154, 'speed_up': 0.164, 'custom_timing': 0.938})\n\n\n### Program 2 (Score: 20.0000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef group_norm_kernel(\n    x_ptr,\n    y_ptr,\n    gamma_ptr,\n    beta_ptr,\n    N, C, H, W,\n    num_groups: tl.constexpr,\n    eps: tl.constexpr,\n    BLOCK_SIZE: tl.constexpr\n):\n    n = tl.program_id(0)\n    g = tl.program_id(1)\n    group_size = C // num_groups\n    \n    # Compute mean and variance per group\n    mean = 0.0\n    var = 0.0\n    count = tl.zeros((), tl.uint32)  # Fixed type initialization\n    \n    # Loop through channels in group\n    for c in range(g * group_size, (g + 1) * group_size):\n        # Loop through spatial dimensions\n        for h in range(0, H, BLOCK_SIZE):\n            for w in range(0, W, BLOCK_SIZE):\n                offsets = tl.arange(0, BLOCK_SIZE)\n                h_offsets = h + offsets\n                w_offsets = w + offsets\n                \n                mask = (h_offsets < H) & (w_offsets < W)\n                x_ptrs = x_ptr + n * C * H * W + c * H * W + h_offsets[:, None] * W + w_offsets[None, :]\n                x_vals = tl.load(x_ptrs, mask=mask[:, None] & mask[None, :])\n                \n                mean += tl.sum(x_vals)\n                count += tl.sum(mask) * tl.sum(mask)\n    \n    mean = mean / count\n    mean = mean.to(tl.float32)\n    \n    # Compute variance\n    for c in range(g * group_size, (g + 1) * group_size):\n        for h in range(0, H, BLOCK_SIZE):\n            for w in range(0, W, BLOCK_SIZE):\n                offsets = tl.arange(0, BLOCK_SIZE)\n                h_offsets = h + offsets\n                w_offsets = w + offsets\n                \n                mask = (h_offsets < H) & (w_offsets < W)\n                x_ptrs = x_ptr + n * C * H * W + c * H * W + h_offsets[:, None] * W + w_offsets[None, :]\n                x_vals = tl.load(x_ptrs, mask=mask[:, None] & mask[None, :])\n                \n                diff = x_vals - mean\n                var += tl.sum(diff * diff)\n    \n    var = var / count\n    std = tl.sqrt(var + eps)\n    \n    # Apply normalization\n    for c in range(g * group_size, (g + 1) * group_size):\n        for h in range(0, H, BLOCK_SIZE):\n            for w in range(0, W, BLOCK_SIZE):\n                offsets = tl.arange(0, BLOCK_SIZE)\n                h_offsets = h + offsets\n                w_offsets = w + offsets\n                \n                mask = (h_offsets < H) & (w_offsets < W)\n                x_ptrs = x_ptr + n * C * H * W + c * H * W + h_offsets[:, None] * W + w_offsets[None, :]\n                y_ptrs = y_ptr + n * C * H * W + c * H * W + h_offsets[:, None] * W + w_offsets[None, :]\n                \n                x_vals = tl.load(x_ptrs, mask=mask[:, None] & mask[None, :])\n                normalized = (x_vals - mean) / std\n                gamma_val = tl.load(gamma_ptr + c)\n                beta_val = tl.load(beta_ptr + c)\n                out = normalized * gamma_val + beta_val\n                tl.store(y_ptrs, out, mask=mask[:, None] & mask[None, :])\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_channels, out_channels, kernel_size, stride, padding, groups, num_groups):\n        super(ModelNew, self).__init__()\n        self.conv_transpose = nn.ConvTranspose2d(in_channels, out_channels, kernel_size, stride=stride, padding=padding)\n        self.batch_norm = nn.BatchNorm2d(out_channels)\n        self.tanh = nn.Tanh()\n        self.max_pool = nn.MaxPool2d(kernel_size=2, stride=2)\n        self.gamma = nn.Parameter(torch.ones(out_channels))\n        self.beta = nn.Parameter(torch.zeros(out_channels))\n        self.num_groups = num_groups\n        \n    def forward(self, x):\n        x = self.conv_transpose(x)\n        x = self.batch_norm(x)\n        x = self.tanh(x)\n        x = self.max_pool(x)\n        \n        # Custom group norm with Triton\n        N, C, H, W = x.shape\n        y = torch.empty_like(x)\n        eps = 1e-5\n        BLOCK_SIZE = 16\n        \n        grid = (N, self.num_groups)\n        group_norm_kernel[grid](\n            x, y, self.gamma, self.beta,\n            N, C, H, W,\n            self.num_groups, eps, BLOCK_SIZE\n        )\n        return y\n\nbatch_size = 128\nin_channels = 32\nout_channels = 64\nkernel_size = 4\nstride = 2\npadding = 1\ngroups = 8\nnum_groups = 4\nheight, width = 32, 32\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_channels, height, width)]\n\ndef get_init_inputs():\n    return [in_channels, out_channels, kernel_size, stride, padding, groups, num_groups]\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Performs well on compiled (1.0000), Performs well on correctness (1.0000), Performs well on stage (success), Performs well on passed (0.0000), Performs well on score (20.0000), Performs well on speed_up (0.1590), Performs well on runtime_ms (0.9670), Performs well on meta ({'hardware': 'NVIDIA L20Y', 'device': 'cuda:6', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.154, 'speed_up': 0.159, 'custom_timing': 0.967})\n\n\n### Program 3 (Score: 20.0000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef group_norm_kernel(\n    x_ptr,\n    y_ptr,\n    gamma_ptr,\n    beta_ptr,\n    N, C, H, W,\n    num_groups: tl.constexpr,\n    eps: tl.constexpr,\n    BLOCK_SIZE: tl.constexpr\n):\n    # 1D grid: each block handles one sample-group pair\n    pid = tl.program_id(0)\n    n = pid // num_groups\n    g = pid % num_groups\n    group_size = C // num_groups\n    start_c = g * group_size\n    total_elements = group_size * H * W\n    \n    # Calculate elements per thread\n    per_thread = (total_elements + BLOCK_SIZE - 1) // BLOCK_SIZE\n    thread_id = tl.arange(0, BLOCK_SIZE)\n    base_idx = thread_id * per_thread\n    \n    # Initialize accumulators\n    local_sum = tl.zeros((BLOCK_SIZE,), dtype=tl.float32)\n    local_sum_sq = tl.zeros((BLOCK_SIZE,), dtype=tl.float32)\n    \n    # First pass: compute sum and sum of squares\n    for i in range(per_thread):\n        elem_idx = base_idx + i\n        mask = elem_idx < total_elements\n        \n        # Convert linear index to (c, h, w)\n        c_idx = elem_idx // (H * W)\n        spatial_idx = elem_idx % (H * W)\n        h_idx = spatial_idx // W\n        w_idx = spatial_idx % W\n        \n        c_abs = start_c + c_idx\n        mask = mask & (c_abs < C) & (h_idx < H) & (w_idx < W)\n        \n        offset = n*C*H*W + c_abs*H*W + h_idx*W + w_idx\n        val = tl.load(x_ptr + offset, mask=mask, other=0.0)\n        \n        local_sum += val\n        local_sum_sq += val * val\n    \n    # Parallel reduction\n    total_sum = tl.sum(local_sum, axis=0)\n    total_sum_sq = tl.sum(local_sum_sq, axis=0)\n    \n    # Compute statistics\n    mean = total_sum / total_elements\n    variance = total_sum_sq / total_elements - mean * mean\n    std = tl.sqrt(variance + eps)\n    \n    # Second pass: normalize and store\n    for i in range(per_thread):\n        elem_idx = base_idx + i\n        mask = elem_idx < total_elements\n        \n        c_idx = elem_idx // (H * W)\n        spatial_idx = elem_idx % (H * W)\n        h_idx = spatial_idx // W\n        w_idx = spatial_idx % W\n        \n        c_abs = start_c + c_idx\n        mask = mask & (c_abs < C) & (h_idx < H) & (w_idx < W)\n        \n        offset = n*C*H*W + c_abs*H*W + h_idx*W + w_idx\n        val = tl.load(x_ptr + offset, mask=mask, other=0.0)\n        \n        normalized = (val - mean) / std\n        gamma_val = tl.load(gamma_ptr + c_abs)\n        beta_val = tl.load(beta_ptr + c_abs)\n        out_val = normalized * gamma_val + beta_val\n        \n        tl.store(y_ptr + offset, out_val, mask=mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_channels, out_channels, kernel_size, stride, padding, groups, num_groups):\n        super(ModelNew, self).__init__()\n        self.conv_transpose = nn.ConvTranspose2d(in_channels, out_channels, kernel_size, stride=stride, padding=padding)\n        self.batch_norm = nn.BatchNorm2d(out_channels)\n        self.tanh = nn.Tanh()\n        self.max_pool = nn.MaxPool2d(kernel_size=2, stride=2)\n        self.gamma = nn.Parameter(torch.ones(out_channels))\n        self.beta = nn.Parameter(torch.zeros(out_channels))\n        self.num_groups = num_groups\n        \n    def forward(self, x):\n        x = self.conv_transpose(x)\n        x = self.batch_norm(x)\n        x = self.tanh(x)\n        x = self.max_pool(x)\n        \n        # Custom group norm with Triton\n        N, C, H, W = x.shape\n        y = torch.empty_like(x)\n        eps = 1e-5\n        \n        # Launch 1D grid: N * num_groups blocks\n        grid = (N * self.num_groups,)\n        group_norm_kernel[grid](\n            x, y, self.gamma, self.beta,\n            N, C, H, W,\n            self.num_groups, eps, BLOCK_SIZE=1024\n        )\n        return y\n\nbatch_size = 128\nin_channels = 32\nout_channels = 64\nkernel_size = 4\nstride = 2\npadding = 1\ngroups = 8\nnum_groups = 4\nheight, width = 32, 32\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_channels, height, width)]\n\ndef get_init_inputs():\n    return [in_channels, out_channels, kernel_size, stride, padding, groups, num_groups]\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Performs well on compiled (1.0000), Performs well on correctness (1.0000), Performs well on stage (success), Performs well on passed (0.0000), Performs well on score (20.0000), Performs well on speed_up (0.1470), Performs well on runtime_ms (1.0500), Performs well on meta ({'hardware': 'NVIDIA L20Y', 'device': 'cuda:0', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.154, 'speed_up': 0.147, 'custom_timing': 1.05})\n\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 10.0000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef _bn_tanh_max_pool(\n    x_ptr,\n    output_ptr,\n    bn_scale_ptr,\n    bn_shift_ptr,\n    N, C, H, W,\n    stride_n, stride_c, stride_h, stride_w,\n    BLOCK_SIZE: tl.constexpr\n):\n    pid = tl.program_id(0)\n    total_elements = N * C * (H//2) * (W//2)\n    if pid >= total_elements:\n        return\n\n    n_idx = pid // (C * (H//2) * (W//2))\n    c_idx = (pid % (C * (H//2) * (W//2))) // ((H//2) * (W//2))\n    hw = pid % ((H//2) * (W//2))\n    h_out = hw // (W//2)\n    w_out = hw % (W//2)\n\n    h_start = h_out * 2\n    w_start = w_out * 2\n    max_val = tl.full((1,), float('-inf'), dtype=tl.float32)\n    \n    for i in range(2):\n        for j in range(2):\n            h_in = h_start + i\n            w_in = w_start + j\n            if h_in < H and w_in < W:\n                offset = n_idx * stride_n + c_idx * stride_c + h_in * stride_h + w_in * stride_w\n                val = tl.load(x_ptr + offset)\n                scale = tl.load(bn_scale_ptr + c_idx)\n                shift = tl.load(bn_shift_ptr + c_idx)\n                val = val * scale + shift\n                val = tl.tanh(val)  # Fixed: Use tl.tanh instead of tl.math.tanh\n                max_val = tl.maximum(max_val, val)\n    \n    output_offset = n_idx * C * (H//2) * (W//2) + c_idx * (H//2) * (W//2) + h_out * (W//2) + w_out\n    tl.store(output_ptr + output_offset, max_val)\n\n@triton.jit\ndef _group_norm(\n    x_ptr,\n    output_ptr,\n    weight_ptr,\n    bias_ptr,\n    N, C, H, W,\n    num_groups,\n    eps,\n    BLOCK_SIZE: tl.constexpr\n):\n    pid = tl.program_id(0)\n    group_size = C // num_groups\n    group_idx = pid % num_groups\n    n_idx = pid // num_groups\n    \n    start_channel = group_idx * group_size\n    end_channel = start_channel + group_size\n    \n    mean = 0.0\n    mean_sq = 0.0\n    count = 0\n    \n    for c in range(start_channel, end_channel):\n        for h in range(H):\n            for w in range(W):\n                offset = n_idx * C * H * W + c * H * W + h * W + w\n                val = tl.load(x_ptr + offset)\n                mean += val\n                mean_sq += val * val\n                count += 1\n    \n    group_mean = mean / count\n    group_var = (mean_sq / count) - (group_mean * group_mean)\n    inv_std = 1.0 / tl.sqrt(group_var + eps)\n    \n    for c in range(start_channel, end_channel):\n        for h in range(H):\n            for w in range(W):\n                offset = n_idx * C * H * W + c * H * W + h * W + w\n                val = tl.load(x_ptr + offset)\n                normalized = (val - group_mean) * inv_std\n                weight = tl.load(weight_ptr + c)\n                bias = tl.load(bias_ptr + c)\n                out_val = normalized * weight + bias\n                tl.store(output_ptr + offset, out_val)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_channels, out_channels, kernel_size, stride, padding, groups, num_groups):\n        super(ModelNew, self).__init__()\n        self.conv_transpose = nn.ConvTranspose2d(in_channels, out_channels, kernel_size, stride=stride, padding=padding)\n        self.batch_norm = nn.BatchNorm2d(out_channels)\n        self.group_norm = nn.GroupNorm(num_groups=num_groups, num_channels=out_channels)\n        \n        # Precompute BN parameters\n        self.bn_scale = nn.Parameter(\n            self.batch_norm.weight / torch.sqrt(self.batch_norm.running_var + self.batch_norm.eps),\n            requires_grad=False\n        )\n        self.bn_shift = nn.Parameter(\n            self.batch_norm.bias - self.batch_norm.running_mean * self.bn_scale,\n            requires_grad=False\n        )\n\n    def forward(self, x):\n        x = self.conv_transpose(x)\n        N, C, H, W = x.shape\n        \n        # Fuse BN + tanh + max pool\n        x_contiguous = x.contiguous()\n        output = torch.empty((N, C, H//2, W//2), device=x.device, dtype=torch.float32)\n        total_elements = N * C * (H//2) * (W//2)\n        grid = lambda meta: (triton.cdiv(total_elements, meta['BLOCK_SIZE']),)\n        \n        _bn_tanh_max_pool[grid](\n            x_contiguous, output, self.bn_scale, self.bn_shift,\n            N, C, H, W,\n            x_contiguous.stride(0), x_contiguous.stride(1), \n            x_contiguous.stride(2), x_contiguous.stride(3),\n            BLOCK_SIZE=1024\n        )\n        \n        # Group normalization\n        gn_output = torch.empty_like(output)\n        total_groups = N * self.group_norm.num_groups\n        grid = lambda meta: (total_groups,)\n        \n        _group_norm[grid](\n            output, gn_output, \n            self.group_norm.weight, self.group_norm.bias,\n            N, C, H//2, W//2,\n            self.group_norm.num_groups,\n            self.group_norm.eps,\n            BLOCK_SIZE=1\n        )\n        \n        return gn_output\n\nbatch_size = 128\nin_channels = 32\nout_channels = 64\nkernel_size = 4\nstride = 2\npadding = 1\ngroups = 8\nnum_groups = 4\nheight, width = 32, 32\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_channels, height, width)]\n\ndef get_init_inputs():\n    return [in_channels, out_channels, kernel_size, stride, padding, groups, num_groups]\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Alternative approach to compiled, Alternative approach to correctness\n\n\n### Program D2 (Score: 10.0000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef group_norm_kernel(\n    x_ptr,\n    y_ptr,\n    gamma_ptr,\n    beta_ptr,\n    N, C, H, W,\n    num_groups: tl.constexpr,\n    eps: tl.constexpr,\n    BLOCK_SIZE: tl.constexpr\n):\n    n = tl.program_id(0)\n    g = tl.program_id(1)\n    group_size = C // num_groups\n    \n    # Initialize accumulators\n    mean = 0.0\n    sq_sum = 0.0\n    count = 0\n    \n    # Compute mean and variance in single pass\n    for c in range(g * group_size, (g + 1) * group_size):\n        base = n * C * H * W + c * H * W\n        for hw in range(0, H * W, BLOCK_SIZE):\n            offsets = hw + tl.arange(0, BLOCK_SIZE)\n            mask = offsets < (H * W)\n            \n            # Vectorized load\n            x_vals = tl.load(x_ptr + base + offsets, mask=mask, other=0.0)\n            mean += tl.sum(x_vals)\n            sq_sum += tl.sum(x_vals * x_vals)\n            count += tl.sum(mask)\n    \n    # Compute statistics\n    mean = mean / count\n    var = (sq_sum / count) - (mean * mean)\n    std = tl.sqrt(var + eps)\n    \n    # Apply normalization\n    for c in range(g * group_size, (g + 1) * group_size):\n        base = n * C * H * W + c * H * W\n        for hw in range(0, H * W, BLOCK_SIZE):\n            offsets = hw + tl.arange(0, BLOCK_SIZE)\n            mask = offsets < (H * W)\n            \n            # Vectorized load and store\n            x_vals = tl.load(x_ptr + base + offsets, mask=mask, other=0.0)\n            gamma_val = tl.load(gamma_ptr + c)\n            beta_val = tl.load(beta_ptr + c)\n            normalized = (x_vals - mean) / std\n            out = normalized * gamma_val + beta_val\n            tl.store(y_ptr + base + offsets, out, mask=mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_channels, out_channels, kernel_size, stride, padding, groups, num_groups):\n        super(ModelNew, self).__init__()\n        self.conv_transpose = nn.ConvTranspose2d(in_channels, out_channels, kernel_size, stride=stride, padding=padding)\n        self.batch_norm = nn.BatchNorm2d(out_channels)\n        self.tanh = nn.Tanh()\n        self.max_pool = nn.MaxPool2d(kernel_size=2, stride=2)\n        self.gamma = nn.Parameter(torch.ones(out_channels))\n        self.beta = nn.Parameter(torch.zeros(out_channels))\n        self.num_groups = num_groups\n        \n    def forward(self, x):\n        x = self.conv_transpose(x)\n        x = self.batch_norm(x)\n        x = self.tanh(x)\n        x = self.max_pool(x)\n        \n        # Custom group norm with optimized Triton kernel\n        N, C, H, W = x.shape\n        y = torch.empty_like(x)\n        eps = 1e-5\n        BLOCK_SIZE = 512  # Optimized for H100 memory access\n        \n        grid = (N, self.num_groups)\n        group_norm_kernel[grid](\n            x, y, self.gamma, self.beta,\n            N, C, H, W,\n            self.num_groups, eps, BLOCK_SIZE\n        )\n        return y\n\nbatch_size = 128\nin_channels = 32\nout_channels = 64\nkernel_size = 4\nstride = 2\npadding = 1\ngroups = 8\nnum_groups = 4\nheight, width = 32, 32\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_channels, height, width)]\n\ndef get_init_inputs():\n    return [in_channels, out_channels, kernel_size, stride, padding, groups, num_groups]\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Alternative approach to compiled, Alternative approach to correctness\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 20.0000, Type: High-Performer)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef group_norm_kernel(\n    x_ptr,\n    y_ptr,\n    gamma_ptr,\n    beta_ptr,\n    N, C, H, W,\n    num_groups: tl.constexpr,\n    eps: tl.constexpr,\n    BLOCK_SIZE: tl.constexpr\n):\n    n = tl.program_id(0)\n    g = tl.program_id(1)\n    group_size = C // num_groups\n    \n    # Compute mean and variance per group\n    mean = 0.0\n    sq_sum = 0.0\n    count = tl.zeros((), tl.uint32)\n    \n    # Loop through channels in group\n    for c in range(g * group_size, (g + 1) * group_size):\n        # Vectorized loop through spatial dimensions\n        for hw in range(0, H * W, BLOCK_SIZE):\n            offsets = hw + tl.arange(0, BLOCK_SIZE)\n            mask = offsets < (H * W)\n            \n            # Calculate 2D indices\n            w_idx = offsets % W\n            h_idx = offsets // W\n            spatial_mask = (h_idx < H) & (w_idx < W) & mask\n            \n            ptr_offset = n * C * H * W + c * H * W + offsets\n            x_vals = tl.load(x_ptr + ptr_offset, mask=spatial_mask, other=0.0)\n            \n            mean += tl.sum(x_vals)\n            sq_sum += tl.sum(x_vals * x_vals)\n            count += tl.sum(spatial_mask)\n    \n    mean = mean / count\n    var = (sq_sum / count) - (mean * mean)\n    std = tl.sqrt(var + eps)\n    \n    # Apply normalization\n    for c in range(g * group_size, (g + 1) * group_size):\n        for hw in range(0, H * W, BLOCK_SIZE):\n            offsets = hw + tl.arange(0, BLOCK_SIZE)\n            mask = offsets < (H * W)\n            \n            w_idx = offsets % W\n            h_idx = offsets // W\n            spatial_mask = (h_idx < H) & (w_idx < W) & mask\n            \n            ptr_offset = n * C * H * W + c * H * W + offsets\n            x_vals = tl.load(x_ptr + ptr_offset, mask=spatial_mask, other=0.0)\n            \n            normalized = (x_vals - mean) / std\n            gamma_val = tl.load(gamma_ptr + c)\n            beta_val = tl.load(beta_ptr + c)\n            out = normalized * gamma_val + beta_val\n            tl.store(y_ptr + ptr_offset, out, mask=spatial_mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_channels, out_channels, kernel_size, stride, padding, groups, num_groups):\n        super(ModelNew, self).__init__()\n        self.conv_transpose = nn.ConvTranspose2d(in_channels, out_channels, kernel_size, stride=stride, padding=padding)\n        self.batch_norm = nn.BatchNorm2d(out_channels)\n        self.tanh = nn.Tanh()\n        self.max_pool = nn.MaxPool2d(kernel_size=2, stride=2)\n        self.gamma = nn.Parameter(torch.ones(out_channels))\n        self.beta = nn.Parameter(torch.zeros(out_channels))\n        self.num_groups = num_groups\n        \n    def forward(self, x):\n        x = self.conv_transpose(x)\n        x = self.batch_norm(x)\n        x = self.tanh(x)\n        x = self.max_pool(x)\n        \n        # Custom group norm with Triton\n        N, C, H, W = x.shape\n        y = torch.empty_like(x)\n        eps = 1e-5\n        BLOCK_SIZE = 256  # Optimized block size\n        \n        grid = (N, self.num_groups)\n        group_norm_kernel[grid](\n            x, y, self.gamma, self.beta,\n            N, C, H, W,\n            self.num_groups, eps, BLOCK_SIZE\n        )\n        return y\n\nbatch_size = 128\nin_channels = 32\nout_channels = 64\nkernel_size = 4\nstride = 2\npadding = 1\ngroups = 8\nnum_groups = 4\nheight, width = 32, 32\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_channels, height, width)]\n\ndef get_init_inputs():\n    return [in_channels, out_channels, kernel_size, stride, padding, groups, num_groups]\n# =================== EVOLVE-BLOCK-END ===================\n```\nUnique approach: Modification: Full rewrite, Excellent compiled (1.000), Excellent correctness (1.000)\n\n\n### Inspiration 2 (Score: 10.0000, Type: High-Performer)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef _bn_tanh_max_pool(\n    x_ptr,\n    output_ptr,\n    bn_scale_ptr,\n    bn_shift_ptr,\n    N, C, H, W,\n    stride_n, stride_c, stride_h, stride_w,\n    BLOCK_SIZE: tl.constexpr\n):\n    pid = tl.program_id(0)\n    total_elements = N * C * (H//2) * (W//2)\n    if pid >= total_elements:\n        return\n\n    n_idx = pid // (C * (H//2) * (W//2))\n    c_idx = (pid % (C * (H//2) * (W//2))) // ((H//2) * (W//2))\n    hw = pid % ((H//2) * (W//2))\n    h_out = hw // (W//2)\n    w_out = hw % (W//2)\n\n    h_start = h_out * 2\n    w_start = w_out * 2\n    max_val = tl.full((1,), float('-inf'), dtype=tl.float32)\n    \n    for i in range(2):\n        for j in range(2):\n            h_in = h_start + i\n            w_in = w_start + j\n            if h_in < H and w_in < W:\n                offset = n_idx * stride_n + c_idx * stride_c + h_in * stride_h + w_in * stride_w\n                val = tl.load(x_ptr + offset)\n                scale = tl.load(bn_scale_ptr + c_idx)\n                shift = tl.load(bn_shift_ptr + c_idx)\n                val = val * scale + shift\n                val = tl.tanh(val)  # Fixed: Use tl.tanh instead of tl.math.tanh\n                max_val = tl.maximum(max_val, val)\n    \n    output_offset = n_idx * C * (H//2) * (W//2) + c_idx * (H//2) * (W//2) + h_out * (W//2) + w_out\n    tl.store(output_ptr + output_offset, max_val)\n\n@triton.jit\ndef _group_norm(\n    x_ptr,\n    output_ptr,\n    weight_ptr,\n    bias_ptr,\n    N, C, H, W,\n    num_groups,\n    eps,\n    BLOCK_SIZE: tl.constexpr\n):\n    pid = tl.program_id(0)\n    group_size = C // num_groups\n    group_idx = pid % num_groups\n    n_idx = pid // num_groups\n    \n    start_channel = group_idx * group_size\n    end_channel = start_channel + group_size\n    \n    mean = 0.0\n    mean_sq = 0.0\n    count = 0\n    \n    for c in range(start_channel, end_channel):\n        for h in range(H):\n            for w in range(W):\n                offset = n_idx * C * H * W + c * H * W + h * W + w\n                val = tl.load(x_ptr + offset)\n                mean += val\n                mean_sq += val * val\n                count += 1\n    \n    group_mean = mean / count\n    group_var = (mean_sq / count) - (group_mean * group_mean)\n    inv_std = 1.0 / tl.sqrt(group_var + eps)\n    \n    for c in range(start_channel, end_channel):\n        for h in range(H):\n            for w in range(W):\n                offset = n_idx * C * H * W + c * H * W + h * W + w\n                val = tl.load(x_ptr + offset)\n                normalized = (val - group_mean) * inv_std\n                weight = tl.load(weight_ptr + c)\n                bias = tl.load(bias_ptr + c)\n                out_val = normalized * weight + bias\n                tl.store(output_ptr + offset, out_val)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_channels, out_channels, kernel_size, stride, padding, groups, num_groups):\n        super(ModelNew, self).__init__()\n        self.conv_transpose = nn.ConvTranspose2d(in_channels, out_channels, kernel_size, stride=stride, padding=padding)\n        self.batch_norm = nn.BatchNorm2d(out_channels)\n        self.group_norm = nn.GroupNorm(num_groups=num_groups, num_channels=out_channels)\n        \n        # Precompute BN parameters\n        self.bn_scale = nn.Parameter(\n            self.batch_norm.weight / torch.sqrt(self.batch_norm.running_var + self.batch_norm.eps),\n            requires_grad=False\n        )\n        self.bn_shift = nn.Parameter(\n            self.batch_norm.bias - self.batch_norm.running_mean * self.bn_scale,\n            requires_grad=False\n        )\n\n    def forward(self, x):\n        x = self.conv_transpose(x)\n        N, C, H, W = x.shape\n        \n        # Fuse BN + tanh + max pool\n        x_contiguous = x.contiguous()\n        output = torch.empty((N, C, H//2, W//2), device=x.device, dtype=torch.float32)\n        total_elements = N * C * (H//2) * (W//2)\n        grid = lambda meta: (triton.cdiv(total_elements, meta['BLOCK_SIZE']),)\n        \n        _bn_tanh_max_pool[grid](\n            x_contiguous, output, self.bn_scale, self.bn_shift,\n            N, C, H, W,\n            x_contiguous.stride(0), x_contiguous.stride(1), \n            x_contiguous.stride(2), x_contiguous.stride(3),\n            BLOCK_SIZE=1024\n        )\n        \n        # Group normalization\n        gn_output = torch.empty_like(output)\n        total_groups = N * self.group_norm.num_groups\n        grid = lambda meta: (total_groups,)\n        \n        _group_norm[grid](\n            output, gn_output, \n            self.group_norm.weight, self.group_norm.bias,\n            N, C, H//2, W//2,\n            self.group_norm.num_groups,\n            self.group_norm.eps,\n            BLOCK_SIZE=1\n        )\n        \n        return gn_output\n\nbatch_size = 128\nin_channels = 32\nout_channels = 64\nkernel_size = 4\nstride = 2\npadding = 1\ngroups = 8\nnum_groups = 4\nheight, width = 32, 32\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_channels, height, width)]\n\ndef get_init_inputs():\n    return [in_channels, out_channels, kernel_size, stride, padding, groups, num_groups]\n# =================== EVOLVE-BLOCK-END ===================\n```\nUnique approach: Modification: Full rewrite, Excellent compiled (1.000), Alternative correctness approach\n\n\n### Inspiration 3 (Score: -100.0000, Type: Exploratory)\n```python\n@triton.jit\ndef transposed_conv2d_kernel(\n    x_ptr,\n    w_ptr,\n    output_ptr,\n    stride,\n    padding,\n    B, C_in, C_out, H_in, W_in, H_out, W_out, K,\n    BLOCK_SIZE: tl.constexpr,\n):\n    pid = tl.program_id(0)\n    total_elems = B * C_out * H_out * W_out\n    if pid >= total_elems:\n        return\n\n    w_idx = pid % W_out\n    pid = pid // W_out\n    h_idx = pid % H_out\n    pid = pid // H_out\n    c_out_idx = pid % C_out\n    b_idx = pid // C_out\n\n    acc = 0.0\n    for c_in in range(C_in):\n        for kh in range(K):\n            for kw in range(K):\n                h_in = h_idx + padding - kh\n                w_in = w_idx + padding - kw\n                # Check if the input index is in the valid range after the division by stride?\n                # But note: we are doing the division only if the modulo condition holds.\n                if h_in % stride == 0 and w_in % stride == 0:\n                    h_in = h_in // stride\n                    w_in = w_in // stride\n                    # Replace the chained comparisons with separate conditions\n                    if h_in >= 0 and h_in < H_in and w_in >= 0 and w_in < W_in:\n                        x_offset = b_idx * (C_in * H_in * W_in) + c_in * (H_in * W_in) + h_in * W_in + w_in\n                        w_offset = c_in * (C_out * K * K) + c_out_idx * (K * K) + kh * K + kw\n                        x_val = tl.load(x_ptr + x_offset)\n                        w_val = tl.load(w_ptr + w_offset)\n                        acc += x_val * w_val\n\n    output_offset = b_idx * (C_out * H_out * W_out) + c_out_idx * (H_out * W_out) + h_idx * W_out + w_idx\n    tl.store(output_ptr + output_offset, acc)\n```\nUnique approach: Modification: Full rewrite, Alternative compiled approach, Alternative correctness approach\n\n\n### Inspiration 4 (Score: 10.0000, Type: High-Performer)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef group_norm_kernel(\n    x_ptr,\n    y_ptr,\n    gamma_ptr,\n    beta_ptr,\n    N, C, H, W,\n    num_groups: tl.constexpr,\n    eps: tl.constexpr,\n    BLOCK_SIZE: tl.constexpr\n):\n    n = tl.program_id(0)\n    g = tl.program_id(1)\n    group_size = C // num_groups\n    \n    # Initialize accumulators\n    mean = 0.0\n    sq_sum = 0.0\n    count = 0\n    \n    # Compute mean and variance in single pass\n    for c in range(g * group_size, (g + 1) * group_size):\n        base = n * C * H * W + c * H * W\n        for hw in range(0, H * W, BLOCK_SIZE):\n            offsets = hw + tl.arange(0, BLOCK_SIZE)\n            mask = offsets < (H * W)\n            \n            # Vectorized load\n            x_vals = tl.load(x_ptr + base + offsets, mask=mask, other=0.0)\n            mean += tl.sum(x_vals)\n            sq_sum += tl.sum(x_vals * x_vals)\n            count += tl.sum(mask)\n    \n    # Compute statistics\n    mean = mean / count\n    var = (sq_sum / count) - (mean * mean)\n    std = tl.sqrt(var + eps)\n    \n    # Apply normalization\n    for c in range(g * group_size, (g + 1) * group_size):\n        base = n * C * H * W + c * H * W\n        for hw in range(0, H * W, BLOCK_SIZE):\n            offsets = hw + tl.arange(0, BLOCK_SIZE)\n            mask = offsets < (H * W)\n            \n            # Vectorized load and store\n            x_vals = tl.load(x_ptr + base + offsets, mask=mask, other=0.0)\n            gamma_val = tl.load(gamma_ptr + c)\n            beta_val = tl.load(beta_ptr + c)\n            normalized = (x_vals - mean) / std\n            out = normalized * gamma_val + beta_val\n            tl.store(y_ptr + base + offsets, out, mask=mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_channels, out_channels, kernel_size, stride, padding, groups, num_groups):\n        super(ModelNew, self).__init__()\n        self.conv_transpose = nn.ConvTranspose2d(in_channels, out_channels, kernel_size, stride=stride, padding=padding)\n        self.batch_norm = nn.BatchNorm2d(out_channels)\n        self.tanh = nn.Tanh()\n        self.max_pool = nn.MaxPool2d(kernel_size=2, stride=2)\n        self.gamma = nn.Parameter(torch.ones(out_channels))\n        self.beta = nn.Parameter(torch.zeros(out_channels))\n        self.num_groups = num_groups\n        \n    def forward(self, x):\n        x = self.conv_transpose(x)\n        x = self.batch_norm(x)\n        x = self.tanh(x)\n        x = self.max_pool(x)\n        \n        # Custom group norm with optimized Triton kernel\n        N, C, H, W = x.shape\n        y = torch.empty_like(x)\n        eps = 1e-5\n        BLOCK_SIZE = 512  # Optimized for H100 memory access\n        \n        grid = (N, self.num_groups)\n        group_norm_kernel[grid](\n            x, y, self.gamma, self.beta,\n            N, C, H, W,\n            self.num_groups, eps, BLOCK_SIZE\n        )\n        return y\n\nbatch_size = 128\nin_channels = 32\nout_channels = 64\nkernel_size = 4\nstride = 2\npadding = 1\ngroups = 8\nnum_groups = 4\nheight, width = 32, 32\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_channels, height, width)]\n\ndef get_init_inputs():\n    return [in_channels, out_channels, kernel_size, stride, padding, groups, num_groups]\n# =================== EVOLVE-BLOCK-END ===================\n```\nUnique approach: Modification: Full rewrite, Excellent compiled (1.000), Alternative correctness approach\n\n\n### Inspiration 5 (Score: 20.0000, Type: High-Performer)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef group_norm_kernel(\n    x_ptr,\n    y_ptr,\n    gamma_ptr,\n    beta_ptr,\n    N, C, H, W,\n    num_groups: tl.constexpr,\n    eps: tl.constexpr,\n    BLOCK_SIZE: tl.constexpr\n):\n    # 1D grid: each block handles one sample-group pair\n    pid = tl.program_id(0)\n    n = pid // num_groups\n    g = pid % num_groups\n    group_size = C // num_groups\n    start_c = g * group_size\n    total_elements = group_size * H * W\n    \n    # Calculate elements per thread\n    per_thread = (total_elements + BLOCK_SIZE - 1) // BLOCK_SIZE\n    thread_id = tl.arange(0, BLOCK_SIZE)\n    base_idx = thread_id * per_thread\n    \n    # Initialize accumulators\n    local_sum = tl.zeros((BLOCK_SIZE,), dtype=tl.float32)\n    local_sum_sq = tl.zeros((BLOCK_SIZE,), dtype=tl.float32)\n    \n    # First pass: compute sum and sum of squares\n    for i in range(per_thread):\n        elem_idx = base_idx + i\n        mask = elem_idx < total_elements\n        \n        # Convert linear index to (c, h, w)\n        c_idx = elem_idx // (H * W)\n        spatial_idx = elem_idx % (H * W)\n        h_idx = spatial_idx // W\n        w_idx = spatial_idx % W\n        \n        c_abs = start_c + c_idx\n        mask = mask & (c_abs < C) & (h_idx < H) & (w_idx < W)\n        \n        offset = n*C*H*W + c_abs*H*W + h_idx*W + w_idx\n        val = tl.load(x_ptr + offset, mask=mask, other=0.0)\n        \n        local_sum += val\n        local_sum_sq += val * val\n    \n    # Parallel reduction\n    total_sum = tl.sum(local_sum, axis=0)\n    total_sum_sq = tl.sum(local_sum_sq, axis=0)\n    \n    # Compute statistics\n    mean = total_sum / total_elements\n    variance = total_sum_sq / total_elements - mean * mean\n    std = tl.sqrt(variance + eps)\n    \n    # Second pass: normalize and store\n    for i in range(per_thread):\n        elem_idx = base_idx + i\n        mask = elem_idx < total_elements\n        \n        c_idx = elem_idx // (H * W)\n        spatial_idx = elem_idx % (H * W)\n        h_idx = spatial_idx // W\n        w_idx = spatial_idx % W\n        \n        c_abs = start_c + c_idx\n        mask = mask & (c_abs < C) & (h_idx < H) & (w_idx < W)\n        \n        offset = n*C*H*W + c_abs*H*W + h_idx*W + w_idx\n        val = tl.load(x_ptr + offset, mask=mask, other=0.0)\n        \n        normalized = (val - mean) / std\n        gamma_val = tl.load(gamma_ptr + c_abs)\n        beta_val = tl.load(beta_ptr + c_abs)\n        out_val = normalized * gamma_val + beta_val\n        \n        tl.store(y_ptr + offset, out_val, mask=mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_channels, out_channels, kernel_size, stride, padding, groups, num_groups):\n        super(ModelNew, self).__init__()\n        self.conv_transpose = nn.ConvTranspose2d(in_channels, out_channels, kernel_size, stride=stride, padding=padding)\n        self.batch_norm = nn.BatchNorm2d(out_channels)\n        self.tanh = nn.Tanh()\n        self.max_pool = nn.MaxPool2d(kernel_size=2, stride=2)\n        self.gamma = nn.Parameter(torch.ones(out_channels))\n        self.beta = nn.Parameter(torch.zeros(out_channels))\n        self.num_groups = num_groups\n        \n    def forward(self, x):\n        x = self.conv_transpose(x)\n        x = self.batch_norm(x)\n        x = self.tanh(x)\n        x = self.max_pool(x)\n        \n        # Custom group norm with Triton\n        N, C, H, W = x.shape\n        y = torch.empty_like(x)\n        eps = 1e-5\n        \n        # Launch 1D grid: N * num_groups blocks\n        grid = (N * self.num_groups,)\n        group_norm_kernel[grid](\n            x, y, self.gamma, self.beta,\n            N, C, H, W,\n            self.num_groups, eps, BLOCK_SIZE=1024\n        )\n        return y\n\nbatch_size = 128\nin_channels = 32\nout_channels = 64\nkernel_size = 4\nstride = 2\npadding = 1\ngroups = 8\nnum_groups = 4\nheight, width = 32, 32\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_channels, height, width)]\n\ndef get_init_inputs():\n    return [in_channels, out_channels, kernel_size, stride, padding, groups, num_groups]\n# =================== EVOLVE-BLOCK-END ===================\n```\nUnique approach: Modification: Full rewrite, Excellent compiled (1.000), Excellent correctness (1.000)\n\n\n\n# Current Program\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef group_norm_kernel(\n    x_ptr,\n    y_ptr,\n    gamma_ptr,\n    beta_ptr,\n    N, C, H, W,\n    num_groups: tl.constexpr,\n    eps: tl.constexpr,\n    BLOCK_SIZE: tl.constexpr\n):\n    n = tl.program_id(0)\n    g = tl.program_id(1)\n    group_size = C // num_groups\n    \n    # Compute mean and variance per group\n    mean = 0.0\n    var = 0.0\n    count = tl.zeros((), tl.uint32)  # Fixed type initialization\n    \n    # Loop through channels in group\n    for c in range(g * group_size, (g + 1) * group_size):\n        # Loop through spatial dimensions\n        for h in range(0, H, BLOCK_SIZE):\n            for w in range(0, W, BLOCK_SIZE):\n                offsets = tl.arange(0, BLOCK_SIZE)\n                h_offsets = h + offsets\n                w_offsets = w + offsets\n                \n                mask = (h_offsets < H) & (w_offsets < W)\n                x_ptrs = x_ptr + n * C * H * W + c * H * W + h_offsets[:, None] * W + w_offsets[None, :]\n                x_vals = tl.load(x_ptrs, mask=mask[:, None] & mask[None, :])\n                \n                mean += tl.sum(x_vals)\n                count += tl.sum(mask) * tl.sum(mask)\n    \n    mean = mean / count\n    mean = mean.to(tl.float32)\n    \n    # Compute variance\n    for c in range(g * group_size, (g + 1) * group_size):\n        for h in range(0, H, BLOCK_SIZE):\n            for w in range(0, W, BLOCK_SIZE):\n                offsets = tl.arange(0, BLOCK_SIZE)\n                h_offsets = h + offsets\n                w_offsets = w + offsets\n                \n                mask = (h_offsets < H) & (w_offsets < W)\n                x_ptrs = x_ptr + n * C * H * W + c * H * W + h_offsets[:, None] * W + w_offsets[None, :]\n                x_vals = tl.load(x_ptrs, mask=mask[:, None] & mask[None, :])\n                \n                diff = x_vals - mean\n                var += tl.sum(diff * diff)\n    \n    var = var / count\n    std = tl.sqrt(var + eps)\n    \n    # Apply normalization\n    for c in range(g * group_size, (g + 1) * group_size):\n        for h in range(0, H, BLOCK_SIZE):\n            for w in range(0, W, BLOCK_SIZE):\n                offsets = tl.arange(0, BLOCK_SIZE)\n                h_offsets = h + offsets\n                w_offsets = w + offsets\n                \n                mask = (h_offsets < H) & (w_offsets < W)\n                x_ptrs = x_ptr + n * C * H * W + c * H * W + h_offsets[:, None] * W + w_offsets[None, :]\n                y_ptrs = y_ptr + n * C * H * W + c * H * W + h_offsets[:, None] * W + w_offsets[None, :]\n                \n                x_vals = tl.load(x_ptrs, mask=mask[:, None] & mask[None, :])\n                normalized = (x_vals - mean) / std\n                gamma_val = tl.load(gamma_ptr + c)\n                beta_val = tl.load(beta_ptr + c)\n                out = normalized * gamma_val + beta_val\n                tl.store(y_ptrs, out, mask=mask[:, None] & mask[None, :])\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_channels, out_channels, kernel_size, stride, padding, groups, num_groups):\n        super(ModelNew, self).__init__()\n        self.conv_transpose = nn.ConvTranspose2d(in_channels, out_channels, kernel_size, stride=stride, padding=padding)\n        self.batch_norm = nn.BatchNorm2d(out_channels)\n        self.tanh = nn.Tanh()\n        self.max_pool = nn.MaxPool2d(kernel_size=2, stride=2)\n        self.gamma = nn.Parameter(torch.ones(out_channels))\n        self.beta = nn.Parameter(torch.zeros(out_channels))\n        self.num_groups = num_groups\n        \n    def forward(self, x):\n        x = self.conv_transpose(x)\n        x = self.batch_norm(x)\n        x = self.tanh(x)\n        x = self.max_pool(x)\n        \n        # Custom group norm with Triton\n        N, C, H, W = x.shape\n        y = torch.empty_like(x)\n        eps = 1e-5\n        BLOCK_SIZE = 16\n        \n        grid = (N, self.num_groups)\n        group_norm_kernel[grid](\n            x, y, self.gamma, self.beta,\n            N, C, H, W,\n            self.num_groups, eps, BLOCK_SIZE\n        )\n        return y\n\nbatch_size = 128\nin_channels = 32\nout_channels = 64\nkernel_size = 4\nstride = 2\npadding = 1\ngroups = 8\nnum_groups = 4\nheight, width = 32, 32\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_channels, height, width)]\n\ndef get_init_inputs():\n    return [in_channels, out_channels, kernel_size, stride, padding, groups, num_groups]\n# =================== EVOLVE-BLOCK-END ===================\n```\n\n# Task\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```\n", "responses": ["<think>\nWe are given the current program that has a Triton kernel for group normalization.\n The current implementation uses a 2D grid (N, num_groups) and for each group, it loops over channels in the group and then over spatial dimensions in blocks.\n However, the current performance (speed_up: 0.159) is very low compared to the reference (0.154 ms reference vs 0.967 ms custom).\n\n The main issues with the current kernel are:\n 1. It uses three nested loops (channels, h, w) and then within h and w, it uses a 2D block (BLOCK_SIZE x BLOCK_SIZE) for each h and w block.\n    This leads to a lot of iterations and might not be efficient.\n\n 2. The kernel does two separate passes for mean and variance, and then a third pass for normalization. This is inefficient.\n\n 3. The kernel uses a 2D block for spatial dimensions, but note that the spatial dimensions are being processed in a tiled manner, which might cause redundant loads.\n\n 4. The current BLOCK_SIZE is set to 16 in the model, which might be too small for efficient memory access.\n\n We note from the top-performing programs that a different approach was taken in Program 1 (score 20, speed_up 0.164) and Program 3 (score 20, speed_up 0.147).\n However, the current program is similar to Program 2 (score 20, speed_up 0.159) but with a BLOCK_SIZE of 16.\n\n We are going to try to optimize the kernel by:\n - Using a single pass for both mean and variance (to reduce the number of passes from two to one).\n - Vectorizing the spatial dimension in a 1D manner (as in Program 1) instead of 2D tiling, which can be more efficient and reduce the number of loops.\n - Increasing the BLOCK_SIZE to 256 (as in Program 1) to improve memory access.\n\n We are going to rewrite the kernel to:\n\n   @triton.jit\n   def group_norm_kernel(\n        ... same arguments ...\n   ):\n        n = tl.program_id(0)\n        g = tl.program_id(1)\n        group_size = C // num_groups\n\n        # We will process the entire group for the sample n in this program.\n        # We'll use a 1D block for the spatial dimension (H*W) and also for the channels in the group? \n        # But note: we are already splitting by group and sample. We want to compute the mean and variance for the entire group.\n\n        # We can use a 1D loop over the entire group (group_size * H * W) but that might be too big for a single block.\n        # Instead, we can use a reduction across multiple threads? But the grid is (N, num_groups) and we are not using thread blocks for reduction.\n\n        # Alternatively, we can do:\n        #   For each channel in the group, we loop over the spatial dimension in 1D blocks (with block size BLOCK_SIZE)\n        #   and accumulate the mean and sum of squares.\n\n        mean = 0.0\n        sq_sum = 0.0\n        count = 0\n\n        for c in range(g * group_size, (g+1)*group_size):\n            base = n * C * H * W + c * H * W\n            for hw in range(0, H*W, BLOCK_SIZE):\n                offsets = hw + tl.arange(0, BLOCK_SIZE)\n                mask = offsets < (H*W)\n                x_vals = tl.load(x_ptr + base + offsets, mask=mask, other=0.0)\n                mean += tl.sum(x_vals)\n                sq_sum += tl.sum(x_vals * x_vals)\n                count += tl.sum(mask)\n\n        mean = mean / count\n        var = (sq_sum / count) - (mean * mean)\n        std = tl.sqrt(var + eps)\n\n        # Now apply normalization in a similar loop\n        for c in range(g * group_size, (g+1)*group_size):\n            base = n * C * H * W + c * H * W\n            for hw in range(0, H*W, BLOCK_SIZE):\n                offsets = hw + tl.arange(0, BLOCK_SIZE)\n                mask = offsets < (H*W)\n                x_vals = tl.load(x_ptr + base + offsets, mask=mask, other=0.0)\n                normalized = (x_vals - mean) / std\n                gamma_val = tl.load(gamma_ptr + c)\n                beta_val = tl.load(beta_ptr + c)\n                out = normalized * gamma_val + beta_val\n                tl.store(y_ptr + base + offsets, out, mask=mask)\n\n This approach:\n   - Uses a single pass for mean and variance (accumulating both in one loop).\n   - Processes the spatial dimension in 1D blocks (vectorized loads and stores).\n   - Is similar to the top Program 1 (which had a BLOCK_SIZE of 256) and Program D2.\n\n However, note that the current program has a BLOCK_SIZE of 16 (which is small) and we are going to change it to 256 in the model.\n\n But note: the grid configuration remains (N, num_groups). Each block handles one sample and one group.\n\n We are going to replace the current kernel with this new one.\n\n Also, we change the BLOCK_SIZE in the model from 16 to 256 (or 512) for better memory access.\n\n Let's try with BLOCK_SIZE=256.\n\n Important: We must not change the function signature of the kernel.\n\n We are going to write the kernel accordingly.\n\n However, note that the current kernel uses a 2D block for spatial (h and w) and we are changing to 1D (H*W). This is a significant change.\n\n We also note that the current program has a 2D grid (N, num_groups) and we are keeping that.\n\n Let's generate the code accordingly.\n\n But note: the current program has a BLOCK_SIZE argument that we are using for the spatial block. In the new kernel, we use it for the 1D block in the spatial dimension (H*W).\n\n We'll adjust the kernel and the model accordingly.\n\n We must be cautious of the data type and the boundary checks.\n\n We are going to write the kernel as described.\n\n Also note: the count variable is now the number of elements in the group (which is group_size * H * W). But we are accumulating by the actual mask, so it should be correct.\n\n Let's write the code.\n</think>\nTo improve the performance of the group normalization kernel, we'll optimize the Triton implementation by:\n1. Switching to a 1D vectorized approach for spatial dimensions instead of 2D tiling\n2. Combining mean and variance calculations in a single pass\n3. Increasing BLOCK_SIZE to 256 for better memory access patterns\n4. Using efficient vectorized loads/stores for spatial dimensions\n\nHere's the optimized implementation:\n\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef group_norm_kernel(\n    x_ptr,\n    y_ptr,\n    gamma_ptr,\n    beta_ptr,\n    N, C, H, W,\n    num_groups: tl.constexpr,\n    eps: tl.constexpr,\n    BLOCK_SIZE: tl.constexpr\n):\n    n = tl.program_id(0)\n    g = tl.program_id(1)\n    group_size = C // num_groups\n    \n    # Initialize accumulators\n    mean = 0.0\n    sq_sum = 0.0\n    count = 0.0\n    \n    # Single-pass calculation for mean and variance\n    for c in range(g * group_size, (g + 1) * group_size):\n        base = n * C * H * W + c * H * W\n        for hw in range(0, H * W, BLOCK_SIZE):\n            offsets = hw + tl.arange(0, BLOCK_SIZE)\n            mask = offsets < (H * W)\n            \n            # Vectorized load\n            x_vals = tl.load(x_ptr + base + offsets, mask=mask, other=0.0)\n            mean += tl.sum(x_vals)\n            sq_sum += tl.sum(x_vals * x_vals)\n            count += tl.sum(mask)\n    \n    # Compute group statistics\n    mean = mean / count\n    var = (sq_sum / count) - (mean * mean)\n    std = tl.sqrt(var + eps)\n    \n    # Apply normalization\n    for c in range(g * group_size, (g + 1) * group_size):\n        base = n * C * H * W + c * H * W\n        for hw in range(0, H * W, BLOCK_SIZE):\n            offsets = hw + tl.arange(0, BLOCK_SIZE)\n            mask = offsets < (H * W)\n            \n            # Vectorized load and store\n            x_vals = tl.load(x_ptr + base + offsets, mask=mask, other=0.0)\n            gamma_val = tl.load(gamma_ptr + c)\n            beta_val = tl.load(beta_ptr + c)\n            normalized = (x_vals - mean) / std\n            out = normalized * gamma_val + beta_val\n            tl.store(y_ptr + base + offsets, out, mask=mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_channels, out_channels, kernel_size, stride, padding, groups, num_groups):\n        super(ModelNew, self).__init__()\n        self.conv_transpose = nn.ConvTranspose2d(in_channels, out_channels, kernel_size, stride=stride, padding=padding)\n        self.batch_norm = nn.BatchNorm2d(out_channels)\n        self.tanh = nn.Tanh()\n        self.max_pool = nn.MaxPool2d(kernel_size=2, stride=2)\n        self.gamma = nn.Parameter(torch.ones(out_channels))\n        self.beta = nn.Parameter(torch.zeros(out_channels))\n        self.num_groups = num_groups\n        \n    def forward(self, x):\n        x = self.conv_transpose(x)\n        x = self.batch_norm(x)\n        x = self.tanh(x)\n        x = self.max_pool(x)\n        \n        # Custom group norm with Triton\n        N, C, H, W = x.shape\n        y = torch.empty_like(x)\n        eps = 1e-5\n        BLOCK_SIZE = 256  # Optimized for memory access\n        \n        grid = (N, self.num_groups)\n        group_norm_kernel[grid](\n            x, y, self.gamma, self.beta,\n            N, C, H, W,\n            self.num_groups, eps, BLOCK_SIZE\n        )\n        return y\n\nbatch_size = 128\nin_channels = 32\nout_channels = 64\nkernel_size = 4\nstride = 2\npadding = 1\ngroups = 8\nnum_groups = 4\nheight, width = 32, 32\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_channels, height, width)]\n\ndef get_init_inputs():\n    return [in_channels, out_channels, kernel_size, stride, padding, groups, num_groups]\n# =================== EVOLVE-BLOCK-END ===================\n```"]}}}