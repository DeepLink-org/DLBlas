{"id": "72cb6312-f32a-4c19-a657-f8d56c18fd77", "code": "# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef conv_transpose3d_kernel(\n    x_ptr,\n    weight_ptr,\n    bias_ptr,\n    output_ptr,\n    stride_d, stride_h, stride_w,\n    padding_d, padding_h, padding_w,\n    scale,\n    B, C_in, C_out, D, H, W,\n    kD, kH, kW,\n    D_out, H_out, W_out,\n    x_s0, x_s1, x_s2, x_s3, x_s4,\n    w_s0, w_s1, w_s2, w_s3, w_s4,\n    o_s0, o_s1, o_s2, o_s3, o_s4,\n    BLOCK_SIZE: tl.constexpr,\n):\n    pid = tl.program_id(0)\n    num_pid = tl.num_programs(0)\n    elements_per_program = tl.cdiv(B * C_out * D_out * H_out * W_out, num_pid)\n    \n    start_idx = pid * elements_per_program\n    end_idx = min(start_idx + elements_per_program, B * C_out * D_out * H_out * W_out)\n    \n    for idx in range(start_idx, end_idx):\n        # Convert linear index to 5D index (b, c_out, d, h, w)\n        w = idx % W_out\n        h = (idx // W_out) % H_out\n        d = (idx // (W_out * H_out)) % D_out\n        c_out = (idx // (W_out * H_out * D_out)) % C_out\n        b = idx // (W_out * H_out * D_out * C_out)\n        \n        acc = 0.0\n        for c_in in range(C_in):\n            for kd in range(kD):\n                for kh in range(kH):\n                    for kw in range(kW):\n                        # Calculate input indices\n                        d_in = (d - kd + padding_d) \n                        h_in = (h - kh + padding_h)\n                        w_in = (w - kw + padding_w)\n                        \n                        # Check if index is valid and divisible by stride\n                        if d_in % stride_d == 0 and h_in % stride_h == 0 and w_in % stride_w == 0:\n                            d_in //= stride_d\n                            h_in //= stride_h\n                            w_in //= stride_w\n                            \n                            if (d_in >= 0 and d_in < D and \n                                h_in >= 0 and h_in < H and \n                                w_in >= 0 and w_in < W):\n                                x_offset = b*x_s0 + c_in*x_s1 + d_in*x_s2 + h_in*x_s3 + w_in*x_s4\n                                w_offset = c_in*w_s0 + c_out*w_s1 + kd*w_s2 + kh*w_s3 + kw*w_s4\n                                \n                                x_val = tl.load(x_ptr + x_offset)\n                                w_val = tl.load(weight_ptr + w_offset)\n                                acc += x_val * w_val\n        \n        # Add bias and scale\n        if bias_ptr is not None:\n            bias_val = tl.load(bias_ptr + c_out)\n            acc += bias_val\n        acc *= scale\n        \n        # Store result\n        out_offset = b*o_s0 + c_out*o_s1 + d*o_s2 + h*o_s3 + w*o_s4\n        tl.store(output_ptr + out_offset, acc)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_channels, out_channels, kernel_size, stride, padding, scale, maxpool_kernel_size):\n        super(ModelNew, self).__init__()\n        self.in_channels = in_channels\n        self.out_channels = out_channels\n        self.kernel_size = kernel_size\n        self.stride = stride\n        self.padding = padding\n        self.scale = scale\n        \n        # Initialize weights and bias\n        self.weight = nn.Parameter(torch.empty(\n            in_channels, out_channels, \n            kernel_size, kernel_size, kernel_size\n        ))\n        self.bias = nn.Parameter(torch.empty(out_channels))\n        \n        # Initialize parameters\n        nn.init.kaiming_uniform_(self.weight, a=math.sqrt(5))\n        fan_in, _ = nn.init._calculate_fan_in_and_fan_out(self.weight)\n        bound = 1 / math.sqrt(fan_in)\n        nn.init.uniform_(self.bias, -bound, bound)\n        \n        self.maxpool = nn.MaxPool3d(kernel_size=maxpool_kernel_size)\n        self.global_avg_pool = nn.AdaptiveAvgPool3d((1, 1, 1))\n        self.clamp_min = 0\n        self.clamp_max = 1\n\n    def forward(self, x):\n        # Compute output dimensions\n        D_out = (x.shape[2] - 1) * self.stride - 2 * self.padding + self.kernel_size\n        H_out = (x.shape[3] - 1) * self.stride - 2 * self.padding + self.kernel_size\n        W_out = (x.shape[4] - 1) * self.stride - 2 * self.padding + self.kernel_size\n        \n        # Create output tensor\n        output = torch.empty(\n            x.shape[0], self.out_channels, D_out, H_out, W_out,\n            device=x.device, dtype=x.dtype\n        )\n        \n        # Get strides\n        x_stride = x.stride()\n        w_stride = self.weight.stride()\n        o_stride = output.stride()\n        \n        # Launch kernel\n        total_elements = output.numel()\n        grid = lambda meta: (triton.cdiv(total_elements, meta['BLOCK_SIZE']),)\n        \n        conv_transpose3d_kernel[grid](\n            x, self.weight, self.bias, output,\n            self.stride, self.stride, self.stride,\n            self.padding, self.padding, self.padding,\n            self.scale,\n            x.shape[0], self.in_channels, self.out_channels,\n            x.shape[2], x.shape[3], x.shape[4],\n            self.kernel_size, self.kernel_size, self.kernel_size,\n            D_out, H_out, W_out,\n            x_stride[0], x_stride[1], x_stride[2], x_stride[3], x_stride[4],\n            w_stride[0], w_stride[1], w_stride[2], w_stride[3], w_stride[4],\n            o_stride[0], o_stride[1], o_stride[2], o_stride[3], o_stride[4],\n            BLOCK_SIZE=128\n        )\n        \n        # Post-processing\n        x = self.maxpool(output)\n        x = self.global_avg_pool(x)\n        x = torch.clamp(x, min=self.clamp_min, max=self.clamp_max)\n        return x\n\nbatch_size = 128\nin_channels = 3\nout_channels = 16\ndepth, height, width = 16, 32, 32\nkernel_size = 3\nstride = 2\npadding = 1\nscale = 0.5\nmaxpool_kernel_size = 2\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_channels, depth, height, width)]\n\ndef get_init_inputs():\n    return [in_channels, out_channels, kernel_size, stride, padding, scale, maxpool_kernel_size]\n# =================== EVOLVE-BLOCK-END ===================", "language": "python", "parent_id": "aa39a6b9-a64b-4aa1-a7ae-a80d26f18aa7", "generation": 1, "timestamp": 1754586517.141251, "iteration_found": 0, "metrics": {"compiled": false, "correctness": false, "score": 1, "stage": "compile_error", "compile_log": "name 'math' is not defined\nTraceback (most recent call last):\n  File \"/cpfs01/shared/llm_kernel/hujiakai/KernelLLM/validation_api_server/evaluator.py\", line 173, in _verification_worker\n    result: KernelExecResult = eval_kernel_against_ref(\n  File \"/cpfs01/shared/llm_kernel/hujiakai/KernelLLM/validation_api_server/helpers/evaluations.py\", line 484, in eval_kernel_against_ref\n    custom_model = ModelNew(*init_args, **init_kwargs)\n  File \"/tmp/tmpkhqiz47n.py\", line 93, in __init__\n    nn.init.kaiming_uniform_(self.weight, a=math.sqrt(5))\nNameError: name 'math' is not defined\n", "exec_log": "[Child] \u7ed1\u5b9a GPU 4, torch sees 1 device(s)\n\n[Exception]\nTraceback (most recent call last):\n  File \"/cpfs01/shared/llm_kernel/hujiakai/KernelLLM/validation_api_server/code_executor.py\", line 71, in _exec_worker\n    exec(textwrap.dedent(code_src), mod.__dict__)\n  File \"<string>\", line 8, in <module>\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 844, in jit\n    return decorator(fn)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 832, in decorator\n    return JITFunction(\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 635, in __init__\n    self.starting_line_number = inspect.getsourcelines(fn)[1]\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/inspect.py\", line 1121, in getsourcelines\n    lines, lnum = findsource(object)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/inspect.py\", line 958, in findsource\n    raise OSError('could not get source code')\nOSError: could not get source code\n", "exit_code": "1"}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": true, "correctness": true, "stage": "reference code", "passed": false, "score": 0.0, "speed_up": 1.0, "runtime_ms": 5.35, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:7", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.111, "speed_up": 0.021, "custom_timing": 5.35}}, "island": 0}, "artifacts_json": null, "artifact_dir": null}