{"id": "b511621a-6e49-4f0a-aa7f-c7a23d11adc4", "code": "# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef min_reduction_kernel(\n    input_ptr,\n    output_ptr,\n    K: tl.constexpr,   # Reduction dimension size\n    M: tl.constexpr,   # Number of output elements\n    VECTOR_SIZE: tl.constexpr\n):\n    pid = tl.program_id(0)\n    if pid >= M:\n        return\n    row_start = input_ptr + pid * K\n    min_val = tl.full((), float('inf'), dtype=tl.float32)\n    \n    # Process the row in vectorized chunks\n    for i in range(0, K, VECTOR_SIZE):\n        offs = i + tl.arange(0, VECTOR_SIZE)\n        mask = offs < K\n        # Create vector of pointers for coalesced access\n        ptrs = row_start + offs\n        vector = tl.load(ptrs, mask=mask, other=float('inf'))\n        # Compute min within the current vector\n        vector_min = tl.min(vector, axis=0)\n        # Update overall min value\n        min_val = tl.minimum(min_val, vector_min)\n    \n    tl.store(output_ptr + pid, min_val)\n\nclass ModelNew(nn.Module):\n    def __init__(self, dim: int):\n        super(ModelNew, self).__init__()\n        self.dim = dim\n\n    def forward(self, x: torch.Tensor) -> torch.Tensor:\n        # Handle negative dimension indexing\n        if self.dim < 0:\n            dim = x.dim() + self.dim\n        else:\n            dim = self.dim\n        \n        original_shape = x.shape\n        # Permute reduction dimension to last for contiguous access\n        if dim != x.dim() - 1:\n            perm = list(range(x.dim()))\n            perm[dim], perm[-1] = perm[-1], perm[dim]\n            x = x.permute(perm)\n        # Ensure contiguous memory layout\n        x = x.contiguous()\n        # Flatten all dimensions except reduction dimension\n        x_2d = x.view(-1, x.shape[-1])\n        M, K = x_2d.shape\n        \n        output_1d = torch.empty(M, device=x.device, dtype=x.dtype)\n        \n        # Configure kernel grid (1D grid for output elements)\n        grid = (M,)\n        min_reduction_kernel[grid](\n            x_2d, output_1d, \n            K, M, \n            VECTOR_SIZE=4,  # Process 4 elements per vector\n            num_warps=4     # Optimize for throughput\n        )\n        \n        # Unpermute output to original dimension order\n        output_shape = list(original_shape)\n        del output_shape[dim]\n        return output_1d.view(output_shape)\n\nbatch_size = 16\ndim1 = 256\ndim2 = 256\n\ndef get_inputs():\n    x = torch.randn(batch_size, dim1, dim2)\n    return [x]\n\ndef get_init_inputs():\n    return [1]  # Example dimension\n# =================== EVOLVE-BLOCK-END ===================", "language": "python", "parent_id": "1b850ad3-6093-4e8f-98d0-3598e138ed82", "generation": 1, "timestamp": 1754638948.8415234, "iteration_found": 5, "metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": false, "score": 20, "speed_up": 0.415, "runtime_ms": 0.0578, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:7", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.024, "speed_up": 0.415, "custom_timing": 0.0578}}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": true, "correctness": true, "stage": "reference code", "passed": false, "score": 0.0, "speed_up": 1.0, "runtime_ms": 0.0256, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:0", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.024, "speed_up": 0.938, "custom_timing": 0.0256}}, "island": 1}, "artifacts_json": null, "artifact_dir": null}