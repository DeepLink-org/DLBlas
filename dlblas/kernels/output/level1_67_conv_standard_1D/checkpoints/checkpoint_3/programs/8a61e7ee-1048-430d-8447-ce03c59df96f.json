{"id": "8a61e7ee-1048-430d-8447-ce03c59df96f", "code": "# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef conv1d_kernel(\n    x_ptr, \n    weight_ptr, \n    output_ptr,\n    batch_size, \n    in_channels, \n    length, \n    out_channels, \n    kernel_size,\n    stride,\n    padding,\n    dilation,\n    groups,\n    stride_x_batch, stride_x_in, stride_x_len,\n    stride_weight_oc, stride_weight_ic, stride_weight_k,\n    stride_output_batch, stride_output_oc, stride_output_len,\n    output_length,\n    BLOCK_IC: tl.constexpr,\n    BLOCK_LEN: tl.constexpr,\n):\n    pid0 = tl.program_id(0)   # batch\n    pid1 = tl.program_id(1)   # output channel\n    pid2 = tl.program_id(2)   # output position block index\n\n    # Check bounds\n    if pid0 >= batch_size or pid1 >= out_channels:\n        return\n\n    # Compute output position block\n    output_positions = pid2 * BLOCK_LEN + tl.arange(0, BLOCK_LEN)\n    mask_len = output_positions < output_length\n\n    # Initialize accumulator\n    acc = tl.zeros((BLOCK_LEN,), dtype=tl.float32)\n\n    # Loop over kernel positions\n    for d in range(0, kernel_size):\n        # Loop over input channels in blocks\n        for ic0 in range(0, in_channels, BLOCK_IC):\n            ic_offsets = ic0 + tl.arange(0, BLOCK_IC)\n            mask_ic = ic_offsets < in_channels\n\n            # Load weight block [BLOCK_IC]\n            w_ptrs = weight_ptr + pid1 * stride_weight_oc + ic_offsets * stride_weight_ic + d * stride_weight_k\n            w = tl.load(w_ptrs, mask=mask_ic, other=0.0)\n\n            # Compute input positions [BLOCK_LEN]\n            pos = (output_positions * stride - padding) + d * dilation\n            mask_pos = (pos >= 0) & (pos < length)\n            mask_2d = mask_ic[:, None] & mask_pos[None, :] & mask_len[None, :]\n\n            # Load input block [BLOCK_IC, BLOCK_LEN]\n            x_ptrs = x_ptr + pid0 * stride_x_batch + (ic_offsets[:, None] * stride_x_in) + (pos[None, :] * stride_x_len)\n            x_vals = tl.load(x_ptrs, mask=mask_2d, other=0.0)\n\n            # Accumulate\n            partial = tl.sum(w[:, None] * x_vals, axis=0)\n            acc += partial\n\n    # Store result\n    output_ptrs = output_ptr + pid0 * stride_output_batch + pid1 * stride_output_oc + output_positions * stride_output_len\n    tl.store(output_ptrs, acc, mask=mask_len)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_channels: int, out_channels: int, kernel_size: int, stride: int = 1, padding: int = 0, dilation: int = 1, groups: int = 1, bias: bool = False):\n        super(ModelNew, self).__init__()\n        self.in_channels = in_channels\n        self.out_channels = out_channels\n        self.kernel_size = kernel_size\n        self.stride = stride\n        self.padding = padding\n        self.dilation = dilation\n        self.groups = groups\n        \n        # Initialize weight\n        self.weight = nn.Parameter(torch.empty(out_channels, in_channels // groups, kernel_size))\n        nn.init.kaiming_uniform_(self.weight, a=math.sqrt(5))\n        \n        if bias:\n            self.bias = nn.Parameter(torch.empty(out_channels))\n            fan_in, _ = nn.init._calculate_fan_in_and_fan_out(self.weight)\n            bound = 1 / math.sqrt(fan_in) if fan_in > 0 else 0\n            nn.init.uniform_(self.bias, -bound, bound)\n        else:\n            self.register_parameter('bias', None)\n            \n    def forward(self, x: torch.Tensor) -> torch.Tensor:\n        if self.groups != 1:\n            return nn.functional.conv1d(\n                x, self.weight, self.bias, self.stride, \n                self.padding, self.dilation, self.groups\n            )\n        \n        # Compute output shape\n        batch_size, _, length = x.shape\n        output_length = (length + 2 * self.padding - self.dilation * (self.kernel_size - 1) - 1) // self.stride + 1\n        output = torch.empty(batch_size, self.out_channels, output_length, device=x.device, dtype=x.dtype)\n        \n        # Get strides\n        stride_x_batch, stride_x_in, stride_x_len = x.stride()\n        stride_weight_oc, stride_weight_ic, stride_weight_k = self.weight.stride()\n        stride_output_batch, stride_output_oc, stride_output_len = output.stride()\n        \n        # Configure grid\n        BLOCK_LEN = 128  # Increased block size for better memory access patterns\n        grid = (batch_size, self.out_channels, triton.cdiv(output_length, BLOCK_LEN))\n        \n        # Launch kernel\n        BLOCK_IC = 32\n        \n        conv1d_kernel[grid](\n            x, self.weight, output,\n            batch_size, self.in_channels, length, self.out_channels, self.kernel_size,\n            self.stride, self.padding, self.dilation, self.groups,\n            stride_x_batch, stride_x_in, stride_x_len,\n            stride_weight_oc, stride_weight_ic, stride_weight_k,\n            stride_output_batch, stride_output_oc, stride_output_len,\n            output_length,\n            BLOCK_IC, BLOCK_LEN\n        )\n        \n        # Add bias if needed\n        if self.bias is not None:\n            output += self.bias[:, None]\n            \n        return output\n\n# Test code\nimport math\nbatch_size = 16\nin_channels = 3\nout_channels = 64\nkernel_size = 3\nlength = 512\n\ndef get_inputs():\n    x = torch.randn(batch_size, in_channels, length, device='cuda')\n    return [x]\n\ndef get_init_inputs():\n    return [in_channels, out_channels, kernel_size]\n# =================== EVOLVE-BLOCK-END ===================", "language": "python", "parent_id": "59819118-f27c-47ff-b92f-a7d71bf7cae5", "generation": 3, "timestamp": 1754650562.6590192, "iteration_found": 18, "metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": false, "score": 20, "speed_up": 0.467, "runtime_ms": 0.079, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:0", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.0369, "speed_up": 0.467, "custom_timing": 0.079}}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": false, "score": 20, "speed_up": 0.417, "runtime_ms": 0.0885, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:3", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.0369, "speed_up": 0.417, "custom_timing": 0.0885}}, "island": 2}, "artifacts_json": null, "artifact_dir": null}