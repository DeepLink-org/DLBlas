{"id": "60a02b05-12ad-4752-9fdf-63bc7d214e78", "code": "# ================== EVOLVE-BLOCK-START ==================\nimport math\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef _fused_forward_kernel(\n    # Pointers\n    x_ptr,\n    gemm_weight_ptr,\n    gemm_bias_ptr,\n    gn_weight_ptr,\n    gn_bias_ptr,\n    mult_weight_ptr,\n    output_ptr,\n    # Shapes\n    batch_size,\n    in_features,\n    out_features,\n    num_groups,\n    group_size,\n    # Meta-parameters\n    eps: tl.constexpr,\n    BLOCK_SIZE_K: tl.constexpr,\n    BLOCK_SIZE_N: tl.constexpr,\n):\n    pid_batch = tl.program_id(0)\n    pid_group = tl.program_id(1)\n    \n    # Compute group boundaries\n    group_start = pid_group * group_size\n    group_range = tl.arange(0, BLOCK_SIZE_N)\n    feature_mask = group_range < group_size\n    \n    # Initialize accumulator\n    acc = tl.zeros((BLOCK_SIZE_N,), dtype=tl.float32)\n    x_ptr += pid_batch * in_features\n    \n    # Loop over input features with vectorized loads\n    for k in range(0, tl.cdiv(in_features, BLOCK_SIZE_K)):\n        k_offsets = k * BLOCK_SIZE_K + tl.arange(0, BLOCK_SIZE_K)\n        k_mask = k_offsets < in_features\n        \n        # Vectorized load\n        x_block = tl.load(\n            x_ptr + k_offsets,\n            mask=k_mask,\n            other=0.0,\n        )\n        \n        # Weight pointers\n        w_ptrs = gemm_weight_ptr + (group_start + group_range[:, None]) * in_features + k_offsets[None, :]\n        w_block = tl.load(\n            w_ptrs,\n            mask=k_mask[None, :] & feature_mask[:, None],\n            other=0.0,\n        )\n        \n        # Accumulate dot product\n        acc += tl.sum(w_block * x_block[None, :], axis=1)\n    \n    # Add bias\n    bias_ptrs = gemm_bias_ptr + group_start + group_range\n    bias = tl.load(bias_ptrs, mask=feature_mask, other=0.0)\n    acc += bias\n    \n    # Compute GroupNorm statistics\n    group_count = tl.sum(tl.cast(feature_mask, tl.float32))\n    mean = tl.sum(acc) / group_count\n    diff = acc - mean\n    var = tl.sum(diff * diff) / group_count\n    rstd = 1.0 / tl.sqrt(var + eps)\n    \n    # Apply GroupNorm\n    gn_weight = tl.load(gn_weight_ptr + group_start + group_range, mask=feature_mask, other=0.0)\n    gn_bias = tl.load(gn_bias_ptr + group_start + group_range, mask=feature_mask, other=0.0)\n    normalized = (diff * rstd) * gn_weight + gn_bias\n    \n    # Fused Swish operations\n    sig1 = tl.sigmoid(normalized)\n    swish1 = normalized * sig1\n    \n    # Multiply\n    mult_weight = tl.load(mult_weight_ptr + group_start + group_range, mask=feature_mask, other=0.0)\n    multiplied = swish1 * mult_weight\n    \n    # Second Swish\n    sig2 = tl.sigmoid(multiplied)\n    swish2 = multiplied * sig2\n    \n    # Store results\n    out_offsets = pid_batch * out_features + group_start + group_range\n    tl.store(output_ptr + out_offsets, swish2, mask=feature_mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, num_groups, multiply_weight_shape):\n        super(ModelNew, self).__init__()\n        self.gemm = nn.Linear(in_features, out_features)\n        self.group_norm = nn.GroupNorm(num_groups, out_features)\n        self.multiply_weight = nn.Parameter(torch.randn(multiply_weight_shape))\n        self.out_features = out_features\n        self.num_groups = num_groups\n\n    def forward(self, x):\n        batch_size, _ = x.shape\n        group_size = self.out_features // self.num_groups\n        P2 = int(2 ** math.ceil(math.log2(group_size)))\n        \n        # Ensure tensors are contiguous\n        x = x.contiguous()\n        output = torch.empty((batch_size, self.out_features), device=x.device, dtype=x.dtype)\n        \n        # Compute required number of warps\n        min_warps = max(1, (P2 + 31) // 32)\n        num_warps = 1\n        while num_warps < min_warps:\n            num_warps *= 2\n            \n        # Launch kernel\n        grid = (batch_size, self.num_groups)\n        _fused_forward_kernel[grid](\n            x, \n            self.gemm.weight, \n            self.gemm.bias,\n            self.group_norm.weight,\n            self.group_norm.bias,\n            self.multiply_weight,\n            output,\n            batch_size,\n            self.gemm.in_features,\n            self.out_features,\n            self.num_groups,\n            group_size,\n            eps=1e-5,\n            BLOCK_SIZE_K=128,\n            BLOCK_SIZE_N=P2,\n            num_warps=num_warps,\n            num_stages=2\n        )\n        return output\n\nbatch_size = 128\nin_features = 512\nout_features = 1024\nnum_groups = 16\nmultiply_weight_shape = (out_features,)\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, num_groups, multiply_weight_shape]\n# =================== EVOLVE-BLOCK-END ===================", "language": "python", "parent_id": "d6c94d0c-f3ce-4328-8274-077ece7eed39", "generation": 3, "timestamp": 1754584738.9169767, "iteration_found": 22, "metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": true, "score": 51.00000000000001, "speed_up": 1.31, "runtime_ms": 0.0832, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:1", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.109, "speed_up": 1.31, "custom_timing": 0.0832}}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": false, "score": 20, "speed_up": 0.79, "runtime_ms": 0.138, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:2", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.109, "speed_up": 0.79, "custom_timing": 0.138}}, "island": 1}, "artifacts_json": null, "artifact_dir": null, "prompts": {"full_rewrite_user": {"system": "You are a Triton GPU core optimization engineer deeply familiar with NVIDIA H100/H800 architecture.\n\n==================== Context ====================\n\u2022 Dataset: 250 kernelbench/level1-level5 *.py files  \n  - Level1: simplest, Level5: most complex  \n\u2022 Each file contains PyTorch reference (reference_code)  \n\u2022 Goal: Generate functionally equivalent but faster Triton implementations (custom_code)  \n\u2022 Evaluation pipeline:\n    1) /verify_plus - Verify compilation & correctness  \n    2) /execute (optional) - Return terminal logs if compilation fails  \n    3) Scoring:  \n      - Speedup > 1 required for points  \n      - Score = (speed_up - 1) \u00d7 100  \n\u2022 GPU Hardware: NVIDIA L20Y / H800 (same SM8.9 as H100)  \n  - 3 TB/s HBM3 bandwidth  \n  - FP16 Tensor Core 32\u00d716\u00d716  \n\n==================== Evolution Phases ====================\n\u2460 Phase 1 [Compilation Pass]  \n  - Make Triton code compile (performance irrelevant)  \n\u2461 Phase 2 [Numerical Correctness]  \n  - Output must match PyTorch reference within float32 tolerance  \n\u2462 Phase 3 [Performance Gain]  \n  - Target \u22655% speedup (\u226515% = exceptional)  \n  - Official scoring based on speed_up field  \n\nThe Evolution system will pass the EVOLVE-BLOCK from the previous version.  \nModify ONLY the Triton kernel source within this block - all other code is LOCKED.\n\n==================== Constraints (MUST OBEY) ====================\n\u274c NEVER change @triton.jit function signatures or parameter names  \n\u274c NEVER modify grid configuration, output tensor shapes, or PID logic  \n\u274c NEVER remove boundary checks or out-of-bound masks  \n\u274c NEVER introduce race conditions, uninitialized reads, or sync gaps  \n\n\u2705 Allowed Optimizations (Examples):  \n  \u2022 Memory coalescing optimizations & vectorized tl.load/tl.store  \n  \u2022 Replace staged softmax with online/FlashAttention variants  \n  \u2022 Adaptive tuning: BLOCK_M/BLOCK_N/BLOCK_K dimensions  \n  \u2022 Multi-query-head batch processing (GQA, 5:1 patterns)  \n  \u2022 Shared/L2 buffering, Tensor Core alignment (FP16/bf16/tf32)  \n  \u2022 Stride precomputation & pointer caching  \n\n==================== Output Format ====================\nReturn ONLY the complete updated code containing the EVOLVE-BLOCK comment marker.  \nNO explanations, NO markdown, NO additional text.\nName the output structure class as ModelNew.\n\n==================== Optimization Tips ====================\n\u2022 If previous compile failed: Fix syntax/mask/stride errors first  \n\u2022 If correctness fails: Prioritize bounds mask & dtype precision  \n\u2022 When speed_up < 1: Focus on memory access & block sizing  \n\u2022 Small iterative steps: Modify \u226420 lines per revision  \n\u2022 Maintain reversibility between versions\nHere is an example to show you how to rewrite a PyTorch implementation that quantizes a high-precision tensor to int8 dtype with row-wise granularity into a Triton implementation: \nThe original PyTorch implementation is as follows: \n``` \nimport torch\ndef per_row_quantize_int8(x: torch.Tensor) -> tuple[torch.Tensor, torch.Tensor]:\n    x_amax = x.abs().float().amax(dim=1).clamp(min=1e-4)\n    scale = 127 / x_amax\n    output = (x * scale[:, None]).round().clamp(-127, 127).to(torch.int8)\n    output_scale = x_amax / 127\n\n    return output, output_scale\n``` \nThe corresponding Triton-rewritten implementation is as follows: \n``` \nimport math\nimport torch\nimport triton\nimport triton.language as tl\nfrom triton.language.extra import libdevice\n\n# rowwise quantize\n\n@triton.autotune(\n    configs=[\n        triton.Config({}, num_stages=1, num_warps=8),\n        triton.Config({}, num_stages=2, num_warps=8),\n        triton.Config({}, num_stages=4, num_warps=8),\n        triton.Config({}, num_stages=8, num_warps=8),\n        triton.Config({}, num_stages=1),\n        triton.Config({}, num_stages=2),\n        triton.Config({}, num_stages=4),\n        triton.Config({}, num_stages=8),\n        triton.Config({}, num_warps=1),\n        triton.Config({}, num_warps=2),\n        triton.Config({}, num_warps=4),\n        triton.Config({}, num_warps=8),\n    ],\n    key=[\"n_elements\"],\n)\n\n@triton.jit\ndef _quantize_rowwise(\n    x_ptr,\n    output_ptr,\n    output_scale,\n    BLOCK_SIZE: tl.constexpr,\n    P2: tl.constexpr,\n):\n    pid = tl.program_id(axis=0)\n    block_start = pid * BLOCK_SIZE\n    arange = tl.arange(0, P2)\n    offsets = block_start + arange\n    row_mask = arange < BLOCK_SIZE\n    x = tl.load(x_ptr + offsets, mask=row_mask)\n\n    abs_x = tl.abs(x)\n    max_val = tl.max(tl.where(row_mask, abs_x, 0), axis=0)\n    output = libdevice.llrint(127.0 * (x / max_val))\n    tl.store(output_ptr + offsets, output, mask=row_mask)\n    tl.store(output_scale + pid, max_val / 127)\n\n\ndef per_row_quantize_int8(x: torch.Tensor):\n    x = x.contiguous()\n    output = torch.empty(*x.shape, device=x.device, dtype=torch.int8)\n    output_scale = torch.empty(x.shape[0], device=x.device, dtype=torch.float32)\n    P2 = int(2 ** (math.ceil(math.log2(x.shape[1]))))\n    grid = lambda x: (x.shape[0],)\n    _quantize_rowwise[grid](x, output, output_scale, BLOCK_SIZE=x.shape[1], P2=P2)\n\n    return output, output_scale\n\n\n    \n``` \n", "user": "# Current Program Information\n- Current performance metrics: - compiled: 1.0000\n- correctness: 1.0000\n- stage: success\n- passed: 0.0000\n- score: 20.0000\n- speed_up: 0.7900\n- runtime_ms: 0.1380\n- meta: {'hardware': 'NVIDIA L20Y', 'device': 'cuda:2', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.109, 'speed_up': 0.79, 'custom_timing': 0.138}\n- Areas identified for improvement: - Consider simplifying the code to improve readability and maintainability\n- Metrics showing improvement: runtime_ms. Consider continuing with similar changes.\n- Metrics showing regression: score, speed_up. Consider reverting or revising recent changes in these areas.\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Unknown changes\n- Performance: compiled: 1.0000, correctness: 1.0000, stage: success, passed: 1.0000, score: 34.5000, speed_up: 1.1450, runtime_ms: 0.0952, meta: {'hardware': 'NVIDIA L20Y', 'device': 'cuda:7', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.109, 'speed_up': 1.145, 'custom_timing': 0.0952}\n- Outcome: Improvement in all metrics\n\n\n### Attempt 2\n- Changes: Unknown changes\n- Performance: compiled: 1.0000, correctness: 1.0000, stage: success, passed: 1.0000, score: 40.0000, speed_up: 1.2000, runtime_ms: 0.0908, meta: {'hardware': 'NVIDIA L20Y', 'device': 'cuda:7', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.109, 'speed_up': 1.2, 'custom_timing': 0.0908}\n- Outcome: Improvement in all metrics\n\n\n### Attempt 1\n- Changes: Unknown changes\n- Performance: compiled: 1.0000, correctness: 1.0000, stage: success, passed: 1.0000, score: 52.9000, speed_up: 1.3290, runtime_ms: 0.0820, meta: {'hardware': 'NVIDIA L20Y', 'device': 'cuda:7', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.109, 'speed_up': 1.329, 'custom_timing': 0.082}\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 52.9000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport math\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef _fused_forward_kernel(\n    # Pointers\n    x_ptr,\n    gemm_weight_ptr,\n    gemm_bias_ptr,\n    gn_weight_ptr,\n    gn_bias_ptr,\n    mult_weight_ptr,\n    output_ptr,\n    # Shapes\n    batch_size,\n    in_features,\n    out_features,\n    num_groups,\n    group_size,\n    # Meta-parameters\n    eps: tl.constexpr,\n    BLOCK_SIZE_K: tl.constexpr,\n    BLOCK_SIZE_N: tl.constexpr,\n):\n    pid_batch = tl.program_id(0)\n    pid_group = tl.program_id(1)\n    \n    # Compute group boundaries\n    group_start = pid_group * group_size\n    group_range = tl.arange(0, BLOCK_SIZE_N)\n    feature_mask = group_range < group_size\n    \n    # Initialize accumulator\n    acc = tl.zeros((BLOCK_SIZE_N,), dtype=tl.float32)\n    x_ptr += pid_batch * in_features\n    \n    # Loop over input features with vectorized loads\n    for k in range(0, tl.cdiv(in_features, BLOCK_SIZE_K)):\n        k_offsets = k * BLOCK_SIZE_K + tl.arange(0, BLOCK_SIZE_K)\n        k_mask = k_offsets < in_features\n        \n        # Vectorized load\n        x_block = tl.load(\n            x_ptr + k_offsets,\n            mask=k_mask,\n            other=0.0,\n        )\n        \n        # Weight pointers\n        w_ptrs = gemm_weight_ptr + (group_start + group_range[:, None]) * in_features + k_offsets[None, :]\n        w_block = tl.load(\n            w_ptrs,\n            mask=k_mask[None, :] & feature_mask[:, None],\n            other=0.0,\n        )\n        \n        # Accumulate dot product\n        acc += tl.sum(w_block * x_block[None, :], axis=1)\n    \n    # Add bias\n    bias_ptrs = gemm_bias_ptr + group_start + group_range\n    bias = tl.load(bias_ptrs, mask=feature_mask, other=0.0)\n    acc += bias\n    \n    # Compute GroupNorm statistics\n    group_count = tl.sum(tl.cast(feature_mask, tl.float32))\n    mean = tl.sum(acc) / group_count\n    diff = acc - mean\n    var = tl.sum(diff * diff) / group_count\n    rstd = 1.0 / tl.sqrt(var + eps)\n    \n    # Apply GroupNorm\n    gn_weight = tl.load(gn_weight_ptr + group_start + group_range, mask=feature_mask, other=0.0)\n    gn_bias = tl.load(gn_bias_ptr + group_start + group_range, mask=feature_mask, other=0.0)\n    normalized = (diff * rstd) * gn_weight + gn_bias\n    \n    # Fused Swish operations\n    sig1 = tl.sigmoid(normalized)\n    swish1 = normalized * sig1\n    \n    # Multiply\n    mult_weight = tl.load(mult_weight_ptr + group_start + group_range, mask=feature_mask, other=0.0)\n    multiplied = swish1 * mult_weight\n    \n    # Second Swish\n    sig2 = tl.sigmoid(multiplied)\n    swish2 = multiplied * sig2\n    \n    # Store results\n    out_offsets = pid_batch * out_features + group_start + group_range\n    tl.store(output_ptr + out_offsets, swish2, mask=feature_mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, num_groups, multiply_weight_shape):\n        super(ModelNew, self).__init__()\n        self.gemm = nn.Linear(in_features, out_features)\n        self.group_norm = nn.GroupNorm(num_groups, out_features)\n        self.multiply_weight = nn.Parameter(torch.randn(multiply_weight_shape))\n        self.out_features = out_features\n        self.num_groups = num_groups\n\n    def forward(self, x):\n        batch_size, _ = x.shape\n        group_size = self.out_features // self.num_groups\n        P2 = int(2 ** math.ceil(math.log2(group_size)))\n        \n        # Ensure tensors are contiguous\n        x = x.contiguous()\n        output = torch.empty((batch_size, self.out_features), device=x.device, dtype=x.dtype)\n        \n        # Compute required number of warps\n        min_warps = max(1, (P2 + 31) // 32)\n        num_warps = 1\n        while num_warps < min_warps:\n            num_warps *= 2\n            \n        # Launch kernel\n        grid = (batch_size, self.num_groups)\n        _fused_forward_kernel[grid](\n            x, \n            self.gemm.weight, \n            self.gemm.bias,\n            self.group_norm.weight,\n            self.group_norm.bias,\n            self.multiply_weight,\n            output,\n            batch_size,\n            self.gemm.in_features,\n            self.out_features,\n            self.num_groups,\n            group_size,\n            eps=1e-5,\n            BLOCK_SIZE_K=128,\n            BLOCK_SIZE_N=P2,\n            num_warps=num_warps,\n            num_stages=2\n        )\n        return output\n\nbatch_size = 128\nin_features = 512\nout_features = 1024\nnum_groups = 16\nmultiply_weight_shape = (out_features,)\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, num_groups, multiply_weight_shape]\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Performs well on compiled (1.0000), Performs well on correctness (1.0000), Performs well on stage (success), Performs well on passed (1.0000), Performs well on score (52.9000), Performs well on speed_up (1.3290), Performs well on runtime_ms (0.0820), Performs well on meta ({'hardware': 'NVIDIA L20Y', 'device': 'cuda:7', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.109, 'speed_up': 1.329, 'custom_timing': 0.082})\n\n\n### Program 2 (Score: 40.0000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_SIZE_K': 64}, num_warps=2),\n        triton.Config({'BLOCK_SIZE_K': 128}, num_warps=2),\n        triton.Config({'BLOCK_SIZE_K': 256}, num_warps=2),\n        triton.Config({'BLOCK_SIZE_K': 512}, num_warps=2),\n        triton.Config({'BLOCK_SIZE_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_K': 128}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_K': 256}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_K': 512}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_K': 64}, num_warps=8),\n        triton.Config({'BLOCK_SIZE_K': 128}, num_warps=8),\n        triton.Config({'BLOCK_SIZE_K': 256}, num_warps=8),\n        triton.Config({'BLOCK_SIZE_K': 512}, num_warps=8),\n    ],\n    key=['batch_size', 'in_features', 'out_features', 'num_groups'],\n)\n@triton.jit\ndef _fused_forward_kernel(\n    # Pointers\n    x_ptr,\n    gemm_weight_ptr,\n    gemm_bias_ptr,\n    gn_weight_ptr,\n    gn_bias_ptr,\n    mult_weight_ptr,\n    output_ptr,\n    # Shapes\n    batch_size,\n    in_features,\n    out_features,\n    num_groups,\n    # Meta-parameters\n    eps: tl.constexpr,\n    BLOCK_SIZE_K: tl.constexpr,\n    GROUP_SIZE: tl.constexpr,\n):\n    pid_batch = tl.program_id(0)\n    pid_group = tl.program_id(1)\n    \n    # Compute group boundaries\n    group_start = pid_group * GROUP_SIZE\n    group_range = tl.arange(0, GROUP_SIZE)\n    feature_mask = group_range < (out_features - group_start)\n    \n    # Initialize accumulator\n    acc = tl.zeros((GROUP_SIZE,), dtype=tl.float32)\n    x_ptrs = x_ptr + pid_batch * in_features\n    \n    # Loop over input features with vectorized loads\n    for k in range(0, tl.cdiv(in_features, BLOCK_SIZE_K)):\n        k_offsets = k * BLOCK_SIZE_K + tl.arange(0, BLOCK_SIZE_K)\n        k_mask = k_offsets < in_features\n        \n        # Vectorized load\n        x_block = tl.load(\n            x_ptrs + k_offsets,\n            mask=k_mask,\n            other=0.0\n        )\n        \n        # Weight pointers with precomputation\n        w_start = (group_start + group_range[:, None]) * in_features\n        w_ptrs = gemm_weight_ptr + w_start + k_offsets[None, :]\n        w_block = tl.load(\n            w_ptrs,\n            mask=k_mask[None, :] & feature_mask[:, None],\n            other=0.0\n        )\n        \n        # Accumulate with efficient dot product\n        acc += tl.sum(w_block * x_block[None, :], axis=1)\n    \n    # Add bias\n    bias_ptrs = gemm_bias_ptr + group_start + group_range\n    bias = tl.load(bias_ptrs, mask=feature_mask, other=0.0)\n    acc += bias\n    \n    # Compute GroupNorm statistics (corrected group size)\n    group_count = tl.sum(tl.cast(feature_mask, tl.float32))\n    mean = tl.sum(acc) / group_count\n    diff = acc - mean\n    var = tl.sum(diff * diff) / group_count\n    rstd = 1.0 / tl.sqrt(var + eps)\n    \n    # Apply GroupNorm with fused operations\n    gn_weight = tl.load(gn_weight_ptr + group_start + group_range, mask=feature_mask, other=0.0)\n    gn_bias = tl.load(gn_bias_ptr + group_start + group_range, mask=feature_mask, other=0.0)\n    normalized = (diff * rstd) * gn_weight + gn_bias\n    \n    # Fused Swish operations\n    sig1 = tl.sigmoid(normalized)\n    swish1 = normalized * sig1\n    \n    # Multiply\n    mult_weight = tl.load(mult_weight_ptr + group_start + group_range, mask=feature_mask, other=0.0)\n    multiplied = swish1 * mult_weight\n    \n    # Second Swish (fused)\n    sig2 = tl.sigmoid(multiplied)\n    swish2 = multiplied * sig2\n    \n    # Store results with coalesced writes\n    out_offsets = pid_batch * out_features + group_start + group_range\n    tl.store(output_ptr + out_offsets, swish2, mask=feature_mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, num_groups, multiply_weight_shape):\n        super(ModelNew, self).__init__()\n        self.gemm = nn.Linear(in_features, out_features)\n        self.group_norm = nn.GroupNorm(num_groups, out_features)\n        self.multiply_weight = nn.Parameter(torch.randn(multiply_weight_shape))\n        self.out_features = out_features\n        self.num_groups = num_groups\n\n    def forward(self, x):\n        batch_size, _ = x.shape\n        group_size = self.out_features // self.num_groups\n        \n        # Ensure tensors are contiguous\n        x = x.contiguous()\n        output = torch.empty((batch_size, self.out_features), device=x.device, dtype=x.dtype)\n        \n        # Launch kernel with optimized parameters\n        grid = (batch_size, self.num_groups)\n        _fused_forward_kernel[grid](\n            x, \n            self.gemm.weight, \n            self.gemm.bias,\n            self.group_norm.weight,\n            self.group_norm.bias,\n            self.multiply_weight,\n            output,\n            batch_size,\n            self.gemm.in_features,\n            self.out_features,\n            self.num_groups,\n            eps=1e-5,\n            GROUP_SIZE=group_size\n        )\n        return output\n\nbatch_size = 128\nin_features = 512\nout_features = 1024\nnum_groups = 16\nmultiply_weight_shape = (out_features,)\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, num_groups, multiply_weight_shape]\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Performs well on compiled (1.0000), Performs well on correctness (1.0000), Performs well on stage (success), Performs well on passed (1.0000), Performs well on score (40.0000), Performs well on speed_up (1.2000), Performs well on runtime_ms (0.0908), Performs well on meta ({'hardware': 'NVIDIA L20Y', 'device': 'cuda:7', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.109, 'speed_up': 1.2, 'custom_timing': 0.0908})\n\n\n### Program 3 (Score: 34.5000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef _fused_forward_kernel(\n    # Pointers\n    x_ptr,\n    gemm_weight_ptr,\n    gemm_bias_ptr,\n    gn_weight_ptr,\n    gn_bias_ptr,\n    mult_weight_ptr,\n    output_ptr,\n    # Shapes\n    batch_size,\n    in_features,\n    out_features,\n    num_groups,\n    # Meta-parameters\n    eps: tl.constexpr,\n    BLOCK_SIZE_K: tl.constexpr,\n    GROUP_SIZE: tl.constexpr,\n):\n    pid_batch = tl.program_id(0)\n    pid_group = tl.program_id(1)\n    \n    # Compute group boundaries\n    group_start = pid_group * GROUP_SIZE\n    group_range = tl.arange(0, GROUP_SIZE)\n    feature_mask = group_range < (out_features - group_start)\n    \n    # Initialize accumulator\n    acc = tl.zeros((GROUP_SIZE,), dtype=tl.float32)\n    x_ptrs = x_ptr + pid_batch * in_features\n    \n    # Loop over input features with vectorized loads\n    for k in range(0, tl.cdiv(in_features, BLOCK_SIZE_K)):\n        k_offsets = k * BLOCK_SIZE_K + tl.arange(0, BLOCK_SIZE_K)\n        k_mask = k_offsets < in_features\n        \n        # Vectorized load\n        x_block = tl.load(\n            x_ptrs + k_offsets,\n            mask=k_mask,\n            other=0.0\n        )\n        \n        # Weight pointers with precomputation\n        w_start = (group_start + group_range[:, None]) * in_features\n        w_ptrs = gemm_weight_ptr + w_start + k_offsets[None, :]\n        w_block = tl.load(\n            w_ptrs,\n            mask=k_mask[None, :] & feature_mask[:, None],\n            other=0.0\n        )\n        \n        # Accumulate with efficient dot product\n        acc += tl.sum(w_block * x_block[None, :], axis=1)\n    \n    # Add bias\n    bias_ptrs = gemm_bias_ptr + group_start + group_range\n    bias = tl.load(bias_ptrs, mask=feature_mask, other=0.0)\n    acc += bias\n    \n    # Compute GroupNorm statistics (corrected group size)\n    group_count = tl.sum(tl.cast(feature_mask, tl.float32))\n    mean = tl.sum(acc) / group_count\n    diff = acc - mean\n    var = tl.sum(diff * diff) / group_count\n    rstd = 1.0 / tl.sqrt(var + eps)\n    \n    # Apply GroupNorm with fused operations\n    gn_weight = tl.load(gn_weight_ptr + group_start + group_range, mask=feature_mask, other=0.0)\n    gn_bias = tl.load(gn_bias_ptr + group_start + group_range, mask=feature_mask, other=0.0)\n    normalized = (diff * rstd) * gn_weight + gn_bias\n    \n    # Fused Swish operations\n    sig1 = tl.sigmoid(normalized)\n    swish1 = normalized * sig1\n    \n    # Multiply\n    mult_weight = tl.load(mult_weight_ptr + group_start + group_range, mask=feature_mask, other=0.0)\n    multiplied = swish1 * mult_weight\n    \n    # Second Swish (fused)\n    sig2 = tl.sigmoid(multiplied)\n    swish2 = multiplied * sig2\n    \n    # Store results with coalesced writes\n    out_offsets = pid_batch * out_features + group_start + group_range\n    tl.store(output_ptr + out_offsets, swish2, mask=feature_mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, num_groups, multiply_weight_shape):\n        super(ModelNew, self).__init__()\n        self.gemm = nn.Linear(in_features, out_features)\n        self.group_norm = nn.GroupNorm(num_groups, out_features)\n        self.multiply_weight = nn.Parameter(torch.randn(multiply_weight_shape))\n        self.out_features = out_features\n        self.num_groups = num_groups\n\n    def forward(self, x):\n        batch_size, _ = x.shape\n        group_size = self.out_features // self.num_groups\n        \n        # Ensure tensors are contiguous\n        x = x.contiguous()\n        output = torch.empty((batch_size, self.out_features), device=x.device, dtype=x.dtype)\n        \n        # Launch kernel with optimized parameters\n        grid = (batch_size, self.num_groups)\n        _fused_forward_kernel[grid](\n            x, \n            self.gemm.weight, \n            self.gemm.bias,\n            self.group_norm.weight,\n            self.group_norm.bias,\n            self.multiply_weight,\n            output,\n            batch_size,\n            self.gemm.in_features,\n            self.out_features,\n            self.num_groups,\n            eps=1e-5,\n            BLOCK_SIZE_K=256,  # Increased for better memory efficiency\n            GROUP_SIZE=group_size\n        )\n        return output\n\nbatch_size = 128\nin_features = 512\nout_features = 1024\nnum_groups = 16\nmultiply_weight_shape = (out_features,)\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, num_groups, multiply_weight_shape]\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Performs well on compiled (1.0000), Performs well on correctness (1.0000), Performs well on stage (success), Performs well on passed (1.0000), Performs well on score (34.5000), Performs well on speed_up (1.1450), Performs well on runtime_ms (0.0952), Performs well on meta ({'hardware': 'NVIDIA L20Y', 'device': 'cuda:7', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.109, 'speed_up': 1.145, 'custom_timing': 0.0952})\n\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 31.2000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_SIZE_K': 64}, num_warps=4, num_stages=4),\n        triton.Config({'BLOCK_SIZE_K': 128}, num_warps=4, num_stages=4),\n        triton.Config({'BLOCK_SIZE_K': 256}, num_warps=4, num_stages=3),\n        triton.Config({'BLOCK_SIZE_K': 512}, num_warps=8, num_stages=2),\n        triton.Config({'BLOCK_SIZE_K': 64}, num_warps=8, num_stages=3),\n        triton.Config({'BLOCK_SIZE_K': 128}, num_warps=8, num_stages=3),\n    ],\n    key=['in_features'],\n)\n@triton.jit\ndef _fused_forward_kernel(\n    # Pointers\n    x_ptr,\n    gemm_weight_ptr,\n    gemm_bias_ptr,\n    gn_weight_ptr,\n    gn_bias_ptr,\n    mult_weight_ptr,\n    output_ptr,\n    # Shapes\n    batch_size,\n    in_features,\n    out_features,\n    num_groups,\n    # Meta-parameters\n    eps: tl.constexpr,\n    BLOCK_SIZE_K: tl.constexpr,\n    GROUP_SIZE: tl.constexpr,\n):\n    pid_batch = tl.program_id(0)\n    pid_group = tl.program_id(1)\n    \n    # Compute group boundaries\n    group_start = pid_group * GROUP_SIZE\n    group_range = tl.arange(0, GROUP_SIZE)\n    feature_mask = group_range < (out_features - group_start)\n    \n    # Precompute weight row pointers for coalesced access\n    weight_row_start = group_start * in_features\n    row_ptrs = gemm_weight_ptr + weight_row_start + group_range[:, None] * in_features\n    \n    # Initialize accumulator\n    acc = tl.zeros((GROUP_SIZE,), dtype=tl.float32)\n    x_ptrs = x_ptr + pid_batch * in_features\n    \n    # Loop over input features with vectorized loads\n    for k in range(0, tl.cdiv(in_features, BLOCK_SIZE_K)):\n        k_offsets = k * BLOCK_SIZE_K + tl.arange(0, BLOCK_SIZE_K)\n        k_mask = k_offsets < in_features\n        \n        # Vectorized load\n        x_block = tl.load(\n            x_ptrs + k_offsets,\n            mask=k_mask,\n            other=0.0\n        )\n        \n        # Load weight block using precomputed row pointers\n        w_ptrs = row_ptrs + k_offsets[None, :]\n        w_block = tl.load(\n            w_ptrs,\n            mask=k_mask[None, :] & feature_mask[:, None],\n            other=0.0\n        )\n        \n        # Efficient accumulation\n        acc += tl.sum(w_block * x_block[None, :], axis=1)\n    \n    # Add bias\n    bias_ptrs = gemm_bias_ptr + group_start + group_range\n    bias = tl.load(bias_ptrs, mask=feature_mask, other=0.0)\n    acc += bias\n    \n    # Compute GroupNorm statistics\n    group_count = tl.sum(tl.cast(feature_mask, tl.float32))\n    mean = tl.sum(acc) / group_count\n    diff = acc - mean\n    var = tl.sum(diff * diff) / group_count\n    rstd = 1.0 / tl.sqrt(var + eps)\n    \n    # Apply GroupNorm with fused operations\n    gn_weight = tl.load(gn_weight_ptr + group_start + group_range, mask=feature_mask, other=0.0)\n    gn_bias = tl.load(gn_bias_ptr + group_start + group_range, mask=feature_mask, other=0.0)\n    normalized = (diff * rstd) * gn_weight + gn_bias\n    \n    # Fused Swish operations\n    swish1 = normalized * tl.sigmoid(normalized)\n    multiplied = swish1 * tl.load(mult_weight_ptr + group_start + group_range, mask=feature_mask, other=0.0)\n    swish2 = multiplied * tl.sigmoid(multiplied)\n    \n    # Store results\n    out_offsets = pid_batch * out_features + group_start + group_range\n    tl.store(output_ptr + out_offsets, swish2, mask=feature_mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, num_groups, multiply_weight_shape):\n        super(ModelNew, self).__init__()\n        self.gemm = nn.Linear(in_features, out_features)\n        self.group_norm = nn.GroupNorm(num_groups, out_features)\n        self.multiply_weight = nn.Parameter(torch.randn(multiply_weight_shape))\n        self.out_features = out_features\n        self.num_groups = num_groups\n\n    def forward(self, x):\n        batch_size, _ = x.shape\n        group_size = self.out_features // self.num_groups\n        \n        # Ensure tensors are contiguous\n        x = x.contiguous()\n        output = torch.empty((batch_size, self.out_features), device=x.device, dtype=x.dtype)\n        \n        # Launch kernel with optimized parameters\n        grid = (batch_size, self.num_groups)\n        _fused_forward_kernel[grid](\n            x, \n            self.gemm.weight, \n            self.gemm.bias,\n            self.group_norm.weight,\n            self.group_norm.bias,\n            self.multiply_weight,\n            output,\n            batch_size,\n            self.gemm.in_features,\n            self.out_features,\n            self.num_groups,\n            eps=1e-5,\n            GROUP_SIZE=group_size\n        )\n        return output\n\nbatch_size = 128\nin_features = 512\nout_features = 1024\nnum_groups = 16\nmultiply_weight_shape = (out_features,)\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, num_groups, multiply_weight_shape]\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Alternative approach to compiled, Alternative approach to correctness\n\n\n### Program D2 (Score: 20.0000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\nimport math\n\n# Triton kernel for optimized GEMM operation\n@triton.jit\ndef _gemm_kernel(\n    a_ptr, b_ptr, c_ptr,\n    M, N, K,\n    stride_am, stride_ak,\n    stride_bk, stride_bn,\n    stride_cm, stride_cn,\n    BLOCK_M: tl.constexpr, BLOCK_N: tl.constexpr, BLOCK_K: tl.constexpr\n):\n    pid = tl.program_id(0)\n    grid_m = tl.cdiv(M, BLOCK_M)\n    grid_n = tl.cdiv(N, BLOCK_N)\n    \n    pid_m = pid // grid_n\n    pid_n = pid % grid_n\n    \n    offs_m = pid_m * BLOCK_M + tl.arange(0, BLOCK_M)\n    offs_n = pid_n * BLOCK_N + tl.arange(0, BLOCK_N)\n    offs_k = tl.arange(0, BLOCK_K)\n    \n    a_ptrs = a_ptr + offs_m[:, None] * stride_am + offs_k[None, :] * stride_ak\n    b_ptrs = b_ptr + offs_k[:, None] * stride_bk + offs_n[None, :] * stride_bn\n    \n    accumulator = tl.zeros((BLOCK_M, BLOCK_N), dtype=tl.float32)\n    for k in range(0, K, BLOCK_K):\n        mask_a = (offs_m[:, None] < M) & (offs_k[None, :] < K - k)\n        mask_b = (offs_k[:, None] < K - k) & (offs_n[None, :] < N)\n        \n        a = tl.load(a_ptrs, mask=mask_a, other=0.0)\n        b = tl.load(b_ptrs, mask=mask_b, other=0.0)\n        \n        accumulator += tl.dot(a, b)\n        a_ptrs += BLOCK_K * stride_ak\n        b_ptrs += BLOCK_K * stride_bk\n    \n    offs_cm = pid_m * BLOCK_M + tl.arange(0, BLOCK_M)\n    offs_cn = pid_n * BLOCK_N + tl.arange(0, BLOCK_N)\n    c_ptrs = c_ptr + stride_cm * offs_cm[:, None] + stride_cn * offs_cn[None, :]\n    \n    mask_c = (offs_cm[:, None] < M) & (offs_cn[None, :] < N)\n    tl.store(c_ptrs, accumulator, mask=mask_c)\n\n# Optimized Linear module using Triton\nclass TritonLinear(nn.Module):\n    def __init__(self, in_features, out_features):\n        super().__init__()\n        self.in_features = in_features\n        self.out_features = out_features\n        self.weight = nn.Parameter(torch.empty(out_features, in_features))\n        self.bias = nn.Parameter(torch.empty(out_features))\n        self.reset_parameters()\n\n    def reset_parameters(self):\n        nn.init.kaiming_uniform_(self.weight, a=math.sqrt(5))\n        fan_in, _ = nn.init._calculate_fan_in_and_fan_out(self.weight)\n        bound = 1 / math.sqrt(fan_in) if fan_in > 0 else 0\n        nn.init.uniform_(self.bias, -bound, bound)\n\n    def forward(self, x):\n        output = torch.empty(\n            x.size(0), \n            self.out_features, \n            device=x.device, \n            dtype=x.dtype\n        )\n        \n        grid = lambda M, N: (triton.cdiv(M, 64) * triton.cdiv(N, 64),)\n        \n        _gemm_kernel[grid(x.size(0), self.out_features)](\n            x, self.weight, output,\n            x.size(0), self.out_features, self.in_features,\n            x.stride(0), x.stride(1),\n            self.weight.stride(1), self.weight.stride(0),  # Fixed weight strides\n            output.stride(0), output.stride(1),\n            BLOCK_M=64, BLOCK_N=64, BLOCK_K=32\n        )\n        \n        output += self.bias\n        return output\n\nclass ModelNew(nn.Module):\n    \"\"\"\n    Model that performs a GEMM, GroupNorm, Swish, Multiply, and Swish operations.\n    \"\"\"\n    def __init__(self, in_features, out_features, num_groups, multiply_weight_shape):\n        super(ModelNew, self).__init__()\n        self.gemm = TritonLinear(in_features, out_features)\n        self.group_norm = nn.GroupNorm(num_groups, out_features)\n        self.multiply_weight = nn.Parameter(torch.randn(multiply_weight_shape)) \n\n    def forward(self, x):\n        # (batch_size, in_features) -> (batch_size, out_features)\n        x = self.gemm(x)\n        # (batch_size, out_features) -> (batch_size, out_features)\n        x = self.group_norm(x)\n        # (batch_size, out_features) -> (batch_size, out_features)\n        x = x * torch.sigmoid(x)\n        # (batch_size, out_features) -> (batch_size, out_features)\n        x = x * self.multiply_weight\n        # (batch_size, out_features) -> (batch_size, out_features)\n        x = x * torch.sigmoid(x)\n        return x\n\nbatch_size = 128\nin_features = 512\nout_features = 1024\nnum_groups = 16\nmultiply_weight_shape = (out_features,)\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, num_groups, multiply_weight_shape]\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Alternative approach to compiled, Alternative approach to correctness\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 52.9000, Type: High-Performer)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport math\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef _fused_forward_kernel(\n    # Pointers\n    x_ptr,\n    gemm_weight_ptr,\n    gemm_bias_ptr,\n    gn_weight_ptr,\n    gn_bias_ptr,\n    mult_weight_ptr,\n    output_ptr,\n    # Shapes\n    batch_size,\n    in_features,\n    out_features,\n    num_groups,\n    group_size,\n    # Meta-parameters\n    eps: tl.constexpr,\n    BLOCK_SIZE_K: tl.constexpr,\n    BLOCK_SIZE_N: tl.constexpr,\n):\n    pid_batch = tl.program_id(0)\n    pid_group = tl.program_id(1)\n    \n    # Compute group boundaries\n    group_start = pid_group * group_size\n    group_range = tl.arange(0, BLOCK_SIZE_N)\n    feature_mask = group_range < group_size\n    \n    # Initialize accumulator\n    acc = tl.zeros((BLOCK_SIZE_N,), dtype=tl.float32)\n    x_ptr += pid_batch * in_features\n    \n    # Loop over input features with vectorized loads\n    for k in range(0, tl.cdiv(in_features, BLOCK_SIZE_K)):\n        k_offsets = k * BLOCK_SIZE_K + tl.arange(0, BLOCK_SIZE_K)\n        k_mask = k_offsets < in_features\n        \n        # Vectorized load\n        x_block = tl.load(\n            x_ptr + k_offsets,\n            mask=k_mask,\n            other=0.0,\n        )\n        \n        # Weight pointers\n        w_ptrs = gemm_weight_ptr + (group_start + group_range[:, None]) * in_features + k_offsets[None, :]\n        w_block = tl.load(\n            w_ptrs,\n            mask=k_mask[None, :] & feature_mask[:, None],\n            other=0.0,\n        )\n        \n        # Accumulate dot product\n        acc += tl.sum(w_block * x_block[None, :], axis=1)\n    \n    # Add bias\n    bias_ptrs = gemm_bias_ptr + group_start + group_range\n    bias = tl.load(bias_ptrs, mask=feature_mask, other=0.0)\n    acc += bias\n    \n    # Compute GroupNorm statistics\n    group_count = tl.sum(tl.cast(feature_mask, tl.float32))\n    mean = tl.sum(acc) / group_count\n    diff = acc - mean\n    var = tl.sum(diff * diff) / group_count\n    rstd = 1.0 / tl.sqrt(var + eps)\n    \n    # Apply GroupNorm\n    gn_weight = tl.load(gn_weight_ptr + group_start + group_range, mask=feature_mask, other=0.0)\n    gn_bias = tl.load(gn_bias_ptr + group_start + group_range, mask=feature_mask, other=0.0)\n    normalized = (diff * rstd) * gn_weight + gn_bias\n    \n    # Fused Swish operations\n    sig1 = tl.sigmoid(normalized)\n    swish1 = normalized * sig1\n    \n    # Multiply\n    mult_weight = tl.load(mult_weight_ptr + group_start + group_range, mask=feature_mask, other=0.0)\n    multiplied = swish1 * mult_weight\n    \n    # Second Swish\n    sig2 = tl.sigmoid(multiplied)\n    swish2 = multiplied * sig2\n    \n    # Store results\n    out_offsets = pid_batch * out_features + group_start + group_range\n    tl.store(output_ptr + out_offsets, swish2, mask=feature_mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, num_groups, multiply_weight_shape):\n        super(ModelNew, self).__init__()\n        self.gemm = nn.Linear(in_features, out_features)\n        self.group_norm = nn.GroupNorm(num_groups, out_features)\n        self.multiply_weight = nn.Parameter(torch.randn(multiply_weight_shape))\n        self.out_features = out_features\n        self.num_groups = num_groups\n\n    def forward(self, x):\n        batch_size, _ = x.shape\n        group_size = self.out_features // self.num_groups\n        P2 = int(2 ** math.ceil(math.log2(group_size)))\n        \n        # Ensure tensors are contiguous\n        x = x.contiguous()\n        output = torch.empty((batch_size, self.out_features), device=x.device, dtype=x.dtype)\n        \n        # Compute required number of warps\n        min_warps = max(1, (P2 + 31) // 32)\n        num_warps = 1\n        while num_warps < min_warps:\n            num_warps *= 2\n            \n        # Launch kernel\n        grid = (batch_size, self.num_groups)\n        _fused_forward_kernel[grid](\n            x, \n            self.gemm.weight, \n            self.gemm.bias,\n            self.group_norm.weight,\n            self.group_norm.bias,\n            self.multiply_weight,\n            output,\n            batch_size,\n            self.gemm.in_features,\n            self.out_features,\n            self.num_groups,\n            group_size,\n            eps=1e-5,\n            BLOCK_SIZE_K=128,\n            BLOCK_SIZE_N=P2,\n            num_warps=num_warps,\n            num_stages=2\n        )\n        return output\n\nbatch_size = 128\nin_features = 512\nout_features = 1024\nnum_groups = 16\nmultiply_weight_shape = (out_features,)\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, num_groups, multiply_weight_shape]\n# =================== EVOLVE-BLOCK-END ===================\n```\nUnique approach: Modification: Full rewrite, Excellent compiled (1.000), Excellent correctness (1.000)\n\n\n### Inspiration 2 (Score: 31.2000, Type: High-Performer)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_SIZE_K': 64}, num_warps=4, num_stages=4),\n        triton.Config({'BLOCK_SIZE_K': 128}, num_warps=4, num_stages=4),\n        triton.Config({'BLOCK_SIZE_K': 256}, num_warps=4, num_stages=3),\n        triton.Config({'BLOCK_SIZE_K': 512}, num_warps=8, num_stages=2),\n        triton.Config({'BLOCK_SIZE_K': 64}, num_warps=8, num_stages=3),\n        triton.Config({'BLOCK_SIZE_K': 128}, num_warps=8, num_stages=3),\n    ],\n    key=['in_features'],\n)\n@triton.jit\ndef _fused_forward_kernel(\n    # Pointers\n    x_ptr,\n    gemm_weight_ptr,\n    gemm_bias_ptr,\n    gn_weight_ptr,\n    gn_bias_ptr,\n    mult_weight_ptr,\n    output_ptr,\n    # Shapes\n    batch_size,\n    in_features,\n    out_features,\n    num_groups,\n    # Meta-parameters\n    eps: tl.constexpr,\n    BLOCK_SIZE_K: tl.constexpr,\n    GROUP_SIZE: tl.constexpr,\n):\n    pid_batch = tl.program_id(0)\n    pid_group = tl.program_id(1)\n    \n    # Compute group boundaries\n    group_start = pid_group * GROUP_SIZE\n    group_range = tl.arange(0, GROUP_SIZE)\n    feature_mask = group_range < (out_features - group_start)\n    \n    # Precompute weight row pointers for coalesced access\n    weight_row_start = group_start * in_features\n    row_ptrs = gemm_weight_ptr + weight_row_start + group_range[:, None] * in_features\n    \n    # Initialize accumulator\n    acc = tl.zeros((GROUP_SIZE,), dtype=tl.float32)\n    x_ptrs = x_ptr + pid_batch * in_features\n    \n    # Loop over input features with vectorized loads\n    for k in range(0, tl.cdiv(in_features, BLOCK_SIZE_K)):\n        k_offsets = k * BLOCK_SIZE_K + tl.arange(0, BLOCK_SIZE_K)\n        k_mask = k_offsets < in_features\n        \n        # Vectorized load\n        x_block = tl.load(\n            x_ptrs + k_offsets,\n            mask=k_mask,\n            other=0.0\n        )\n        \n        # Load weight block using precomputed row pointers\n        w_ptrs = row_ptrs + k_offsets[None, :]\n        w_block = tl.load(\n            w_ptrs,\n            mask=k_mask[None, :] & feature_mask[:, None],\n            other=0.0\n        )\n        \n        # Efficient accumulation\n        acc += tl.sum(w_block * x_block[None, :], axis=1)\n    \n    # Add bias\n    bias_ptrs = gemm_bias_ptr + group_start + group_range\n    bias = tl.load(bias_ptrs, mask=feature_mask, other=0.0)\n    acc += bias\n    \n    # Compute GroupNorm statistics\n    group_count = tl.sum(tl.cast(feature_mask, tl.float32))\n    mean = tl.sum(acc) / group_count\n    diff = acc - mean\n    var = tl.sum(diff * diff) / group_count\n    rstd = 1.0 / tl.sqrt(var + eps)\n    \n    # Apply GroupNorm with fused operations\n    gn_weight = tl.load(gn_weight_ptr + group_start + group_range, mask=feature_mask, other=0.0)\n    gn_bias = tl.load(gn_bias_ptr + group_start + group_range, mask=feature_mask, other=0.0)\n    normalized = (diff * rstd) * gn_weight + gn_bias\n    \n    # Fused Swish operations\n    swish1 = normalized * tl.sigmoid(normalized)\n    multiplied = swish1 * tl.load(mult_weight_ptr + group_start + group_range, mask=feature_mask, other=0.0)\n    swish2 = multiplied * tl.sigmoid(multiplied)\n    \n    # Store results\n    out_offsets = pid_batch * out_features + group_start + group_range\n    tl.store(output_ptr + out_offsets, swish2, mask=feature_mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, num_groups, multiply_weight_shape):\n        super(ModelNew, self).__init__()\n        self.gemm = nn.Linear(in_features, out_features)\n        self.group_norm = nn.GroupNorm(num_groups, out_features)\n        self.multiply_weight = nn.Parameter(torch.randn(multiply_weight_shape))\n        self.out_features = out_features\n        self.num_groups = num_groups\n\n    def forward(self, x):\n        batch_size, _ = x.shape\n        group_size = self.out_features // self.num_groups\n        \n        # Ensure tensors are contiguous\n        x = x.contiguous()\n        output = torch.empty((batch_size, self.out_features), device=x.device, dtype=x.dtype)\n        \n        # Launch kernel with optimized parameters\n        grid = (batch_size, self.num_groups)\n        _fused_forward_kernel[grid](\n            x, \n            self.gemm.weight, \n            self.gemm.bias,\n            self.group_norm.weight,\n            self.group_norm.bias,\n            self.multiply_weight,\n            output,\n            batch_size,\n            self.gemm.in_features,\n            self.out_features,\n            self.num_groups,\n            eps=1e-5,\n            GROUP_SIZE=group_size\n        )\n        return output\n\nbatch_size = 128\nin_features = 512\nout_features = 1024\nnum_groups = 16\nmultiply_weight_shape = (out_features,)\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, num_groups, multiply_weight_shape]\n# =================== EVOLVE-BLOCK-END ===================\n```\nUnique approach: Modification: Full rewrite, Excellent compiled (1.000), Excellent correctness (1.000)\n\n\n### Inspiration 3 (Score: 34.5000, Type: High-Performer)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef _fused_forward_kernel(\n    # Pointers\n    x_ptr,\n    gemm_weight_ptr,\n    gemm_bias_ptr,\n    gn_weight_ptr,\n    gn_bias_ptr,\n    mult_weight_ptr,\n    output_ptr,\n    # Shapes\n    batch_size,\n    in_features,\n    out_features,\n    num_groups,\n    # Meta-parameters\n    eps: tl.constexpr,\n    BLOCK_SIZE_K: tl.constexpr,\n    GROUP_SIZE: tl.constexpr,\n):\n    pid_batch = tl.program_id(0)\n    pid_group = tl.program_id(1)\n    \n    # Compute group boundaries\n    group_start = pid_group * GROUP_SIZE\n    group_range = tl.arange(0, GROUP_SIZE)\n    feature_mask = group_range < (out_features - group_start)\n    \n    # Initialize accumulator\n    acc = tl.zeros((GROUP_SIZE,), dtype=tl.float32)\n    x_ptrs = x_ptr + pid_batch * in_features\n    \n    # Loop over input features with vectorized loads\n    for k in range(0, tl.cdiv(in_features, BLOCK_SIZE_K)):\n        k_offsets = k * BLOCK_SIZE_K + tl.arange(0, BLOCK_SIZE_K)\n        k_mask = k_offsets < in_features\n        \n        # Vectorized load\n        x_block = tl.load(\n            x_ptrs + k_offsets,\n            mask=k_mask,\n            other=0.0\n        )\n        \n        # Weight pointers with precomputation\n        w_start = (group_start + group_range[:, None]) * in_features\n        w_ptrs = gemm_weight_ptr + w_start + k_offsets[None, :]\n        w_block = tl.load(\n            w_ptrs,\n            mask=k_mask[None, :] & feature_mask[:, None],\n            other=0.0\n        )\n        \n        # Accumulate with efficient dot product\n        acc += tl.sum(w_block * x_block[None, :], axis=1)\n    \n    # Add bias\n    bias_ptrs = gemm_bias_ptr + group_start + group_range\n    bias = tl.load(bias_ptrs, mask=feature_mask, other=0.0)\n    acc += bias\n    \n    # Compute GroupNorm statistics (corrected group size)\n    group_count = tl.sum(tl.cast(feature_mask, tl.float32))\n    mean = tl.sum(acc) / group_count\n    diff = acc - mean\n    var = tl.sum(diff * diff) / group_count\n    rstd = 1.0 / tl.sqrt(var + eps)\n    \n    # Apply GroupNorm with fused operations\n    gn_weight = tl.load(gn_weight_ptr + group_start + group_range, mask=feature_mask, other=0.0)\n    gn_bias = tl.load(gn_bias_ptr + group_start + group_range, mask=feature_mask, other=0.0)\n    normalized = (diff * rstd) * gn_weight + gn_bias\n    \n    # Fused Swish operations\n    sig1 = tl.sigmoid(normalized)\n    swish1 = normalized * sig1\n    \n    # Multiply\n    mult_weight = tl.load(mult_weight_ptr + group_start + group_range, mask=feature_mask, other=0.0)\n    multiplied = swish1 * mult_weight\n    \n    # Second Swish (fused)\n    sig2 = tl.sigmoid(multiplied)\n    swish2 = multiplied * sig2\n    \n    # Store results with coalesced writes\n    out_offsets = pid_batch * out_features + group_start + group_range\n    tl.store(output_ptr + out_offsets, swish2, mask=feature_mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, num_groups, multiply_weight_shape):\n        super(ModelNew, self).__init__()\n        self.gemm = nn.Linear(in_features, out_features)\n        self.group_norm = nn.GroupNorm(num_groups, out_features)\n        self.multiply_weight = nn.Parameter(torch.randn(multiply_weight_shape))\n        self.out_features = out_features\n        self.num_groups = num_groups\n\n    def forward(self, x):\n        batch_size, _ = x.shape\n        group_size = self.out_features // self.num_groups\n        \n        # Ensure tensors are contiguous\n        x = x.contiguous()\n        output = torch.empty((batch_size, self.out_features), device=x.device, dtype=x.dtype)\n        \n        # Launch kernel with optimized parameters\n        grid = (batch_size, self.num_groups)\n        _fused_forward_kernel[grid](\n            x, \n            self.gemm.weight, \n            self.gemm.bias,\n            self.group_norm.weight,\n            self.group_norm.bias,\n            self.multiply_weight,\n            output,\n            batch_size,\n            self.gemm.in_features,\n            self.out_features,\n            self.num_groups,\n            eps=1e-5,\n            BLOCK_SIZE_K=256,  # Increased for better memory efficiency\n            GROUP_SIZE=group_size\n        )\n        return output\n\nbatch_size = 128\nin_features = 512\nout_features = 1024\nnum_groups = 16\nmultiply_weight_shape = (out_features,)\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, num_groups, multiply_weight_shape]\n# =================== EVOLVE-BLOCK-END ===================\n```\nUnique approach: Modification: Full rewrite, Excellent compiled (1.000), Excellent correctness (1.000)\n\n\n### Inspiration 4 (Score: 40.0000, Type: High-Performer)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_SIZE_K': 64}, num_warps=2),\n        triton.Config({'BLOCK_SIZE_K': 128}, num_warps=2),\n        triton.Config({'BLOCK_SIZE_K': 256}, num_warps=2),\n        triton.Config({'BLOCK_SIZE_K': 512}, num_warps=2),\n        triton.Config({'BLOCK_SIZE_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_K': 128}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_K': 256}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_K': 512}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_K': 64}, num_warps=8),\n        triton.Config({'BLOCK_SIZE_K': 128}, num_warps=8),\n        triton.Config({'BLOCK_SIZE_K': 256}, num_warps=8),\n        triton.Config({'BLOCK_SIZE_K': 512}, num_warps=8),\n    ],\n    key=['batch_size', 'in_features', 'out_features', 'num_groups'],\n)\n@triton.jit\ndef _fused_forward_kernel(\n    # Pointers\n    x_ptr,\n    gemm_weight_ptr,\n    gemm_bias_ptr,\n    gn_weight_ptr,\n    gn_bias_ptr,\n    mult_weight_ptr,\n    output_ptr,\n    # Shapes\n    batch_size,\n    in_features,\n    out_features,\n    num_groups,\n    # Meta-parameters\n    eps: tl.constexpr,\n    BLOCK_SIZE_K: tl.constexpr,\n    GROUP_SIZE: tl.constexpr,\n):\n    pid_batch = tl.program_id(0)\n    pid_group = tl.program_id(1)\n    \n    # Compute group boundaries\n    group_start = pid_group * GROUP_SIZE\n    group_range = tl.arange(0, GROUP_SIZE)\n    feature_mask = group_range < (out_features - group_start)\n    \n    # Initialize accumulator\n    acc = tl.zeros((GROUP_SIZE,), dtype=tl.float32)\n    x_ptrs = x_ptr + pid_batch * in_features\n    \n    # Loop over input features with vectorized loads\n    for k in range(0, tl.cdiv(in_features, BLOCK_SIZE_K)):\n        k_offsets = k * BLOCK_SIZE_K + tl.arange(0, BLOCK_SIZE_K)\n        k_mask = k_offsets < in_features\n        \n        # Vectorized load\n        x_block = tl.load(\n            x_ptrs + k_offsets,\n            mask=k_mask,\n            other=0.0\n        )\n        \n        # Weight pointers with precomputation\n        w_start = (group_start + group_range[:, None]) * in_features\n        w_ptrs = gemm_weight_ptr + w_start + k_offsets[None, :]\n        w_block = tl.load(\n            w_ptrs,\n            mask=k_mask[None, :] & feature_mask[:, None],\n            other=0.0\n        )\n        \n        # Accumulate with efficient dot product\n        acc += tl.sum(w_block * x_block[None, :], axis=1)\n    \n    # Add bias\n    bias_ptrs = gemm_bias_ptr + group_start + group_range\n    bias = tl.load(bias_ptrs, mask=feature_mask, other=0.0)\n    acc += bias\n    \n    # Compute GroupNorm statistics (corrected group size)\n    group_count = tl.sum(tl.cast(feature_mask, tl.float32))\n    mean = tl.sum(acc) / group_count\n    diff = acc - mean\n    var = tl.sum(diff * diff) / group_count\n    rstd = 1.0 / tl.sqrt(var + eps)\n    \n    # Apply GroupNorm with fused operations\n    gn_weight = tl.load(gn_weight_ptr + group_start + group_range, mask=feature_mask, other=0.0)\n    gn_bias = tl.load(gn_bias_ptr + group_start + group_range, mask=feature_mask, other=0.0)\n    normalized = (diff * rstd) * gn_weight + gn_bias\n    \n    # Fused Swish operations\n    sig1 = tl.sigmoid(normalized)\n    swish1 = normalized * sig1\n    \n    # Multiply\n    mult_weight = tl.load(mult_weight_ptr + group_start + group_range, mask=feature_mask, other=0.0)\n    multiplied = swish1 * mult_weight\n    \n    # Second Swish (fused)\n    sig2 = tl.sigmoid(multiplied)\n    swish2 = multiplied * sig2\n    \n    # Store results with coalesced writes\n    out_offsets = pid_batch * out_features + group_start + group_range\n    tl.store(output_ptr + out_offsets, swish2, mask=feature_mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, num_groups, multiply_weight_shape):\n        super(ModelNew, self).__init__()\n        self.gemm = nn.Linear(in_features, out_features)\n        self.group_norm = nn.GroupNorm(num_groups, out_features)\n        self.multiply_weight = nn.Parameter(torch.randn(multiply_weight_shape))\n        self.out_features = out_features\n        self.num_groups = num_groups\n\n    def forward(self, x):\n        batch_size, _ = x.shape\n        group_size = self.out_features // self.num_groups\n        \n        # Ensure tensors are contiguous\n        x = x.contiguous()\n        output = torch.empty((batch_size, self.out_features), device=x.device, dtype=x.dtype)\n        \n        # Launch kernel with optimized parameters\n        grid = (batch_size, self.num_groups)\n        _fused_forward_kernel[grid](\n            x, \n            self.gemm.weight, \n            self.gemm.bias,\n            self.group_norm.weight,\n            self.group_norm.bias,\n            self.multiply_weight,\n            output,\n            batch_size,\n            self.gemm.in_features,\n            self.out_features,\n            self.num_groups,\n            eps=1e-5,\n            GROUP_SIZE=group_size\n        )\n        return output\n\nbatch_size = 128\nin_features = 512\nout_features = 1024\nnum_groups = 16\nmultiply_weight_shape = (out_features,)\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, num_groups, multiply_weight_shape]\n# =================== EVOLVE-BLOCK-END ===================\n```\nUnique approach: Modification: Full rewrite, Excellent compiled (1.000), Excellent correctness (1.000)\n\n\n### Inspiration 5 (Score: 10.0000, Type: High-Performer)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport math\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n# Triton kernel for GEMM operation\n@triton.jit\ndef gemm_kernel(\n    x_ptr, w_ptr, b_ptr, out_ptr,\n    in_features, out_features,\n    stride_xb, stride_xm,\n    stride_wn, stride_wm,\n    stride_outb, stride_outn,\n    BLOCK_SIZE_M: tl.constexpr, BLOCK_SIZE_N: tl.constexpr, BLOCK_SIZE_K: tl.constexpr,\n    USE_TF32: tl.constexpr\n):\n    pid_batch = tl.program_id(0)\n    pid_feature = tl.program_id(1)\n    \n    # Create pointers for the current batch and feature block\n    x_ptr += pid_batch * stride_xb\n    out_ptr += pid_batch * stride_outb + pid_feature * BLOCK_SIZE_N\n    \n    # Calculate feature block offsets\n    feature_off = pid_feature * BLOCK_SIZE_N\n    w_ptr += feature_off * stride_wn\n    \n    # Initialize accumulator\n    acc = tl.zeros((BLOCK_SIZE_N,), dtype=tl.float32)\n    \n    # Loop over K dimension\n    for k in range(0, tl.cdiv(in_features, BLOCK_SIZE_K)):\n        # Calculate offsets and mask for K dimension\n        k_off = k * BLOCK_SIZE_K\n        cols = k_off + tl.arange(0, BLOCK_SIZE_K)\n        k_mask = cols < in_features\n        \n        # Load input block\n        x = tl.load(x_ptr + cols, mask=k_mask, other=0.0)\n        \n        # Create pointers and mask for weight block\n        rows = tl.arange(0, BLOCK_SIZE_N)\n        row_mask = rows < (out_features - feature_off)\n        w_ptrs = w_ptr + rows[:, None] * stride_wn + cols[None, :] * stride_wm\n        mask_2d = row_mask[:, None] & k_mask[None, :]\n        w = tl.load(w_ptrs, mask=mask_2d, other=0.0)\n        \n        # Compute partial dot product using element-wise operations\n        w = w.to(tl.float32)\n        x = x.to(tl.float32)\n        partial_1d = tl.sum(w * x[None, :], axis=1)\n        acc += partial_1d\n    \n    # Add bias\n    if b_ptr is not None:\n        b = tl.load(b_ptr + feature_off + tl.arange(0, BLOCK_SIZE_N), mask=row_mask, other=0.0)\n        acc += b\n    \n    # Store result\n    tl.store(out_ptr + tl.arange(0, BLOCK_SIZE_N), acc, mask=row_mask)\n\n# Triton kernel for fused GroupNorm + Swish + Multiply + Swish\n@triton.jit\ndef fused_gn_swish_mul_swish_kernel(\n    x_ptr, gn_weight_ptr, gn_bias_ptr, mul_weight_ptr, out_ptr,\n    num_features, num_groups, eps,\n    BLOCK_SIZE: tl.constexpr\n):\n    pid_batch = tl.program_id(0)\n    pid_group = tl.program_id(1)\n    \n    # Calculate group parameters\n    group_size = num_features // num_groups\n    group_start = pid_group * group_size\n    group_end = group_start + group_size\n    \n    # Create pointers for current batch and group\n    x_ptr += pid_batch * num_features + group_start\n    gn_weight_ptr += group_start\n    gn_bias_ptr += group_start\n    mul_weight_ptr += group_start\n    out_ptr += pid_batch * num_features + group_start\n    \n    # Load data for the group\n    idxs = tl.arange(0, BLOCK_SIZE)\n    mask = idxs < group_size\n    \n    x = tl.load(x_ptr + idxs, mask=mask, other=0.0)\n    gn_weight = tl.load(gn_weight_ptr + idxs, mask=mask, other=0.0)\n    gn_bias = tl.load(gn_bias_ptr + idxs, mask=mask, other=0.0)\n    mul_weight = tl.load(mul_weight_ptr + idxs, mask=mask, other=0.0)\n    \n    # Compute mean and variance\n    mean = tl.sum(x, axis=0) / group_size\n    x_centered = x - mean\n    var = tl.sum(x_centered * x_centered, axis=0) / group_size + eps\n    inv_std = 1.0 / tl.sqrt(var)\n    \n    # GroupNorm calculation\n    normalized = x_centered * inv_std\n    y = normalized * gn_weight + gn_bias\n    \n    # First Swish activation\n    swish1 = y * tl.sigmoid(y)\n    \n    # Multiply with weight\n    multiplied = swish1 * mul_weight\n    \n    # Second Swish activation\n    swish2 = multiplied * tl.sigmoid(multiplied)\n    \n    # Store result\n    tl.store(out_ptr + idxs, swish2, mask=mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, num_groups, multiply_weight_shape):\n        super(ModelNew, self).__init__()\n        self.in_features = in_features\n        self.out_features = out_features\n        self.num_groups = num_groups\n        \n        # Initialize weights and biases\n        self.weight = nn.Parameter(torch.empty(out_features, in_features))\n        self.bias = nn.Parameter(torch.empty(out_features))\n        self.gn_weight = nn.Parameter(torch.ones(out_features))\n        self.gn_bias = nn.Parameter(torch.zeros(out_features))\n        self.multiply_weight = nn.Parameter(torch.randn(multiply_weight_shape))\n        \n        # Initialize parameters\n        nn.init.kaiming_uniform_(self.weight, a=math.sqrt(5))\n        fan_in, _ = nn.init._calculate_fan_in_and_fan_out(self.weight)\n        bound = 1 / math.sqrt(fan_in) if fan_in > 0 else 0\n        nn.init.uniform_(self.bias, -bound, bound)\n\n    def forward(self, x):\n        batch_size, _ = x.shape\n        \n        # Allocate output for GEMM\n        out = torch.empty((batch_size, self.out_features), device=x.device, dtype=torch.float32)\n        \n        # Configure GEMM kernel\n        grid = (batch_size, triton.cdiv(self.out_features, 64))\n        gemm_kernel[grid](\n            x, self.weight, self.bias, out,\n            self.in_features, self.out_features,\n            x.stride(0), x.stride(1),\n            self.weight.stride(0), self.weight.stride(1),\n            out.stride(0), out.stride(1),\n            BLOCK_SIZE_M=1, BLOCK_SIZE_N=64, BLOCK_SIZE_K=64,\n            USE_TF32=True\n        )\n        \n        # Configure fused kernel\n        group_size = self.out_features // self.num_groups\n        grid = (batch_size, self.num_groups)\n        fused_gn_swish_mul_swish_kernel[grid](\n            out, self.gn_weight, self.gn_bias, self.multiply_weight, out,\n            self.out_features, self.num_groups, 1e-5,\n            BLOCK_SIZE=group_size\n        )\n        \n        return out\n\nbatch_size = 128\nin_features = 512\nout_features = 1024\nnum_groups = 16\nmultiply_weight_shape = (out_features,)\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, num_groups, multiply_weight_shape]\n# =================== EVOLVE-BLOCK-END ===================\n```\nUnique approach: Modification: Full rewrite, Excellent compiled (1.000), Alternative correctness approach\n\n\n\n# Current Program\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\nimport math\n\n# Triton kernel for optimized GEMM operation\n@triton.jit\ndef _gemm_kernel(\n    a_ptr, b_ptr, c_ptr,\n    M, N, K,\n    stride_am, stride_ak,\n    stride_bk, stride_bn,\n    stride_cm, stride_cn,\n    BLOCK_M: tl.constexpr, BLOCK_N: tl.constexpr, BLOCK_K: tl.constexpr\n):\n    pid = tl.program_id(0)\n    grid_m = tl.cdiv(M, BLOCK_M)\n    grid_n = tl.cdiv(N, BLOCK_N)\n    \n    pid_m = pid // grid_n\n    pid_n = pid % grid_n\n    \n    offs_m = pid_m * BLOCK_M + tl.arange(0, BLOCK_M)\n    offs_n = pid_n * BLOCK_N + tl.arange(0, BLOCK_N)\n    offs_k = tl.arange(0, BLOCK_K)\n    \n    a_ptrs = a_ptr + offs_m[:, None] * stride_am + offs_k[None, :] * stride_ak\n    b_ptrs = b_ptr + offs_k[:, None] * stride_bk + offs_n[None, :] * stride_bn\n    \n    accumulator = tl.zeros((BLOCK_M, BLOCK_N), dtype=tl.float32)\n    for k in range(0, K, BLOCK_K):\n        mask_a = (offs_m[:, None] < M) & (offs_k[None, :] < K - k)\n        mask_b = (offs_k[:, None] < K - k) & (offs_n[None, :] < N)\n        \n        a = tl.load(a_ptrs, mask=mask_a, other=0.0)\n        b = tl.load(b_ptrs, mask=mask_b, other=0.0)\n        \n        accumulator += tl.dot(a, b)\n        a_ptrs += BLOCK_K * stride_ak\n        b_ptrs += BLOCK_K * stride_bk\n    \n    offs_cm = pid_m * BLOCK_M + tl.arange(0, BLOCK_M)\n    offs_cn = pid_n * BLOCK_N + tl.arange(0, BLOCK_N)\n    c_ptrs = c_ptr + stride_cm * offs_cm[:, None] + stride_cn * offs_cn[None, :]\n    \n    mask_c = (offs_cm[:, None] < M) & (offs_cn[None, :] < N)\n    tl.store(c_ptrs, accumulator, mask=mask_c)\n\n# Optimized Linear module using Triton\nclass TritonLinear(nn.Module):\n    def __init__(self, in_features, out_features):\n        super().__init__()\n        self.in_features = in_features\n        self.out_features = out_features\n        self.weight = nn.Parameter(torch.empty(out_features, in_features))\n        self.bias = nn.Parameter(torch.empty(out_features))\n        self.reset_parameters()\n\n    def reset_parameters(self):\n        nn.init.kaiming_uniform_(self.weight, a=math.sqrt(5))\n        fan_in, _ = nn.init._calculate_fan_in_and_fan_out(self.weight)\n        bound = 1 / math.sqrt(fan_in) if fan_in > 0 else 0\n        nn.init.uniform_(self.bias, -bound, bound)\n\n    def forward(self, x):\n        output = torch.empty(\n            x.size(0), \n            self.out_features, \n            device=x.device, \n            dtype=x.dtype\n        )\n        \n        grid = lambda M, N: (triton.cdiv(M, 64) * triton.cdiv(N, 64),)\n        \n        _gemm_kernel[grid(x.size(0), self.out_features)](\n            x, self.weight, output,\n            x.size(0), self.out_features, self.in_features,\n            x.stride(0), x.stride(1),\n            self.weight.stride(1), self.weight.stride(0),  # Fixed weight strides\n            output.stride(0), output.stride(1),\n            BLOCK_M=64, BLOCK_N=64, BLOCK_K=32\n        )\n        \n        output += self.bias\n        return output\n\nclass ModelNew(nn.Module):\n    \"\"\"\n    Model that performs a GEMM, GroupNorm, Swish, Multiply, and Swish operations.\n    \"\"\"\n    def __init__(self, in_features, out_features, num_groups, multiply_weight_shape):\n        super(ModelNew, self).__init__()\n        self.gemm = TritonLinear(in_features, out_features)\n        self.group_norm = nn.GroupNorm(num_groups, out_features)\n        self.multiply_weight = nn.Parameter(torch.randn(multiply_weight_shape)) \n\n    def forward(self, x):\n        # (batch_size, in_features) -> (batch_size, out_features)\n        x = self.gemm(x)\n        # (batch_size, out_features) -> (batch_size, out_features)\n        x = self.group_norm(x)\n        # (batch_size, out_features) -> (batch_size, out_features)\n        x = x * torch.sigmoid(x)\n        # (batch_size, out_features) -> (batch_size, out_features)\n        x = x * self.multiply_weight\n        # (batch_size, out_features) -> (batch_size, out_features)\n        x = x * torch.sigmoid(x)\n        return x\n\nbatch_size = 128\nin_features = 512\nout_features = 1024\nnum_groups = 16\nmultiply_weight_shape = (out_features,)\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, num_groups, multiply_weight_shape]\n# =================== EVOLVE-BLOCK-END ===================\n```\n\n# Task\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```\n", "responses": ["<think>\nWe are given the current program which is a Triton implementation of a model that does:\n  1. GEMM (using a Triton kernel for the matrix multiplication)\n  2. GroupNorm (using PyTorch's built-in)\n  3. Two sets of Swish (x * sigmoid(x)) and an element-wise multiplication in between.\n\nThe current performance shows a speed_up of 0.79 (which is worse than the reference) and a score of 20.0.\n\nLooking at the evolution history, the top-performing programs (with scores above 50) use a fused Triton kernel that combines:\n  - The GEMM operation\n  - The GroupNorm\n  - The two Swish operations and the element-wise multiplication\n\nThe current program, however, uses a Triton kernel only for the GEMM and then does the rest in separate PyTorch operations. This likely leads to multiple kernel launches and memory reads/writes, which is inefficient.\n\nTherefore, the plan is to replace the current implementation (which uses Triton for GEMM and then PyTorch for the rest) with a fully fused Triton kernel, similar to the top-performing programs.\n\nWe will design a kernel that:\n  - Takes the input tensor and all the parameters (gemm weight, gemm bias, group norm weight, group norm bias, multiply weight)\n  - For each batch and each group, it:\n        a. Computes the GEMM (matrix-vector product for the group) for the given batch and group.\n        b. Computes the group normalization (mean, variance, normalize) for the group.\n        c. Applies the first Swish (x * sigmoid(x)).\n        d. Multiplies by the multiply_weight.\n        e. Applies the second Swish.\n\nWe note that the top-performing programs have a kernel that is launched with grid = (batch_size, num_groups). Each block handles one group for one batch.\n\nWe will follow the structure of the top-performing program (Program 1 in the list) but adapt it to our current problem.\n\nKey parameters:\n  - batch_size: the first dimension of the input\n  - in_features: the input feature dimension (for the GEMM)\n  - out_features: the output feature dimension (for the GEMM and the rest)\n  - num_groups: for GroupNorm\n  - group_size: out_features // num_groups\n\nThe kernel signature and the main loop for the GEMM part will be similar.\n\nWe also note that the top programs use:\n  - BLOCK_SIZE_K: the block size for the inner dimension (K) of the GEMM (input features)\n  - BLOCK_SIZE_N: the block size for the group (which is the group_size, but padded to the next power of two for efficient memory access)\n\nWe will compute the group_size and then P2 (the next power of two for group_size) to set BLOCK_SIZE_N.\n\nWe will also compute the number of warps dynamically based on P2.\n\nThe kernel will have the following parameters (pointers and scalars) and will be structured as:\n\n  pid_batch = program_id(0)\n  pid_group = program_id(1)\n\n  group_start = pid_group * group_size\n  group_range = ... (using tl.arange(0, BLOCK_SIZE_N))\n\n  We will then loop over the input features (in BLOCK_SIZE_K chunks) to compute the GEMM result for the group.\n\n  Then we compute the GroupNorm statistics (mean and variance) for the group.\n\n  Then apply the GroupNorm (scale and shift).\n\n  Then do the two Swish operations with the multiply in between.\n\n  Then store the result.\n\nWe will also use the autotuning for the BLOCK_SIZE_K and other parameters? Actually, the top program does not use autotuning but sets BLOCK_SIZE_K=128 and BLOCK_SIZE_N to P2 (the next power of two). They also set the number of warps and stages.\n\nHowever, note that the top program (Program 1) does not use autotune but sets the block sizes and then computes the number of warps.\n\nWe will follow that approach.\n\nSteps:\n\n  1. Remove the TritonLinear class and replace it with a fused kernel.\n  2. Define a Triton kernel that does the entire fused operation.\n  3. In the forward method of ModelNew, we will:\n        - Set group_size = out_features // num_groups\n        - Compute P2 = 2 ** ceil(log2(group_size))  [to set BLOCK_SIZE_N to the next power of two]\n        - Compute the number of warps (min_warps = max(1, (P2+31)//32) and then find the next power of two for warps)\n        - Launch the kernel with grid=(batch_size, num_groups)\n\n  4. We must ensure that all tensors are contiguous.\n\nWe note that the top program (Program 1) uses the following kernel parameters:\n\n    x, \n    self.gemm.weight, \n    self.gemm.bias,\n    self.group_norm.weight,\n    self.group_norm.bias,\n    self.multiply_weight,\n    output,\n    batch_size,\n    self.gemm.in_features,   # in_features\n    self.out_features,        # out_features\n    self.num_groups,          # num_groups\n    group_size,               # group_size (the actual group size, not P2)\n    eps=1e-5,\n    BLOCK_SIZE_K=128,\n    BLOCK_SIZE_N=P2,         # the next power of two for group_size\n\nWe will do the same.\n\nLet's write the kernel and the model accordingly.\n\nNote: The kernel must be written with care to handle the boundaries (using masks).\n\nWe will base the kernel on the one from the top program (Program 1) but note that the current problem has an extra multiply and an extra Swish.\n\nHowever, note that the top program in the history for this problem (the one with score 52.9) does exactly the same operations as we need.\n\nTherefore, we can use the kernel from that program.\n\nWe will copy the kernel from Program 1 and adapt the class ModelNew accordingly.\n\nBut note: the current program has two Swish operations and a multiply in between. The top program also does:\n\n    # Fused Swish operations\n    sig1 = tl.sigmoid(normalized)\n    swish1 = normalized * sig1\n\n    # Multiply\n    mult_weight = tl.load(mult_weight_ptr + group_start + group_range, mask=feature_mask, other=0.0)\n    multiplied = swish1 * mult_weight\n\n    # Second Swish\n    sig2 = tl.sigmoid(multiplied)\n    swish2 = multiplied * sig2\n\nThis matches exactly.\n\nSo we will use the kernel from the top program (Program 1) and the ModelNew class from that program.\n\nHowever, note that the top program uses nn.Linear and nn.GroupNorm and then uses their weights and biases in the kernel.\n\nWe will do the same.\n\nTherefore, the rewritten program will be:\n\n  - The kernel from Program 1 (the top program) with the same parameters and body.\n  - The ModelNew class that initializes the linear layer (gemm) and group norm (group_norm) and the multiply_weight as an nn.Parameter.\n  - The forward method that sets up the kernel launch.\n\nWe note that the top program uses:\n    group_size = self.out_features // self.num_groups\n    P2 = int(2 ** math.ceil(math.log2(group_size)))\n\nand then sets BLOCK_SIZE_N = P2.\n\nIt also dynamically sets the number of warps.\n\nWe will do the same.\n\nLet's write the code accordingly.\n\nWe also note that the current program has a batch size of 128, in_features=512, out_features=1024, num_groups=16.\n\nWe must ensure that the group_size = 1024 // 16 = 64, and P2 = 64 (since 64 is a power of two).\n\nBut in general, we compute P2 as the next power of two.\n\nWe will now write the code accordingly.\n\nImportant: We must not change the function signature of the kernel (if we are copying from the top program) and the ModelNew class.\n\nWe are going to replace the entire EVOLVE-BLOCK with the code from the top program (Program 1) because that program has a high score.\n\nBut note: the top program in the history is for the same problem? Yes, because the inputs and the operations are the same.\n\nTherefore, we will output the code of the top program (Program 1) as the new version.\n\nHowever, note that the current program might have been modified from the top program in the history? We are free to change.\n\nLet me copy the code from the top program (Program 1) and replace the current program.\n\nBut note: the top program (Program 1) is:\n\n    import math\n    import torch\n    import torch.nn as nn\n    import triton\n    import triton.language as tl\n\n    @triton.jit\n    def _fused_forward_kernel(...):\n        ...  # as above\n\n    class ModelNew(nn.Module):\n        ... # as above\n\n    ... # and the rest\n\nWe will output that code.\n\nBut note: the current program has a function get_inputs and get_init_inputs. The top program also has these functions. So we are safe.\n\nTherefore, we will replace the current program with the top program (Program 1) from the history.\n\nHowever, note that the top program (Program 1) in the history has the following at the end:\n\n    batch_size = 128\n    in_features = 512\n    out_features = 1024\n    num_groups = 16\n    multiply_weight_shape = (out_features,)\n\n    def get_inputs():\n        return [torch.randn(batch_size, in_features)]\n\n    def get_init_inputs():\n        return [in_features, out_features, num_groups, multiply_weight_shape]\n\nThis matches the current program.\n\nSo we will output the entire code block of the top program.\n\nBut note: the top program has a kernel that does the entire fused operation, so it should be faster.\n\nLet me write it.\n\nNote: We are only allowed to output the code block between EVOLVE-BLOCK-START and EVOLVE-BLOCK-END.\n\nWe will output:\n\n    # ================== EVOLVE-BLOCK-START ==================\n    ... (the code of the top program)\n    # =================== EVOLVE-BLOCK-END ===================\n\nWe are copying from the provided history.\n\nBut note: the top program (Program 1) in the history is the one with the highest score (52.9).\n\nLet me copy it exactly.\n\nHowever, note that the history section has the code as a string. We must copy it exactly.\n\nBut note: the history section might have been truncated? We have the entire code.\n\nWe will output the code of Program 1.\n\nBut note: the kernel in Program 1 uses the variable 'group_size' and also uses BLOCK_SIZE_N = P2 (which is the next power of two). This is efficient for memory access.\n\nWe hope this will improve the speed_up.\n\nLet me write the code.\n\nImportant: We are not allowed to change the class name (ModelNew) or the functions get_inputs and get_init_inputs. The top program already uses these.\n\nSo we output the entire code block of Program 1.\n\nHowever, note that the top program in the history has a kernel named `_fused_forward_kernel` and a class `ModelNew` that uses that kernel.\n\nWe are replacing the current program (which uses two separate Triton kernels and then PyTorch) with this fused kernel.\n\nThis should be much faster.\n\nLet's write the code.\n</think>\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport math\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef _fused_forward_kernel(\n    # Pointers\n    x_ptr,\n    gemm_weight_ptr,\n    gemm_bias_ptr,\n    gn_weight_ptr,\n    gn_bias_ptr,\n    mult_weight_ptr,\n    output_ptr,\n    # Shapes\n    batch_size,\n    in_features,\n    out_features,\n    num_groups,\n    group_size,\n    # Meta-parameters\n    eps: tl.constexpr,\n    BLOCK_SIZE_K: tl.constexpr,\n    BLOCK_SIZE_N: tl.constexpr,\n):\n    pid_batch = tl.program_id(0)\n    pid_group = tl.program_id(1)\n    \n    # Compute group boundaries\n    group_start = pid_group * group_size\n    group_range = tl.arange(0, BLOCK_SIZE_N)\n    feature_mask = group_range < group_size\n    \n    # Initialize accumulator\n    acc = tl.zeros((BLOCK_SIZE_N,), dtype=tl.float32)\n    x_ptr += pid_batch * in_features\n    \n    # Loop over input features with vectorized loads\n    for k in range(0, tl.cdiv(in_features, BLOCK_SIZE_K)):\n        k_offsets = k * BLOCK_SIZE_K + tl.arange(0, BLOCK_SIZE_K)\n        k_mask = k_offsets < in_features\n        \n        # Vectorized load\n        x_block = tl.load(\n            x_ptr + k_offsets,\n            mask=k_mask,\n            other=0.0,\n        )\n        \n        # Weight pointers\n        w_ptrs = gemm_weight_ptr + (group_start + group_range[:, None]) * in_features + k_offsets[None, :]\n        w_block = tl.load(\n            w_ptrs,\n            mask=k_mask[None, :] & feature_mask[:, None],\n            other=0.0,\n        )\n        \n        # Accumulate dot product\n        acc += tl.sum(w_block * x_block[None, :], axis=1)\n    \n    # Add bias\n    bias_ptrs = gemm_bias_ptr + group_start + group_range\n    bias = tl.load(bias_ptrs, mask=feature_mask, other=0.0)\n    acc += bias\n    \n    # Compute GroupNorm statistics\n    group_count = tl.sum(tl.cast(feature_mask, tl.float32))\n    mean = tl.sum(acc) / group_count\n    diff = acc - mean\n    var = tl.sum(diff * diff) / group_count\n    rstd = 1.0 / tl.sqrt(var + eps)\n    \n    # Apply GroupNorm\n    gn_weight = tl.load(gn_weight_ptr + group_start + group_range, mask=feature_mask, other=0.0)\n    gn_bias = tl.load(gn_bias_ptr + group_start + group_range, mask=feature_mask, other=0.0)\n    normalized = (diff * rstd) * gn_weight + gn_bias\n    \n    # Fused Swish operations\n    sig1 = tl.sigmoid(normalized)\n    swish1 = normalized * sig1\n    \n    # Multiply\n    mult_weight = tl.load(mult_weight_ptr + group_start + group_range, mask=feature_mask, other=0.0)\n    multiplied = swish1 * mult_weight\n    \n    # Second Swish\n    sig2 = tl.sigmoid(multiplied)\n    swish2 = multiplied * sig2\n    \n    # Store results\n    out_offsets = pid_batch * out_features + group_start + group_range\n    tl.store(output_ptr + out_offsets, swish2, mask=feature_mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, num_groups, multiply_weight_shape):\n        super(ModelNew, self).__init__()\n        self.gemm = nn.Linear(in_features, out_features)\n        self.group_norm = nn.GroupNorm(num_groups, out_features)\n        self.multiply_weight = nn.Parameter(torch.randn(multiply_weight_shape))\n        self.out_features = out_features\n        self.num_groups = num_groups\n\n    def forward(self, x):\n        batch_size, _ = x.shape\n        group_size = self.out_features // self.num_groups\n        P2 = int(2 ** math.ceil(math.log2(group_size)))\n        \n        # Ensure tensors are contiguous\n        x = x.contiguous()\n        output = torch.empty((batch_size, self.out_features), device=x.device, dtype=x.dtype)\n        \n        # Compute required number of warps\n        min_warps = max(1, (P2 + 31) // 32)\n        num_warps = 1\n        while num_warps < min_warps:\n            num_warps *= 2\n            \n        # Launch kernel\n        grid = (batch_size, self.num_groups)\n        _fused_forward_kernel[grid](\n            x, \n            self.gemm.weight, \n            self.gemm.bias,\n            self.group_norm.weight,\n            self.group_norm.bias,\n            self.multiply_weight,\n            output,\n            batch_size,\n            self.gemm.in_features,\n            self.out_features,\n            self.num_groups,\n            group_size,\n            eps=1e-5,\n            BLOCK_SIZE_K=128,\n            BLOCK_SIZE_N=P2,\n            num_warps=num_warps,\n            num_stages=2\n        )\n        return output\n\nbatch_size = 128\nin_features = 512\nout_features = 1024\nnum_groups = 16\nmultiply_weight_shape = (out_features,)\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, num_groups, multiply_weight_shape]\n# =================== EVOLVE-BLOCK-END ===================\n```"]}}}