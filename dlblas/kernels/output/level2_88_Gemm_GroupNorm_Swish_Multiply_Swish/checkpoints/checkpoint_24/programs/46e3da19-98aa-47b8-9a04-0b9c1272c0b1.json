{"id": "46e3da19-98aa-47b8-9a04-0b9c1272c0b1", "code": "@triton.jit\ndef _gemm_kernel(\n    a_ptr, b_ptr, c_ptr,\n    M, N, K,\n    stride_am, stride_ak,\n    stride_bk, stride_bn,\n    stride_cm, stride_cn,\n    BLOCK_M: tl.constexpr, BLOCK_N: tl.constexpr, BLOCK_K: tl.constexpr\n):\n    pid = tl.program_id(0)\n    grid_m = tl.cdiv(M, BLOCK_M)\n    grid_n = tl.cdiv(N, BLOCK_N)\n    \n    pid_m = pid // grid_n\n    pid_n = pid % grid_n\n    \n    offs_m = pid_m * BLOCK_M + tl.arange(0, BLOCK_M)\n    offs_n = pid_n * BLOCK_N + tl.arange(0, BLOCK_N)\n    k_offsets = tl.arange(0, BLOCK_K)\n    \n    a_ptrs = a_ptr + offs_m[:, None] * stride_am + k_offsets[None, :] * stride_ak\n    b_ptrs = b_ptr + k_offsets[:, None] * stride_bk + offs_n[None, :] * stride_bn\n    \n    accumulator = tl.zeros((BLOCK_M, BLOCK_N), dtype=tl.float32)\n    \n    # Prefetch first block\n    k_abs0 = k_offsets\n    mask_a0 = (offs_m[:, None] < M) & (k_abs0[None, :] < K)\n    mask_b0 = (k_abs0[:, None] < K) & (offs_n[None, :] < N)\n    a = tl.load(a_ptrs, mask=mask_a0, other=0.0)\n    b = tl.load(b_ptrs, mask=mask_b0, other=0.0)\n    a_ptrs += BLOCK_K * stride_ak\n    b_ptrs += BLOCK_K * stride_bk\n    \n    # Main loop with prefetching\n    for k in range(0, K - BLOCK_K, BLOCK_K):\n        # Prefetch next block\n        k_abs_next = k + BLOCK_K + k_offsets\n        mask_a_next = (offs_m[:, None] < M) & (k_abs_next[None, :] < K)\n        mask_b_next = (k_abs_next[:, None] < K) & (offs_n[None, :] < N)\n        next_a = tl.load(a_ptrs, mask=mask_a_next, other=0.0, eviction_policy=\"evict_last\")\n        next_b = tl.load(b_ptrs, mask=mask_b_next, other=0.0, eviction_policy=\"evict_last\")\n        \n        # Compute current block with Tensor Cores\n        accumulator += tl.dot(a, b, allow_tf32=True)\n        \n        # Advance to next block\n        a, b = next_a, next_b\n        a_ptrs += BLOCK_K * stride_ak\n        b_ptrs += BLOCK_K * stride_bk\n    \n    # Process last block\n    k_abs_last = K - BLOCK_K + k_offsets\n    mask_a_last = (offs_m[:, None] < M) & (k_abs_last[None, :] < K)\n    mask_b_last = (k_abs_last[:, None] < K) & (offs_n[None, :] < N)\n    a_last = tl.load(a_ptrs, mask=mask_a_last, other=0.0)\n    b_last = tl.load(b_ptrs, mask=mask_b_last, other=0.0)\n    accumulator += tl.dot(a, b, allow_tf32=True) + tl.dot(a_last, b_last, allow_tf32=True)\n    \n    # Write back results\n    offs_cm = pid_m * BLOCK_M + tl.arange(0, BLOCK_M)\n    offs_cn = pid_n * BLOCK_N + tl.arange(0, BLOCK_N)\n    c_ptrs = c_ptr + stride_cm * offs_cm[:, None] + stride_cn * offs_cn[None, :]\n    mask_c = (offs_cm[:, None] < M) & (offs_cn[None, :] < N)\n    tl.store(c_ptrs, accumulator, mask=mask_c)", "language": "python", "parent_id": "a4927e02-0fb7-487a-97ec-e32118865172", "generation": 3, "timestamp": 1754585057.2355742, "iteration_found": 21, "metrics": {"compiled": false, "correctness": false, "score": -100.0, "stage": "no_valid_triton_code", "feedback": "You need to generate real and valid triton code for the core function. The key word 'import triton' is not found."}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": false, "correctness": false, "score": -100.0, "stage": "no_valid_triton_code", "feedback": "You need to generate real and valid triton code for the core function. The key word 'import triton' is not found."}, "island": 0}, "artifacts_json": null, "artifact_dir": null, "prompts": {"full_rewrite_user": {"system": "You are a Triton GPU core optimization engineer deeply familiar with NVIDIA H100/H800 architecture.\n\n==================== Context ====================\n\u2022 Dataset: 250 kernelbench/level1-level5 *.py files  \n  - Level1: simplest, Level5: most complex  \n\u2022 Each file contains PyTorch reference (reference_code)  \n\u2022 Goal: Generate functionally equivalent but faster Triton implementations (custom_code)  \n\u2022 Evaluation pipeline:\n    1) /verify_plus - Verify compilation & correctness  \n    2) /execute (optional) - Return terminal logs if compilation fails  \n    3) Scoring:  \n      - Speedup > 1 required for points  \n      - Score = (speed_up - 1) \u00d7 100  \n\u2022 GPU Hardware: NVIDIA L20Y / H800 (same SM8.9 as H100)  \n  - 3 TB/s HBM3 bandwidth  \n  - FP16 Tensor Core 32\u00d716\u00d716  \n\n==================== Evolution Phases ====================\n\u2460 Phase 1 [Compilation Pass]  \n  - Make Triton code compile (performance irrelevant)  \n\u2461 Phase 2 [Numerical Correctness]  \n  - Output must match PyTorch reference within float32 tolerance  \n\u2462 Phase 3 [Performance Gain]  \n  - Target \u22655% speedup (\u226515% = exceptional)  \n  - Official scoring based on speed_up field  \n\nThe Evolution system will pass the EVOLVE-BLOCK from the previous version.  \nModify ONLY the Triton kernel source within this block - all other code is LOCKED.\n\n==================== Constraints (MUST OBEY) ====================\n\u274c NEVER change @triton.jit function signatures or parameter names  \n\u274c NEVER modify grid configuration, output tensor shapes, or PID logic  \n\u274c NEVER remove boundary checks or out-of-bound masks  \n\u274c NEVER introduce race conditions, uninitialized reads, or sync gaps  \n\n\u2705 Allowed Optimizations (Examples):  \n  \u2022 Memory coalescing optimizations & vectorized tl.load/tl.store  \n  \u2022 Replace staged softmax with online/FlashAttention variants  \n  \u2022 Adaptive tuning: BLOCK_M/BLOCK_N/BLOCK_K dimensions  \n  \u2022 Multi-query-head batch processing (GQA, 5:1 patterns)  \n  \u2022 Shared/L2 buffering, Tensor Core alignment (FP16/bf16/tf32)  \n  \u2022 Stride precomputation & pointer caching  \n\n==================== Output Format ====================\nReturn ONLY the complete updated code containing the EVOLVE-BLOCK comment marker.  \nNO explanations, NO markdown, NO additional text.\nName the output structure class as ModelNew.\n\n==================== Optimization Tips ====================\n\u2022 If previous compile failed: Fix syntax/mask/stride errors first  \n\u2022 If correctness fails: Prioritize bounds mask & dtype precision  \n\u2022 When speed_up < 1: Focus on memory access & block sizing  \n\u2022 Small iterative steps: Modify \u226420 lines per revision  \n\u2022 Maintain reversibility between versions\nHere is an example to show you how to rewrite a PyTorch implementation that quantizes a high-precision tensor to int8 dtype with row-wise granularity into a Triton implementation: \nThe original PyTorch implementation is as follows: \n``` \nimport torch\ndef per_row_quantize_int8(x: torch.Tensor) -> tuple[torch.Tensor, torch.Tensor]:\n    x_amax = x.abs().float().amax(dim=1).clamp(min=1e-4)\n    scale = 127 / x_amax\n    output = (x * scale[:, None]).round().clamp(-127, 127).to(torch.int8)\n    output_scale = x_amax / 127\n\n    return output, output_scale\n``` \nThe corresponding Triton-rewritten implementation is as follows: \n``` \nimport math\nimport torch\nimport triton\nimport triton.language as tl\nfrom triton.language.extra import libdevice\n\n# rowwise quantize\n\n@triton.autotune(\n    configs=[\n        triton.Config({}, num_stages=1, num_warps=8),\n        triton.Config({}, num_stages=2, num_warps=8),\n        triton.Config({}, num_stages=4, num_warps=8),\n        triton.Config({}, num_stages=8, num_warps=8),\n        triton.Config({}, num_stages=1),\n        triton.Config({}, num_stages=2),\n        triton.Config({}, num_stages=4),\n        triton.Config({}, num_stages=8),\n        triton.Config({}, num_warps=1),\n        triton.Config({}, num_warps=2),\n        triton.Config({}, num_warps=4),\n        triton.Config({}, num_warps=8),\n    ],\n    key=[\"n_elements\"],\n)\n\n@triton.jit\ndef _quantize_rowwise(\n    x_ptr,\n    output_ptr,\n    output_scale,\n    BLOCK_SIZE: tl.constexpr,\n    P2: tl.constexpr,\n):\n    pid = tl.program_id(axis=0)\n    block_start = pid * BLOCK_SIZE\n    arange = tl.arange(0, P2)\n    offsets = block_start + arange\n    row_mask = arange < BLOCK_SIZE\n    x = tl.load(x_ptr + offsets, mask=row_mask)\n\n    abs_x = tl.abs(x)\n    max_val = tl.max(tl.where(row_mask, abs_x, 0), axis=0)\n    output = libdevice.llrint(127.0 * (x / max_val))\n    tl.store(output_ptr + offsets, output, mask=row_mask)\n    tl.store(output_scale + pid, max_val / 127)\n\n\ndef per_row_quantize_int8(x: torch.Tensor):\n    x = x.contiguous()\n    output = torch.empty(*x.shape, device=x.device, dtype=torch.int8)\n    output_scale = torch.empty(x.shape[0], device=x.device, dtype=torch.float32)\n    P2 = int(2 ** (math.ceil(math.log2(x.shape[1]))))\n    grid = lambda x: (x.shape[0],)\n    _quantize_rowwise[grid](x, output, output_scale, BLOCK_SIZE=x.shape[1], P2=P2)\n\n    return output, output_scale\n\n\n    \n``` \n", "user": "# Current Program Information\n- Current performance metrics: - compiled: 0.0000\n- correctness: 0.0000\n- score: -100.0000\n- stage: no_valid_triton_code\n- feedback: You need to generate real and valid triton code for the core function. The key word 'import triton' is not found.\n- Areas identified for improvement: - Consider simplifying the code to improve readability and maintainability\n- Metrics showing regression: score. Consider reverting or revising recent changes in these areas.\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Unknown changes\n- Performance: compiled: 1.0000, correctness: 0.0000, score: 10.0000, stage: wrong_answer, verify_payload: {'id': 'level2_88_Gemm_GroupNorm_Swish_Multiply_Swish', 'result': {'compiled': True, 'correctness': False, 'metadata': {'hardware': 'NVIDIA L20Y', 'device': 'cuda:0', 'runtime_error': 'Traceback (most recent call last):\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/language/core.py\", line 42, in wrapper\\n    return fn(*args, **kwargs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/language/core.py\", line 2045, in dot\\n    return _semantic.dot(input, other, acc, input_precision, max_num_imprecise_acc, out_dtype)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/language/semantic.py\", line 1497, in dot\\n    assert lhs_rank == rhs_rank == 2 or lhs_rank == rhs_rank == 3, f\"Both inputs must be either 2D or 3D; (lhs: {lhs.shape} vs rhs: {rhs.shape})\"\\nAssertionError: Both inputs must be either 2D or 3D; (lhs: [\\'constexpr[64]\\'] vs rhs: [\\'constexpr[64]\\'])\\n\\nThe above exception was the direct cause of the following exception:\\n\\nTraceback (most recent call last):\\n  File \"/cpfs01/shared/llm_kernel/hujiakai/KernelLLM/validation_api_server/helpers/evaluations.py\", line 720, in run_and_check_correctness\\n    output_new = model_new(*inputs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1773, in _wrapped_call_impl\\n    return self._call_impl(*args, **kwargs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1784, in _call_impl\\n    return forward_call(*args, **kwargs)\\n  File \"/tmp/tmpbqp9kzpo.py\", line 140, in forward\\n    gemm_kernel[grid](\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 390, in <lambda>\\n    return lambda *args, **kwargs: self.run(grid=grid, warmup=False, *args, **kwargs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 594, in run\\n    kernel = self.compile(src, target=target, options=options.__dict__)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/compiler/compiler.py\", line 339, in compile\\n    module = src.make_ir(options, codegen_fns, module_map, context)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/compiler/compiler.py\", line 83, in make_ir\\n    return ast_to_ttir(self.fn, self, context=context, options=options, codegen_fns=codegen_fns,\\ntriton.compiler.errors.CompilationError: at 40:15:\\n        k_mask = cols < in_features\\n\\n        # Load input block\\n        x = tl.load(x_ptr + cols, mask=k_mask, other=0.0)\\n\\n        # Load weight block\\n        w = tl.load(w_ptr + cols, mask=k_mask, other=0.0)\\n\\n        # Compute partial dot product\\n        w = w.to(tl.float32)\\n        x = x.to(tl.float32)\\n        acc += tl.dot(w, x, allow_tf32=USE_TF32)\\n               ^\\n\\n\\nThe above exception was the direct cause of the following exception:\\n\\nTraceback (most recent call last):\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/language/core.py\", line 42, in wrapper\\n    return fn(*args, **kwargs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/language/core.py\", line 2045, in dot\\n    return _semantic.dot(input, other, acc, input_precision, max_num_imprecise_acc, out_dtype)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/language/semantic.py\", line 1497, in dot\\n    assert lhs_rank == rhs_rank == 2 or lhs_rank == rhs_rank == 3, f\"Both inputs must be either 2D or 3D; (lhs: {lhs.shape} vs rhs: {rhs.shape})\"\\nAssertionError: Both inputs must be either 2D or 3D; (lhs: [\\'constexpr[64]\\'] vs rhs: [\\'constexpr[64]\\'])\\n', 'runtime_error_name': 'triton.compiler.errors.CompilationError', 'reference_timing_ms': 0.109, 'speed_up': -1.0, 'custom_timing': -1.0}, 'runtime': -1.0, 'runtime_stats': {}}}\n- Outcome: Mixed results\n\n\n### Attempt 2\n- Changes: Unknown changes\n- Performance: compiled: 1.0000, correctness: 0.0000, score: 10.0000, stage: wrong_answer, verify_payload: {'id': 'level2_88_Gemm_GroupNorm_Swish_Multiply_Swish', 'result': {'compiled': True, 'correctness': False, 'metadata': {'hardware': 'NVIDIA L20Y', 'device': 'cuda:4', 'runtime_error': 'Traceback (most recent call last):\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/language/core.py\", line 42, in wrapper\\n    return fn(*args, **kwargs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/language/core.py\", line 2045, in dot\\n    return _semantic.dot(input, other, acc, input_precision, max_num_imprecise_acc, out_dtype)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/language/semantic.py\", line 1498, in dot\\n    assert lhs.shape[-1].value == rhs.shape[\\nAssertionError: First input shape ([\\'constexpr[64]\\', \\'constexpr[32]\\']) and second input shape [\\'constexpr[64]\\', \\'constexpr[32]\\'] are not compatible for matmul (second index of first shape (32) must be equal to first index of second shape (64)\\n\\nThe above exception was the direct cause of the following exception:\\n\\nTraceback (most recent call last):\\n  File \"/cpfs01/shared/llm_kernel/hujiakai/KernelLLM/validation_api_server/helpers/evaluations.py\", line 720, in run_and_check_correctness\\n    output_new = model_new(*inputs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1773, in _wrapped_call_impl\\n    return self._call_impl(*args, **kwargs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1784, in _call_impl\\n    return forward_call(*args, **kwargs)\\n  File \"/tmp/tmpent6fzl3.py\", line 156, in forward\\n    gemm_triton_kernel[grid](\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 390, in <lambda>\\n    return lambda *args, **kwargs: self.run(grid=grid, warmup=False, *args, **kwargs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 239, in run\\n    benchmark()\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 228, in benchmark\\n    timings = {config: self._bench(*args, config=config, **kwargs) for config in pruned_configs}\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 228, in <dictcomp>\\n    timings = {config: self._bench(*args, config=config, **kwargs) for config in pruned_configs}\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 160, in _bench\\n    return self.do_bench(kernel_call, quantiles=(0.5, 0.2, 0.8))\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/testing.py\", line 149, in do_bench\\n    fn()\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 146, in kernel_call\\n    self.fn.run(\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 594, in run\\n    kernel = self.compile(src, target=target, options=options.__dict__)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/compiler/compiler.py\", line 339, in compile\\n    module = src.make_ir(options, codegen_fns, module_map, context)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/compiler/compiler.py\", line 83, in make_ir\\n    return ast_to_ttir(self.fn, self, context=context, options=options, codegen_fns=codegen_fns,\\ntriton.compiler.errors.CompilationError: at 41:15:\\n        )\\n\\n        # Load weight block\\n        w_ptr_mask = feature_mask[:, None] & k_mask[None, :]\\n        w_vals = tl.load(\\n            weight_ptr + k_idx[None, :] * stride_wk + feature_idx[:, None] * stride_wn,\\n            mask=w_ptr_mask,\\n            other=0.0\\n        )\\n\\n        # Compute partial dot product\\n        acc += tl.dot(x_vals, w_vals, allow_tf32=True)\\n               ^\\n\\n\\nThe above exception was the direct cause of the following exception:\\n\\nTraceback (most recent call last):\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/language/core.py\", line 42, in wrapper\\n    return fn(*args, **kwargs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/language/core.py\", line 2045, in dot\\n    return _semantic.dot(input, other, acc, input_precision, max_num_imprecise_acc, out_dtype)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/language/semantic.py\", line 1498, in dot\\n    assert lhs.shape[-1].value == rhs.shape[\\nAssertionError: First input shape ([\\'constexpr[64]\\', \\'constexpr[32]\\']) and second input shape [\\'constexpr[64]\\', \\'constexpr[32]\\'] are not compatible for matmul (second index of first shape (32) must be equal to first index of second shape (64)\\n', 'runtime_error_name': 'triton.compiler.errors.CompilationError', 'reference_timing_ms': 0.109, 'speed_up': -1.0, 'custom_timing': -1.0}, 'runtime': -1.0, 'runtime_stats': {}}}\n- Outcome: Mixed results\n\n\n### Attempt 1\n- Changes: Unknown changes\n- Performance: compiled: 1.0000, correctness: 1.0000, stage: success, passed: 1.0000, score: 34.5000, speed_up: 1.1450, runtime_ms: 0.0952, meta: {'hardware': 'NVIDIA L20Y', 'device': 'cuda:7', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.109, 'speed_up': 1.145, 'custom_timing': 0.0952}\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 34.5000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef _fused_forward_kernel(\n    # Pointers\n    x_ptr,\n    gemm_weight_ptr,\n    gemm_bias_ptr,\n    gn_weight_ptr,\n    gn_bias_ptr,\n    mult_weight_ptr,\n    output_ptr,\n    # Shapes\n    batch_size,\n    in_features,\n    out_features,\n    num_groups,\n    # Meta-parameters\n    eps: tl.constexpr,\n    BLOCK_SIZE_K: tl.constexpr,\n    GROUP_SIZE: tl.constexpr,\n):\n    pid_batch = tl.program_id(0)\n    pid_group = tl.program_id(1)\n    \n    # Compute group boundaries\n    group_start = pid_group * GROUP_SIZE\n    group_range = tl.arange(0, GROUP_SIZE)\n    feature_mask = group_range < (out_features - group_start)\n    \n    # Initialize accumulator\n    acc = tl.zeros((GROUP_SIZE,), dtype=tl.float32)\n    x_ptrs = x_ptr + pid_batch * in_features\n    \n    # Loop over input features with vectorized loads\n    for k in range(0, tl.cdiv(in_features, BLOCK_SIZE_K)):\n        k_offsets = k * BLOCK_SIZE_K + tl.arange(0, BLOCK_SIZE_K)\n        k_mask = k_offsets < in_features\n        \n        # Vectorized load\n        x_block = tl.load(\n            x_ptrs + k_offsets,\n            mask=k_mask,\n            other=0.0\n        )\n        \n        # Weight pointers with precomputation\n        w_start = (group_start + group_range[:, None]) * in_features\n        w_ptrs = gemm_weight_ptr + w_start + k_offsets[None, :]\n        w_block = tl.load(\n            w_ptrs,\n            mask=k_mask[None, :] & feature_mask[:, None],\n            other=0.0\n        )\n        \n        # Accumulate with efficient dot product\n        acc += tl.sum(w_block * x_block[None, :], axis=1)\n    \n    # Add bias\n    bias_ptrs = gemm_bias_ptr + group_start + group_range\n    bias = tl.load(bias_ptrs, mask=feature_mask, other=0.0)\n    acc += bias\n    \n    # Compute GroupNorm statistics (corrected group size)\n    group_count = tl.sum(tl.cast(feature_mask, tl.float32))\n    mean = tl.sum(acc) / group_count\n    diff = acc - mean\n    var = tl.sum(diff * diff) / group_count\n    rstd = 1.0 / tl.sqrt(var + eps)\n    \n    # Apply GroupNorm with fused operations\n    gn_weight = tl.load(gn_weight_ptr + group_start + group_range, mask=feature_mask, other=0.0)\n    gn_bias = tl.load(gn_bias_ptr + group_start + group_range, mask=feature_mask, other=0.0)\n    normalized = (diff * rstd) * gn_weight + gn_bias\n    \n    # Fused Swish operations\n    sig1 = tl.sigmoid(normalized)\n    swish1 = normalized * sig1\n    \n    # Multiply\n    mult_weight = tl.load(mult_weight_ptr + group_start + group_range, mask=feature_mask, other=0.0)\n    multiplied = swish1 * mult_weight\n    \n    # Second Swish (fused)\n    sig2 = tl.sigmoid(multiplied)\n    swish2 = multiplied * sig2\n    \n    # Store results with coalesced writes\n    out_offsets = pid_batch * out_features + group_start + group_range\n    tl.store(output_ptr + out_offsets, swish2, mask=feature_mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, num_groups, multiply_weight_shape):\n        super(ModelNew, self).__init__()\n        self.gemm = nn.Linear(in_features, out_features)\n        self.group_norm = nn.GroupNorm(num_groups, out_features)\n        self.multiply_weight = nn.Parameter(torch.randn(multiply_weight_shape))\n        self.out_features = out_features\n        self.num_groups = num_groups\n\n    def forward(self, x):\n        batch_size, _ = x.shape\n        group_size = self.out_features // self.num_groups\n        \n        # Ensure tensors are contiguous\n        x = x.contiguous()\n        output = torch.empty((batch_size, self.out_features), device=x.device, dtype=x.dtype)\n        \n        # Launch kernel with optimized parameters\n        grid = (batch_size, self.num_groups)\n        _fused_forward_kernel[grid](\n            x, \n            self.gemm.weight, \n            self.gemm.bias,\n            self.group_norm.weight,\n            self.group_norm.bias,\n            self.multiply_weight,\n            output,\n            batch_size,\n            self.gemm.in_features,\n            self.out_features,\n            self.num_groups,\n            eps=1e-5,\n            BLOCK_SIZE_K=256,  # Increased for better memory efficiency\n            GROUP_SIZE=group_size\n        )\n        return output\n\nbatch_size = 128\nin_features = 512\nout_features = 1024\nnum_groups = 16\nmultiply_weight_shape = (out_features,)\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, num_groups, multiply_weight_shape]\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Performs well on compiled (1.0000), Performs well on correctness (1.0000), Performs well on stage (success), Performs well on passed (1.0000), Performs well on score (34.5000), Performs well on speed_up (1.1450), Performs well on runtime_ms (0.0952), Performs well on meta ({'hardware': 'NVIDIA L20Y', 'device': 'cuda:7', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.109, 'speed_up': 1.145, 'custom_timing': 0.0952})\n\n\n### Program 2 (Score: 10.0000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n# Optimized GEMM kernel using Triton\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_SIZE_B': 64, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 64}, num_stages=4, num_warps=8),\n        triton.Config({'BLOCK_SIZE_B': 64, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 32}, num_stages=4, num_warps=4),\n        triton.Config({'BLOCK_SIZE_B': 32, 'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 32}, num_stages=4, num_warps=4),\n        triton.Config({'BLOCK_SIZE_B': 128, 'BLOCK_SIZE_N': 32, 'BLOCK_SIZE_K': 64}, num_stages=4, num_warps=4),\n    ],\n    key=['batch_size', 'out_features', 'in_features'],\n)\n@triton.jit\ndef gemm_triton_kernel(\n    x_ptr, weight_ptr, bias_ptr, output_ptr,\n    batch_size, in_features, out_features,\n    stride_xb, stride_xk,\n    stride_wk, stride_wn,\n    stride_ob, stride_on,\n    BLOCK_SIZE_B: tl.constexpr, BLOCK_SIZE_N: tl.constexpr, BLOCK_SIZE_K: tl.constexpr,\n):\n    pid_b = tl.program_id(0)\n    pid_n = tl.program_id(1)\n    \n    batch_idx = pid_b * BLOCK_SIZE_B + tl.arange(0, BLOCK_SIZE_B)\n    feature_idx = pid_n * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n    \n    batch_mask = batch_idx < batch_size\n    feature_mask = feature_idx < out_features\n    \n    acc = tl.zeros((BLOCK_SIZE_B, BLOCK_SIZE_N), dtype=tl.float32)\n    \n    for k in range(0, tl.cdiv(in_features, BLOCK_SIZE_K)):\n        k_idx = k * BLOCK_SIZE_K + tl.arange(0, BLOCK_SIZE_K)\n        k_mask = k_idx < in_features\n        \n        # Load input block\n        x_ptr_mask = batch_mask[:, None] & k_mask[None, :]\n        x_vals = tl.load(\n            x_ptr + batch_idx[:, None] * stride_xb + k_idx[None, :] * stride_xk,\n            mask=x_ptr_mask,\n            other=0.0\n        )\n        \n        # Load weight block\n        w_ptr_mask = feature_mask[:, None] & k_mask[None, :]\n        w_vals = tl.load(\n            weight_ptr + k_idx[None, :] * stride_wk + feature_idx[:, None] * stride_wn,\n            mask=w_ptr_mask,\n            other=0.0\n        )\n        \n        # Compute partial dot product\n        acc += tl.dot(x_vals, w_vals, allow_tf32=True)\n    \n    # Add bias\n    bias_vals = tl.load(bias_ptr + feature_idx, mask=feature_mask, other=0.0)\n    acc += bias_vals[None, :]\n    \n    # Store results\n    out_ptr_mask = batch_mask[:, None] & feature_mask[None, :]\n    tl.store(\n        output_ptr + batch_idx[:, None] * stride_ob + feature_idx[None, :] * stride_on,\n        acc,\n        mask=out_ptr_mask\n    )\n\n# Fused GroupNorm + Swish + Multiply + Swish kernel\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_SIZE': 128}, num_warps=8),\n        triton.Config({'BLOCK_SIZE': 64}, num_warps=4),\n        triton.Config({'BLOCK_SIZE': 256}, num_warps=8),\n    ],\n    key=['out_features'],\n)\n@triton.jit\ndef fused_gn_swish_kernel(\n    x_ptr, gn_weight_ptr, gn_bias_ptr, mult_weight_ptr, output_ptr,\n    batch_size, out_features, num_groups,\n    stride_xb, stride_xf,\n    stride_ob, stride_of,\n    BLOCK_SIZE: tl.constexpr,\n):\n    pid = tl.program_id(0)\n    group_id = pid % num_groups\n    batch_idx = pid // num_groups\n    \n    if batch_idx >= batch_size:\n        return\n    \n    group_size = out_features // num_groups\n    group_start = group_id * group_size\n    feature_idx = group_start + tl.arange(0, BLOCK_SIZE)\n    feature_mask = feature_idx < (group_id + 1) * group_size\n    \n    # Load data\n    x_vals = tl.load(\n        x_ptr + batch_idx * stride_xb + feature_idx * stride_xf,\n        mask=feature_mask,\n        other=0.0\n    )\n    \n    # Load normalization parameters\n    gn_weight = tl.load(gn_weight_ptr + feature_idx, mask=feature_mask, other=0.0)\n    gn_bias = tl.load(gn_bias_ptr + feature_idx, mask=feature_mask, other=0.0)\n    \n    # GroupNorm calculations\n    mean = tl.sum(x_vals, axis=0) / group_size\n    centered = x_vals - mean\n    var = tl.sum(centered * centered, axis=0) / group_size\n    rstd = tl.math.rsqrt(var + 1e-5)\n    norm = centered * rstd * gn_weight + gn_bias\n    \n    # First Swish\n    swish1 = norm * tl.sigmoid(norm)\n    \n    # Multiply weight\n    mult_weight = tl.load(mult_weight_ptr + feature_idx, mask=feature_mask, other=0.0)\n    multiplied = swish1 * mult_weight\n    \n    # Second Swish\n    swish2 = multiplied * tl.sigmoid(multiplied)\n    \n    # Store results\n    tl.store(\n        output_ptr + batch_idx * stride_ob + feature_idx * stride_of,\n        swish2,\n        mask=feature_mask\n    )\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, num_groups, multiply_weight_shape):\n        super(ModelNew, self).__init__()\n        self.gemm = nn.Linear(in_features, out_features)\n        self.group_norm = nn.GroupNorm(num_groups, out_features)\n        self.multiply_weight = nn.Parameter(torch.randn(multiply_weight_shape))\n        self.out_features = out_features\n        self.num_groups = num_groups\n\n    def forward(self, x):\n        # GEMM operation\n        batch_size, _ = x.shape\n        out = torch.empty((batch_size, self.out_features), \n                         device=x.device, dtype=x.dtype)\n        \n        grid = (\n            triton.cdiv(batch_size, 64),\n            triton.cdiv(self.out_features, 64),\n        )\n        \n        gemm_triton_kernel[grid](\n            x, self.gemm.weight, self.gemm.bias, out,\n            batch_size, self.gemm.in_features, self.gemm.out_features,\n            x.stride(0), x.stride(1),\n            self.gemm.weight.stride(0), self.gemm.weight.stride(1),\n            out.stride(0), out.stride(1),\n        )\n        \n        # Fused GroupNorm + Swish + Multiply + Swish\n        grid_gn = (batch_size * self.num_groups,)\n        fused_gn_swish_kernel[grid_gn](\n            out, \n            self.group_norm.weight, \n            self.group_norm.bias, \n            self.multiply_weight, \n            out,\n            batch_size, self.out_features, self.num_groups,\n            out.stride(0), out.stride(1),\n            out.stride(0), out.stride(1),\n            BLOCK_SIZE=self.out_features // self.num_groups\n        )\n        \n        return out\n\nbatch_size = 128\nin_features = 512\nout_features = 1024\nnum_groups = 16\nmultiply_weight_shape = (out_features,)\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, num_groups, multiply_weight_shape]\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Performs well on compiled (1.0000), Performs well on correctness (0.0000), Performs well on score (10.0000), Performs well on stage (wrong_answer), Performs well on verify_payload ({'id': 'level2_88_Gemm_GroupNorm_Swish_Multiply_Swish', 'result': {'compiled': True, 'correctness': False, 'metadata': {'hardware': 'NVIDIA L20Y', 'device': 'cuda:4', 'runtime_error': 'Traceback (most recent call last):\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/language/core.py\", line 42, in wrapper\\n    return fn(*args, **kwargs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/language/core.py\", line 2045, in dot\\n    return _semantic.dot(input, other, acc, input_precision, max_num_imprecise_acc, out_dtype)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/language/semantic.py\", line 1498, in dot\\n    assert lhs.shape[-1].value == rhs.shape[\\nAssertionError: First input shape ([\\'constexpr[64]\\', \\'constexpr[32]\\']) and second input shape [\\'constexpr[64]\\', \\'constexpr[32]\\'] are not compatible for matmul (second index of first shape (32) must be equal to first index of second shape (64)\\n\\nThe above exception was the direct cause of the following exception:\\n\\nTraceback (most recent call last):\\n  File \"/cpfs01/shared/llm_kernel/hujiakai/KernelLLM/validation_api_server/helpers/evaluations.py\", line 720, in run_and_check_correctness\\n    output_new = model_new(*inputs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1773, in _wrapped_call_impl\\n    return self._call_impl(*args, **kwargs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1784, in _call_impl\\n    return forward_call(*args, **kwargs)\\n  File \"/tmp/tmpent6fzl3.py\", line 156, in forward\\n    gemm_triton_kernel[grid](\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 390, in <lambda>\\n    return lambda *args, **kwargs: self.run(grid=grid, warmup=False, *args, **kwargs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 239, in run\\n    benchmark()\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 228, in benchmark\\n    timings = {config: self._bench(*args, config=config, **kwargs) for config in pruned_configs}\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 228, in <dictcomp>\\n    timings = {config: self._bench(*args, config=config, **kwargs) for config in pruned_configs}\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 160, in _bench\\n    return self.do_bench(kernel_call, quantiles=(0.5, 0.2, 0.8))\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/testing.py\", line 149, in do_bench\\n    fn()\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 146, in kernel_call\\n    self.fn.run(\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 594, in run\\n    kernel = self.compile(src, target=target, options=options.__dict__)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/compiler/compiler.py\", line 339, in compile\\n    module = src.make_ir(options, codegen_fns, module_map, context)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/compiler/compiler.py\", line 83, in make_ir\\n    return ast_to_ttir(self.fn, self, context=context, options=options, codegen_fns=codegen_fns,\\ntriton.compiler.errors.CompilationError: at 41:15:\\n        )\\n\\n        # Load weight block\\n        w_ptr_mask = feature_mask[:, None] & k_mask[None, :]\\n        w_vals = tl.load(\\n            weight_ptr + k_idx[None, :] * stride_wk + feature_idx[:, None] * stride_wn,\\n            mask=w_ptr_mask,\\n            other=0.0\\n        )\\n\\n        # Compute partial dot product\\n        acc += tl.dot(x_vals, w_vals, allow_tf32=True)\\n               ^\\n\\n\\nThe above exception was the direct cause of the following exception:\\n\\nTraceback (most recent call last):\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/language/core.py\", line 42, in wrapper\\n    return fn(*args, **kwargs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/language/core.py\", line 2045, in dot\\n    return _semantic.dot(input, other, acc, input_precision, max_num_imprecise_acc, out_dtype)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/language/semantic.py\", line 1498, in dot\\n    assert lhs.shape[-1].value == rhs.shape[\\nAssertionError: First input shape ([\\'constexpr[64]\\', \\'constexpr[32]\\']) and second input shape [\\'constexpr[64]\\', \\'constexpr[32]\\'] are not compatible for matmul (second index of first shape (32) must be equal to first index of second shape (64)\\n', 'runtime_error_name': 'triton.compiler.errors.CompilationError', 'reference_timing_ms': 0.109, 'speed_up': -1.0, 'custom_timing': -1.0}, 'runtime': -1.0, 'runtime_stats': {}}})\n\n\n### Program 3 (Score: 10.0000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport math\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n# Triton kernel for GEMM operation\n@triton.jit\ndef gemm_kernel(\n    x_ptr, w_ptr, b_ptr, out_ptr,\n    in_features, out_features,\n    stride_xb, stride_xm,\n    stride_wn, stride_wm,\n    stride_outb, stride_outn,\n    BLOCK_SIZE_M: tl.constexpr, BLOCK_SIZE_N: tl.constexpr, BLOCK_SIZE_K: tl.constexpr,\n    USE_TF32: tl.constexpr\n):\n    pid_batch = tl.program_id(0)\n    pid_feature = tl.program_id(1)\n    \n    # Create pointers for the current batch and feature block\n    x_ptr += pid_batch * stride_xb\n    out_ptr += pid_batch * stride_outb + pid_feature * BLOCK_SIZE_N\n    \n    # Calculate feature block offsets\n    feature_off = pid_feature * BLOCK_SIZE_N\n    w_ptr += feature_off * stride_wn\n    \n    # Initialize accumulator\n    acc = tl.zeros((BLOCK_SIZE_N,), dtype=tl.float32)\n    \n    # Loop over K dimension\n    for k in range(0, tl.cdiv(in_features, BLOCK_SIZE_K)):\n        # Calculate offsets and mask for K dimension\n        k_off = k * BLOCK_SIZE_K\n        cols = k_off + tl.arange(0, BLOCK_SIZE_K)\n        k_mask = cols < in_features\n        \n        # Load input block\n        x = tl.load(x_ptr + cols, mask=k_mask, other=0.0)\n        \n        # Load weight block\n        w = tl.load(w_ptr + cols, mask=k_mask, other=0.0)\n        \n        # Compute partial dot product\n        w = w.to(tl.float32)\n        x = x.to(tl.float32)\n        acc += tl.dot(w, x, allow_tf32=USE_TF32)\n    \n    # Add bias\n    if b_ptr is not None:\n        b = tl.load(b_ptr + feature_off + tl.arange(0, BLOCK_SIZE_N), mask=tl.arange(0, BLOCK_SIZE_N) < (out_features - feature_off), other=0.0)\n        acc += b\n    \n    # Store result\n    tl.store(out_ptr + tl.arange(0, BLOCK_SIZE_N), acc, mask=tl.arange(0, BLOCK_SIZE_N) < (out_features - feature_off))\n\n# Triton kernel for fused GroupNorm + Swish + Multiply + Swish\n@triton.jit\ndef fused_gn_swish_mul_swish_kernel(\n    x_ptr, gn_weight_ptr, gn_bias_ptr, mul_weight_ptr, out_ptr,\n    num_features, num_groups, eps,\n    BLOCK_SIZE: tl.constexpr\n):\n    pid_batch = tl.program_id(0)\n    pid_group = tl.program_id(1)\n    \n    # Calculate group parameters\n    group_size = num_features // num_groups\n    group_start = pid_group * group_size\n    group_end = group_start + group_size\n    \n    # Create pointers for current batch and group\n    x_ptr += pid_batch * num_features + group_start\n    gn_weight_ptr += group_start\n    gn_bias_ptr += group_start\n    mul_weight_ptr += group_start\n    out_ptr += pid_batch * num_features + group_start\n    \n    # Load data for the group\n    idxs = tl.arange(0, BLOCK_SIZE)\n    mask = idxs < group_size\n    \n    x = tl.load(x_ptr + idxs, mask=mask, other=0.0)\n    gn_weight = tl.load(gn_weight_ptr + idxs, mask=mask, other=0.0)\n    gn_bias = tl.load(gn_bias_ptr + idxs, mask=mask, other=0.0)\n    mul_weight = tl.load(mul_weight_ptr + idxs, mask=mask, other=0.0)\n    \n    # Compute mean and variance\n    mean = tl.sum(x, axis=0) / group_size\n    x_centered = x - mean\n    var = tl.sum(x_centered * x_centered, axis=0) / group_size + eps\n    inv_std = 1.0 / tl.sqrt(var)\n    \n    # GroupNorm calculation\n    normalized = x_centered * inv_std\n    y = normalized * gn_weight + gn_bias\n    \n    # First Swish activation\n    swish1 = y * tl.sigmoid(y)\n    \n    # Multiply with weight\n    multiplied = swish1 * mul_weight\n    \n    # Second Swish activation\n    swish2 = multiplied * tl.sigmoid(multiplied)\n    \n    # Store result\n    tl.store(out_ptr + idxs, swish2, mask=mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, num_groups, multiply_weight_shape):\n        super(ModelNew, self).__init__()\n        self.in_features = in_features\n        self.out_features = out_features\n        self.num_groups = num_groups\n        \n        # Initialize weights and biases\n        self.weight = nn.Parameter(torch.empty(out_features, in_features))\n        self.bias = nn.Parameter(torch.empty(out_features))\n        self.gn_weight = nn.Parameter(torch.ones(out_features))\n        self.gn_bias = nn.Parameter(torch.zeros(out_features))\n        self.multiply_weight = nn.Parameter(torch.randn(multiply_weight_shape))\n        \n        # Initialize parameters\n        nn.init.kaiming_uniform_(self.weight, a=math.sqrt(5))\n        fan_in, _ = nn.init._calculate_fan_in_and_fan_out(self.weight)\n        bound = 1 / math.sqrt(fan_in) if fan_in > 0 else 0\n        nn.init.uniform_(self.bias, -bound, bound)\n\n    def forward(self, x):\n        batch_size, _ = x.shape\n        \n        # Allocate output for GEMM\n        out = torch.empty((batch_size, self.out_features), device=x.device, dtype=torch.float32)\n        \n        # Configure GEMM kernel\n        grid = (batch_size, triton.cdiv(self.out_features, 64))\n        gemm_kernel[grid](\n            x, self.weight, self.bias, out,\n            self.in_features, self.out_features,\n            x.stride(0), x.stride(1),\n            self.weight.stride(0), self.weight.stride(1),\n            out.stride(0), out.stride(1),\n            BLOCK_SIZE_M=1, BLOCK_SIZE_N=64, BLOCK_SIZE_K=64,\n            USE_TF32=True\n        )\n        \n        # Configure fused kernel\n        group_size = self.out_features // self.num_groups\n        grid = (batch_size, self.num_groups)\n        fused_gn_swish_mul_swish_kernel[grid](\n            out, self.gn_weight, self.gn_bias, self.multiply_weight, out,\n            self.out_features, self.num_groups, 1e-5,\n            BLOCK_SIZE=group_size\n        )\n        \n        return out\n\nbatch_size = 128\nin_features = 512\nout_features = 1024\nnum_groups = 16\nmultiply_weight_shape = (out_features,)\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, num_groups, multiply_weight_shape]\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Performs well on compiled (1.0000), Performs well on correctness (0.0000), Performs well on score (10.0000), Performs well on stage (wrong_answer), Performs well on verify_payload ({'id': 'level2_88_Gemm_GroupNorm_Swish_Multiply_Swish', 'result': {'compiled': True, 'correctness': False, 'metadata': {'hardware': 'NVIDIA L20Y', 'device': 'cuda:0', 'runtime_error': 'Traceback (most recent call last):\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/language/core.py\", line 42, in wrapper\\n    return fn(*args, **kwargs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/language/core.py\", line 2045, in dot\\n    return _semantic.dot(input, other, acc, input_precision, max_num_imprecise_acc, out_dtype)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/language/semantic.py\", line 1497, in dot\\n    assert lhs_rank == rhs_rank == 2 or lhs_rank == rhs_rank == 3, f\"Both inputs must be either 2D or 3D; (lhs: {lhs.shape} vs rhs: {rhs.shape})\"\\nAssertionError: Both inputs must be either 2D or 3D; (lhs: [\\'constexpr[64]\\'] vs rhs: [\\'constexpr[64]\\'])\\n\\nThe above exception was the direct cause of the following exception:\\n\\nTraceback (most recent call last):\\n  File \"/cpfs01/shared/llm_kernel/hujiakai/KernelLLM/validation_api_server/helpers/evaluations.py\", line 720, in run_and_check_correctness\\n    output_new = model_new(*inputs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1773, in _wrapped_call_impl\\n    return self._call_impl(*args, **kwargs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1784, in _call_impl\\n    return forward_call(*args, **kwargs)\\n  File \"/tmp/tmpbqp9kzpo.py\", line 140, in forward\\n    gemm_kernel[grid](\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 390, in <lambda>\\n    return lambda *args, **kwargs: self.run(grid=grid, warmup=False, *args, **kwargs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 594, in run\\n    kernel = self.compile(src, target=target, options=options.__dict__)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/compiler/compiler.py\", line 339, in compile\\n    module = src.make_ir(options, codegen_fns, module_map, context)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/compiler/compiler.py\", line 83, in make_ir\\n    return ast_to_ttir(self.fn, self, context=context, options=options, codegen_fns=codegen_fns,\\ntriton.compiler.errors.CompilationError: at 40:15:\\n        k_mask = cols < in_features\\n\\n        # Load input block\\n        x = tl.load(x_ptr + cols, mask=k_mask, other=0.0)\\n\\n        # Load weight block\\n        w = tl.load(w_ptr + cols, mask=k_mask, other=0.0)\\n\\n        # Compute partial dot product\\n        w = w.to(tl.float32)\\n        x = x.to(tl.float32)\\n        acc += tl.dot(w, x, allow_tf32=USE_TF32)\\n               ^\\n\\n\\nThe above exception was the direct cause of the following exception:\\n\\nTraceback (most recent call last):\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/language/core.py\", line 42, in wrapper\\n    return fn(*args, **kwargs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/language/core.py\", line 2045, in dot\\n    return _semantic.dot(input, other, acc, input_precision, max_num_imprecise_acc, out_dtype)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/language/semantic.py\", line 1497, in dot\\n    assert lhs_rank == rhs_rank == 2 or lhs_rank == rhs_rank == 3, f\"Both inputs must be either 2D or 3D; (lhs: {lhs.shape} vs rhs: {rhs.shape})\"\\nAssertionError: Both inputs must be either 2D or 3D; (lhs: [\\'constexpr[64]\\'] vs rhs: [\\'constexpr[64]\\'])\\n', 'runtime_error_name': 'triton.compiler.errors.CompilationError', 'reference_timing_ms': 0.109, 'speed_up': -1.0, 'custom_timing': -1.0}, 'runtime': -1.0, 'runtime_stats': {}}})\n\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 1.0000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit(num_warps=8, num_stages=1)\ndef _fused_forward_kernel(\n    # Pointers\n    x_ptr,\n    gemm_weight_ptr,\n    gemm_bias_ptr,\n    gn_weight_ptr,\n    gn_bias_ptr,\n    mult_weight_ptr,\n    output_ptr,\n    # Shapes\n    batch_size,\n    in_features,\n    out_features,\n    num_groups,\n    # Meta-parameters\n    eps: tl.constexpr,\n    BLOCK_SIZE_K: tl.constexpr,\n    GROUP_SIZE: tl.constexpr,\n):\n    pid_batch = tl.program_id(0)\n    pid_group = tl.program_id(1)\n    \n    # Compute group boundaries\n    group_start = pid_group * GROUP_SIZE\n    group_range = tl.arange(0, GROUP_SIZE)\n    feature_mask = group_range < (out_features - group_start)\n    \n    # Precompute weight row pointers for coalesced access\n    weight_row_start = group_start * in_features\n    row_ptrs = gemm_weight_ptr + weight_row_start + group_range[:, None] * in_features\n    \n    # Initialize accumulator\n    acc = tl.zeros((GROUP_SIZE,), dtype=tl.float32)\n    x_ptrs = x_ptr + pid_batch * in_features\n    \n    # Loop over input features with vectorized loads\n    for k in range(0, tl.cdiv(in_features, BLOCK_SIZE_K)):\n        k_offsets = k * BLOCK_SIZE_K + tl.arange(0, BLOCK_SIZE_K)\n        k_mask = k_offsets < in_features\n        \n        # Vectorized load\n        x_block = tl.load(\n            x_ptrs + k_offsets,\n            mask=k_mask,\n            other=0.0\n        )\n        \n        # Load weight block using precomputed row pointers\n        w_ptrs = row_ptrs + k_offsets[None, :]\n        w_block = tl.load(\n            w_ptrs,\n            mask=k_mask[None, :] & feature_mask[:, None],\n            other=0.0\n        )\n        \n        # Efficient accumulation\n        acc += tl.sum(w_block * x_block[None, :], axis=1)\n    \n    # Add bias\n    bias_ptrs = gemm_bias_ptr + group_start + group_range\n    bias = tl.load(bias_ptrs, mask=feature_mask, other=0.0)\n    acc += bias\n    \n    # Compute GroupNorm statistics\n    group_count = tl.sum(tl.cast(feature_mask, tl.float32))\n    mean = tl.sum(acc) / group_count\n    diff = acc - mean\n    var = tl.sum(diff * diff) / group_count\n    rstd = 1.0 / tl.sqrt(var + eps)\n    \n    # Apply GroupNorm with fused operations\n    gn_weight = tl.load(gn_weight_ptr + group_start + group_range, mask=feature_mask, other=0.0)\n    gn_bias = tl.load(gn_bias_ptr + group_start + group_range, mask=feature_mask, other=0.0)\n    normalized = (diff * rstd) * gn_weight + gn_bias\n    \n    # Fused Swish operations\n    swish1 = normalized * tl.sigmoid(normalized)\n    multiplied = swish1 * tl.load(mult_weight_ptr + group_start + group_range, mask=feature_mask, other=0.0)\n    swish2 = multiplied * tl.sigmoid(multiplied)\n    \n    # Store results\n    out_offsets = pid_batch * out_features + group_start + group_range\n    tl.store(output_ptr + out_offsets, swish2, mask=feature_mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, num_groups, multiply_weight_shape):\n        super(ModelNew, self).__init__()\n        self.gemm = nn.Linear(in_features, out_features)\n        self.group_norm = nn.GroupNorm(num_groups, out_features)\n        self.multiply_weight = nn.Parameter(torch.randn(multiply_weight_shape))\n        self.out_features = out_features\n        self.num_groups = num_groups\n\n    def forward(self, x):\n        batch_size, _ = x.shape\n        group_size = self.out_features // self.num_groups\n        \n        # Ensure tensors are contiguous\n        x = x.contiguous()\n        output = torch.empty((batch_size, self.out_features), device=x.device, dtype=x.dtype)\n        \n        # Launch kernel with optimized parameters\n        grid = (batch_size, self.num_groups)\n        _fused_forward_kernel[grid](\n            x, \n            self.gemm.weight, \n            self.gemm.bias,\n            self.group_norm.weight,\n            self.group_norm.bias,\n            self.multiply_weight,\n            output,\n            batch_size,\n            self.gemm.in_features,\n            self.out_features,\n            self.num_groups,\n            eps=1e-5,\n            BLOCK_SIZE_K=256,  # Fixed optimal block size\n            GROUP_SIZE=group_size\n        )\n        return output\n\nbatch_size = 128\nin_features = 512\nout_features = 1024\nnum_groups = 16\nmultiply_weight_shape = (out_features,)\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, num_groups, multiply_weight_shape]\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Alternative approach to compiled, Alternative approach to correctness\n\n\n### Program D2 (Score: 10.0000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport math\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n# Fixed GEMM kernel with 2D tensor handling\n@triton.jit\ndef gemm_kernel(\n    x_ptr, w_ptr, b_ptr, out_ptr,\n    in_features, out_features,\n    stride_xb, stride_xm,\n    stride_wn, stride_wm,\n    stride_outb, stride_outn,\n    BLOCK_SIZE_M: tl.constexpr, BLOCK_SIZE_N: tl.constexpr, BLOCK_SIZE_K: tl.constexpr,\n    USE_TF32: tl.constexpr\n):\n    pid_batch = tl.program_id(0)\n    pid_feature = tl.program_id(1)\n    \n    # Create pointers for current batch\n    x_ptr += pid_batch * stride_xb\n    out_ptr += pid_batch * stride_outb\n    \n    # Calculate feature block\n    feature_idx = pid_feature * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n    feature_mask = feature_idx < out_features\n    \n    # Initialize accumulator\n    acc = tl.zeros((BLOCK_SIZE_N,), dtype=tl.float32)\n    \n    # Loop over K dimension with vectorized loads\n    for k in range(0, tl.cdiv(in_features, BLOCK_SIZE_K)):\n        k_idx = k * BLOCK_SIZE_K + tl.arange(0, BLOCK_SIZE_K)\n        k_mask = k_idx < in_features\n        \n        # Load input block (vectorized)\n        x_vals = tl.load(\n            x_ptr + k_idx,\n            mask=k_mask,\n            other=0.0\n        )\n        \n        # Load weight block (2D tensor)\n        w_ptrs = w_ptr + feature_idx[:, None] * stride_wn + k_idx[None, :] * stride_wm\n        w_vals = tl.load(\n            w_ptrs,\n            mask=feature_mask[:, None] & k_mask[None, :],\n            other=0.0\n        )\n        \n        # Compute partial dot product\n        partial = tl.sum(w_vals * x_vals[None, :], axis=1)\n        acc += partial\n    \n    # Add bias with vectorized load\n    if b_ptr is not None:\n        b_vals = tl.load(\n            b_ptr + feature_idx,\n            mask=feature_mask,\n            other=0.0\n        )\n        acc += b_vals\n    \n    # Store result with vectorized store\n    tl.store(\n        out_ptr + feature_idx,\n        acc,\n        mask=feature_mask\n    )\n\n# Triton kernel for fused GroupNorm + Swish + Multiply + Swish\n@triton.jit\ndef fused_gn_swish_mul_swish_kernel(\n    x_ptr, gn_weight_ptr, gn_bias_ptr, mul_weight_ptr, out_ptr,\n    num_features, num_groups, eps,\n    BLOCK_SIZE: tl.constexpr\n):\n    pid_batch = tl.program_id(0)\n    pid_group = tl.program_id(1)\n    \n    # Calculate group parameters\n    group_size = num_features // num_groups\n    group_start = pid_group * group_size\n    group_end = group_start + group_size\n    \n    # Create pointers for current batch and group\n    x_ptr += pid_batch * num_features + group_start\n    gn_weight_ptr += group_start\n    gn_bias_ptr += group_start\n    mul_weight_ptr += group_start\n    out_ptr += pid_batch * num_features + group_start\n    \n    # Load data for the group\n    idxs = tl.arange(0, BLOCK_SIZE)\n    mask = idxs < group_size\n    \n    x = tl.load(x_ptr + idxs, mask=mask, other=0.0)\n    gn_weight = tl.load(gn_weight_ptr + idxs, mask=mask, other=0.0)\n    gn_bias = tl.load(gn_bias_ptr + idxs, mask=mask, other=0.0)\n    mul_weight = tl.load(mul_weight_ptr + idxs, mask=mask, other=0.0)\n    \n    # Compute mean and variance\n    mean = tl.sum(x, axis=0) / group_size\n    x_centered = x - mean\n    var = tl.sum(x_centered * x_centered, axis=0) / group_size + eps\n    inv_std = 1.0 / tl.sqrt(var)\n    \n    # GroupNorm calculation\n    normalized = x_centered * inv_std\n    y = normalized * gn_weight + gn_bias\n    \n    # First Swish activation\n    swish1 = y * tl.sigmoid(y)\n    \n    # Multiply with weight\n    multiplied = swish1 * mul_weight\n    \n    # Second Swish activation\n    swish2 = multiplied * tl.sigmoid(multiplied)\n    \n    # Store result\n    tl.store(out_ptr + idxs, swish2, mask=mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, num_groups, multiply_weight_shape):\n        super(ModelNew, self).__init__()\n        self.in_features = in_features\n        self.out_features = out_features\n        self.num_groups = num_groups\n        \n        # Initialize weights and biases\n        self.weight = nn.Parameter(torch.empty(out_features, in_features))\n        self.bias = nn.Parameter(torch.empty(out_features))\n        self.gn_weight = nn.Parameter(torch.ones(out_features))\n        self.gn_bias = nn.Parameter(torch.zeros(out_features))\n        self.multiply_weight = nn.Parameter(torch.randn(multiply_weight_shape))\n        \n        # Initialize parameters\n        nn.init.kaiming_uniform_(self.weight, a=math.sqrt(5))\n        fan_in, _ = nn.init._calculate_fan_in_and_fan_out(self.weight)\n        bound = 1 / math.sqrt(fan_in) if fan_in > 0 else 0\n        nn.init.uniform_(self.bias, -bound, bound)\n\n    def forward(self, x):\n        batch_size, _ = x.shape\n        \n        # Allocate output for GEMM\n        out = torch.empty((batch_size, self.out_features), device=x.device, dtype=torch.float32)\n        \n        # Configure GEMM kernel\n        grid = (batch_size, triton.cdiv(self.out_features, 64))\n        gemm_kernel[grid](\n            x, self.weight, self.bias, out,\n            self.in_features, self.out_features,\n            x.stride(0), x.stride(1),\n            self.weight.stride(0), self.weight.stride(1),\n            out.stride(0), out.stride(1),\n            BLOCK_SIZE_M=1, BLOCK_SIZE_N=64, BLOCK_SIZE_K=64,\n            USE_TF32=True\n        )\n        \n        # Configure fused kernel\n        group_size = self.out_features // self.num_groups\n        grid = (batch_size, self.num_groups)\n        fused_gn_swish_mul_swish_kernel[grid](\n            out, self.gn_weight, self.gn_bias, self.multiply_weight, out,\n            self.out_features, self.num_groups, 1e-5,\n            BLOCK_SIZE=group_size\n        )\n        \n        return out\n\nbatch_size = 128\nin_features = 512\nout_features = 1024\nnum_groups = 16\nmultiply_weight_shape = (out_features,)\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, num_groups, multiply_weight_shape]\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Alternative approach to compiled, Alternative approach to correctness\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 34.5000, Type: High-Performer)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef _fused_forward_kernel(\n    # Pointers\n    x_ptr,\n    gemm_weight_ptr,\n    gemm_bias_ptr,\n    gn_weight_ptr,\n    gn_bias_ptr,\n    mult_weight_ptr,\n    output_ptr,\n    # Shapes\n    batch_size,\n    in_features,\n    out_features,\n    num_groups,\n    # Meta-parameters\n    eps: tl.constexpr,\n    BLOCK_SIZE_K: tl.constexpr,\n    GROUP_SIZE: tl.constexpr,\n):\n    pid_batch = tl.program_id(0)\n    pid_group = tl.program_id(1)\n    \n    # Compute group boundaries\n    group_start = pid_group * GROUP_SIZE\n    group_range = tl.arange(0, GROUP_SIZE)\n    feature_mask = group_range < (out_features - group_start)\n    \n    # Initialize accumulator\n    acc = tl.zeros((GROUP_SIZE,), dtype=tl.float32)\n    x_ptrs = x_ptr + pid_batch * in_features\n    \n    # Loop over input features with vectorized loads\n    for k in range(0, tl.cdiv(in_features, BLOCK_SIZE_K)):\n        k_offsets = k * BLOCK_SIZE_K + tl.arange(0, BLOCK_SIZE_K)\n        k_mask = k_offsets < in_features\n        \n        # Vectorized load\n        x_block = tl.load(\n            x_ptrs + k_offsets,\n            mask=k_mask,\n            other=0.0\n        )\n        \n        # Weight pointers with precomputation\n        w_start = (group_start + group_range[:, None]) * in_features\n        w_ptrs = gemm_weight_ptr + w_start + k_offsets[None, :]\n        w_block = tl.load(\n            w_ptrs,\n            mask=k_mask[None, :] & feature_mask[:, None],\n            other=0.0\n        )\n        \n        # Accumulate with efficient dot product\n        acc += tl.sum(w_block * x_block[None, :], axis=1)\n    \n    # Add bias\n    bias_ptrs = gemm_bias_ptr + group_start + group_range\n    bias = tl.load(bias_ptrs, mask=feature_mask, other=0.0)\n    acc += bias\n    \n    # Compute GroupNorm statistics (corrected group size)\n    group_count = tl.sum(tl.cast(feature_mask, tl.float32))\n    mean = tl.sum(acc) / group_count\n    diff = acc - mean\n    var = tl.sum(diff * diff) / group_count\n    rstd = 1.0 / tl.sqrt(var + eps)\n    \n    # Apply GroupNorm with fused operations\n    gn_weight = tl.load(gn_weight_ptr + group_start + group_range, mask=feature_mask, other=0.0)\n    gn_bias = tl.load(gn_bias_ptr + group_start + group_range, mask=feature_mask, other=0.0)\n    normalized = (diff * rstd) * gn_weight + gn_bias\n    \n    # Fused Swish operations\n    sig1 = tl.sigmoid(normalized)\n    swish1 = normalized * sig1\n    \n    # Multiply\n    mult_weight = tl.load(mult_weight_ptr + group_start + group_range, mask=feature_mask, other=0.0)\n    multiplied = swish1 * mult_weight\n    \n    # Second Swish (fused)\n    sig2 = tl.sigmoid(multiplied)\n    swish2 = multiplied * sig2\n    \n    # Store results with coalesced writes\n    out_offsets = pid_batch * out_features + group_start + group_range\n    tl.store(output_ptr + out_offsets, swish2, mask=feature_mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, num_groups, multiply_weight_shape):\n        super(ModelNew, self).__init__()\n        self.gemm = nn.Linear(in_features, out_features)\n        self.group_norm = nn.GroupNorm(num_groups, out_features)\n        self.multiply_weight = nn.Parameter(torch.randn(multiply_weight_shape))\n        self.out_features = out_features\n        self.num_groups = num_groups\n\n    def forward(self, x):\n        batch_size, _ = x.shape\n        group_size = self.out_features // self.num_groups\n        \n        # Ensure tensors are contiguous\n        x = x.contiguous()\n        output = torch.empty((batch_size, self.out_features), device=x.device, dtype=x.dtype)\n        \n        # Launch kernel with optimized parameters\n        grid = (batch_size, self.num_groups)\n        _fused_forward_kernel[grid](\n            x, \n            self.gemm.weight, \n            self.gemm.bias,\n            self.group_norm.weight,\n            self.group_norm.bias,\n            self.multiply_weight,\n            output,\n            batch_size,\n            self.gemm.in_features,\n            self.out_features,\n            self.num_groups,\n            eps=1e-5,\n            BLOCK_SIZE_K=256,  # Increased for better memory efficiency\n            GROUP_SIZE=group_size\n        )\n        return output\n\nbatch_size = 128\nin_features = 512\nout_features = 1024\nnum_groups = 16\nmultiply_weight_shape = (out_features,)\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, num_groups, multiply_weight_shape]\n# =================== EVOLVE-BLOCK-END ===================\n```\nUnique approach: Modification: Full rewrite, Excellent compiled (1.000), Excellent correctness (1.000)\n\n\n### Inspiration 2 (Score: 10.0000, Type: High-Performer)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n# Optimized GEMM kernel using Triton\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_SIZE_B': 64, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 64}, num_stages=4, num_warps=8),\n        triton.Config({'BLOCK_SIZE_B': 64, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 32}, num_stages=4, num_warps=4),\n        triton.Config({'BLOCK_SIZE_B': 32, 'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 32}, num_stages=4, num_warps=4),\n        triton.Config({'BLOCK_SIZE_B': 128, 'BLOCK_SIZE_N': 32, 'BLOCK_SIZE_K': 64}, num_stages=4, num_warps=4),\n    ],\n    key=['batch_size', 'out_features', 'in_features'],\n)\n@triton.jit\ndef gemm_triton_kernel(\n    x_ptr, weight_ptr, bias_ptr, output_ptr,\n    batch_size, in_features, out_features,\n    stride_xb, stride_xk,\n    stride_wk, stride_wn,\n    stride_ob, stride_on,\n    BLOCK_SIZE_B: tl.constexpr, BLOCK_SIZE_N: tl.constexpr, BLOCK_SIZE_K: tl.constexpr,\n):\n    pid_b = tl.program_id(0)\n    pid_n = tl.program_id(1)\n    \n    batch_idx = pid_b * BLOCK_SIZE_B + tl.arange(0, BLOCK_SIZE_B)\n    feature_idx = pid_n * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n    \n    batch_mask = batch_idx < batch_size\n    feature_mask = feature_idx < out_features\n    \n    acc = tl.zeros((BLOCK_SIZE_B, BLOCK_SIZE_N), dtype=tl.float32)\n    \n    for k in range(0, tl.cdiv(in_features, BLOCK_SIZE_K)):\n        k_idx = k * BLOCK_SIZE_K + tl.arange(0, BLOCK_SIZE_K)\n        k_mask = k_idx < in_features\n        \n        # Load input block\n        x_ptr_mask = batch_mask[:, None] & k_mask[None, :]\n        x_vals = tl.load(\n            x_ptr + batch_idx[:, None] * stride_xb + k_idx[None, :] * stride_xk,\n            mask=x_ptr_mask,\n            other=0.0\n        )\n        \n        # Load weight block\n        w_ptr_mask = feature_mask[:, None] & k_mask[None, :]\n        w_vals = tl.load(\n            weight_ptr + k_idx[None, :] * stride_wk + feature_idx[:, None] * stride_wn,\n            mask=w_ptr_mask,\n            other=0.0\n        )\n        \n        # Compute partial dot product\n        acc += tl.dot(x_vals, w_vals, allow_tf32=True)\n    \n    # Add bias\n    bias_vals = tl.load(bias_ptr + feature_idx, mask=feature_mask, other=0.0)\n    acc += bias_vals[None, :]\n    \n    # Store results\n    out_ptr_mask = batch_mask[:, None] & feature_mask[None, :]\n    tl.store(\n        output_ptr + batch_idx[:, None] * stride_ob + feature_idx[None, :] * stride_on,\n        acc,\n        mask=out_ptr_mask\n    )\n\n# Fused GroupNorm + Swish + Multiply + Swish kernel\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_SIZE': 128}, num_warps=8),\n        triton.Config({'BLOCK_SIZE': 64}, num_warps=4),\n        triton.Config({'BLOCK_SIZE': 256}, num_warps=8),\n    ],\n    key=['out_features'],\n)\n@triton.jit\ndef fused_gn_swish_kernel(\n    x_ptr, gn_weight_ptr, gn_bias_ptr, mult_weight_ptr, output_ptr,\n    batch_size, out_features, num_groups,\n    stride_xb, stride_xf,\n    stride_ob, stride_of,\n    BLOCK_SIZE: tl.constexpr,\n):\n    pid = tl.program_id(0)\n    group_id = pid % num_groups\n    batch_idx = pid // num_groups\n    \n    if batch_idx >= batch_size:\n        return\n    \n    group_size = out_features // num_groups\n    group_start = group_id * group_size\n    feature_idx = group_start + tl.arange(0, BLOCK_SIZE)\n    feature_mask = feature_idx < (group_id + 1) * group_size\n    \n    # Load data\n    x_vals = tl.load(\n        x_ptr + batch_idx * stride_xb + feature_idx * stride_xf,\n        mask=feature_mask,\n        other=0.0\n    )\n    \n    # Load normalization parameters\n    gn_weight = tl.load(gn_weight_ptr + feature_idx, mask=feature_mask, other=0.0)\n    gn_bias = tl.load(gn_bias_ptr + feature_idx, mask=feature_mask, other=0.0)\n    \n    # GroupNorm calculations\n    mean = tl.sum(x_vals, axis=0) / group_size\n    centered = x_vals - mean\n    var = tl.sum(centered * centered, axis=0) / group_size\n    rstd = tl.math.rsqrt(var + 1e-5)\n    norm = centered * rstd * gn_weight + gn_bias\n    \n    # First Swish\n    swish1 = norm * tl.sigmoid(norm)\n    \n    # Multiply weight\n    mult_weight = tl.load(mult_weight_ptr + feature_idx, mask=feature_mask, other=0.0)\n    multiplied = swish1 * mult_weight\n    \n    # Second Swish\n    swish2 = multiplied * tl.sigmoid(multiplied)\n    \n    # Store results\n    tl.store(\n        output_ptr + batch_idx * stride_ob + feature_idx * stride_of,\n        swish2,\n        mask=feature_mask\n    )\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, num_groups, multiply_weight_shape):\n        super(ModelNew, self).__init__()\n        self.gemm = nn.Linear(in_features, out_features)\n        self.group_norm = nn.GroupNorm(num_groups, out_features)\n        self.multiply_weight = nn.Parameter(torch.randn(multiply_weight_shape))\n        self.out_features = out_features\n        self.num_groups = num_groups\n\n    def forward(self, x):\n        # GEMM operation\n        batch_size, _ = x.shape\n        out = torch.empty((batch_size, self.out_features), \n                         device=x.device, dtype=x.dtype)\n        \n        grid = (\n            triton.cdiv(batch_size, 64),\n            triton.cdiv(self.out_features, 64),\n        )\n        \n        gemm_triton_kernel[grid](\n            x, self.gemm.weight, self.gemm.bias, out,\n            batch_size, self.gemm.in_features, self.gemm.out_features,\n            x.stride(0), x.stride(1),\n            self.gemm.weight.stride(0), self.gemm.weight.stride(1),\n            out.stride(0), out.stride(1),\n        )\n        \n        # Fused GroupNorm + Swish + Multiply + Swish\n        grid_gn = (batch_size * self.num_groups,)\n        fused_gn_swish_kernel[grid_gn](\n            out, \n            self.group_norm.weight, \n            self.group_norm.bias, \n            self.multiply_weight, \n            out,\n            batch_size, self.out_features, self.num_groups,\n            out.stride(0), out.stride(1),\n            out.stride(0), out.stride(1),\n            BLOCK_SIZE=self.out_features // self.num_groups\n        )\n        \n        return out\n\nbatch_size = 128\nin_features = 512\nout_features = 1024\nnum_groups = 16\nmultiply_weight_shape = (out_features,)\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, num_groups, multiply_weight_shape]\n# =================== EVOLVE-BLOCK-END ===================\n```\nUnique approach: Modification: Full rewrite, Excellent compiled (1.000), Alternative correctness approach\n\n\n### Inspiration 3 (Score: 10.0000, Type: High-Performer)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport math\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n# Triton kernel for GEMM operation\n@triton.jit\ndef gemm_kernel(\n    x_ptr, w_ptr, b_ptr, out_ptr,\n    in_features, out_features,\n    stride_xb, stride_xm,\n    stride_wn, stride_wm,\n    stride_outb, stride_outn,\n    BLOCK_SIZE_M: tl.constexpr, BLOCK_SIZE_N: tl.constexpr, BLOCK_SIZE_K: tl.constexpr,\n    USE_TF32: tl.constexpr\n):\n    pid_batch = tl.program_id(0)\n    pid_feature = tl.program_id(1)\n    \n    # Create pointers for the current batch and feature block\n    x_ptr += pid_batch * stride_xb\n    out_ptr += pid_batch * stride_outb + pid_feature * BLOCK_SIZE_N\n    \n    # Calculate feature block offsets\n    feature_off = pid_feature * BLOCK_SIZE_N\n    w_ptr += feature_off * stride_wn\n    \n    # Initialize accumulator\n    acc = tl.zeros((BLOCK_SIZE_N,), dtype=tl.float32)\n    \n    # Loop over K dimension\n    for k in range(0, tl.cdiv(in_features, BLOCK_SIZE_K)):\n        # Calculate offsets and mask for K dimension\n        k_off = k * BLOCK_SIZE_K\n        cols = k_off + tl.arange(0, BLOCK_SIZE_K)\n        k_mask = cols < in_features\n        \n        # Load input block\n        x = tl.load(x_ptr + cols, mask=k_mask, other=0.0)\n        \n        # Load weight block\n        w = tl.load(w_ptr + cols, mask=k_mask, other=0.0)\n        \n        # Compute partial dot product\n        w = w.to(tl.float32)\n        x = x.to(tl.float32)\n        acc += tl.dot(w, x, allow_tf32=USE_TF32)\n    \n    # Add bias\n    if b_ptr is not None:\n        b = tl.load(b_ptr + feature_off + tl.arange(0, BLOCK_SIZE_N), mask=tl.arange(0, BLOCK_SIZE_N) < (out_features - feature_off), other=0.0)\n        acc += b\n    \n    # Store result\n    tl.store(out_ptr + tl.arange(0, BLOCK_SIZE_N), acc, mask=tl.arange(0, BLOCK_SIZE_N) < (out_features - feature_off))\n\n# Triton kernel for fused GroupNorm + Swish + Multiply + Swish\n@triton.jit\ndef fused_gn_swish_mul_swish_kernel(\n    x_ptr, gn_weight_ptr, gn_bias_ptr, mul_weight_ptr, out_ptr,\n    num_features, num_groups, eps,\n    BLOCK_SIZE: tl.constexpr\n):\n    pid_batch = tl.program_id(0)\n    pid_group = tl.program_id(1)\n    \n    # Calculate group parameters\n    group_size = num_features // num_groups\n    group_start = pid_group * group_size\n    group_end = group_start + group_size\n    \n    # Create pointers for current batch and group\n    x_ptr += pid_batch * num_features + group_start\n    gn_weight_ptr += group_start\n    gn_bias_ptr += group_start\n    mul_weight_ptr += group_start\n    out_ptr += pid_batch * num_features + group_start\n    \n    # Load data for the group\n    idxs = tl.arange(0, BLOCK_SIZE)\n    mask = idxs < group_size\n    \n    x = tl.load(x_ptr + idxs, mask=mask, other=0.0)\n    gn_weight = tl.load(gn_weight_ptr + idxs, mask=mask, other=0.0)\n    gn_bias = tl.load(gn_bias_ptr + idxs, mask=mask, other=0.0)\n    mul_weight = tl.load(mul_weight_ptr + idxs, mask=mask, other=0.0)\n    \n    # Compute mean and variance\n    mean = tl.sum(x, axis=0) / group_size\n    x_centered = x - mean\n    var = tl.sum(x_centered * x_centered, axis=0) / group_size + eps\n    inv_std = 1.0 / tl.sqrt(var)\n    \n    # GroupNorm calculation\n    normalized = x_centered * inv_std\n    y = normalized * gn_weight + gn_bias\n    \n    # First Swish activation\n    swish1 = y * tl.sigmoid(y)\n    \n    # Multiply with weight\n    multiplied = swish1 * mul_weight\n    \n    # Second Swish activation\n    swish2 = multiplied * tl.sigmoid(multiplied)\n    \n    # Store result\n    tl.store(out_ptr + idxs, swish2, mask=mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, num_groups, multiply_weight_shape):\n        super(ModelNew, self).__init__()\n        self.in_features = in_features\n        self.out_features = out_features\n        self.num_groups = num_groups\n        \n        # Initialize weights and biases\n        self.weight = nn.Parameter(torch.empty(out_features, in_features))\n        self.bias = nn.Parameter(torch.empty(out_features))\n        self.gn_weight = nn.Parameter(torch.ones(out_features))\n        self.gn_bias = nn.Parameter(torch.zeros(out_features))\n        self.multiply_weight = nn.Parameter(torch.randn(multiply_weight_shape))\n        \n        # Initialize parameters\n        nn.init.kaiming_uniform_(self.weight, a=math.sqrt(5))\n        fan_in, _ = nn.init._calculate_fan_in_and_fan_out(self.weight)\n        bound = 1 / math.sqrt(fan_in) if fan_in > 0 else 0\n        nn.init.uniform_(self.bias, -bound, bound)\n\n    def forward(self, x):\n        batch_size, _ = x.shape\n        \n        # Allocate output for GEMM\n        out = torch.empty((batch_size, self.out_features), device=x.device, dtype=torch.float32)\n        \n        # Configure GEMM kernel\n        grid = (batch_size, triton.cdiv(self.out_features, 64))\n        gemm_kernel[grid](\n            x, self.weight, self.bias, out,\n            self.in_features, self.out_features,\n            x.stride(0), x.stride(1),\n            self.weight.stride(0), self.weight.stride(1),\n            out.stride(0), out.stride(1),\n            BLOCK_SIZE_M=1, BLOCK_SIZE_N=64, BLOCK_SIZE_K=64,\n            USE_TF32=True\n        )\n        \n        # Configure fused kernel\n        group_size = self.out_features // self.num_groups\n        grid = (batch_size, self.num_groups)\n        fused_gn_swish_mul_swish_kernel[grid](\n            out, self.gn_weight, self.gn_bias, self.multiply_weight, out,\n            self.out_features, self.num_groups, 1e-5,\n            BLOCK_SIZE=group_size\n        )\n        \n        return out\n\nbatch_size = 128\nin_features = 512\nout_features = 1024\nnum_groups = 16\nmultiply_weight_shape = (out_features,)\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, num_groups, multiply_weight_shape]\n# =================== EVOLVE-BLOCK-END ===================\n```\nUnique approach: Modification: Full rewrite, Excellent compiled (1.000), Alternative correctness approach\n\n\n### Inspiration 4 (Score: 10.0000, Type: High-Performer)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport math\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n# Fixed GEMM kernel with 2D tensor handling\n@triton.jit\ndef gemm_kernel(\n    x_ptr, w_ptr, b_ptr, out_ptr,\n    in_features, out_features,\n    stride_xb, stride_xm,\n    stride_wn, stride_wm,\n    stride_outb, stride_outn,\n    BLOCK_SIZE_M: tl.constexpr, BLOCK_SIZE_N: tl.constexpr, BLOCK_SIZE_K: tl.constexpr,\n    USE_TF32: tl.constexpr\n):\n    pid_batch = tl.program_id(0)\n    pid_feature = tl.program_id(1)\n    \n    # Create pointers for current batch\n    x_ptr += pid_batch * stride_xb\n    out_ptr += pid_batch * stride_outb\n    \n    # Calculate feature block\n    feature_idx = pid_feature * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n    feature_mask = feature_idx < out_features\n    \n    # Initialize accumulator\n    acc = tl.zeros((BLOCK_SIZE_N,), dtype=tl.float32)\n    \n    # Loop over K dimension with vectorized loads\n    for k in range(0, tl.cdiv(in_features, BLOCK_SIZE_K)):\n        k_idx = k * BLOCK_SIZE_K + tl.arange(0, BLOCK_SIZE_K)\n        k_mask = k_idx < in_features\n        \n        # Load input block (vectorized)\n        x_vals = tl.load(\n            x_ptr + k_idx,\n            mask=k_mask,\n            other=0.0\n        )\n        \n        # Load weight block (2D tensor)\n        w_ptrs = w_ptr + feature_idx[:, None] * stride_wn + k_idx[None, :] * stride_wm\n        w_vals = tl.load(\n            w_ptrs,\n            mask=feature_mask[:, None] & k_mask[None, :],\n            other=0.0\n        )\n        \n        # Compute partial dot product\n        partial = tl.sum(w_vals * x_vals[None, :], axis=1)\n        acc += partial\n    \n    # Add bias with vectorized load\n    if b_ptr is not None:\n        b_vals = tl.load(\n            b_ptr + feature_idx,\n            mask=feature_mask,\n            other=0.0\n        )\n        acc += b_vals\n    \n    # Store result with vectorized store\n    tl.store(\n        out_ptr + feature_idx,\n        acc,\n        mask=feature_mask\n    )\n\n# Triton kernel for fused GroupNorm + Swish + Multiply + Swish\n@triton.jit\ndef fused_gn_swish_mul_swish_kernel(\n    x_ptr, gn_weight_ptr, gn_bias_ptr, mul_weight_ptr, out_ptr,\n    num_features, num_groups, eps,\n    BLOCK_SIZE: tl.constexpr\n):\n    pid_batch = tl.program_id(0)\n    pid_group = tl.program_id(1)\n    \n    # Calculate group parameters\n    group_size = num_features // num_groups\n    group_start = pid_group * group_size\n    group_end = group_start + group_size\n    \n    # Create pointers for current batch and group\n    x_ptr += pid_batch * num_features + group_start\n    gn_weight_ptr += group_start\n    gn_bias_ptr += group_start\n    mul_weight_ptr += group_start\n    out_ptr += pid_batch * num_features + group_start\n    \n    # Load data for the group\n    idxs = tl.arange(0, BLOCK_SIZE)\n    mask = idxs < group_size\n    \n    x = tl.load(x_ptr + idxs, mask=mask, other=0.0)\n    gn_weight = tl.load(gn_weight_ptr + idxs, mask=mask, other=0.0)\n    gn_bias = tl.load(gn_bias_ptr + idxs, mask=mask, other=0.0)\n    mul_weight = tl.load(mul_weight_ptr + idxs, mask=mask, other=0.0)\n    \n    # Compute mean and variance\n    mean = tl.sum(x, axis=0) / group_size\n    x_centered = x - mean\n    var = tl.sum(x_centered * x_centered, axis=0) / group_size + eps\n    inv_std = 1.0 / tl.sqrt(var)\n    \n    # GroupNorm calculation\n    normalized = x_centered * inv_std\n    y = normalized * gn_weight + gn_bias\n    \n    # First Swish activation\n    swish1 = y * tl.sigmoid(y)\n    \n    # Multiply with weight\n    multiplied = swish1 * mul_weight\n    \n    # Second Swish activation\n    swish2 = multiplied * tl.sigmoid(multiplied)\n    \n    # Store result\n    tl.store(out_ptr + idxs, swish2, mask=mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, num_groups, multiply_weight_shape):\n        super(ModelNew, self).__init__()\n        self.in_features = in_features\n        self.out_features = out_features\n        self.num_groups = num_groups\n        \n        # Initialize weights and biases\n        self.weight = nn.Parameter(torch.empty(out_features, in_features))\n        self.bias = nn.Parameter(torch.empty(out_features))\n        self.gn_weight = nn.Parameter(torch.ones(out_features))\n        self.gn_bias = nn.Parameter(torch.zeros(out_features))\n        self.multiply_weight = nn.Parameter(torch.randn(multiply_weight_shape))\n        \n        # Initialize parameters\n        nn.init.kaiming_uniform_(self.weight, a=math.sqrt(5))\n        fan_in, _ = nn.init._calculate_fan_in_and_fan_out(self.weight)\n        bound = 1 / math.sqrt(fan_in) if fan_in > 0 else 0\n        nn.init.uniform_(self.bias, -bound, bound)\n\n    def forward(self, x):\n        batch_size, _ = x.shape\n        \n        # Allocate output for GEMM\n        out = torch.empty((batch_size, self.out_features), device=x.device, dtype=torch.float32)\n        \n        # Configure GEMM kernel\n        grid = (batch_size, triton.cdiv(self.out_features, 64))\n        gemm_kernel[grid](\n            x, self.weight, self.bias, out,\n            self.in_features, self.out_features,\n            x.stride(0), x.stride(1),\n            self.weight.stride(0), self.weight.stride(1),\n            out.stride(0), out.stride(1),\n            BLOCK_SIZE_M=1, BLOCK_SIZE_N=64, BLOCK_SIZE_K=64,\n            USE_TF32=True\n        )\n        \n        # Configure fused kernel\n        group_size = self.out_features // self.num_groups\n        grid = (batch_size, self.num_groups)\n        fused_gn_swish_mul_swish_kernel[grid](\n            out, self.gn_weight, self.gn_bias, self.multiply_weight, out,\n            self.out_features, self.num_groups, 1e-5,\n            BLOCK_SIZE=group_size\n        )\n        \n        return out\n\nbatch_size = 128\nin_features = 512\nout_features = 1024\nnum_groups = 16\nmultiply_weight_shape = (out_features,)\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, num_groups, multiply_weight_shape]\n# =================== EVOLVE-BLOCK-END ===================\n```\nUnique approach: Modification: Full rewrite, Excellent compiled (1.000), Alternative correctness approach\n\n\n### Inspiration 5 (Score: 1.0000, Type: High-Performer)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit(num_warps=8, num_stages=1)\ndef _fused_forward_kernel(\n    # Pointers\n    x_ptr,\n    gemm_weight_ptr,\n    gemm_bias_ptr,\n    gn_weight_ptr,\n    gn_bias_ptr,\n    mult_weight_ptr,\n    output_ptr,\n    # Shapes\n    batch_size,\n    in_features,\n    out_features,\n    num_groups,\n    # Meta-parameters\n    eps: tl.constexpr,\n    BLOCK_SIZE_K: tl.constexpr,\n    GROUP_SIZE: tl.constexpr,\n):\n    pid_batch = tl.program_id(0)\n    pid_group = tl.program_id(1)\n    \n    # Compute group boundaries\n    group_start = pid_group * GROUP_SIZE\n    group_range = tl.arange(0, GROUP_SIZE)\n    feature_mask = group_range < (out_features - group_start)\n    \n    # Precompute weight row pointers for coalesced access\n    weight_row_start = group_start * in_features\n    row_ptrs = gemm_weight_ptr + weight_row_start + group_range[:, None] * in_features\n    \n    # Initialize accumulator\n    acc = tl.zeros((GROUP_SIZE,), dtype=tl.float32)\n    x_ptrs = x_ptr + pid_batch * in_features\n    \n    # Loop over input features with vectorized loads\n    for k in range(0, tl.cdiv(in_features, BLOCK_SIZE_K)):\n        k_offsets = k * BLOCK_SIZE_K + tl.arange(0, BLOCK_SIZE_K)\n        k_mask = k_offsets < in_features\n        \n        # Vectorized load\n        x_block = tl.load(\n            x_ptrs + k_offsets,\n            mask=k_mask,\n            other=0.0\n        )\n        \n        # Load weight block using precomputed row pointers\n        w_ptrs = row_ptrs + k_offsets[None, :]\n        w_block = tl.load(\n            w_ptrs,\n            mask=k_mask[None, :] & feature_mask[:, None],\n            other=0.0\n        )\n        \n        # Efficient accumulation\n        acc += tl.sum(w_block * x_block[None, :], axis=1)\n    \n    # Add bias\n    bias_ptrs = gemm_bias_ptr + group_start + group_range\n    bias = tl.load(bias_ptrs, mask=feature_mask, other=0.0)\n    acc += bias\n    \n    # Compute GroupNorm statistics\n    group_count = tl.sum(tl.cast(feature_mask, tl.float32))\n    mean = tl.sum(acc) / group_count\n    diff = acc - mean\n    var = tl.sum(diff * diff) / group_count\n    rstd = 1.0 / tl.sqrt(var + eps)\n    \n    # Apply GroupNorm with fused operations\n    gn_weight = tl.load(gn_weight_ptr + group_start + group_range, mask=feature_mask, other=0.0)\n    gn_bias = tl.load(gn_bias_ptr + group_start + group_range, mask=feature_mask, other=0.0)\n    normalized = (diff * rstd) * gn_weight + gn_bias\n    \n    # Fused Swish operations\n    swish1 = normalized * tl.sigmoid(normalized)\n    multiplied = swish1 * tl.load(mult_weight_ptr + group_start + group_range, mask=feature_mask, other=0.0)\n    swish2 = multiplied * tl.sigmoid(multiplied)\n    \n    # Store results\n    out_offsets = pid_batch * out_features + group_start + group_range\n    tl.store(output_ptr + out_offsets, swish2, mask=feature_mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, num_groups, multiply_weight_shape):\n        super(ModelNew, self).__init__()\n        self.gemm = nn.Linear(in_features, out_features)\n        self.group_norm = nn.GroupNorm(num_groups, out_features)\n        self.multiply_weight = nn.Parameter(torch.randn(multiply_weight_shape))\n        self.out_features = out_features\n        self.num_groups = num_groups\n\n    def forward(self, x):\n        batch_size, _ = x.shape\n        group_size = self.out_features // self.num_groups\n        \n        # Ensure tensors are contiguous\n        x = x.contiguous()\n        output = torch.empty((batch_size, self.out_features), device=x.device, dtype=x.dtype)\n        \n        # Launch kernel with optimized parameters\n        grid = (batch_size, self.num_groups)\n        _fused_forward_kernel[grid](\n            x, \n            self.gemm.weight, \n            self.gemm.bias,\n            self.group_norm.weight,\n            self.group_norm.bias,\n            self.multiply_weight,\n            output,\n            batch_size,\n            self.gemm.in_features,\n            self.out_features,\n            self.num_groups,\n            eps=1e-5,\n            BLOCK_SIZE_K=256,  # Fixed optimal block size\n            GROUP_SIZE=group_size\n        )\n        return output\n\nbatch_size = 128\nin_features = 512\nout_features = 1024\nnum_groups = 16\nmultiply_weight_shape = (out_features,)\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, num_groups, multiply_weight_shape]\n# =================== EVOLVE-BLOCK-END ===================\n```\nUnique approach: Modification: Full rewrite, Alternative compiled approach, Alternative correctness approach\n\n\n\n# Current Program\n```python\n@triton.jit\ndef _gemm_kernel(\n    a_ptr, b_ptr, c_ptr,\n    M, N, K,\n    stride_am, stride_ak,\n    stride_bk, stride_bn,\n    stride_cm, stride_cn,\n    BLOCK_M: tl.constexpr, BLOCK_N: tl.constexpr, BLOCK_K: tl.constexpr\n):\n    pid = tl.program_id(0)\n    grid_m = tl.cdiv(M, BLOCK_M)\n    grid_n = tl.cdiv(N, BLOCK_N)\n    \n    pid_m = pid // grid_n\n    pid_n = pid % grid_n\n    \n    offs_m = pid_m * BLOCK_M + tl.arange(0, BLOCK_M)\n    offs_n = pid_n * BLOCK_N + tl.arange(0, BLOCK_N)\n    k_offsets = tl.arange(0, BLOCK_K)   # This is the offset within the block, not absolute\n    # We will compute the absolute k index in the loop\n    \n    a_ptrs = a_ptr + offs_m[:, None] * stride_am + k_offsets[None, :] * stride_ak\n    b_ptrs = b_ptr + k_offsets[:, None] * stride_bk + offs_n[None, :] * stride_bn\n    \n    accumulator = tl.zeros((BLOCK_M, BLOCK_N), dtype=tl.float32)\n    for k in range(0, K, BLOCK_K):\n        # Absolute k indices for this block\n        k_abs = k + k_offsets\n        # Mask for A: rows in [0, M) and columns (k_abs) in [0, K)\n        mask_a = (offs_m[:, None] < M) & (k_abs[None, :] < K)\n        # Mask for B: rows (k_abs) in [0, K) and columns in [0, N)\n        mask_b = (k_abs[:, None] < K) & (offs_n[None, :] < N)\n        \n        a = tl.load(a_ptrs, mask=mask_a, other=0.0)\n        b = tl.load(b_ptrs, mask=mask_b, other=0.0)\n        \n        accumulator += tl.dot(a, b)\n        a_ptrs += BLOCK_K * stride_ak\n        b_ptrs += BLOCK_K * stride_bk\n    \n    offs_cm = pid_m * BLOCK_M + tl.arange(0, BLOCK_M)\n    offs_cn = pid_n * BLOCK_N + tl.arange(0, BLOCK_N)\n    c_ptrs = c_ptr + stride_cm * offs_cm[:, None] + stride_cn * offs_cn[None, :]\n    \n    mask_c = (offs_cm[:, None] < M) & (offs_cn[None, :] < N)\n    tl.store(c_ptrs, accumulator, mask=mask_c)\n```\n\n# Task\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```\n", "responses": ["<think>\nWe are given a Triton kernel for GEMM (matrix multiplication) that has performance issues.\n The current kernel uses a naive approach and does not utilize shared memory or other optimizations.\n\n The task is to rewrite the GEMM kernel to improve performance.\n\n Key observations from the current kernel:\n   - It uses a 1D grid of program IDs, then computes 2D indices (pid_m, pid_n) for the output block.\n   - It loads blocks of A and B directly from global memory without any tiling or shared memory.\n   - The inner loop accumulates the dot product for a block of the output matrix.\n\n However, note that the provided kernel does not include the entire program (like the class definition and the forward function).\n We are only allowed to change the Triton kernel source within the EVOLVE-BLOCK.\n\n Since the problem states that we must not change the function signature, we must keep the same parameters.\n\n We are targeting NVIDIA H100/H800 (SM8.9) with FP16 Tensor Cores. Therefore, we should aim to use tensor cores.\n\n Steps for optimization:\n  1. Use tensor cores by specifying input types as fp16 and using tl.dot with allow_tf32 or out_dtype=tl.float32.\n  2. Use block tiling with multiple stages to hide memory latency.\n  3. Use shared memory (via tl.load with _ptr and tl.advance) to cache blocks of A and B to reduce global memory accesses.\n  4. Adjust the block sizes (BLOCK_M, BLOCK_N, BLOCK_K) to be multiples of 16 (for tensor core operations) and tune them.\n\n However, note the constraints:\n  - We cannot change the function signature (parameter names or order) or the grid configuration.\n\n We are going to restructure the kernel to:\n  - Use a 2D grid (we note that the current kernel uses a 1D grid and then computes 2D indices. We can change to 2D grid? \n    But the constraint says: \"NEVER modify grid configuration\". However, the grid configuration is set by the caller. \n    The kernel itself does not set the grid. The kernel only uses the program_id. \n\n    The current kernel uses:\n        pid = tl.program_id(0)\n        grid_m = tl.cdiv(M, BLOCK_M)\n        grid_n = tl.cdiv(N, BLOCK_N)\n        pid_m = pid // grid_n\n        pid_n = pid % grid_n\n\n    This is a common way to flatten a 2D grid into 1D. But note: the grid launched by the caller is 1D (with size grid_m * grid_n).\n\n    We are not allowed to change the grid configuration (the way the caller sets the grid). Therefore, we must keep the same 1D grid.\n\n  5. We can still optimize the inner loop by using shared memory and tensor cores.\n\n How to use tensor cores in Triton for GEMM?\n  - We need to set the input pointers to be of fp16 (or bf16) and then use tl.dot with the appropriate parameters.\n  - The current kernel uses a and b as float32? We see that the accumulator is float32.\n\n  However, note that the input tensors might be float32. The problem does not specify. We have to check the reference model.\n\n  But the problem says: the Triton implementation must be functionally equivalent. So if the reference uses float32, we can use tf32 tensor cores.\n\n  We can use `allow_tf32=True` in tl.dot for FP32 inputs. For FP16, we would use out_dtype=tl.float16 and then convert.\n\n  But note: the reference code is not provided. We are only given the Triton kernel.\n\n  Since the current kernel uses float32 for the accumulator and the loads, we assume the inputs are float32.\n\n  We can change the kernel to use tf32 tensor cores by adding `allow_tf32=True` in the dot product.\n\n  However, the current kernel already uses `tl.dot` without specifying `allow_tf32`. We can set it to True to enable tensor cores.\n\n  Also, we can change the block sizes to be multiples of 16 for better tensor core utilization.\n\n  But the main optimization is to use shared memory to cache blocks of A and B.\n\n Plan for shared memory:\n\n  We will:\n    - Declare shared memory buffers for a block of A and a block of B.\n    - In the inner loop over K, we will load a block of A (of size BLOCK_M x BLOCK_K) and a block of B (of size BLOCK_K x BLOCK_N) from global memory into shared memory.\n    - Then we will compute the dot product from the shared memory.\n\n  However, note: Triton does not have explicit shared memory. Instead, we can use the `tl.load` with `cache_modifier` option to cache in L1. \n  But for shared memory, we can use `tl.make_block_ptr` and `tl.load` with `eviction_policy='evict_last'`? \n  Actually, Triton 2.0 has explicit shared memory: we can declare a static array with `tl.static` and `tl.array` but then we have to manage the data movement.\n\n  Alternatively, we can use the `tl.dot` instruction that automatically uses tensor cores and we rely on the compiler to use shared memory.\n\n  However, the Triton documentation and examples (like in the tutorial) show that for optimal performance we should use:\n\n      a = tl.load(a_ptrs, ...)\n      b = tl.load(b_ptrs, ...)\n      accumulator = tl.dot(a, b, ...)\n\n  and the compiler will automatically use shared memory and tensor cores when possible.\n\n  But the current kernel does not use the blocking in K dimension optimally because it does not cache the A and B blocks.\n\n  We can try to restructure the kernel to use a two-stage loading: first load a block of A and B into registers? \n  But that is not efficient because the block might be too large.\n\n  Alternatively, we can use the `tl.make_block_ptr` and `tl.load` with `cache_modifier` to hint caching.\n\n  However, the Triton GEMM example in the official documentation uses a different approach:\n\n      a_ptrs = a_ptr + off_am[:, None] * stride_am + off_k[None, :] * stride_ak\n      b_ptrs = b_ptr + off_bk[:, None] * stride_bk + off_bn[None, :] * stride_bn\n\n      # Prefetch the next block of A and B.\n      a = tl.load(a_ptrs)\n      b = tl.load(b_ptrs)\n\n      # We accumulate along the K dimension.\n      accumulator += tl.dot(a, b, allow_tf32=allow_tf32)\n\n  And then advance the pointers.\n\n  But note: the example also uses a loop over K and does not use shared memory explicitly.\n\n  The Triton compiler is designed to automatically promote to shared memory when it sees a dot product in a loop.\n\n  Therefore, the current kernel might already be optimized by the compiler? \n\n  However, the current kernel does not use the next block prefetching. We can add prefetching to hide the memory latency.\n\n  Also, the block sizes might be suboptimal.\n\n  Let's look at the constraints on block sizes for tensor cores: \n    - BLOCK_M and BLOCK_N should be multiples of 16, and BLOCK_K should be 16, 32, or 64.\n\n  We will change the block sizes to be 128x128x32 (for example) and enable tf32.\n\n  But note: the current kernel uses the same block sizes as passed by the caller? Actually, the kernel uses BLOCK_M, BLOCK_N, BLOCK_K as template constants.\n\n  We are going to change the kernel to:\n\n    - Use tensor cores by setting `allow_tf32=True` in the dot product.\n    - Adjust the block sizes in the caller? But we cannot change the caller because it is outside the EVOLVE-BLOCK.\n\n  However, the problem says: we can change the Triton kernel source. And the block sizes are provided as `tl.constexpr` and we are allowed to change them? \n  But note: the constraint says: \"Adaptive tuning: BLOCK_M/BLOCK_N/BLOCK_K dimensions\" is allowed.\n\n  But we cannot change the function signature. The block sizes are passed as parameters. So we can change the way we use them, but the caller must set them appropriately.\n\n  However, the kernel is called with specific block sizes. The caller sets them. We cannot change the caller.\n\n  Therefore, we must leave the block sizes as they are passed in. We can only change the kernel implementation.\n\n  Alternatively, we can change the kernel to use fixed block sizes? But the constraint says we must not change the function signature.\n\n  We have to use the provided block sizes.\n\n  So what can we do?\n\n  We can restructure the kernel to use a two-dimensional block of threads? Currently, each program is responsible for a block of size BLOCK_M x BLOCK_N.\n\n  We can split the work within a block by using warps? But Triton abstracts that.\n\n  Alternatively, we can use the tensor core instruction only if the block sizes are appropriate? But that might break for arbitrary block sizes.\n\n  Given the constraints, we will:\n\n    - Change the dot product to use `allow_tf32=True` to enable tensor cores for FP32 inputs.\n    - Prefetch the next block of A and B to hide memory latency.\n\n  Prefetching:\n\n      We will load the next block of A and B at the beginning of the next iteration, so that the load is overlapped with the computation.\n\n  How?\n\n      We can use two sets of pointers: one for the current block and one for the next.\n\n  But note: the inner loop is:\n\n      for k in range(0, K, BLOCK_K):\n          load A block at k\n          load B block at k\n          compute dot product\n\n      We can change to:\n\n          load first A block and B block (at k=0)\n          for k in range(0, K - BLOCK_K, BLOCK_K):\n              prefetch next A block and B block (at k+BLOCK_K)\n              compute dot product for current block\n              swap current and next\n          compute last block\n\n  However, this complicates the code.\n\n  Alternatively, Triton has `tl.advance` to move pointers and then prefetch using `tl.load` with `eviction_policy='evict_first'`.\n\n  We can do:\n\n      a_ptrs = ...\n      b_ptrs = ...\n\n      a = tl.load(a_ptrs, mask=mask_a, other=0.0)\n      b = tl.load(b_ptrs, mask=mask_b, other=0.0)\n\n      for k in range(0, K, BLOCK_K):\n          # Prefetch next block\n          next_a_ptrs = a_ptrs + BLOCK_K * stride_ak\n          next_b_ptrs = b_ptrs + BLOCK_K * stride_bk\n          # Check masks for the next block? We can compute the next k index: next_k = k + BLOCK_K\n          next_k_abs = k + BLOCK_K + k_offsets\n          next_mask_a = (offs_m[:, None] < M) & (next_k_abs[None, :] < K)\n          next_mask_b = (next_k_abs[:, None] < K) & (offs_n[None, :] < N)\n          next_a = tl.load(next_a_ptrs, mask=next_mask_a, other=0.0, eviction_policy='evict_last')\n          next_b = tl.load(next_b_ptrs, mask=next_mask_b, other=0.0, eviction_policy='evict_last')\n\n          # Compute the dot product for the current block\n          accumulator += tl.dot(a, b, allow_tf32=True)\n\n          # Move to the next block\n          a, b = next_a, next_b\n          a_ptrs, b_ptrs = next_a_ptrs, next_b_ptrs\n\n      # Process the last block (without prefetching)\n      accumulator += tl.dot(a, b, allow_tf32=True)\n\n  But note: the loop condition: we are stepping by BLOCK_K. We are prefetching the next block at the beginning of the current iteration.\n\n  However, we are prefetching at the same time as we are computing, so we need to make sure that the prefetch is issued early enough.\n\n  We will try to restructure the loop to have one less iteration for the prefetch.\n\n  Alternatively, we can use a software pipeline:\n\n      load first block\n      for k in range(0, K, BLOCK_K):\n          if k + BLOCK_K < K:\n              prefetch next block\n          compute current block\n\n  But the Triton compiler might already do prefetching? \n\n  Given the complexity, and since we are only allowed to change the kernel source, we will do:\n\n      - Enable tf32 in the dot product.\n      - Change the block sizes to be passed by the caller to be multiples of 16? But we cannot change the caller.\n\n  Therefore, we must rely on the caller to set appropriate block sizes.\n\n  Alternatively, we can adjust the block sizes inside the kernel? But they are `tl.constexpr` and fixed at compile time.\n\n  We are stuck with the block sizes passed by the caller.\n\n  However, we note that the kernel is called with:\n\n      BLOCK_M, BLOCK_N, BLOCK_K\n\n  We can change the kernel to use a fixed internal block size for the tensor core operation? But that would break the interface.\n\n  Given the constraints, we will:\n\n      - Change the dot product to use tensor cores (allow_tf32=True) for better performance on H100.\n      - Prefetch the next block in the inner loop to hide memory latency.\n\n  But note: the current kernel already uses a loop over K and loads the next block by advancing the pointers at the end of the loop.\n\n  We can try to prefetch the next block at the beginning of the loop body to overlap the load of the next block with the computation of the current block.\n\n  However, Triton is an IR and the compiler might handle scheduling. We can try to use the `eviction_policy` to keep the next block in cache.\n\n  Alternatively, we can use double buffering: we have two sets of registers for A and B, and we prefetch the next block while computing the current.\n\n  We will implement double buffering:\n\n      // Load first block\n      a0 = tl.load(a_ptrs, mask=mask_a0, other=0.0)\n      b0 = tl.load(b_ptrs, mask=mask_b0, other=0.0)\n      a_ptrs = a_ptrs + BLOCK_K * stride_ak\n      b_ptrs = b_ptrs + BLOCK_K * stride_bk\n\n      for k in range(BLOCK_K, K, BLOCK_K):\n          // Prefetch next block\n          a1 = tl.load(a_ptrs, mask=mask_a1, other=0.0)\n          b1 = tl.load(b_ptrs, mask=mask_b1, other=0.0)\n          a_ptrs = a_ptrs + BLOCK_K * stride_ak\n          b_ptrs = b_ptrs + BLOCK_K * stride_bk\n\n          // Compute on current block (a0, b0)\n          accumulator += tl.dot(a0, b0, allow_tf32=True)\n\n          // Swap: next becomes current\n          a0, b0 = a1, b1\n\n      // Compute the last block\n      accumulator += tl.dot(a0, b0, allow_tf32=True)\n\n  But note: we have to compute the masks for the next block. We can compute the absolute k index for the next block.\n\n  We'll do:\n\n      k_index = k_initial + BLOCK_K   [for the first next block]\n\n  We'll adjust the loop accordingly.\n\n  However, this adds complexity and might not be necessary if the Triton compiler is smart enough.\n\n  Given the time, we will try the following:\n\n      - Change the dot product to use tensor cores: `allow_tf32=True`\n      - Adjust the block sizes in the kernel? We cannot, because they are passed by the caller.\n\n  But note: the kernel is called from a context we cannot change. So we must rely on the caller to set good block sizes.\n\n  However, the problem says: we can change the Triton kernel source. We are allowed to change the block sizes if they are passed as `tl.constexpr`? \n  But we are not allowed to change the function signature. The block sizes are parameters. We must use the same names.\n\n  We can change the way we use the block sizes? We can break the block into smaller chunks to use tensor cores? \n\n  For example, if the provided BLOCK_M is 128, we can break it into 4 warps of 32? But that would require changing the kernel structure.\n\n  Alternatively, we can use the tensor core operation on a fixed tile size (like 16x16) and then accumulate in registers.\n\n  This would require restructuring the kernel to have nested loops within the block.\n\n  Given the complexity and the constraints, we decide to do:\n\n      - Use `allow_tf32=True` in the dot product to enable tensor cores.\n      - Change the loop to use double buffering to prefetch the next block.\n\n  We will restructure the kernel accordingly.\n\n  Steps for double buffering:\n\n      Let a0, b0 be the current block, and a1, b1 be the next block.\n\n      Initialize:\n          k0 = 0\n          Load a0 = block at k0, b0 = block at k0\n          Advance pointers to k1 = BLOCK_K\n          Prefetch a1, b1 at k1 (if k1 < K)\n\n      Loop for k in range(BLOCK_K, K, BLOCK_K):\n          Load next block at k_current (which becomes the next for the next iteration) \n          Compute the dot product for the current block (a0, b0)\n          Swap: current becomes next, and next becomes the new load.\n\n      Compute the last block.\n\n  We have to be careful with masks.\n\n  We'll write the kernel accordingly.\n\n  However, note that the current kernel already has a loop over K. We are going to change that loop to double buffering.\n\n  We'll also note that the current kernel uses:\n\n      k_offsets = tl.arange(0, BLOCK_K)   # This is the offset within the block, not absolute\n\n  We can compute the absolute k index as: k_start = k, then k_abs = k_start + k_offsets.\n\n  We'll do:\n\n      k_start = 0\n      k_abs0 = k_start + k_offsets\n      mask_a0 = (offs_m[:, None] < M) & (k_abs0[None, :] < K)\n      mask_b0 = (k_abs0[:, None] < K) & (offs_n[None, :] < N)\n\n      a0 = tl.load(a_ptrs, mask=mask_a0, other=0.0)\n      b0 = tl.load(b_ptrs, mask=mask_b0, other=0.0)\n\n      a_ptrs += BLOCK_K * stride_ak\n      b_ptrs += BLOCK_K * stride_bk\n\n      # Prefetch next block for k_start = BLOCK_K\n      k_start = BLOCK_K\n      k_abs1 = k_start + k_offsets\n      mask_a1 = (offs_m[:, None] < M) & (k_abs1[None, :] < K)\n      mask_b1 = (k_abs1[:, None] < K) & (offs_n[None, :] < N)\n\n      a1 = tl.load(a_ptrs, mask=mask_a1, other=0.0)\n      b1 = tl.load(b_ptrs, mask=mask_b1, other=0.0)\n\n      a_ptrs += BLOCK_K * stride_ak\n      b_ptrs += BLOCK_K * stride_bk\n\n      accumulator = tl.zeros((BLOCK_M, BLOCK_N), dtype=tl.float32)\n      # First accumulation: for k0\n      accumulator += tl.dot(a0, b0, allow_tf32=True)\n\n      for k in range(BLOCK_K, K - BLOCK_K, BLOCK_K):\n          # Prefetch next block at k_start + BLOCK_K\n          k_start_next = k_start + BLOCK_K\n          k_abs_next = k_start_next + k_offsets\n          mask_a_next = (offs_m[:, None] < M) & (k_abs_next[None, :] < K)\n          mask_b_next = (k_abs_next[:, None] < K) & (offs_n[None, :] < N)\n\n          a_next = tl.load(a_ptrs, mask=mask_a_next, other=0.0)\n          b_next = tl.load(b_ptrs, mask=mask_b_next, other=0.0)\n\n          a_ptrs += BLOCK_K * stride_ak\n          b_ptrs += BLOCK_K * stride_bk\n\n          # Compute current block (a1, b1) which corresponds to k_start\n          accumulator += tl.dot(a1, b1, allow_tf32=True)\n\n          # Rotate buffers: a0, b0 become a1, b1; a1, b1 become a_next, b_next\n          a0, b0 = a1, b1\n          a1, b1 = a_next, b_next\n          k_start = k_start_next\n\n      # Last two blocks: we have a0, b0 and a1, b1 for the last two blocks?\n      # But note: the loop goes to K - BLOCK_K (exclusive) and then we break.\n      # We have to process the block at k_start (which is the last full block) and then the next block might be partial?\n\n      # We have already loaded a1, b1 for the block at k_start = (last full block index) and then the next block (if any) we did not prefetch.\n\n      # Actually, the loop condition: we break when k >= K - BLOCK_K? Not exactly: we break when k is in [BLOCK_K, K - BLOCK_K) stepping by BLOCK_K.\n\n      # We have one more block at k_start (which is the last block we loaded) and then there might be one more block that we haven't loaded? \n\n      # Let's reexamine: the loop runs for k from BLOCK_K to K - BLOCK_K (exclusive) in steps of BLOCK_K. \n      # Then we break and then we have to process the block at k_start = (K - 2*BLOCK_K) + BLOCK_K = K - BLOCK_K? \n\n      # Actually, we have already loaded two blocks initially: one at 0 and one at BLOCK_K. Then the loop starts at k=BLOCK_K and we load the next block at 2*BLOCK_K.\n\n      # At the end of the loop, we have two blocks in registers: a0, b0 and a1, b1. We have processed a0, b0 in the first accumulation and then in the loop we process a1, b1 as the current block.\n\n      # Then we break and we still have the last block (a1, b1) unprocessed? \n\n      # We break out of the loop and then we have to process the last block? \n\n      # We do:\n\n          accumulator += tl.dot(a1, b1, allow_tf32=True)\n\n      # But what about the last block that might be beyond the last full block? We have to process the block at the last full block.\n\n      # However, note that the loop condition: the loop runs for k from BLOCK_K to K - BLOCK_K (exclusive). \n      # The number of blocks is n_blocks = ceil(K / BLOCK_K). We have already processed the first block (0) and then in the loop we process blocks starting at BLOCK_K, 2*BLOCK_K, ... until the last full block that is less than K - BLOCK_K.\n\n      # Then we have one more block at the end? \n\n      # Actually, we break when k_start_next = k_start + BLOCK_K >= K - BLOCK_K? Not exactly.\n\n      # We'll change the loop to run for `for k in range(BLOCK_K, K, BLOCK_K)` and then we don't know how many blocks.\n\n  This double buffering is complex and error-prone.\n\n  Given the time, and since the Triton compiler might already do prefetching, we decide to only change the dot product to use tensor cores and hope that the block sizes are set appropriately by the caller.\n\n  We change:\n\n      accumulator += tl.dot(a, b)   ->   accumulator += tl.dot(a, b, allow_tf32=True)\n\n  And we leave the rest.\n\n  But note: the current kernel does not use the next block prefetching. We will add a simple prefetch of the next block at the beginning of the loop without double buffering.\n\n  We'll do:\n\n      a_ptrs = ...\n      b_ptrs = ...\n\n      // Prefetch first block\n      a = tl.load(a_ptrs, mask=mask_a, other=0.0)\n      b = tl.load(b_ptrs, mask=mask_b, other=0.0)\n\n      for k in range(0, K, BLOCK_K):\n          // Prefetch next block if there is one\n          if k + BLOCK_K < K:\n              next_a_ptrs = a_ptrs + BLOCK_K * stride_ak\n              next_b_ptrs = b_ptrs + BLOCK_K * stride_bk\n              next_k_abs = k + BLOCK_K + k_offsets\n              next_mask_a = (offs_m[:, None] < M) & (next_k_abs[None, :] < K)\n              next_mask_b = (next_k_abs[:, None] < K) & (offs_n[None, :] < N)\n              next_a = tl.load(next_a_ptrs, mask=next_mask_a, other=0.0, eviction_policy='evict_last')\n              next_b = tl.load(next_b_ptrs, mask=next_mask_b, other=0.0, eviction_policy='evict_last')\n\n          // Compute dot product for current block\n          accumulator += tl.dot(a, b, allow_tf32=True)\n\n          // Set current to next if there is a next block\n          if k + BLOCK_K < K:\n              a, b = next_a, next_b\n              a_ptrs, b_ptrs = next_a_ptrs, next_b_ptrs\n\n  But note: the first block is loaded outside the loop, and then inside the loop we prefetch the next block and then compute the current block.\n\n  We have to be careful at the last block.\n\n  We'll adjust.\n\n  However, the Triton compiler might schedule the load of the next block early enough.\n\n  We will implement this.\n\n  Steps:\n\n      k_offsets = tl.arange(0, BLOCK_K)   # relative offset in the block\n\n      // Calculate initial masks for the first block at k=0\n      k_abs = 0 + k_offsets\n      mask_a = (offs_m[:, None] < M) & (k_abs[None, :] < K)\n      mask_b = (k_abs[:, None] < K) & (offs_n[None, :] < N)\n\n      a = tl.load(a_ptrs, mask=mask_a, other=0.0)\n      b = tl.load(b_ptrs, mask=mask_b, other=0.0)\n\n      // Advance pointers for the next block\n      a_ptrs += BLOCK_K * stride_ak\n      b_ptrs += BLOCK_K * stride_bk\n\n      // We are going to iterate for n_blocks = ceil(K / BLOCK_K) times, but we have already loaded the first block.\n      // So we start k at 0, and we have n_blocks-1 blocks left? Actually, we have to process n_blocks blocks.\n\n      // We change the loop to run for n_blocks blocks.\n\n      // Instead, we do:\n\n      for k in range(0, K, BLOCK_K):\n          // Prefetch next block for the next iteration, if any\n          next_k = k + BLOCK_K\n          if next_k < K:\n              next_k_abs = next_k + k_offsets\n              next_mask_a = (offs_m[:, None] < M) & (next_k_abs[None, :] < K)\n              next_mask_b = (next_k_abs[:, None] < K) & (offs_n[None, :] < N)\n              next_a = tl.load(a_ptrs, mask=next_mask_a, other=0.0, eviction_policy='evict_last')\n              next_b = tl.load(b_ptrs, mask=next_mask_b, other=0.0, eviction_policy='evict_last')\n\n          // Compute current block\n          accumulator += tl.dot(a, b, allow_tf32=True)\n\n          // If there is a next block, set a, b to the next block and advance pointers\n          if next_k < K:\n              a, b = next_a, next_b\n              a_ptrs += BLOCK_K * stride_ak\n              b_ptrs += BLOCK_K * stride_bk\n\n  But note: the first block was loaded before the loop. Then in the first iteration (k=0) we will compute it, and then set a, b to the next block (if any) and advance the pointers.\n\n  The last block will be processed without prefetching.\n\n  This should work.\n\n  We'll implement this.\n\n  Summary of changes:\n\n      - Enable tf32 in the dot product.\n      - Prefetch the next block in the inner loop to overlap memory and computation.\n\n  We hope this will improve performance.\n\n  Note: We must not remove boundary checks. We keep the masks.\n\n  Let's rewrite the kernel accordingly.\n\n  We note that the current kernel initializes `accumulator` to zero and then accumulates. We keep that.\n\n  We also note that the current kernel uses:\n\n      for k in range(0, K, BLOCK_K):\n          ... load a and b ...\n\n          accumulator += tl.dot(a, b)\n\n          a_ptrs += BLOCK_K * stride_ak\n          b_ptrs += BLOCK_K * stride_bk\n\n  We are changing to:\n\n      // Load first block before the loop\n      k_abs = 0 + k_offsets\n      mask_a = (offs_m[:, None] < M) & (k_abs[None, :] < K)\n      mask_b = (k_abs[:, None] < K) & (offs_n[None, :] < N)\n      a = tl.load(a_ptrs, mask=mask_a, other=0.0)\n      b = tl.load(b_ptrs, mask=mask_b, other=0.0)\n      a_ptrs += BLOCK_K * stride_ak\n      b_ptrs += BLOCK_K * stride_bk\n\n      accumulator = tl.zeros((BLOCK_M, BLOCK_N), dtype=tl.float32)\n\n      // Loop over k from 0 to K (stepping by BLOCK_K) - note: we have already loaded the first block, so we start at k=0\n      for k in range(0, K, BLOCK_K):\n          next_k = k + BLOCK_K\n          if next_k < K:\n              next_k_abs = next_k + k_offsets\n              next_mask_a = (offs_m[:, None] < M) & (next_k_abs[None, :] < K)\n              next_mask_b = (next_k_abs[:, None] < K) & (offs_n[None, :] < N)\n              next_a = tl.load(a_ptrs, mask=next_mask_a, other=0.0, eviction_policy='evict_last')\n              next_b = tl.load(b_ptrs, mask=next_mask_b, other=0.0, eviction_policy='evict_last')\n\n          // Compute the current block\n          accumulator += tl.dot(a, b, allow_tf32=True)\n\n          if next_k < K:\n              a, b = next_a, next_b\n              a_ptrs += BLOCK_K * stride_ak\n              b_ptrs += BLOCK_K * stride_bk\n\n  But note: the loop runs for every block. The first block is processed in the first iteration. The last block is processed without prefetching.\n\n  We must ensure that for the last block, we do not prefetch (because there is no next block) and we do not advance the pointers after the last block.\n\n  Also, note that the loop variable `k` is not used except to calculate `next_k`. We can also use a counter.\n\n  This should be correct.\n\n  Let's write the kernel accordingly.\n\n  We'll also change the block sizes to be multiples of 16 in the caller? But we cannot change the caller. We hope the caller sets good block sizes.\n\n  We'll keep the block sizes as passed.\n\n  We are ready to rewrite the kernel.\n</think>\nBased on the analysis, here's the optimized Triton GEMM kernel with key improvements:\n\n1. Enabled Tensor Cores using `allow_tf32=True` for FP32 inputs\n2. Added software prefetching to hide memory latency\n3. Maintained proper boundary checks and masking\n4. Improved memory access patterns\n\n```python\n@triton.jit\ndef _gemm_kernel(\n    a_ptr, b_ptr, c_ptr,\n    M, N, K,\n    stride_am, stride_ak,\n    stride_bk, stride_bn,\n    stride_cm, stride_cn,\n    BLOCK_M: tl.constexpr, BLOCK_N: tl.constexpr, BLOCK_K: tl.constexpr\n):\n    pid = tl.program_id(0)\n    grid_m = tl.cdiv(M, BLOCK_M)\n    grid_n = tl.cdiv(N, BLOCK_N)\n    \n    pid_m = pid // grid_n\n    pid_n = pid % grid_n\n    \n    offs_m = pid_m * BLOCK_M + tl.arange(0, BLOCK_M)\n    offs_n = pid_n * BLOCK_N + tl.arange(0, BLOCK_N)\n    k_offsets = tl.arange(0, BLOCK_K)\n    \n    a_ptrs = a_ptr + offs_m[:, None] * stride_am + k_offsets[None, :] * stride_ak\n    b_ptrs = b_ptr + k_offsets[:, None] * stride_bk + offs_n[None, :] * stride_bn\n    \n    accumulator = tl.zeros((BLOCK_M, BLOCK_N), dtype=tl.float32)\n    \n    # Prefetch first block\n    k_abs0 = k_offsets\n    mask_a0 = (offs_m[:, None] < M) & (k_abs0[None, :] < K)\n    mask_b0 = (k_abs0[:, None] < K) & (offs_n[None, :] < N)\n    a = tl.load(a_ptrs, mask=mask_a0, other=0.0)\n    b = tl.load(b_ptrs, mask=mask_b0, other=0.0)\n    a_ptrs += BLOCK_K * stride_ak\n    b_ptrs += BLOCK_K * stride_bk\n    \n    # Main loop with prefetching\n    for k in range(0, K - BLOCK_K, BLOCK_K):\n        # Prefetch next block\n        k_abs_next = k + BLOCK_K + k_offsets\n        mask_a_next = (offs_m[:, None] < M) & (k_abs_next[None, :] < K)\n        mask_b_next = (k_abs_next[:, None] < K) & (offs_n[None, :] < N)\n        next_a = tl.load(a_ptrs, mask=mask_a_next, other=0.0, eviction_policy=\"evict_last\")\n        next_b = tl.load(b_ptrs, mask=mask_b_next, other=0.0, eviction_policy=\"evict_last\")\n        \n        # Compute current block with Tensor Cores\n        accumulator += tl.dot(a, b, allow_tf32=True)\n        \n        # Advance to next block\n        a, b = next_a, next_b\n        a_ptrs += BLOCK_K * stride_ak\n        b_ptrs += BLOCK_K * stride_bk\n    \n    # Process last block\n    k_abs_last = K - BLOCK_K + k_offsets\n    mask_a_last = (offs_m[:, None] < M) & (k_abs_last[None, :] < K)\n    mask_b_last = (k_abs_last[:, None] < K) & (offs_n[None, :] < N)\n    a_last = tl.load(a_ptrs, mask=mask_a_last, other=0.0)\n    b_last = tl.load(b_ptrs, mask=mask_b_last, other=0.0)\n    accumulator += tl.dot(a, b, allow_tf32=True) + tl.dot(a_last, b_last, allow_tf32=True)\n    \n    # Write back results\n    offs_cm = pid_m * BLOCK_M + tl.arange(0, BLOCK_M)\n    offs_cn = pid_n * BLOCK_N + tl.arange(0, BLOCK_N)\n    c_ptrs = c_ptr + stride_cm * offs_cm[:, None] + stride_cn * offs_cn[None, :]\n    mask_c = (offs_cm[:, None] < M) & (offs_cn[None, :] < N)\n    tl.store(c_ptrs, accumulator, mask=mask_c)\n```"]}}}