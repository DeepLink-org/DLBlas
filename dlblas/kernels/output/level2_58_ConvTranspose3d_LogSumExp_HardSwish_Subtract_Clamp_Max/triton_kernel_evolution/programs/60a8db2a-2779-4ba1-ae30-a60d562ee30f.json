{"id": "60a8db2a-2779-4ba1-ae30-a60d562ee30f", "code": "# ================== EVOLVE-BLOCK-START ==================\nimport math\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef _kernel(x_ptr, output_ptr, bias_ptr, \n            stride_b, stride_c, stride_d, stride_h, stride_w,\n            stride_b_out, stride_c_out, stride_d_out, stride_h_out, stride_w_out,\n            C, B, D, H, W,\n            BLOCK_SIZE_C: tl.constexpr,\n            BLOCK_H: tl.constexpr, BLOCK_W: tl.constexpr):\n    # 3D grid organization\n    pid0 = tl.program_id(0)  # batch and depth\n    pid1 = tl.program_id(1)  # spatial blocks in height\n    pid2 = tl.program_id(2)  # spatial blocks in width\n    \n    # Reconstruct indices\n    batch_idx = pid0 // D\n    d_idx = pid0 % D\n    h_idx = pid1 * BLOCK_H\n    w_idx = pid2 * BLOCK_W\n    \n    # Base pointers\n    base = batch_idx * stride_b + d_idx * stride_d\n    base_out = batch_idx * stride_b_out + d_idx * stride_d_out\n    \n    # Create masks for boundaries\n    h_mask = (h_idx + tl.arange(0, BLOCK_H)) < H\n    w_mask = (w_idx + tl.arange(0, BLOCK_W)) < W\n    spatial_mask = h_mask[:, None] & w_mask[None, :]\n    c_offsets = tl.arange(0, BLOCK_SIZE_C)\n    c_mask = c_offsets < C\n    \n    # Prepare pointers and load input data [BLOCK_SIZE_C, BLOCK_H, BLOCK_W]\n    c_offsets_3d = c_offsets[:, None, None] * stride_c\n    h_offsets = (h_idx + tl.arange(0, BLOCK_H))[None, :, None] * stride_h\n    w_offsets = (w_idx + tl.arange(0, BLOCK_W))[None, None, :] * stride_w\n    x_ptrs = x_ptr + base + c_offsets_3d + h_offsets + w_offsets\n    x_vals = tl.load(x_ptrs, \n                    mask=c_mask[:, None, None] & spatial_mask[None, :, :], \n                    other=-float('inf'))\n    \n    # LogSumExp with numerical stability\n    max_val = tl.max(x_vals, axis=0)\n    safe_vals = x_vals - max_val\n    exp_vals = tl.exp(safe_vals)\n    sum_exp = tl.sum(exp_vals, axis=0)\n    lse = tl.log(sum_exp) + max_val\n    lse = tl.where(spatial_mask, lse, 0.0)  # Avoid NaN in invalid spatial locations\n    \n    # HardSwish activation\n    hswish = lse * tl.sigmoid(lse + 3.0) / 6.0\n    \n    # Load bias and compute candidate values\n    bias_vals = tl.load(bias_ptr + c_offsets, mask=c_mask, other=0.0)\n    candidate = hswish[None, :, :] - bias_vals[:, None, None]\n    candidate = tl.minimum(tl.maximum(candidate, -1.0), 1.0)\n    candidate = tl.where(c_mask[:, None, None], candidate, -float('inf'))\n    \n    # Max reduction over channels\n    max_candidate = tl.max(candidate, axis=0)\n    \n    # Prepare output pointers and store results\n    out_ptrs = output_ptr + base_out + \\\n               (h_idx + tl.arange(0, BLOCK_H))[:, None] * stride_h_out + \\\n               (w_idx + tl.arange(0, BLOCK_W))[None, :] * stride_w_out\n    tl.store(out_ptrs, max_candidate, mask=spatial_mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_channels, out_channels, kernel_size, stride, padding, bias_shape):\n        super(ModelNew, self).__init__()\n        self.conv_transpose = nn.ConvTranspose3d(in_channels, out_channels, kernel_size, stride=stride, padding=padding)\n        self.bias = nn.Parameter(torch.randn(bias_shape))\n\n    def forward(self, x):\n        x = self.conv_transpose(x)\n        B, C, D, H, W = x.shape\n        output = torch.empty(B, 1, D, H, W, device=x.device, dtype=x.dtype)\n        bias_1d = self.bias.view(-1)\n        \n        # Tensor strides\n        s_b, s_c, s_d, s_h, s_w = x.stride()\n        s_b_out, s_c_out, s_d_out, s_h_out, s_w_out = output.stride()\n        \n        # Grid configuration with spatial tiling\n        grid_h = (H + 7) // 8\n        grid_w = (W + 7) // 8\n        grid = (B * D, grid_h, grid_w)\n        \n        # Launch kernel with optimized block sizes\n        _kernel[grid](\n            x, output, bias_1d, \n            s_b, s_c, s_d, s_h, s_w,\n            s_b_out, s_c_out, s_d_out, s_h_out, s_w_out,\n            C, B, D, H, W,\n            BLOCK_SIZE_C=triton.next_power_of_2(C),\n            BLOCK_H=8, BLOCK_W=8\n        )\n        \n        return output\n\nbatch_size = 128\nin_channels = 3\nout_channels = 16\ndepth, height, width = 16, 32, 32\nkernel_size = 3\nstride = 2\npadding = 1\nbias_shape = (out_channels, 1, 1, 1)\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_channels, depth, height, width)]\n\ndef get_init_inputs():\n    return [in_channels, out_channels, kernel_size, stride, padding, bias_shape]\n# =================== EVOLVE-BLOCK-END ===================", "language": "python", "parent_id": "917346a9-0167-489a-aa9c-017f1bbb3002", "generation": 3, "timestamp": 1754578737.9810638, "iteration_found": 26, "metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": false, "score": 20, "speed_up": 0.032, "runtime_ms": 6.08, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:6", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.195, "speed_up": 0.032, "custom_timing": 6.08}}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": false, "score": 20, "speed_up": 0.01, "runtime_ms": 19.7, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:0", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.195, "speed_up": 0.01, "custom_timing": 19.7}}, "island": 1}, "artifacts_json": null, "artifact_dir": null}