{"id": "e642e79d-f5f1-4e92-8b26-adf181043b23", "code": "# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\nimport math\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 256, 'BLOCK_SIZE_K': 32}, num_warps=8),\n        triton.Config({'BLOCK_SIZE_M': 256, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 32}, num_warps=8),\n    ],\n    key=['M', 'N', 'K'],\n)\n@triton.jit\ndef fused_linear_div_gelu_kernel(\n    # Pointers to matrices\n    x_ptr, weight_ptr, bias_ptr, output_ptr,\n    # Matrix dimensions\n    M, N, K, divisor,\n    # Strides\n    stride_xm, stride_xk,\n    stride_wk, stride_wn,\n    stride_om, stride_on,\n    # Blocking\n    BLOCK_SIZE_M: tl.constexpr,\n    BLOCK_SIZE_N: tl.constexpr,\n    BLOCK_SIZE_K: tl.constexpr,\n):\n    pid = tl.program_id(0)\n    pid_m = pid // tl.cdiv(N, BLOCK_SIZE_N)\n    pid_n = pid % tl.cdiv(N, BLOCK_SIZE_N)\n    \n    # Offsets for the block to process\n    offs_m = pid_m * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)\n    offs_n = pid_n * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n    offs_k = tl.arange(0, BLOCK_SIZE_K)\n    \n    # Pointers to the blocks of x and weight\n    x_ptrs = x_ptr + offs_m[:, None] * stride_xm + offs_k[None, :] * stride_xk\n    w_ptrs = weight_ptr + offs_k[:, None] * stride_wk + offs_n[None, :] * stride_wn\n    \n    # Initialize accumulator\n    acc = tl.zeros((BLOCK_SIZE_M, BLOCK_SIZE_N), dtype=tl.float32)\n    \n    # Loop over K dimension\n    k_remaining = K\n    for _ in range(0, tl.cdiv(K, BLOCK_SIZE_K)):\n        # Create masks to prevent out-of-bounds access\n        k_mask = offs_k < k_remaining\n        x_mask = (offs_m[:, None] < M) & k_mask[None, :]\n        w_mask = k_mask[:, None] & (offs_n[None, :] < N)\n        \n        # Load blocks\n        x_block = tl.load(x_ptrs, mask=x_mask, other=0.0)\n        w_block = tl.load(w_ptrs, mask=w_mask, other=0.0)\n        \n        # Compute partial matrix multiplication\n        acc += tl.dot(x_block, w_block)\n        \n        # Update pointers and remaining elements\n        x_ptrs += BLOCK_SIZE_K * stride_xk\n        w_ptrs += BLOCK_SIZE_K * stride_wk\n        k_remaining -= BLOCK_SIZE_K\n    \n    # Add bias if present\n    if bias_ptr is not None:\n        b_ptrs = bias_ptr + offs_n\n        b_mask = offs_n < N\n        bias = tl.load(b_ptrs, mask=b_mask, other=0.0)\n        acc += bias[None, :]\n    \n    # Apply division and GELU activation\n    scaled = acc / divisor\n    gelu = scaled * 0.5 * (1.0 + tl.erf(scaled * 0.7071067811865475))\n    \n    # Store output with appropriate masking\n    offs_m_base = pid_m * BLOCK_SIZE_M\n    offs_n_base = pid_n * BLOCK_SIZE_N\n    out_ptrs = output_ptr + offs_m[:, None] * stride_om + offs_n[None, :] * stride_on\n    out_mask = (offs_m[:, None] < M) & (offs_n[None, :] < N)\n    tl.store(out_ptrs, gelu, mask=out_mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, input_size, output_size, divisor):\n        super(ModelNew, self).__init__()\n        self.input_size = input_size\n        self.output_size = output_size\n        self.divisor = divisor\n        \n        # Initialize parameters\n        self.weight = nn.Parameter(torch.empty(output_size, input_size))\n        self.bias = nn.Parameter(torch.empty(output_size))\n        self.weight_t = None  # Will hold transposed weights\n        \n        # Kaiming initialization\n        nn.init.kaiming_uniform_(self.weight, a=math.sqrt(5))\n        fan_in, _ = nn.init._calculate_fan_in_and_fan_out(self.weight)\n        bound = 1 / math.sqrt(fan_in) if fan_in > 0 else 0\n        nn.init.uniform_(self.bias, -bound, bound)\n\n    def forward(self, x):\n        # Ensure inputs are contiguous\n        x = x.contiguous()\n        \n        # Pre-transpose weights once\n        if self.weight_t is None:\n            self.weight_t = self.weight.t().contiguous()\n        \n        M, K = x.shape\n        N = self.output_size\n        output = torch.empty((M, N), device=x.device, dtype=x.dtype)\n        \n        # Grid configuration\n        grid = lambda meta: (triton.cdiv(M, meta['BLOCK_SIZE_M']) * triton.cdiv(N, meta['BLOCK_SIZE_N']),)\n        \n        # Launch kernel\n        fused_linear_div_gelu_kernel[grid](\n            x, self.weight_t, self.bias, output,\n            M, N, K, self.divisor,\n            x.stride(0), x.stride(1),\n            self.weight_t.stride(0), self.weight_t.stride(1),\n            output.stride(0), output.stride(1),\n        )\n        return output\n\nbatch_size = 128\ninput_size = 512\noutput_size = 1024\ndivisor = 10.0\n\ndef get_inputs():\n    return [torch.randn(batch_size, input_size)]\n\ndef get_init_inputs():\n    return [input_size, output_size, divisor]\n# =================== EVOLVE-BLOCK-END ===================", "language": "python", "parent_id": "aaac6693-5ebf-4a9a-92bd-52479a32af87", "generation": 1, "timestamp": 1754582250.6501386, "iteration_found": 10, "metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": false, "score": 20, "speed_up": 0.686, "runtime_ms": 0.0768, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:0", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.0527, "speed_up": 0.686, "custom_timing": 0.0768}}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": true, "correctness": true, "stage": "reference code", "passed": false, "score": 0.0, "speed_up": 1.0, "runtime_ms": 0.0453, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:6", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.0527, "speed_up": 1.163, "custom_timing": 0.0453}}, "island": 2}, "artifacts_json": null, "artifact_dir": null, "prompts": {"full_rewrite_user": {"system": "You are a Triton GPU core optimization engineer deeply familiar with NVIDIA H100/H800 architecture.\n\n==================== Context ====================\n\u2022 Dataset: 250 kernelbench/level1-level5 *.py files  \n  - Level1: simplest, Level5: most complex  \n\u2022 Each file contains PyTorch reference (reference_code)  \n\u2022 Goal: Generate functionally equivalent but faster Triton implementations (custom_code)  \n\u2022 Evaluation pipeline:\n    1) /verify_plus - Verify compilation & correctness  \n    2) /execute (optional) - Return terminal logs if compilation fails  \n    3) Scoring:  \n      - Speedup > 1 required for points  \n      - Score = (speed_up - 1) \u00d7 100  \n\u2022 GPU Hardware: NVIDIA L20Y / H800 (same SM8.9 as H100)  \n  - 3 TB/s HBM3 bandwidth  \n  - FP16 Tensor Core 32\u00d716\u00d716  \n\n==================== Evolution Phases ====================\n\u2460 Phase 1 [Compilation Pass]  \n  - Make Triton code compile (performance irrelevant)  \n\u2461 Phase 2 [Numerical Correctness]  \n  - Output must match PyTorch reference within float32 tolerance  \n\u2462 Phase 3 [Performance Gain]  \n  - Target \u22655% speedup (\u226515% = exceptional)  \n  - Official scoring based on speed_up field  \n\nThe Evolution system will pass the EVOLVE-BLOCK from the previous version.  \nModify ONLY the Triton kernel source within this block - all other code is LOCKED.\n\n==================== Constraints (MUST OBEY) ====================\n\u274c NEVER change @triton.jit function signatures or parameter names  \n\u274c NEVER modify grid configuration, output tensor shapes, or PID logic  \n\u274c NEVER remove boundary checks or out-of-bound masks  \n\u274c NEVER introduce race conditions, uninitialized reads, or sync gaps  \n\n\u2705 Allowed Optimizations (Examples):  \n  \u2022 Memory coalescing optimizations & vectorized tl.load/tl.store  \n  \u2022 Replace staged softmax with online/FlashAttention variants  \n  \u2022 Adaptive tuning: BLOCK_M/BLOCK_N/BLOCK_K dimensions  \n  \u2022 Multi-query-head batch processing (GQA, 5:1 patterns)  \n  \u2022 Shared/L2 buffering, Tensor Core alignment (FP16/bf16/tf32)  \n  \u2022 Stride precomputation & pointer caching  \n\n==================== Output Format ====================\nReturn ONLY the complete updated code containing the EVOLVE-BLOCK comment marker.  \nNO explanations, NO markdown, NO additional text.\nName the output structure class as ModelNew.\n\n==================== Optimization Tips ====================\n\u2022 If previous compile failed: Fix syntax/mask/stride errors first  \n\u2022 If correctness fails: Prioritize bounds mask & dtype precision  \n\u2022 When speed_up < 1: Focus on memory access & block sizing  \n\u2022 Small iterative steps: Modify \u226420 lines per revision  \n\u2022 Maintain reversibility between versions\nHere is an example to show you how to rewrite a PyTorch implementation that quantizes a high-precision tensor to int8 dtype with row-wise granularity into a Triton implementation: \nThe original PyTorch implementation is as follows: \n``` \nimport torch\ndef per_row_quantize_int8(x: torch.Tensor) -> tuple[torch.Tensor, torch.Tensor]:\n    x_amax = x.abs().float().amax(dim=1).clamp(min=1e-4)\n    scale = 127 / x_amax\n    output = (x * scale[:, None]).round().clamp(-127, 127).to(torch.int8)\n    output_scale = x_amax / 127\n\n    return output, output_scale\n``` \nThe corresponding Triton-rewritten implementation is as follows: \n``` \nimport math\nimport torch\nimport triton\nimport triton.language as tl\nfrom triton.language.extra import libdevice\n\n# rowwise quantize\n\n@triton.autotune(\n    configs=[\n        triton.Config({}, num_stages=1, num_warps=8),\n        triton.Config({}, num_stages=2, num_warps=8),\n        triton.Config({}, num_stages=4, num_warps=8),\n        triton.Config({}, num_stages=8, num_warps=8),\n        triton.Config({}, num_stages=1),\n        triton.Config({}, num_stages=2),\n        triton.Config({}, num_stages=4),\n        triton.Config({}, num_stages=8),\n        triton.Config({}, num_warps=1),\n        triton.Config({}, num_warps=2),\n        triton.Config({}, num_warps=4),\n        triton.Config({}, num_warps=8),\n    ],\n    key=[\"n_elements\"],\n)\n\n@triton.jit\ndef _quantize_rowwise(\n    x_ptr,\n    output_ptr,\n    output_scale,\n    BLOCK_SIZE: tl.constexpr,\n    P2: tl.constexpr,\n):\n    pid = tl.program_id(axis=0)\n    block_start = pid * BLOCK_SIZE\n    arange = tl.arange(0, P2)\n    offsets = block_start + arange\n    row_mask = arange < BLOCK_SIZE\n    x = tl.load(x_ptr + offsets, mask=row_mask)\n\n    abs_x = tl.abs(x)\n    max_val = tl.max(tl.where(row_mask, abs_x, 0), axis=0)\n    output = libdevice.llrint(127.0 * (x / max_val))\n    tl.store(output_ptr + offsets, output, mask=row_mask)\n    tl.store(output_scale + pid, max_val / 127)\n\n\ndef per_row_quantize_int8(x: torch.Tensor):\n    x = x.contiguous()\n    output = torch.empty(*x.shape, device=x.device, dtype=torch.int8)\n    output_scale = torch.empty(x.shape[0], device=x.device, dtype=torch.float32)\n    P2 = int(2 ** (math.ceil(math.log2(x.shape[1]))))\n    grid = lambda x: (x.shape[0],)\n    _quantize_rowwise[grid](x, output, output_scale, BLOCK_SIZE=x.shape[1], P2=P2)\n\n    return output, output_scale\n\n\n    \n``` \n", "user": "# Current Program Information\n- Current performance metrics: - compiled: 1.0000\n- correctness: 1.0000\n- stage: reference code\n- passed: 0.0000\n- score: 0.0000\n- speed_up: 1.0000\n- runtime_ms: 0.0453\n- meta: {'hardware': 'NVIDIA L20Y', 'device': 'cuda:6', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.0527, 'speed_up': 1.163, 'custom_timing': 0.0453}\n- Areas identified for improvement: - Consider simplifying the code to improve readability and maintainability\n- Metrics showing improvement: speed_up, runtime_ms. Consider continuing with similar changes.\n- Metrics showing regression: score. Consider reverting or revising recent changes in these areas.\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Unknown changes\n- Performance: compiled: 1.0000, correctness: 0.0000, score: 10.0000, stage: wrong_answer, verify_payload: {'id': 'level2_86_Matmul_Divide_GELU', 'result': {'compiled': True, 'correctness': False, 'metadata': {'hardware': 'NVIDIA L20Y', 'device': 'cuda:3', 'runtime_error': 'Traceback (most recent call last):\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/language/core.py\", line 42, in wrapper\\n    return fn(*args, **kwargs)\\nTypeError: dot() got an unexpected keyword argument \\'trans_b\\'\\n\\nThe above exception was the direct cause of the following exception:\\n\\nTraceback (most recent call last):\\n  File \"/cpfs01/shared/llm_kernel/hujiakai/KernelLLM/validation_api_server/helpers/evaluations.py\", line 720, in run_and_check_correctness\\n    output_new = model_new(*inputs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1773, in _wrapped_call_impl\\n    return self._call_impl(*args, **kwargs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1784, in _call_impl\\n    return forward_call(*args, **kwargs)\\n  File \"/tmp/tmprai6u7c7.py\", line 90, in forward\\n    x = triton_linear(x, self.weight, self.bias)\\n  File \"/tmp/tmprai6u7c7.py\", line 68, in triton_linear\\n    linear_kernel[grid](\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 390, in <lambda>\\n    return lambda *args, **kwargs: self.run(grid=grid, warmup=False, *args, **kwargs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 239, in run\\n    benchmark()\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 228, in benchmark\\n    timings = {config: self._bench(*args, config=config, **kwargs) for config in pruned_configs}\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 228, in <dictcomp>\\n    timings = {config: self._bench(*args, config=config, **kwargs) for config in pruned_configs}\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 160, in _bench\\n    return self.do_bench(kernel_call, quantiles=(0.5, 0.2, 0.8))\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/testing.py\", line 149, in do_bench\\n    fn()\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 146, in kernel_call\\n    self.fn.run(\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 594, in run\\n    kernel = self.compile(src, target=target, options=options.__dict__)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/compiler/compiler.py\", line 339, in compile\\n    module = src.make_ir(options, codegen_fns, module_map, context)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/compiler/compiler.py\", line 83, in make_ir\\n    return ast_to_ttir(self.fn, self, context=context, options=options, codegen_fns=codegen_fns,\\ntriton.compiler.errors.CompilationError: at 29:15:\\n    w_ptrs = weight_ptr + offs_n[:, None] * stride_wn + offs_k[None, :] * stride_wk\\n\\n    acc = tl.zeros((BLOCK_SIZE_M, BLOCK_SIZE_N), dtype=tl.float32)\\n\\n    for k in range(0, tl.cdiv(K, BLOCK_SIZE_K)):\\n        k_remaining = K - k * BLOCK_SIZE_K\\n        k_mask = offs_k < k_remaining\\n\\n        a = tl.load(x_ptrs, mask=k_mask[None, :] & (offs_m[:, None] < M), other=0.0)\\n        b = tl.load(w_ptrs, mask=k_mask[None, :] & (offs_n[:, None] < N), other=0.0)\\n\\n        acc += tl.dot(a, b, trans_b=True)\\n               ^\\n\\n\\nThe above exception was the direct cause of the following exception:\\n\\nTraceback (most recent call last):\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/language/core.py\", line 42, in wrapper\\n    return fn(*args, **kwargs)\\nTypeError: dot() got an unexpected keyword argument \\'trans_b\\'\\n', 'runtime_error_name': 'triton.compiler.errors.CompilationError', 'reference_timing_ms': 0.0527, 'speed_up': -1.0, 'custom_timing': -1.0}, 'runtime': -1.0, 'runtime_stats': {}}}\n- Outcome: Mixed results\n\n\n### Attempt 2\n- Changes: Unknown changes\n- Performance: compiled: 1.0000, correctness: 0.0000, score: 10.0000, stage: wrong_answer, verify_payload: {'id': 'level2_86_Matmul_Divide_GELU', 'result': {'compiled': True, 'correctness': False, 'metadata': {'hardware': 'NVIDIA L20Y', 'device': 'cuda:4', 'max_difference': ['0.178050', '0.187824', '0.193828', '0.186985'], 'avg_difference': ['0.016259', '0.016318', '0.016305', '0.016288'], 'correctness_issue': 'Output mismatch', 'correctness_trials': '(1 / 5)', 'reference_timing_ms': 0.0527, 'speed_up': -1.0, 'custom_timing': -1.0}, 'runtime': -1.0, 'runtime_stats': {}}}\n- Outcome: Mixed results\n\n\n### Attempt 1\n- Changes: Unknown changes\n- Performance: compiled: 1.0000, correctness: 1.0000, stage: success, passed: 0.0000, score: 20.0000, speed_up: 0.4150, runtime_ms: 0.1270, meta: {'hardware': 'NVIDIA L20Y', 'device': 'cuda:3', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.0527, 'speed_up': 0.415, 'custom_timing': 0.127}\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 20.0000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\nimport math\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_SIZE': 128, 'BLOCK_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_SIZE': 256, 'BLOCK_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_SIZE': 64, 'BLOCK_K': 128}, num_warps=4),\n        triton.Config({'BLOCK_SIZE': 128, 'BLOCK_K': 128}, num_warps=4),\n        triton.Config({'BLOCK_SIZE': 256, 'BLOCK_K': 64}, num_warps=8),\n    ],\n    key=['input_size', 'output_size'],\n)\n@triton.jit\ndef _fused_linear_div_gelu(\n    x_ptr, weight_ptr, bias_ptr, output_ptr,\n    input_size, output_size, divisor,\n    batch_size, stride_x, stride_out,\n    BLOCK_SIZE: tl.constexpr, BLOCK_K: tl.constexpr,\n    HAS_BIAS: tl.constexpr,\n):\n    # Compute program IDs\n    pid_batch = tl.program_id(0)\n    pid_output_block = tl.program_id(1)\n    \n    # Create output block offset\n    output_offset = pid_output_block * BLOCK_SIZE + tl.arange(0, BLOCK_SIZE)\n    output_mask = output_offset < output_size\n    \n    # Initialize accumulator\n    acc = tl.zeros((BLOCK_SIZE,), dtype=tl.float32)\n    \n    # Loop over input features in blocks\n    for k in range(0, input_size, BLOCK_K):\n        k_offset = k + tl.arange(0, BLOCK_K)\n        k_mask = k_offset < input_size\n        \n        # Load input block\n        x_ptr_offset = pid_batch * stride_x + k_offset\n        x_block = tl.load(x_ptr + x_ptr_offset, mask=k_mask, other=0.0)\n        \n        # Load weight block\n        w_ptr_offset = output_offset[:, None] * input_size + k_offset[None, :]\n        w_block = tl.load(weight_ptr + w_ptr_offset, mask=output_mask[:, None] & k_mask[None, :], other=0.0)\n        \n        # Compute partial dot product\n        acc += tl.sum(x_block[None, :] * w_block, axis=1)\n    \n    # Load bias if exists\n    if HAS_BIAS:\n        bias_block = tl.load(bias_ptr + output_offset, mask=output_mask, other=0.0)\n        acc += bias_block\n    \n    # Apply division and approximate GELU\n    scaled = acc / divisor\n    gelu = scaled * 0.5 * (1.0 + tl.erf(scaled * 0.7071067811865475))\n    \n    # Store output\n    out_ptr_offset = pid_batch * stride_out + output_offset\n    tl.store(output_ptr + out_ptr_offset, gelu, mask=output_mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, input_size, output_size, divisor):\n        super(ModelNew, self).__init__()\n        self.input_size = input_size\n        self.output_size = output_size\n        self.divisor = divisor\n        \n        # Initialize parameters as in nn.Linear\n        self.weight = nn.Parameter(torch.empty(output_size, input_size))\n        self.bias = nn.Parameter(torch.empty(output_size))\n        nn.init.kaiming_uniform_(self.weight, a=math.sqrt(5))\n        fan_in, _ = nn.init._calculate_fan_in_and_fan_out(self.weight)\n        bound = 1 / math.sqrt(fan_in) if fan_in > 0 else 0\n        nn.init.uniform_(self.bias, -bound, bound)\n\n    def forward(self, x):\n        batch_size, _ = x.shape\n        output = torch.empty((batch_size, self.output_size), \n                             device=x.device, dtype=x.dtype)\n        \n        # Dynamic grid based on autotuned BLOCK_SIZE\n        grid = lambda meta: (batch_size, triton.cdiv(self.output_size, meta['BLOCK_SIZE']))\n        \n        # Launch kernel\n        _fused_linear_div_gelu[grid](\n            x, self.weight, self.bias, output,\n            self.input_size, self.output_size, self.divisor,\n            batch_size, x.stride(0), output.stride(0),\n            HAS_BIAS=True\n        )\n        return output\n\nbatch_size = 128\ninput_size = 512\noutput_size = 1024\ndivisor = 10.0\n\ndef get_inputs():\n    return [torch.randn(batch_size, input_size)]\n\ndef get_init_inputs():\n    return [input_size, output_size, divisor]\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Performs well on compiled (1.0000), Performs well on correctness (1.0000), Performs well on stage (success), Performs well on passed (0.0000), Performs well on score (20.0000), Performs well on speed_up (0.4150), Performs well on runtime_ms (0.1270), Performs well on meta ({'hardware': 'NVIDIA L20Y', 'device': 'cuda:3', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.0527, 'speed_up': 0.415, 'custom_timing': 0.127})\n\n\n### Program 2 (Score: 10.0000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\nimport math\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_SIZE': 128, 'BLOCK_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_SIZE': 256, 'BLOCK_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_SIZE': 64, 'BLOCK_K': 128}, num_warps=4),\n        triton.Config({'BLOCK_SIZE': 128, 'BLOCK_K': 128}, num_warps=4),\n        triton.Config({'BLOCK_SIZE': 256, 'BLOCK_K': 64}, num_warps=8),\n    ],\n    key=['input_size', 'output_size'],\n)\n@triton.jit\ndef _fused_linear_div_gelu(\n    x_ptr, weight_ptr, bias_ptr, output_ptr,\n    input_size, output_size, divisor,\n    batch_size, stride_x, stride_out,\n    BLOCK_SIZE: tl.constexpr, BLOCK_K: tl.constexpr,\n    HAS_BIAS: tl.constexpr,\n):\n    # Compute program IDs\n    pid_batch = tl.program_id(0)\n    pid_output_block = tl.program_id(1)\n    \n    # Create output block offset\n    output_offset = pid_output_block * BLOCK_SIZE + tl.arange(0, BLOCK_SIZE)\n    output_mask = output_offset < output_size\n    \n    # Initialize accumulator\n    acc = tl.zeros((BLOCK_SIZE,), dtype=tl.float32)\n    \n    # Loop over input features in blocks\n    for k in range(0, input_size, BLOCK_K):\n        k_offset = k + tl.arange(0, BLOCK_K)\n        k_mask = k_offset < input_size\n        \n        # Load input block\n        x_ptr_offset = pid_batch * stride_x + k_offset\n        x_block = tl.load(x_ptr + x_ptr_offset, mask=k_mask, other=0.0)\n        \n        # Load weight block\n        w_ptr_offset = output_offset[:, None] * input_size + k_offset[None, :]\n        w_block = tl.load(weight_ptr + w_ptr_offset, mask=output_mask[:, None] & k_mask[None, :], other=0.0)\n        \n        # Compute partial dot product\n        acc += tl.sum(x_block[None, :] * w_block, axis=1)\n    \n    # Load bias if exists\n    if HAS_BIAS:\n        bias_block = tl.load(bias_ptr + output_offset, mask=output_mask, other=0.0)\n        acc += bias_block\n    \n    # Apply division and approximate GELU\n    scaled = acc / divisor\n    gelu = scaled * 0.5 * (1.0 + tl.erf(scaled * 0.7071067811865475))\n    \n    # Store output\n    out_ptr_offset = pid_batch * stride_out + output_offset\n    tl.store(output_ptr + out_ptr_offset, gelu, mask=output_mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, input_size, output_size, divisor):\n        super(ModelNew, self).__init__()\n        self.input_size = input_size\n        self.output_size = output_size\n        self.divisor = divisor\n        \n        # Initialize parameters as in nn.Linear\n        self.weight = nn.Parameter(torch.empty(output_size, input_size))\n        self.bias = nn.Parameter(torch.empty(output_size))\n        nn.init.kaiming_uniform_(self.weight, a=math.sqrt(5))\n        fan_in, _ = nn.init._calculate_fan_in_and_fan_out(self.weight)\n        bound = 1 / math.sqrt(fan_in) if fan_in > 0 else 0\n        nn.init.uniform_(self.bias, -bound, bound)\n\n    def forward(self, x):\n        batch_size, _ = x.shape\n        output = torch.empty((batch_size, self.output_size), \n                             device=x.device, dtype=x.dtype)\n        \n        # Determine grid dimensions\n        grid = (batch_size, triton.cdiv(self.output_size, 128))\n        \n        # Launch kernel\n        _fused_linear_div_gelu[grid](\n            x, self.weight, self.bias, output,\n            self.input_size, self.output_size, self.divisor,\n            batch_size, x.stride(0), output.stride(0),\n            HAS_BIAS=True\n        )\n        return output\n\nbatch_size = 128\ninput_size = 512\noutput_size = 1024\ndivisor = 10.0\n\ndef get_inputs():\n    return [torch.randn(batch_size, input_size)]\n\ndef get_init_inputs():\n    return [input_size, output_size, divisor]\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Performs well on compiled (1.0000), Performs well on correctness (0.0000), Performs well on score (10.0000), Performs well on stage (wrong_answer), Performs well on verify_payload ({'id': 'level2_86_Matmul_Divide_GELU', 'result': {'compiled': True, 'correctness': False, 'metadata': {'hardware': 'NVIDIA L20Y', 'device': 'cuda:4', 'max_difference': ['0.178050', '0.187824', '0.193828', '0.186985'], 'avg_difference': ['0.016259', '0.016318', '0.016305', '0.016288'], 'correctness_issue': 'Output mismatch', 'correctness_trials': '(1 / 5)', 'reference_timing_ms': 0.0527, 'speed_up': -1.0, 'custom_timing': -1.0}, 'runtime': -1.0, 'runtime_stats': {}}})\n\n\n### Program 3 (Score: 10.0000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 256, 'BLOCK_SIZE_K': 32}, num_stages=4, num_warps=4),\n        triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 32}, num_stages=4, num_warps=4),\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 32}, num_stages=4, num_warps=4),\n        triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 32}, num_stages=4, num_warps=4),\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 32}, num_stages=4, num_warps=4),\n    ],\n    key=['M', 'N', 'K'],\n)\n@triton.jit\ndef linear_kernel(\n    x_ptr, weight_ptr, bias_ptr, output_ptr,\n    M, N, K,\n    stride_xm, stride_xk,\n    stride_wn, stride_wk,\n    stride_om, stride_on,\n    BLOCK_SIZE_M: tl.constexpr, BLOCK_SIZE_N: tl.constexpr, BLOCK_SIZE_K: tl.constexpr,\n):\n    pid = tl.program_id(0)\n    pid_m = pid // tl.cdiv(N, BLOCK_SIZE_N)\n    pid_n = pid % tl.cdiv(N, BLOCK_SIZE_N)\n    \n    offs_m = pid_m * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)\n    offs_n = pid_n * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n    offs_k = tl.arange(0, BLOCK_SIZE_K)\n    \n    x_ptrs = x_ptr + offs_m[:, None] * stride_xm + offs_k[None, :] * stride_xk\n    w_ptrs = weight_ptr + offs_n[:, None] * stride_wn + offs_k[None, :] * stride_wk\n    \n    acc = tl.zeros((BLOCK_SIZE_M, BLOCK_SIZE_N), dtype=tl.float32)\n    \n    for k in range(0, tl.cdiv(K, BLOCK_SIZE_K)):\n        k_remaining = K - k * BLOCK_SIZE_K\n        k_mask = offs_k < k_remaining\n        \n        a = tl.load(x_ptrs, mask=k_mask[None, :] & (offs_m[:, None] < M), other=0.0)\n        b = tl.load(w_ptrs, mask=k_mask[None, :] & (offs_n[:, None] < N), other=0.0)\n        \n        acc += tl.dot(a, b, trans_b=True)\n        x_ptrs += BLOCK_SIZE_K * stride_xk\n        w_ptrs += BLOCK_SIZE_K * stride_wk\n    \n    if bias_ptr is not None:\n        b_ptrs = bias_ptr + offs_n\n        bias = tl.load(b_ptrs, mask=offs_n < N, other=0.0)\n        acc += bias[None, :]\n    \n    offs_m = pid_m * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)\n    offs_n = pid_n * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n    out_ptrs = output_ptr + offs_m[:, None] * stride_om + offs_n[None, :] * stride_on\n    out_mask = (offs_m[:, None] < M) & (offs_n[None, :] < N)\n    tl.store(out_ptrs, acc, mask=out_mask)\n\ndef triton_linear(x, weight, bias):\n    M, K = x.shape\n    N, _ = weight.shape\n    output = torch.empty((M, N), device=x.device, dtype=x.dtype)\n    \n    grid = lambda META: (triton.cdiv(M, META['BLOCK_SIZE_M']) * triton.cdiv(N, META['BLOCK_SIZE_N']),)\n    \n    linear_kernel[grid](\n        x, weight, bias, output,\n        M, N, K,\n        x.stride(0), x.stride(1),\n        weight.stride(0), weight.stride(1),\n        output.stride(0), output.stride(1),\n    )\n    return output\n\nclass ModelNew(nn.Module):\n    def __init__(self, input_size, output_size, divisor):\n        super(ModelNew, self).__init__()\n        self.weight = nn.Parameter(torch.empty(output_size, input_size))\n        self.bias = nn.Parameter(torch.empty(output_size))\n        self.divisor = divisor\n        nn.init.kaiming_uniform_(self.weight, a=5**0.5)\n        if self.bias is not None:\n            fan_in, _ = nn.init._calculate_fan_in_and_fan_out(self.weight)\n            bound = 1 / (fan_in**0.5) if fan_in > 0 else 0\n            nn.init.uniform_(self.bias, -bound, bound)\n\n    def forward(self, x):\n        x = triton_linear(x, self.weight, self.bias)\n        x = x / self.divisor\n        x = torch.nn.functional.gelu(x)\n        return x\n\nbatch_size = 128\ninput_size = 512\noutput_size = 1024\ndivisor = 10.0\n\ndef get_inputs():\n    return [torch.randn(batch_size, input_size)]\n\ndef get_init_inputs():\n    return [input_size, output_size, divisor]\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Performs well on compiled (1.0000), Performs well on correctness (0.0000), Performs well on score (10.0000), Performs well on stage (wrong_answer), Performs well on verify_payload ({'id': 'level2_86_Matmul_Divide_GELU', 'result': {'compiled': True, 'correctness': False, 'metadata': {'hardware': 'NVIDIA L20Y', 'device': 'cuda:3', 'runtime_error': 'Traceback (most recent call last):\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/language/core.py\", line 42, in wrapper\\n    return fn(*args, **kwargs)\\nTypeError: dot() got an unexpected keyword argument \\'trans_b\\'\\n\\nThe above exception was the direct cause of the following exception:\\n\\nTraceback (most recent call last):\\n  File \"/cpfs01/shared/llm_kernel/hujiakai/KernelLLM/validation_api_server/helpers/evaluations.py\", line 720, in run_and_check_correctness\\n    output_new = model_new(*inputs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1773, in _wrapped_call_impl\\n    return self._call_impl(*args, **kwargs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1784, in _call_impl\\n    return forward_call(*args, **kwargs)\\n  File \"/tmp/tmprai6u7c7.py\", line 90, in forward\\n    x = triton_linear(x, self.weight, self.bias)\\n  File \"/tmp/tmprai6u7c7.py\", line 68, in triton_linear\\n    linear_kernel[grid](\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 390, in <lambda>\\n    return lambda *args, **kwargs: self.run(grid=grid, warmup=False, *args, **kwargs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 239, in run\\n    benchmark()\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 228, in benchmark\\n    timings = {config: self._bench(*args, config=config, **kwargs) for config in pruned_configs}\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 228, in <dictcomp>\\n    timings = {config: self._bench(*args, config=config, **kwargs) for config in pruned_configs}\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 160, in _bench\\n    return self.do_bench(kernel_call, quantiles=(0.5, 0.2, 0.8))\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/testing.py\", line 149, in do_bench\\n    fn()\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 146, in kernel_call\\n    self.fn.run(\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 594, in run\\n    kernel = self.compile(src, target=target, options=options.__dict__)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/compiler/compiler.py\", line 339, in compile\\n    module = src.make_ir(options, codegen_fns, module_map, context)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/compiler/compiler.py\", line 83, in make_ir\\n    return ast_to_ttir(self.fn, self, context=context, options=options, codegen_fns=codegen_fns,\\ntriton.compiler.errors.CompilationError: at 29:15:\\n    w_ptrs = weight_ptr + offs_n[:, None] * stride_wn + offs_k[None, :] * stride_wk\\n\\n    acc = tl.zeros((BLOCK_SIZE_M, BLOCK_SIZE_N), dtype=tl.float32)\\n\\n    for k in range(0, tl.cdiv(K, BLOCK_SIZE_K)):\\n        k_remaining = K - k * BLOCK_SIZE_K\\n        k_mask = offs_k < k_remaining\\n\\n        a = tl.load(x_ptrs, mask=k_mask[None, :] & (offs_m[:, None] < M), other=0.0)\\n        b = tl.load(w_ptrs, mask=k_mask[None, :] & (offs_n[:, None] < N), other=0.0)\\n\\n        acc += tl.dot(a, b, trans_b=True)\\n               ^\\n\\n\\nThe above exception was the direct cause of the following exception:\\n\\nTraceback (most recent call last):\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/language/core.py\", line 42, in wrapper\\n    return fn(*args, **kwargs)\\nTypeError: dot() got an unexpected keyword argument \\'trans_b\\'\\n', 'runtime_error_name': 'triton.compiler.errors.CompilationError', 'reference_timing_ms': 0.0527, 'speed_up': -1.0, 'custom_timing': -1.0}, 'runtime': -1.0, 'runtime_stats': {}}})\n\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.0000)\n```python\n\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\n\nclass ModelNew(nn.Module):\n    \"\"\"\n    A model that performs a matrix multiplication, divides by a scalar, and applies GELU activation.\n    \"\"\"\n    def __init__(self, input_size, output_size, divisor):\n        super(ModelNew, self).__init__()\n        self.linear = nn.Linear(input_size, output_size)\n        self.divisor = divisor\n\n    def forward(self, x):\n        \"\"\"\n        Args:\n            x (torch.Tensor): Input tensor of shape (batch_size, input_size).\n        Returns:\n            torch.Tensor: Output tensor of shape (batch_size, output_size).\n        \"\"\"\n        x = self.linear(x)\n        x = x / self.divisor\n        x = torch.nn.functional.gelu(x)\n        return x\n\nbatch_size = 128\ninput_size = 512\noutput_size = 1024\ndivisor = 10.0\n\ndef get_inputs():\n    return [torch.randn(batch_size, input_size)]\n\ndef get_init_inputs():\n    return [input_size, output_size, divisor]\n# =================== EVOLVE-BLOCK-END ===================\n\n```\nKey features: Alternative approach to compiled, Alternative approach to correctness\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 20.0000, Type: High-Performer)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\nimport math\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_SIZE': 128, 'BLOCK_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_SIZE': 256, 'BLOCK_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_SIZE': 64, 'BLOCK_K': 128}, num_warps=4),\n        triton.Config({'BLOCK_SIZE': 128, 'BLOCK_K': 128}, num_warps=4),\n        triton.Config({'BLOCK_SIZE': 256, 'BLOCK_K': 64}, num_warps=8),\n    ],\n    key=['input_size', 'output_size'],\n)\n@triton.jit\ndef _fused_linear_div_gelu(\n    x_ptr, weight_ptr, bias_ptr, output_ptr,\n    input_size, output_size, divisor,\n    batch_size, stride_x, stride_out,\n    BLOCK_SIZE: tl.constexpr, BLOCK_K: tl.constexpr,\n    HAS_BIAS: tl.constexpr,\n):\n    # Compute program IDs\n    pid_batch = tl.program_id(0)\n    pid_output_block = tl.program_id(1)\n    \n    # Create output block offset\n    output_offset = pid_output_block * BLOCK_SIZE + tl.arange(0, BLOCK_SIZE)\n    output_mask = output_offset < output_size\n    \n    # Initialize accumulator\n    acc = tl.zeros((BLOCK_SIZE,), dtype=tl.float32)\n    \n    # Loop over input features in blocks\n    for k in range(0, input_size, BLOCK_K):\n        k_offset = k + tl.arange(0, BLOCK_K)\n        k_mask = k_offset < input_size\n        \n        # Load input block\n        x_ptr_offset = pid_batch * stride_x + k_offset\n        x_block = tl.load(x_ptr + x_ptr_offset, mask=k_mask, other=0.0)\n        \n        # Load weight block\n        w_ptr_offset = output_offset[:, None] * input_size + k_offset[None, :]\n        w_block = tl.load(weight_ptr + w_ptr_offset, mask=output_mask[:, None] & k_mask[None, :], other=0.0)\n        \n        # Compute partial dot product\n        acc += tl.sum(x_block[None, :] * w_block, axis=1)\n    \n    # Load bias if exists\n    if HAS_BIAS:\n        bias_block = tl.load(bias_ptr + output_offset, mask=output_mask, other=0.0)\n        acc += bias_block\n    \n    # Apply division and approximate GELU\n    scaled = acc / divisor\n    gelu = scaled * 0.5 * (1.0 + tl.erf(scaled * 0.7071067811865475))\n    \n    # Store output\n    out_ptr_offset = pid_batch * stride_out + output_offset\n    tl.store(output_ptr + out_ptr_offset, gelu, mask=output_mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, input_size, output_size, divisor):\n        super(ModelNew, self).__init__()\n        self.input_size = input_size\n        self.output_size = output_size\n        self.divisor = divisor\n        \n        # Initialize parameters as in nn.Linear\n        self.weight = nn.Parameter(torch.empty(output_size, input_size))\n        self.bias = nn.Parameter(torch.empty(output_size))\n        nn.init.kaiming_uniform_(self.weight, a=math.sqrt(5))\n        fan_in, _ = nn.init._calculate_fan_in_and_fan_out(self.weight)\n        bound = 1 / math.sqrt(fan_in) if fan_in > 0 else 0\n        nn.init.uniform_(self.bias, -bound, bound)\n\n    def forward(self, x):\n        batch_size, _ = x.shape\n        output = torch.empty((batch_size, self.output_size), \n                             device=x.device, dtype=x.dtype)\n        \n        # Dynamic grid based on autotuned BLOCK_SIZE\n        grid = lambda meta: (batch_size, triton.cdiv(self.output_size, meta['BLOCK_SIZE']))\n        \n        # Launch kernel\n        _fused_linear_div_gelu[grid](\n            x, self.weight, self.bias, output,\n            self.input_size, self.output_size, self.divisor,\n            batch_size, x.stride(0), output.stride(0),\n            HAS_BIAS=True\n        )\n        return output\n\nbatch_size = 128\ninput_size = 512\noutput_size = 1024\ndivisor = 10.0\n\ndef get_inputs():\n    return [torch.randn(batch_size, input_size)]\n\ndef get_init_inputs():\n    return [input_size, output_size, divisor]\n# =================== EVOLVE-BLOCK-END ===================\n```\nUnique approach: Modification: Full rewrite, Excellent compiled (1.000), Excellent correctness (1.000)\n\n\n\n# Current Program\n```python\n\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\n\nclass ModelNew(nn.Module):\n    \"\"\"\n    A model that performs a matrix multiplication, divides by a scalar, and applies GELU activation.\n    \"\"\"\n    def __init__(self, input_size, output_size, divisor):\n        super(ModelNew, self).__init__()\n        self.linear = nn.Linear(input_size, output_size)\n        self.divisor = divisor\n\n    def forward(self, x):\n        \"\"\"\n        Args:\n            x (torch.Tensor): Input tensor of shape (batch_size, input_size).\n        Returns:\n            torch.Tensor: Output tensor of shape (batch_size, output_size).\n        \"\"\"\n        x = self.linear(x)\n        x = x / self.divisor\n        x = torch.nn.functional.gelu(x)\n        return x\n\nbatch_size = 128\ninput_size = 512\noutput_size = 1024\ndivisor = 10.0\n\ndef get_inputs():\n    return [torch.randn(batch_size, input_size)]\n\ndef get_init_inputs():\n    return [input_size, output_size, divisor]\n# =================== EVOLVE-BLOCK-END ===================\n\n```\n\n# Task\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```\n", "responses": ["<think>\nWe are given a PyTorch reference implementation that uses nn.Linear, then divides by a scalar and applies GELU.\n The goal is to rewrite it in Triton to get a speedup.\n\n The current program is the reference PyTorch code. We have to replace it with a Triton implementation.\n\n We have seen from the evolution history that several Triton implementations have been tried, but they had issues.\n\n The top-performing program (Program 1) achieved a speedup of 0.415 (which is a slowdown) but passed correctness.\n We need to do better.\n\n Steps:\n 1. We will design a Triton kernel that fuses the linear layer (matrix multiplication with bias), the division, and the GELU.\n 2. We note that the matrix multiplication can be done in blocks to utilize shared memory and tensor cores.\n 3. We must be cautious about the Triton version and the available operations.\n\n Important: The error in Attempt 3 was due to using `tl.dot(a, b, trans_b=True)`. The Triton dot operation does not have a `trans_b` argument.\n\n How to do matrix multiplication in Triton?\n  - We can use `tl.dot` but note that it expects the second matrix to be in row-major and without transposing we are effectively doing A * B^T?\n  - Actually, in the reference PyTorch code, the linear layer does: x @ weight.t() + bias.\n\n So we have two options:\n   Option 1: Store the weight matrix in row-major (as in PyTorch) and then in the kernel we do:\n        acc += tl.dot(a, b)   # where a is a block of x (M x K) and b is a block of weight (N x K) -> but then we need to transpose b?\n   Actually, if we have the weight in row-major (each row is a feature vector) then to compute x @ weight.t() we can do:\n        x_block: [BLOCK_M, BLOCK_K]\n        weight_block: [BLOCK_N, BLOCK_K]   # because weight is stored as [output_size, input_size] (row-major)\n        Then we want to compute: x_block @ weight_block.T -> which is [BLOCK_M, BLOCK_N]\n\n   So we can use: `tl.dot(x_block, weight_block, trans_b=True)`\n\n However, note the error in Attempt 3: \"TypeError: dot() got an unexpected keyword argument 'trans_b'\"\n\n This indicates that the version of Triton being used might not support the `trans_b` argument? Or it might be spelled differently.\n\n Let's check the Triton documentation: \n   In Triton 2.1, `tl.dot` supports `trans_a` and `trans_b` (see https://triton-lang.org/main/python-api/generated/triton.language.dot.html)\n\n But note: The error says \"unexpected keyword argument 'trans_b'\", which suggests that the environment might be using an older version?\n\n Alternatively, we can avoid transposing by storing the weight matrix in column-major? But that would break the PyTorch compatibility because nn.Linear uses row-major.\n\n Another approach is to pre-transpose the weight matrix? But that would cost time.\n\n Since the environment is fixed (we are in an evaluation system) and we know that the Triton version in use does not support `trans_b`, we have to avoid it.\n\n How can we do the matrix multiplication without trans_b?\n   We can pre-transpose the entire weight matrix and store it in column-major? Then we can do a normal dot product without trans_b.\n\n However, note the constraints: we cannot change the signature of the function and we are using the same weight as in PyTorch (row-major).\n\n Therefore, we have two options:\n\n Option 1: Use the row-major weight and load it in a way that we can do a dot product without transposing. \n   We can load the weight block in a transposed manner by changing the way we compute offsets? But note: the weight tensor is contiguous in row-major.\n\n   We want to compute: \n        C_block = A_block @ B_block^T\n\n   Without trans_b, we can do:\n        C_block = (B_block @ A_block^T)^T   -> but that is not efficient.\n\n Option 2: Use the row-major weight and do a manual loop for the dot product? That would be slow.\n\n Option 3: Use the `tl.dot` without trans_b and rearrange the dimensions. \n\n   We note that the operation we want is:\n        x (M, K) @ weight (N, K)^T = x (M, K) @ weight^T (K, N) -> (M, N)\n\n   We can instead consider:\n        weight (N, K) is stored in row-major. We want to compute the dot product of x and weight in the natural way.\n\n   We can load a block of weight as [BLOCK_K, BLOCK_N] and then transpose it in the kernel? But then we can do:\n        acc = tl.dot(x_block, weight_block_transposed)\n\n   How to transpose a block? We can use `tl.trans(weight_block)`? But Triton does not have a built-in transpose for arbitrary blocks? And it might be expensive.\n\n Option 4: Change the kernel to use a different blocking strategy: instead of having each program compute a block of the output, we can use a block for the inner dimension and accumulate? This is the approach taken in the top-performing Program 1 (which used a loop over K and then a vector dot product for each row of the output).\n\n   Program 1 did:\n        for k in range(0, input_size, BLOCK_K):\n            load a block of x: [BLOCK_SIZE] (vector)\n            load a block of weight: [BLOCK_SIZE, BLOCK_K] -> but note: they did:\n                w_ptr_offset = output_offset[:, None] * input_size + k_offset[None, :]\n                w_block = ... [BLOCK_SIZE, BLOCK_K]   # this is a block of the weight matrix for the current output block and the current k block.\n\n            Then they did: \n                acc += tl.sum(x_block[None, :] * w_block, axis=1)\n\n        This is equivalent to a vector-matrix product for a row of the output? Actually, note:\n            x_block[None, :] is [1, BLOCK_K] and w_block is [BLOCK_SIZE, BLOCK_K]. Then the product is [BLOCK_SIZE, BLOCK_K] and sum over axis=1 gives [BLOCK_SIZE] (a row of the output for the current batch).\n\n        This is a valid way to compute the matrix multiplication without using `tl.dot`. However, it is not as efficient as using tensor cores.\n\n Given that the hardware is H100 (with tensor cores) we want to use tensor cores for the matrix multiplication.\n\n How can we use tensor cores without trans_b?\n\n Insight: The tensor cores in Triton are used via `tl.dot` and the operation must be aligned to 16x16x16 for fp16. We are using float32? The problem does not specify, but the reference code uses float32.\n\n However, note: the reference code uses whatever the input is. The input is generated by `torch.randn(batch_size, input_size)` which is float32.\n\n We can try to use the tensor cores for fp32 by using tf32? But Triton might automatically use tensor cores for fp32 when available.\n\n But the main issue is the `trans_b` argument.\n\n After checking the Triton source code, the `trans_b` argument is supported in the latest versions. However, the error indicates that in the evaluation environment it is not.\n\n Therefore, we must avoid using `trans_b`.\n\n Alternative approach: Pre-transpose the weight matrix once in the initialization and store it as column-major? Then we can do:\n\n        x (M, K) @ weight_col_major (K, N) -> (M, N)\n\n   without any transpose.\n\n Steps:\n   In the __init__:\n        self.weight = nn.Parameter(torch.empty(output_size, input_size))\n        ... initialize ...\n        but then we also store a transposed version? However, we cannot change the class interface because the test uses the same parameters.\n\n   But note: the test passes the same inputs (the weight and bias) to the kernel. We are allowed to preprocess the weight once.\n\n   We can do:\n        self.weight_t = self.weight.t().contiguous()\n\n   Then in the kernel, we can use the weight_t as a [input_size, output_size] matrix? But then the kernel would use column-major.\n\n   However, note that the linear kernel in PyTorch is: x @ weight.t() + bias.\n\n   With the transposed weight stored as contiguous, we have: weight_t is [input_size, output_size] and we want to compute x @ weight_t? \n        But note: (x @ weight_t) = (x @ (weight.t())). So it's the same.\n\n   So we can do:\n\n        output = x @ weight_t   [without transposing]\n\n   Then in the kernel, we can do:\n        Let the weight matrix be stored as [input_size, output_size] (column-major for the original weight, but row-major for the transposed weight).\n\n        Then we can do:\n            x_block: [BLOCK_M, BLOCK_K]\n            weight_block: [BLOCK_K, BLOCK_N]   # because the weight_t is stored as [K, N] (row-major in the new view)\n\n        Then we can do: \n            acc = tl.dot(x_block, weight_block)   # [BLOCK_M, BLOCK_N]\n\n   This does not require trans_b.\n\n   But note: we are changing the layout of the weight. We have to do this in the __init__ and then in the forward we must use the transposed weight.\n\n   However, the constraint says: \"NEVER change grid configuration, output tensor shapes, or PID logic\". We are changing the weight layout but not the output shape.\n\n   But note: the problem says we cannot change the function signature of the Triton kernel. However, we are passing the same tensors? Actually, we would pass the transposed weight tensor.\n\n   This is acceptable because the kernel is our own. But note: the test will pass the same parameters (self.weight and self.bias) to the model. We are allowed to preprocess the weight.\n\n   However, we must be cautious: the original model has `self.weight` of shape [output_size, input_size]. We are creating a new buffer `self.weight_t` of shape [input_size, output_size]. This is acceptable.\n\n   But note: the model might be trained? The problem does not specify. We are only doing inference? The inputs are random.\n\n   Since the test only runs forward, we can do:\n\n        self.weight_t = self.weight.t().contiguous()\n\n   Then in the kernel, we use the transposed weight.\n\n   Also note: the bias remains the same.\n\n   How about the memory? We are using extra memory for the transposed weight. But that is acceptable.\n\n Implementation:\n\n   We will write a Triton kernel that expects:\n        x: [batch_size, input_size] (row-major)\n        weight_t: [input_size, output_size] (row-major) -> so each row of weight_t is a column of the original weight? Actually, the transposed weight is stored as row-major: the first row of weight_t is the first column of weight.\n\n   Then the operation is: x @ weight_t -> [batch_size, output_size]\n\n   This is the same as the original: x @ weight.t()\n\n   Now we can use `tl.dot` without trans_b.\n\n   We will design a kernel that uses tensor cores by having blocks that are multiples of 16 for M, N, K.\n\n   Steps in the kernel:\n\n        pid_batch = program_id(0)\n        pid_row = program_id(1)   # for the rows of the output (which is the same as the rows of x? no, the output is [batch_size, output_size])\n\n        Actually, we have two dimensions: batch and output features. We can map:\n            pid_batch: batch index\n            pid_output_block: block index for the output features.\n\n        But note: the matrix multiplication for a single batch element: [1, input_size] @ [input_size, output_size] -> [1, output_size]\n\n        We want to parallelize over batch and output features.\n\n        We can set:\n            grid = (batch_size, triton.cdiv(output_size, BLOCK_SIZE_N))\n\n        Then in the kernel:\n\n            pid_batch = program_id(0)\n            pid_output_block = program_id(1)\n\n            offs_batch = pid_batch\n            offs_n = pid_output_block * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n\n            # We also have to block the input_size (K) dimension.\n\n            acc = tl.zeros((BLOCK_SIZE_N,), dtype=tl.float32)   # we are computing one row of the output? Actually, we are computing a block of the output for one batch and a set of output features.\n\n            But note: the output for one batch is a row vector of length output_size. We are computing a contiguous block of that row.\n\n            How to load x? We need the entire row of x? But we are blocking K.\n\n        Alternatively, we can use a 2D grid for the output matrix: \n            grid = (triton.cdiv(batch_size, BLOCK_SIZE_M), triton.cdiv(output_size, BLOCK_SIZE_N))\n\n        Then each program computes a block [BLOCK_SIZE_M, BLOCK_SIZE_N] of the output.\n\n        Steps:\n            pid_m = program_id(0)   # for batch dimension (M = batch_size)\n            pid_n = program_id(1)   # for output dimension (N = output_size)\n\n            offs_m = pid_m * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)\n            offs_n = pid_n * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n\n            # We need to block the K dimension (input_size) into blocks of BLOCK_SIZE_K.\n\n            acc = tl.zeros((BLOCK_SIZE_M, BLOCK_SIZE_N), dtype=tl.float32)\n\n            for k in range(0, input_size, BLOCK_SIZE_K):\n                offs_k = k + tl.arange(0, BLOCK_SIZE_K)\n\n                # Load x: [BLOCK_SIZE_M, BLOCK_SIZE_K] from x_ptr\n                x_ptrs = x_ptr + offs_m[:, None] * stride_xm + offs_k[None, :]   # stride_xm: typically input_size? but we have batch stride: x is [batch_size, input_size] -> stride_xm = input_size? Actually, stride(0) is input_size? \n                # But note: x is contiguous? We are making it contiguous in the kernel launch? We can assume contiguous.\n\n                # Load weight_t: [BLOCK_SIZE_K, BLOCK_SIZE_N] from weight_t_ptr\n                w_ptrs = weight_t_ptr + offs_k[:, None] * stride_wk + offs_n[None, :]   # weight_t is [input_size, output_size] -> stride_wk = output_size? and stride for n is 1? \n                # Actually, weight_t is stored row-major: so the stride for the first dimension (k) is output_size? and the second dimension (n) is 1? \n                # But note: we are using offs_k and offs_n. We want to load a block of [BLOCK_SIZE_K, BLOCK_SIZE_N]? Then we do:\n                #   weight_t[offs_k, offs_n] -> but we need to use the strides.\n\n                # We have:\n                #   weight_t_ptr + offs_k * stride_wk + offs_n   [if the matrix is row-major: stride_wk = output_size? and then we want to broadcast?]\n\n                # Actually, we can do:\n                x_block = tl.load(x_ptrs, mask=(offs_m[:, None] < batch_size) & (offs_k[None, :] < input_size), other=0.0)\n                w_block = tl.load(w_ptrs, mask=(offs_k[:, None] < input_size) & (offs_n[None, :] < output_size), other=0.0)\n\n                # Now, x_block: [BLOCK_SIZE_M, BLOCK_SIZE_K]\n                # w_block: [BLOCK_SIZE_K, BLOCK_SIZE_N]   -> but note: the way we loaded, we have:\n                #   w_ptrs = weight_t_ptr + (offs_k[:, None] * stride_wk + offs_n[None, :]) -> this gives a [BLOCK_SIZE_K, BLOCK_SIZE_N] matrix? \n                #   But the addresses are not contiguous? We are doing a 2D load with a mask.\n\n                # Then we do:\n                acc += tl.dot(x_block, w_block)   # [BLOCK_SIZE_M, BLOCK_SIZE_N]\n\n            # Then add bias? But note: the bias is of size [output_size]. We are computing a block of the output. We only need the bias for the current block of n.\n            if bias_ptr is not None:\n                b_ptrs = bias_ptr + offs_n   # [BLOCK_SIZE_N]\n                bias = tl.load(b_ptrs, mask=offs_n < output_size, other=0.0)\n                # Now we have to add bias to every row of the block? So we do:\n                acc += bias[None, :]   # broadcast to [BLOCK_SIZE_M, BLOCK_SIZE_N]\n\n            # Then apply division and GELU:\n            scaled = acc / divisor\n            gelu = scaled * 0.5 * (1.0 + tl.erf(scaled / math.sqrt(2.0)))   # note: 0.7071067811865475 is 1/sqrt(2)\n\n            # Store output: [batch_size, output_size]\n            out_ptrs = output_ptr + offs_m[:, None] * stride_om + offs_n[None, :]   # output is [batch_size, output_size] -> row-major: stride_om = output_size\n            tl.store(out_ptrs, gelu, mask=(offs_m[:, None] < batch_size) & (offs_n[None, :] < output_size))\n\n 4. We must set the strides appropriately.\n\n 5. We must also consider that the tensor core requires the block sizes to be multiples of 16. So we set BLOCK_SIZE_M, BLOCK_SIZE_N, BLOCK_SIZE_K to multiples of 16.\n\n 6. We will use autotune for the block sizes.\n\n 7. We note that the kernel must be compiled and run correctly.\n\n Let's write the code accordingly.\n\n However, note: the current program (reference) does not use Triton at all. We are replacing the entire forward pass.\n\n Steps in the model:\n\n   In __init__:\n        We create the weight and bias as before, but we also create a transposed weight that is contiguous.\n\n   In forward:\n        We call the Triton kernel with the transposed weight.\n\n   We note: the input x must be contiguous.\n\n   We also note: the kernel must be launched with the correct grid.\n\n Implementation:\n\n   We will define a Triton kernel as described.\n\n   We will set the grid dimensions to (triton.cdiv(batch_size, BLOCK_SIZE_M), triton.cdiv(output_size, BLOCK_SIZE_N))\n\n   We will use autotune to choose the block sizes.\n\n   We note: the kernel does the entire fused operation: linear, division, GELU.\n\n Let's code accordingly.\n\n But note: the error in Attempt 3 was a compilation error in the dot product. We are now using a dot product without trans_b, so it should work.\n\n However, we are using a newer Triton feature? We are using a 2D grid and a 2D block for the matrix multiplication. This is standard.\n\n We will try to write the kernel and hope that the environment supports the 2D grid and the dot product without trans_b.\n\n Given the constraints, we must not change the function signature of the Triton kernel? Actually, the kernel is defined by us. The constraint says: \"NEVER change @triton.jit function signatures or parameter names\". We are defining the kernel for the first time? So we can define the parameters as we wish? But note: the model class must have the same interface.\n\n   The model class: \n        __init__(self, input_size, output_size, divisor)\n        forward(self, x)\n\n   And we have the same.\n\n   The kernel will be called from the forward method.\n\n   The kernel parameters: \n        x_ptr, weight_t_ptr, bias_ptr, output_ptr, \n        batch_size, input_size, output_size, divisor, \n        stride_xm, stride_xk, \n        stride_wk, stride_wn,   # for weight_t: but note we are using row-major for weight_t -> so the strides are [output_size, 1]? \n        stride_om, stride_on,   # for output: [output_size, 1]? \n        and then the block sizes.\n\n   We note: the input x is [batch_size, input_size] -> row-major: so stride_xm = input_size, stride_xk = 1? \n        Actually, the stride for the batch dimension (dim0) is input_size? and for the feature dimension (dim1) is 1? \n\n        But wait: in PyTorch, a contiguous tensor [batch_size, input_size] has strides (input_size, 1) if row-major.\n\n   Similarly, weight_t is [input_size, output_size] and we made it contiguous -> so strides (output_size, 1).\n\n   Output is [batch_size, output_size] -> contiguous: strides (output_size, 1).\n\n   So we can set:\n        stride_xm = x.stride(0)\n        stride_xk = x.stride(1)   # which is 1\n\n        stride_wk = weight_t.stride(0)   # output_size\n        stride_wn = weight_t.stride(1)   # 1\n\n        stride_om = output.stride(0)   # output_size\n        stride_on = output.stride(1)   # 1\n\n   But note: the kernel uses:\n        x_ptrs = x_ptr + offs_m[:, None] * stride_xm + offs_k[None, :] * stride_xk\n        w_ptrs = weight_t_ptr + offs_k[:, None] * stride_wk + offs_n[None, :] * stride_wn\n\n   This matches.\n\n   We are ready.\n\n Let's write the kernel.\n\n We note: the GELU formula: 0.5 * x * (1 + erf(x / sqrt(2)))\n        We can compute: scaled = (x @ weight_t + bias) / divisor\n        Then gelu = 0.5 * scaled * (1 + tl.erf(scaled * 0.7071067811865475))\n\n We must include the bias after the matrix multiplication.\n\n We are going to do:\n\n        acc = (x_block @ w_block)   [for the current block of k]\n        then after the loop, we add the bias (which is a vector of length BLOCK_SIZE_N) and then do the scaling and GELU.\n\n We must be cautious with the masking: we have to mask the loads and the stores.\n\n We are going to try this approach.\n\n Given the time, we will write the kernel and hope it compiles and runs correctly.\n\n We will use autotune for the block sizes.\n\n Note: the problem says to return the entire code block.\n\n We are going to replace the current model class with one that uses the Triton kernel.\n\n We note: the kernel must be defined above the model class.\n\n Let's code accordingly.\n\n IMPORTANT: We must not remove the boundary checks.\n\n We are going to write the kernel and the model class.\n\n We note: the test has a fixed batch size (128), input_size (512), output_size (1024), divisor (10.0).\n\n But the model is general.\n\n We define the kernel with the name `_fused_linear_div_gelu_kernel`.\n\n Let's write the code.\n</think>\nTo optimize the current PyTorch implementation, we'll create a fused Triton kernel that combines the matrix multiplication, division, and GELU activation. The key optimizations include:\n\n1. Pre-transposing weights to avoid transpose operations in the kernel\n2. Using tensor cores with appropriately sized blocks (multiples of 16)\n3. Fusing division and GELU activation with the matrix multiply\n4. Adding autotuning for optimal block sizes\n5. Using efficient memory access patterns with masking\n\nHere's the optimized implementation:\n\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\nimport math\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 256, 'BLOCK_SIZE_K': 32}, num_warps=8),\n        triton.Config({'BLOCK_SIZE_M': 256, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 32}, num_warps=8),\n    ],\n    key=['M', 'N', 'K'],\n)\n@triton.jit\ndef fused_linear_div_gelu_kernel(\n    # Pointers to matrices\n    x_ptr, weight_ptr, bias_ptr, output_ptr,\n    # Matrix dimensions\n    M, N, K, divisor,\n    # Strides\n    stride_xm, stride_xk,\n    stride_wk, stride_wn,\n    stride_om, stride_on,\n    # Blocking\n    BLOCK_SIZE_M: tl.constexpr,\n    BLOCK_SIZE_N: tl.constexpr,\n    BLOCK_SIZE_K: tl.constexpr,\n):\n    pid = tl.program_id(0)\n    pid_m = pid // tl.cdiv(N, BLOCK_SIZE_N)\n    pid_n = pid % tl.cdiv(N, BLOCK_SIZE_N)\n    \n    # Offsets for the block to process\n    offs_m = pid_m * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)\n    offs_n = pid_n * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n    offs_k = tl.arange(0, BLOCK_SIZE_K)\n    \n    # Pointers to the blocks of x and weight\n    x_ptrs = x_ptr + offs_m[:, None] * stride_xm + offs_k[None, :] * stride_xk\n    w_ptrs = weight_ptr + offs_k[:, None] * stride_wk + offs_n[None, :] * stride_wn\n    \n    # Initialize accumulator\n    acc = tl.zeros((BLOCK_SIZE_M, BLOCK_SIZE_N), dtype=tl.float32)\n    \n    # Loop over K dimension\n    k_remaining = K\n    for _ in range(0, tl.cdiv(K, BLOCK_SIZE_K)):\n        # Create masks to prevent out-of-bounds access\n        k_mask = offs_k < k_remaining\n        x_mask = (offs_m[:, None] < M) & k_mask[None, :]\n        w_mask = k_mask[:, None] & (offs_n[None, :] < N)\n        \n        # Load blocks\n        x_block = tl.load(x_ptrs, mask=x_mask, other=0.0)\n        w_block = tl.load(w_ptrs, mask=w_mask, other=0.0)\n        \n        # Compute partial matrix multiplication\n        acc += tl.dot(x_block, w_block)\n        \n        # Update pointers and remaining elements\n        x_ptrs += BLOCK_SIZE_K * stride_xk\n        w_ptrs += BLOCK_SIZE_K * stride_wk\n        k_remaining -= BLOCK_SIZE_K\n    \n    # Add bias if present\n    if bias_ptr is not None:\n        b_ptrs = bias_ptr + offs_n\n        b_mask = offs_n < N\n        bias = tl.load(b_ptrs, mask=b_mask, other=0.0)\n        acc += bias[None, :]\n    \n    # Apply division and GELU activation\n    scaled = acc / divisor\n    gelu = scaled * 0.5 * (1.0 + tl.erf(scaled * 0.7071067811865475))\n    \n    # Store output with appropriate masking\n    offs_m_base = pid_m * BLOCK_SIZE_M\n    offs_n_base = pid_n * BLOCK_SIZE_N\n    out_ptrs = output_ptr + offs_m[:, None] * stride_om + offs_n[None, :] * stride_on\n    out_mask = (offs_m[:, None] < M) & (offs_n[None, :] < N)\n    tl.store(out_ptrs, gelu, mask=out_mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, input_size, output_size, divisor):\n        super(ModelNew, self).__init__()\n        self.input_size = input_size\n        self.output_size = output_size\n        self.divisor = divisor\n        \n        # Initialize parameters\n        self.weight = nn.Parameter(torch.empty(output_size, input_size))\n        self.bias = nn.Parameter(torch.empty(output_size))\n        self.weight_t = None  # Will hold transposed weights\n        \n        # Kaiming initialization\n        nn.init.kaiming_uniform_(self.weight, a=math.sqrt(5))\n        fan_in, _ = nn.init._calculate_fan_in_and_fan_out(self.weight)\n        bound = 1 / math.sqrt(fan_in) if fan_in > 0 else 0\n        nn.init.uniform_(self.bias, -bound, bound)\n\n    def forward(self, x):\n        # Ensure inputs are contiguous\n        x = x.contiguous()\n        \n        # Pre-transpose weights once\n        if self.weight_t is None:\n            self.weight_t = self.weight.t().contiguous()\n        \n        M, K = x.shape\n        N = self.output_size\n        output = torch.empty((M, N), device=x.device, dtype=x.dtype)\n        \n        # Grid configuration\n        grid = lambda meta: (triton.cdiv(M, meta['BLOCK_SIZE_M']) * triton.cdiv(N, meta['BLOCK_SIZE_N']),)\n        \n        # Launch kernel\n        fused_linear_div_gelu_kernel[grid](\n            x, self.weight_t, self.bias, output,\n            M, N, K, self.divisor,\n            x.stride(0), x.stride(1),\n            self.weight_t.stride(0), self.weight_t.stride(1),\n            output.stride(0), output.stride(1),\n        )\n        return output\n\nbatch_size = 128\ninput_size = 512\noutput_size = 1024\ndivisor = 10.0\n\ndef get_inputs():\n    return [torch.randn(batch_size, input_size)]\n\ndef get_init_inputs():\n    return [input_size, output_size, divisor]\n# =================== EVOLVE-BLOCK-END ===================\n```"]}}}