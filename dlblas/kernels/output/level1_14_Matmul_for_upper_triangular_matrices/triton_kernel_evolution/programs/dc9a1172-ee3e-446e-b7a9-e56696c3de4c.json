{"id": "dc9a1172-ee3e-446e-b7a9-e56696c3de4c", "code": "# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\nclass ModelNew(nn.Module):\n    def __init__(self):\n        super().__init__()\n    \n    def forward(self, A, B):\n        N = A.size(0)\n        C = torch.zeros_like(A)\n        A = A.contiguous()\n        B = B.contiguous()\n        \n        BLOCK_SIZE = 128\n        BLOCK_K = 32\n        grid = (N,)\n        \n        self.upper_tri_matmul_kernel[grid](\n            A, B, C,\n            N, A.stride(0), A.stride(1),\n            B.stride(0), B.stride(1),\n            C.stride(0), C.stride(1),\n            BLOCK_SIZE=BLOCK_SIZE,\n            BLOCK_K=BLOCK_K\n        )\n        return C\n\n    @staticmethod\n    @triton.jit\n    def upper_tri_matmul_kernel(\n        A_ptr, B_ptr, C_ptr,\n        N, stride_am, stride_an,\n        stride_bm, stride_bn,\n        stride_cm, stride_cn,\n        BLOCK_SIZE: tl.constexpr,\n        BLOCK_K: tl.constexpr\n    ):\n        row = tl.program_id(0)\n        if row >= N:\n            return\n            \n        col_offsets = tl.arange(0, BLOCK_SIZE)\n        k_offsets = tl.arange(0, BLOCK_K)\n        \n        for j_base in range(row, N, BLOCK_SIZE):\n            j = j_base + col_offsets\n            mask_j = j < N\n            \n            acc = tl.zeros((BLOCK_SIZE,), dtype=tl.float32)\n            \n            for k_base in range(row, N, BLOCK_K):\n                k = k_base + k_offsets\n                mask_k = k < N\n                \n                # Load A block (vector)\n                a_ptrs = A_ptr + row * stride_am + k * stride_an\n                a = tl.load(a_ptrs, mask=mask_k, other=0.0)\n                \n                # Load B block (matrix)\n                b_ptrs = B_ptr + k[:, None] * stride_bm + j[None, :] * stride_bn\n                b = tl.load(b_ptrs, mask=mask_k[:, None] & mask_j[None, :], other=0.0)\n                \n                # Compute update mask\n                update_mask = (k[:, None] <= j[None, :]) & mask_k[:, None] & mask_j[None, :]\n                \n                # Vectorized computation\n                product = a[:, None] * b\n                product = tl.where(update_mask, product, 0.0)\n                partial = tl.sum(product, axis=0)\n                acc += partial\n                \n            tl.store(C_ptr + row * stride_cm + j * stride_cn, acc, mask=mask_j)\n\nN = 4096\n\ndef get_inputs():\n    A = torch.triu(torch.randn(N, N, device='cuda'))\n    B = torch.triu(torch.randn(N, N, device='cuda'))\n    return [A, B]\n\ndef get_init_inputs():\n    return []\n# =================== EVOLVE-BLOCK-END ===================", "language": "python", "parent_id": "3e38ffd3-1957-4df3-a083-5649fcb1d793", "generation": 3, "timestamp": 1754638685.7032058, "iteration_found": 20, "metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": false, "score": 20, "speed_up": 0.002, "runtime_ms": 19.5, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:7", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.0355, "speed_up": 0.002, "custom_timing": 19.5}}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": false, "score": 20, "speed_up": 0.002, "runtime_ms": 22.7, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:6", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.0355, "speed_up": 0.002, "custom_timing": 22.7}}, "island": 1}, "artifacts_json": null, "artifact_dir": null}