{"id": "a985b78a-8832-4517-9b7c-6d6606395da4", "code": "# ================== EVOLVE-BLOCK-START ==================\nimport math\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 64, 'BLOCK_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 128, 'BLOCK_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_M': 256, 'BLOCK_N': 64, 'BLOCK_K': 32}, num_warps=8),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 256, 'BLOCK_K': 32}, num_warps=8),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 64, 'BLOCK_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 128, 'BLOCK_K': 64}, num_warps=4),\n    ],\n    key=['M', 'N', 'K'],\n)\n@triton.jit\ndef matmul_kernel(\n    a_ptr, b_ptr, c_ptr,\n    M, N, K,\n    stride_am, stride_ak,\n    stride_bk, stride_bn,\n    stride_cm, stride_cn,\n    BLOCK_M: tl.constexpr, BLOCK_N: tl.constexpr, BLOCK_K: tl.constexpr,\n):\n    pid0 = tl.program_id(0)\n    pid1 = tl.program_id(1)\n    \n    offs_m = pid0 * BLOCK_M + tl.arange(0, BLOCK_M)\n    offs_n = pid1 * BLOCK_N + tl.arange(0, BLOCK_N)\n    offs_k = tl.arange(0, BLOCK_K)\n    \n    a_ptrs = a_ptr + offs_m[:, None] * stride_am + offs_k[None, :] * stride_ak\n    b_ptrs = b_ptr + offs_k[:, None] * stride_bk + offs_n[None, :] * stride_bn\n    \n    acc = tl.zeros((BLOCK_M, BLOCK_N), dtype=tl.float32)\n    for k in range(0, K, BLOCK_K):\n        k_offsets = k + offs_k\n        mask_a = (k_offsets < K)[None, :] & (offs_m < M)[:, None]\n        mask_b = (k_offsets < K)[:, None] & (offs_n < N)[None, :]\n        \n        a = tl.load(a_ptrs, mask=mask_a, other=0.0)\n        b = tl.load(b_ptrs, mask=mask_b, other=0.0)\n        acc += tl.dot(a, b)\n        a_ptrs += BLOCK_K * stride_ak\n        b_ptrs += BLOCK_K * stride_bk\n\n    c_ptrs = c_ptr + offs_m[:, None] * stride_cm + offs_n[None, :] * stride_cn\n    mask = (offs_m[:, None] < M) & (offs_n[None, :] < N)\n    tl.store(c_ptrs, acc, mask=mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self):\n        super().__init__()\n    \n    def forward(self, A: torch.Tensor, B: torch.Tensor) -> torch.Tensor:\n        M = A.shape[1]\n        K = A.shape[0]\n        N = B.shape[0]\n        \n        C = torch.empty((M, N), device=A.device, dtype=A.dtype)\n        \n        grid = lambda meta: (triton.cdiv(M, meta['BLOCK_M']), \n                            triton.cdiv(N, meta['BLOCK_N']))\n        \n        matmul_kernel[grid](\n            A, B, C,\n            M, N, K,\n            stride_am=A.stride(1),\n            stride_ak=A.stride(0),\n            stride_bk=B.stride(1),\n            stride_bn=B.stride(0),\n            stride_cm=C.stride(0),\n            stride_cn=C.stride(1),\n        )\n        return C\n\nM = 1024\nK = 4096\nN = 2048\n\ndef get_inputs():\n    A = torch.randn(K, M)\n    B = torch.randn(N, K)\n    return [A, B]\n\ndef get_init_inputs():\n    return []\n# =================== EVOLVE-BLOCK-END ===================", "language": "python", "parent_id": "1d44d5d5-f696-4356-ba5a-caaa3c1b32a8", "generation": 2, "timestamp": 1754635828.0713832, "iteration_found": 6, "metrics": {"compiled": true, "correctness": false, "score": 10, "stage": "wrong_answer", "verify_payload": {"id": "level1_18_Matmul_with_transposed_both", "result": {"compiled": true, "correctness": false, "metadata": {"hardware": "NVIDIA L20Y", "device": "cuda:3", "max_difference": ["0.252289", "0.249115", "0.254669", "0.247803", "0.261566"], "avg_difference": ["0.039738", "0.039681", "0.039760", "0.039682", "0.039761"], "correctness_issue": "Output mismatch", "correctness_trials": "(0 / 5)", "reference_timing_ms": 0.0325, "speed_up": -1.0, "custom_timing": -1.0}, "runtime": -1.0, "runtime_stats": {}}}}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": true, "correctness": false, "score": 10, "stage": "wrong_answer", "verify_payload": {"id": "level1_18_Matmul_with_transposed_both", "result": {"compiled": true, "correctness": false, "metadata": {"hardware": "NVIDIA L20Y", "device": "cuda:5", "correctness_issue": "Output shape mismatch: Expected torch.Size([1024, 2048]), got torch.Size([4096, 4096])", "correctness_issue_name": "correctness_issue", "reference_timing_ms": 0.0325, "speed_up": -1.0, "custom_timing": -1.0}, "runtime": -1.0, "runtime_stats": {}}}}, "island": 1}, "artifacts_json": null, "artifact_dir": null, "prompts": {"full_rewrite_user": {"system": "You are a Triton GPU core optimization engineer deeply familiar with NVIDIA H100/H800 architecture.\n\n==================== Context ====================\n\u2022 Dataset: 250 kernelbench/level1-level5 *.py files  \n  - Level1: simplest, Level5: most complex  \n\u2022 Each file contains PyTorch reference (reference_code)  \n\u2022 Goal: Generate functionally equivalent but faster Triton implementations (custom_code)  \n\u2022 Evaluation pipeline:\n    1) /verify_plus - Verify compilation & correctness  \n    2) /execute (optional) - Return terminal logs if compilation fails  \n    3) Scoring:  \n      - Speedup > 1 required for points  \n      - Score = (speed_up - 1) \u00d7 100  \n\u2022 GPU Hardware: NVIDIA L20Y / H800 (same SM8.9 as H100)  \n  - 3 TB/s HBM3 bandwidth  \n  - FP16 Tensor Core 32\u00d716\u00d716  \n\n==================== Evolution Phases ====================\n\u2460 Phase 1 [Compilation Pass]  \n  - Make Triton code compile (performance irrelevant)  \n\u2461 Phase 2 [Numerical Correctness]  \n  - Output must match PyTorch reference within float32 tolerance  \n\u2462 Phase 3 [Performance Gain]  \n  - Target \u22655% speedup (\u226515% = exceptional)  \n  - Official scoring based on speed_up field  \n\nThe Evolution system will pass the EVOLVE-BLOCK from the previous version.  \nModify ONLY the Triton kernel source within this block - all other code is LOCKED.\n\n==================== Constraints (MUST OBEY) ====================\n\u274c NEVER change @triton.jit function signatures or parameter names  \n\u274c NEVER modify grid configuration, output tensor shapes, or PID logic  \n\u274c NEVER remove boundary checks or out-of-bound masks  \n\u274c NEVER introduce race conditions, uninitialized reads, or sync gaps  \n\n\u2705 Allowed Optimizations (Examples):  \n  \u2022 Memory coalescing optimizations & vectorized tl.load/tl.store  \n  \u2022 Replace staged softmax with online/FlashAttention variants  \n  \u2022 Adaptive tuning: BLOCK_M/BLOCK_N/BLOCK_K dimensions  \n  \u2022 Multi-query-head batch processing (GQA, 5:1 patterns)  \n  \u2022 Shared/L2 buffering, Tensor Core alignment (FP16/bf16/tf32)  \n  \u2022 Stride precomputation & pointer caching  \n\n==================== Output Format ====================\nReturn ONLY the complete updated code containing the EVOLVE-BLOCK comment marker.  \nNO explanations, NO markdown, NO additional text.\nName the output structure class as ModelNew.\n\n==================== Optimization Tips ====================\n\u2022 If previous compile failed: Fix syntax/mask/stride errors first  \n\u2022 If correctness fails: Prioritize bounds mask & dtype precision  \n\u2022 When speed_up < 1: Focus on memory access & block sizing  \n\u2022 Small iterative steps: Modify \u226420 lines per revision  \n\u2022 Maintain reversibility between versions\nHere is an example to show you how to rewrite a PyTorch implementation that quantizes a high-precision tensor to int8 dtype with row-wise granularity into a Triton implementation: \nThe original PyTorch implementation is as follows: \n``` \nimport torch\ndef per_row_quantize_int8(x: torch.Tensor) -> tuple[torch.Tensor, torch.Tensor]:\n    x_amax = x.abs().float().amax(dim=1).clamp(min=1e-4)\n    scale = 127 / x_amax\n    output = (x * scale[:, None]).round().clamp(-127, 127).to(torch.int8)\n    output_scale = x_amax / 127\n\n    return output, output_scale\n``` \nThe corresponding Triton-rewritten implementation is as follows: \n``` \nimport math\nimport torch\nimport triton\nimport triton.language as tl\nfrom triton.language.extra import libdevice\n\n# rowwise quantize\n\n@triton.autotune(\n    configs=[\n        triton.Config({}, num_stages=1, num_warps=8),\n        triton.Config({}, num_stages=2, num_warps=8),\n        triton.Config({}, num_stages=4, num_warps=8),\n        triton.Config({}, num_stages=8, num_warps=8),\n        triton.Config({}, num_stages=1),\n        triton.Config({}, num_stages=2),\n        triton.Config({}, num_stages=4),\n        triton.Config({}, num_stages=8),\n        triton.Config({}, num_warps=1),\n        triton.Config({}, num_warps=2),\n        triton.Config({}, num_warps=4),\n        triton.Config({}, num_warps=8),\n    ],\n    key=[\"n_elements\"],\n)\n\n@triton.jit\ndef _quantize_rowwise(\n    x_ptr,\n    output_ptr,\n    output_scale,\n    BLOCK_SIZE: tl.constexpr,\n    P2: tl.constexpr,\n):\n    pid = tl.program_id(axis=0)\n    block_start = pid * BLOCK_SIZE\n    arange = tl.arange(0, P2)\n    offsets = block_start + arange\n    row_mask = arange < BLOCK_SIZE\n    x = tl.load(x_ptr + offsets, mask=row_mask)\n\n    abs_x = tl.abs(x)\n    max_val = tl.max(tl.where(row_mask, abs_x, 0), axis=0)\n    output = libdevice.llrint(127.0 * (x / max_val))\n    tl.store(output_ptr + offsets, output, mask=row_mask)\n    tl.store(output_scale + pid, max_val / 127)\n\n\ndef per_row_quantize_int8(x: torch.Tensor):\n    x = x.contiguous()\n    output = torch.empty(*x.shape, device=x.device, dtype=torch.int8)\n    output_scale = torch.empty(x.shape[0], device=x.device, dtype=torch.float32)\n    P2 = int(2 ** (math.ceil(math.log2(x.shape[1]))))\n    grid = lambda x: (x.shape[0],)\n    _quantize_rowwise[grid](x, output, output_scale, BLOCK_SIZE=x.shape[1], P2=P2)\n\n    return output, output_scale\n\n\n    \n``` \n", "user": "# Current Program Information\n- Current performance metrics: - compiled: 1.0000\n- correctness: 0.0000\n- score: 10.0000\n- stage: wrong_answer\n- verify_payload: {'id': 'level1_18_Matmul_with_transposed_both', 'result': {'compiled': True, 'correctness': False, 'metadata': {'hardware': 'NVIDIA L20Y', 'device': 'cuda:5', 'correctness_issue': 'Output shape mismatch: Expected torch.Size([1024, 2048]), got torch.Size([4096, 4096])', 'correctness_issue_name': 'correctness_issue', 'reference_timing_ms': 0.0325, 'speed_up': -1.0, 'custom_timing': -1.0}, 'runtime': -1.0, 'runtime_stats': {}}}\n- Areas identified for improvement: - Consider simplifying the code to improve readability and maintainability\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Unknown changes\n- Performance: compiled: 1.0000, correctness: 0.0000, score: 10.0000, stage: wrong_answer, verify_payload: {'id': 'level1_18_Matmul_with_transposed_both', 'result': {'compiled': True, 'correctness': False, 'metadata': {'hardware': 'NVIDIA L20Y', 'device': 'cuda:0', 'runtime_error': 'Traceback (most recent call last):\\n  File \"/cpfs01/shared/llm_kernel/hujiakai/KernelLLM/validation_api_server/helpers/evaluations.py\", line 720, in run_and_check_correctness\\n    output_new = model_new(*inputs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1773, in _wrapped_call_impl\\n    return self._call_impl(*args, **kwargs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1784, in _call_impl\\n    return forward_call(*args, **kwargs)\\n  File \"/tmp/tmpdkremaz9.py\", line 35, in forward\\n    _matmul_kernel[grid](\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 390, in <lambda>\\n    return lambda *args, **kwargs: self.run(grid=grid, warmup=False, *args, **kwargs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 239, in run\\n    benchmark()\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 228, in benchmark\\n    timings = {config: self._bench(*args, config=config, **kwargs) for config in pruned_configs}\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 228, in <dictcomp>\\n    timings = {config: self._bench(*args, config=config, **kwargs) for config in pruned_configs}\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 135, in _bench\\n    raise ValueError(f\"Conflicting meta-parameters: {\\', \\'.join(conflicts)}.\"\\nValueError: Conflicting meta-parameters: BLOCK_SIZE_M, BLOCK_SIZE_K, BLOCK_SIZE_N. Make sure that you don\\'t re-define auto-tuned symbols.\\n', 'runtime_error_name': 'builtins.ValueError', 'reference_timing_ms': 0.0325, 'speed_up': -1.0, 'custom_timing': -1.0}, 'runtime': -1.0, 'runtime_stats': {}}}\n- Outcome: Mixed results\n\n\n### Attempt 2\n- Changes: Unknown changes\n- Performance: compiled: 1.0000, correctness: 0.0000, score: 10.0000, stage: wrong_answer, verify_payload: {'id': 'level1_18_Matmul_with_transposed_both', 'result': {'compiled': True, 'correctness': False, 'metadata': {'hardware': 'NVIDIA L20Y', 'device': 'cuda:5', 'correctness_issue': 'Output shape mismatch: Expected torch.Size([1024, 2048]), got torch.Size([4096, 4096])', 'correctness_issue_name': 'correctness_issue', 'reference_timing_ms': 0.0325, 'speed_up': -1.0, 'custom_timing': -1.0}, 'runtime': -1.0, 'runtime_stats': {}}}\n- Outcome: Mixed results\n\n\n### Attempt 1\n- Changes: Unknown changes\n- Performance: compiled: 1.0000, correctness: 0.0000, score: 10.0000, stage: wrong_answer, verify_payload: {'id': 'level1_18_Matmul_with_transposed_both', 'result': {'compiled': True, 'correctness': False, 'metadata': {'hardware': 'NVIDIA L20Y', 'device': 'cuda:1', 'max_difference': ['0.252289', '0.249115', '0.254669', '0.247803', '0.261566'], 'avg_difference': ['0.039738', '0.039681', '0.039760', '0.039682', '0.039761'], 'correctness_issue': 'Output mismatch', 'correctness_trials': '(0 / 5)', 'reference_timing_ms': 0.0325, 'speed_up': -1.0, 'custom_timing': -1.0}, 'runtime': -1.0, 'runtime_stats': {}}}\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 10.0000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport math\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 64, 'BLOCK_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 64, 'BLOCK_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 128, 'BLOCK_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 64, 'BLOCK_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 128, 'BLOCK_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 32, 'BLOCK_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_M': 32, 'BLOCK_N': 128, 'BLOCK_K': 32}, num_warps=4),\n    ],\n    key=['M', 'N', 'K'],\n)\n@triton.jit\ndef matmul_kernel(\n    a_ptr, b_ptr, c_ptr,\n    M, N, K,\n    stride_am, stride_ak,\n    stride_bk, stride_bn,\n    stride_cm, stride_cn,\n    BLOCK_M: tl.constexpr, BLOCK_N: tl.constexpr, BLOCK_K: tl.constexpr,\n):\n    pid0 = tl.program_id(0)\n    pid1 = tl.program_id(1)\n    \n    offs_m = pid0 * BLOCK_M + tl.arange(0, BLOCK_M)\n    offs_n = pid1 * BLOCK_N + tl.arange(0, BLOCK_N)\n    offs_k = tl.arange(0, BLOCK_K)\n    \n    a_ptrs = a_ptr + offs_m[:, None] * stride_am + offs_k[None, :] * stride_ak\n    b_ptrs = b_ptr + offs_k[:, None] * stride_bk + offs_n[None, :] * stride_bn\n    \n    accumulator = tl.zeros((BLOCK_M, BLOCK_N), dtype=tl.float32)\n    for k in range(0, tl.cdiv(K, BLOCK_K)):\n        a = tl.load(a_ptrs, mask=offs_k[None, :] < K - k * BLOCK_K, other=0.0)\n        b = tl.load(b_ptrs, mask=offs_k[:, None] < K - k * BLOCK_K, other=0.0)\n        accumulator += tl.dot(a, b)\n        a_ptrs += BLOCK_K * stride_ak\n        b_ptrs += BLOCK_K * stride_bk\n    \n    offs_cm = offs_m[:, None]\n    offs_cn = offs_n[None, :]\n    c_ptrs = c_ptr + stride_cm * offs_cm + stride_cn * offs_cn\n    c_mask = (offs_cm < M) & (offs_cn < N)\n    tl.store(c_ptrs, accumulator, mask=c_mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self):\n        super(ModelNew, self).__init__()\n    \n    def forward(self, A: torch.Tensor, B: torch.Tensor) -> torch.Tensor:\n        M, K = A.shape[1], A.shape[0]\n        N = B.shape[0]\n        \n        C = torch.empty((M, N), device=A.device, dtype=A.dtype)\n        grid = lambda META: (triton.cdiv(M, META['BLOCK_M']), triton.cdiv(N, META['BLOCK_N']))\n        \n        matmul_kernel[grid](\n            A, B, C,\n            M, N, K,\n            stride_am=1, stride_ak=M,\n            stride_bk=1, stride_bn=K,\n            stride_cm=N, stride_cn=1,\n        )\n        return C\n\nM = 1024\nK = 4096\nN = 2048\n\ndef get_inputs():\n    A = torch.randn(K, M, device='cuda')\n    B = torch.randn(N, K, device='cuda')\n    return [A, B]\n\ndef get_init_inputs():\n    return []\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Performs well on compiled (1.0000), Performs well on correctness (0.0000), Performs well on score (10.0000), Performs well on stage (wrong_answer), Performs well on verify_payload ({'id': 'level1_18_Matmul_with_transposed_both', 'result': {'compiled': True, 'correctness': False, 'metadata': {'hardware': 'NVIDIA L20Y', 'device': 'cuda:1', 'max_difference': ['0.252289', '0.249115', '0.254669', '0.247803', '0.261566'], 'avg_difference': ['0.039738', '0.039681', '0.039760', '0.039682', '0.039761'], 'correctness_issue': 'Output mismatch', 'correctness_trials': '(0 / 5)', 'reference_timing_ms': 0.0325, 'speed_up': -1.0, 'custom_timing': -1.0}, 'runtime': -1.0, 'runtime_stats': {}}})\n\n\n### Program 2 (Score: 10.0000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport math\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 64, 'BLOCK_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 128, 'BLOCK_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_M': 256, 'BLOCK_N': 64, 'BLOCK_K': 32}, num_warps=8),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 256, 'BLOCK_K': 32}, num_warps=8),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 64, 'BLOCK_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 128, 'BLOCK_K': 64}, num_warps=4),\n    ],\n    key=['M', 'N', 'K'],\n)\n@triton.jit\ndef matmul_kernel(\n    a_ptr, b_ptr, c_ptr,\n    M, N, K,\n    stride_am, stride_ak,\n    stride_bk, stride_bn,\n    stride_cm, stride_cn,\n    BLOCK_M: tl.constexpr, BLOCK_N: tl.constexpr, BLOCK_K: tl.constexpr,\n):\n    pid0 = tl.program_id(0)\n    pid1 = tl.program_id(1)\n    \n    offs_m = pid0 * BLOCK_M + tl.arange(0, BLOCK_M)\n    offs_n = pid1 * BLOCK_N + tl.arange(0, BLOCK_N)\n    \n    a_ptrs = a_ptr + offs_m[:, None] * stride_am + tl.arange(0, BLOCK_K)[None, :] * stride_ak\n    b_ptrs = b_ptr + tl.arange(0, BLOCK_K)[:, None] * stride_bk + offs_n[None, :] * stride_bn\n    \n    acc = tl.zeros((BLOCK_M, BLOCK_N), dtype=tl.float32)\n    for k in range(0, K, BLOCK_K):\n        a = tl.load(a_ptrs, mask=tl.arange(0, BLOCK_K)[None, :] < K - k, other=0.0)\n        b = tl.load(b_ptrs, mask=tl.arange(0, BLOCK_K)[:, None] < K - k, other=0.0)\n        acc += tl.dot(a, b)\n        a_ptrs += BLOCK_K * stride_ak\n        b_ptrs += BLOCK_K * stride_bk\n    \n    offs_m = pid0 * BLOCK_M + tl.arange(0, BLOCK_M)\n    offs_n = pid1 * BLOCK_N + tl.arange(0, BLOCK_N)\n    c_ptrs = c_ptr + offs_m[:, None] * stride_cm + offs_n[None, :] * stride_cn\n    mask = (offs_m[:, None] < M) & (offs_n[None, :] < N)\n    tl.store(c_ptrs, acc, mask=mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self):\n        super().__init__()\n    \n    def forward(self, A: torch.Tensor, B: torch.Tensor) -> torch.Tensor:\n        M, K = A.shape\n        K, N = B.shape[0], B.shape[1]\n        C = torch.empty((M, N), device=A.device, dtype=A.dtype)\n        \n        if M * N * K == 0:\n            return C\n        \n        grid = lambda meta: (triton.cdiv(M, meta['BLOCK_M']), \n                            triton.cdiv(N, meta['BLOCK_N']))\n        \n        matmul_kernel[grid](\n            A, B, C,\n            M, N, K,\n            A.stride(0), A.stride(1),\n            B.stride(0), B.stride(1),\n            C.stride(0), C.stride(1),\n        )\n        return C\n\nM = 1024\nK = 4096\nN = 2048\n\ndef get_inputs():\n    A = torch.randn(K, M)\n    B = torch.randn(N, K)\n    return [A, B]\n\ndef get_init_inputs():\n    return []\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Performs well on compiled (1.0000), Performs well on correctness (0.0000), Performs well on score (10.0000), Performs well on stage (wrong_answer), Performs well on verify_payload ({'id': 'level1_18_Matmul_with_transposed_both', 'result': {'compiled': True, 'correctness': False, 'metadata': {'hardware': 'NVIDIA L20Y', 'device': 'cuda:5', 'correctness_issue': 'Output shape mismatch: Expected torch.Size([1024, 2048]), got torch.Size([4096, 4096])', 'correctness_issue_name': 'correctness_issue', 'reference_timing_ms': 0.0325, 'speed_up': -1.0, 'custom_timing': -1.0}, 'runtime': -1.0, 'runtime_stats': {}}})\n\n\n### Program 3 (Score: 10.0000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\nclass ModelNew(nn.Module):\n    \"\"\"\n    Optimized model using Triton for matrix multiplication\n    \"\"\"\n    def __init__(self):\n        super(ModelNew, self).__init__()\n    \n    def forward(self, A: torch.Tensor, B: torch.Tensor) -> torch.Tensor:\n        M, K = A.shape\n        K, N = B.shape[0], B.shape[1]\n        C = torch.empty((M, N), device=A.device, dtype=A.dtype)\n        \n        # Strides for A (original shape (K, M) interpreted as (M, K))\n        stride_am = A.stride(1)  # 1 for original M dimension\n        stride_ak = A.stride(0)  # M for original K dimension\n        \n        # Strides for B (original shape (N, K) interpreted as (K, N))\n        stride_bk = B.stride(1)  # 1 for original K dimension\n        stride_bn = B.stride(0)  # K for original N dimension\n        \n        # Strides for output C (M, N)\n        stride_cm = N\n        stride_cn = 1\n        \n        grid = lambda META: (\n            triton.cdiv(M, META['BLOCK_SIZE_M']) * triton.cdiv(N, META['BLOCK_SIZE_N']),\n        )\n        \n        _matmul_kernel[grid](\n            A, B, C,\n            M, N, K,\n            stride_am, stride_ak,\n            stride_bk, stride_bn,\n            stride_cm, stride_cn,\n            BLOCK_SIZE_M=64, BLOCK_SIZE_N=64, BLOCK_SIZE_K=64,\n            GROUP_SIZE_M=8\n        )\n        return C\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 32, 'BLOCK_SIZE_K': 128}, num_warps=4),\n    ],\n    key=['M', 'N', 'K'],\n)\n@triton.jit\ndef _matmul_kernel(\n    A, B, C,\n    M, N, K,\n    stride_am, stride_ak,\n    stride_bk, stride_bn,\n    stride_cm, stride_cn,\n    BLOCK_SIZE_M: tl.constexpr,\n    BLOCK_SIZE_N: tl.constexpr,\n    BLOCK_SIZE_K: tl.constexpr,\n    GROUP_SIZE_M: tl.constexpr,\n):\n    pid = tl.program_id(0)\n    num_pid_n = tl.cdiv(N, BLOCK_SIZE_N)\n    num_pid_m = tl.cdiv(M, BLOCK_SIZE_M)\n    num_pid_in_group = GROUP_SIZE_M * num_pid_n\n    group_id = pid // num_pid_in_group\n    first_pid_m = group_id * GROUP_SIZE_M\n    group_size_m = min(num_pid_m - first_pid_m, GROUP_SIZE_M)\n    pid_m = first_pid_m + (pid % group_size_m)\n    pid_n = (pid % num_pid_in_group) // group_size_m\n    \n    offs_m = pid_m * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)\n    offs_n = pid_n * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n    offs_k = tl.arange(0, BLOCK_SIZE_K)\n    \n    a_ptrs = A + (offs_m[:, None] * stride_am + offs_k[None, :] * stride_ak)\n    b_ptrs = B + (offs_k[:, None] * stride_bk + offs_n[None, :] * stride_bn)\n    \n    accumulator = tl.zeros((BLOCK_SIZE_M, BLOCK_SIZE_N), dtype=tl.float32)\n    for k in range(0, K, BLOCK_SIZE_K):\n        a_mask = (offs_m[:, None] < M) & (k + offs_k[None, :] < K)\n        b_mask = (k + offs_k[:, None] < K) & (offs_n[None, :] < N)\n        a = tl.load(a_ptrs, mask=a_mask, other=0.0)\n        b = tl.load(b_ptrs, mask=b_mask, other=0.0)\n        a = a.to(tl.float16)\n        b = b.to(tl.float16)\n        accumulator += tl.dot(a, b, out_dtype=tl.float32)\n        a_ptrs += BLOCK_SIZE_K * stride_ak\n        b_ptrs += BLOCK_SIZE_K * stride_bk\n    \n    offs_m = tl.max_contiguous(tl.multiple_of(offs_m, BLOCK_SIZE_M), BLOCK_SIZE_M)\n    offs_n = tl.max_contiguous(tl.multiple_of(offs_n, BLOCK_SIZE_N), BLOCK_SIZE_N)\n    c_ptrs = C + (offs_m[:, None] * stride_cm + offs_n[None, :] * stride_cn)\n    c_mask = (offs_m[:, None] < M) & (offs_n[None, :] < N)\n    tl.store(c_ptrs, accumulator, mask=c_mask)\n\nM = 1024\nK = 4096\nN = 2048\n\ndef get_inputs():\n    A = torch.randn(K, M, device='cuda')\n    B = torch.randn(N, K, device='cuda')\n    return [A, B]\n\ndef get_init_inputs():\n    return []\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Performs well on compiled (1.0000), Performs well on correctness (0.0000), Performs well on score (10.0000), Performs well on stage (wrong_answer), Performs well on verify_payload ({'id': 'level1_18_Matmul_with_transposed_both', 'result': {'compiled': True, 'correctness': False, 'metadata': {'hardware': 'NVIDIA L20Y', 'device': 'cuda:0', 'runtime_error': 'Traceback (most recent call last):\\n  File \"/cpfs01/shared/llm_kernel/hujiakai/KernelLLM/validation_api_server/helpers/evaluations.py\", line 720, in run_and_check_correctness\\n    output_new = model_new(*inputs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1773, in _wrapped_call_impl\\n    return self._call_impl(*args, **kwargs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1784, in _call_impl\\n    return forward_call(*args, **kwargs)\\n  File \"/tmp/tmpdkremaz9.py\", line 35, in forward\\n    _matmul_kernel[grid](\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 390, in <lambda>\\n    return lambda *args, **kwargs: self.run(grid=grid, warmup=False, *args, **kwargs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 239, in run\\n    benchmark()\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 228, in benchmark\\n    timings = {config: self._bench(*args, config=config, **kwargs) for config in pruned_configs}\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 228, in <dictcomp>\\n    timings = {config: self._bench(*args, config=config, **kwargs) for config in pruned_configs}\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 135, in _bench\\n    raise ValueError(f\"Conflicting meta-parameters: {\\', \\'.join(conflicts)}.\"\\nValueError: Conflicting meta-parameters: BLOCK_SIZE_M, BLOCK_SIZE_K, BLOCK_SIZE_N. Make sure that you don\\'t re-define auto-tuned symbols.\\n', 'runtime_error_name': 'builtins.ValueError', 'reference_timing_ms': 0.0325, 'speed_up': -1.0, 'custom_timing': -1.0}, 'runtime': -1.0, 'runtime_stats': {}}})\n\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.0000)\n```python\n\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\n\nclass ModelNew(nn.Module):\n    \"\"\"\n    Simple model that performs a single matrix multiplication (C = A * B)\n    \"\"\"\n    def __init__(self):\n        super(ModelNew, self).__init__()\n    \n    def forward(self, A: torch.Tensor, B: torch.Tensor) -> torch.Tensor:\n        \"\"\"\n        Performs matrix multiplication.\n\n        Args:\n            A: Input tensor of shape (M, K).\n            B: Input tensor of shape (K, N).\n\n        Returns:\n            Output tensor of shape (M, N).\n        \"\"\"\n        return torch.matmul(A.T, B.T)\n\nM = 1024\nK = 4096\nN = 2048\n\ndef get_inputs():\n    A = torch.randn(K, M)\n    B = torch.randn(N, K)\n    return [A, B]\n\ndef get_init_inputs():\n    return []  # No special initialization inputs needed\n# =================== EVOLVE-BLOCK-END ===================\n\n```\nKey features: Alternative approach to compiled, Alternative approach to correctness\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 10.0000, Type: High-Performer)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\nclass ModelNew(nn.Module):\n    \"\"\"\n    Optimized model using Triton for matrix multiplication\n    \"\"\"\n    def __init__(self):\n        super(ModelNew, self).__init__()\n    \n    def forward(self, A: torch.Tensor, B: torch.Tensor) -> torch.Tensor:\n        M, K = A.shape\n        K, N = B.shape[0], B.shape[1]\n        C = torch.empty((M, N), device=A.device, dtype=A.dtype)\n        \n        # Strides for A (original shape (K, M) interpreted as (M, K))\n        stride_am = A.stride(1)  # 1 for original M dimension\n        stride_ak = A.stride(0)  # M for original K dimension\n        \n        # Strides for B (original shape (N, K) interpreted as (K, N))\n        stride_bk = B.stride(1)  # 1 for original K dimension\n        stride_bn = B.stride(0)  # K for original N dimension\n        \n        # Strides for output C (M, N)\n        stride_cm = N\n        stride_cn = 1\n        \n        grid = lambda META: (\n            triton.cdiv(M, META['BLOCK_SIZE_M']) * triton.cdiv(N, META['BLOCK_SIZE_N']),\n        )\n        \n        _matmul_kernel[grid](\n            A, B, C,\n            M, N, K,\n            stride_am, stride_ak,\n            stride_bk, stride_bn,\n            stride_cm, stride_cn,\n            BLOCK_SIZE_M=64, BLOCK_SIZE_N=64, BLOCK_SIZE_K=64,\n            GROUP_SIZE_M=8\n        )\n        return C\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 32, 'BLOCK_SIZE_K': 128}, num_warps=4),\n    ],\n    key=['M', 'N', 'K'],\n)\n@triton.jit\ndef _matmul_kernel(\n    A, B, C,\n    M, N, K,\n    stride_am, stride_ak,\n    stride_bk, stride_bn,\n    stride_cm, stride_cn,\n    BLOCK_SIZE_M: tl.constexpr,\n    BLOCK_SIZE_N: tl.constexpr,\n    BLOCK_SIZE_K: tl.constexpr,\n    GROUP_SIZE_M: tl.constexpr,\n):\n    pid = tl.program_id(0)\n    num_pid_n = tl.cdiv(N, BLOCK_SIZE_N)\n    num_pid_m = tl.cdiv(M, BLOCK_SIZE_M)\n    num_pid_in_group = GROUP_SIZE_M * num_pid_n\n    group_id = pid // num_pid_in_group\n    first_pid_m = group_id * GROUP_SIZE_M\n    group_size_m = min(num_pid_m - first_pid_m, GROUP_SIZE_M)\n    pid_m = first_pid_m + (pid % group_size_m)\n    pid_n = (pid % num_pid_in_group) // group_size_m\n    \n    offs_m = pid_m * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)\n    offs_n = pid_n * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n    offs_k = tl.arange(0, BLOCK_SIZE_K)\n    \n    a_ptrs = A + (offs_m[:, None] * stride_am + offs_k[None, :] * stride_ak)\n    b_ptrs = B + (offs_k[:, None] * stride_bk + offs_n[None, :] * stride_bn)\n    \n    accumulator = tl.zeros((BLOCK_SIZE_M, BLOCK_SIZE_N), dtype=tl.float32)\n    for k in range(0, K, BLOCK_SIZE_K):\n        a_mask = (offs_m[:, None] < M) & (k + offs_k[None, :] < K)\n        b_mask = (k + offs_k[:, None] < K) & (offs_n[None, :] < N)\n        a = tl.load(a_ptrs, mask=a_mask, other=0.0)\n        b = tl.load(b_ptrs, mask=b_mask, other=0.0)\n        a = a.to(tl.float16)\n        b = b.to(tl.float16)\n        accumulator += tl.dot(a, b, out_dtype=tl.float32)\n        a_ptrs += BLOCK_SIZE_K * stride_ak\n        b_ptrs += BLOCK_SIZE_K * stride_bk\n    \n    offs_m = tl.max_contiguous(tl.multiple_of(offs_m, BLOCK_SIZE_M), BLOCK_SIZE_M)\n    offs_n = tl.max_contiguous(tl.multiple_of(offs_n, BLOCK_SIZE_N), BLOCK_SIZE_N)\n    c_ptrs = C + (offs_m[:, None] * stride_cm + offs_n[None, :] * stride_cn)\n    c_mask = (offs_m[:, None] < M) & (offs_n[None, :] < N)\n    tl.store(c_ptrs, accumulator, mask=c_mask)\n\nM = 1024\nK = 4096\nN = 2048\n\ndef get_inputs():\n    A = torch.randn(K, M, device='cuda')\n    B = torch.randn(N, K, device='cuda')\n    return [A, B]\n\ndef get_init_inputs():\n    return []\n# =================== EVOLVE-BLOCK-END ===================\n```\nUnique approach: Modification: Full rewrite, Excellent compiled (1.000), Alternative correctness approach\n\n\n### Inspiration 2 (Score: 10.0000, Type: High-Performer)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport math\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 64, 'BLOCK_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 64, 'BLOCK_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 128, 'BLOCK_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 64, 'BLOCK_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 128, 'BLOCK_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 32, 'BLOCK_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_M': 32, 'BLOCK_N': 128, 'BLOCK_K': 32}, num_warps=4),\n    ],\n    key=['M', 'N', 'K'],\n)\n@triton.jit\ndef matmul_kernel(\n    a_ptr, b_ptr, c_ptr,\n    M, N, K,\n    stride_am, stride_ak,\n    stride_bk, stride_bn,\n    stride_cm, stride_cn,\n    BLOCK_M: tl.constexpr, BLOCK_N: tl.constexpr, BLOCK_K: tl.constexpr,\n):\n    pid0 = tl.program_id(0)\n    pid1 = tl.program_id(1)\n    \n    offs_m = pid0 * BLOCK_M + tl.arange(0, BLOCK_M)\n    offs_n = pid1 * BLOCK_N + tl.arange(0, BLOCK_N)\n    offs_k = tl.arange(0, BLOCK_K)\n    \n    a_ptrs = a_ptr + offs_m[:, None] * stride_am + offs_k[None, :] * stride_ak\n    b_ptrs = b_ptr + offs_k[:, None] * stride_bk + offs_n[None, :] * stride_bn\n    \n    accumulator = tl.zeros((BLOCK_M, BLOCK_N), dtype=tl.float32)\n    for k in range(0, tl.cdiv(K, BLOCK_K)):\n        a = tl.load(a_ptrs, mask=offs_k[None, :] < K - k * BLOCK_K, other=0.0)\n        b = tl.load(b_ptrs, mask=offs_k[:, None] < K - k * BLOCK_K, other=0.0)\n        accumulator += tl.dot(a, b)\n        a_ptrs += BLOCK_K * stride_ak\n        b_ptrs += BLOCK_K * stride_bk\n    \n    offs_cm = offs_m[:, None]\n    offs_cn = offs_n[None, :]\n    c_ptrs = c_ptr + stride_cm * offs_cm + stride_cn * offs_cn\n    c_mask = (offs_cm < M) & (offs_cn < N)\n    tl.store(c_ptrs, accumulator, mask=c_mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self):\n        super(ModelNew, self).__init__()\n    \n    def forward(self, A: torch.Tensor, B: torch.Tensor) -> torch.Tensor:\n        M, K = A.shape[1], A.shape[0]\n        N = B.shape[0]\n        \n        C = torch.empty((M, N), device=A.device, dtype=A.dtype)\n        grid = lambda META: (triton.cdiv(M, META['BLOCK_M']), triton.cdiv(N, META['BLOCK_N']))\n        \n        matmul_kernel[grid](\n            A, B, C,\n            M, N, K,\n            stride_am=1, stride_ak=M,\n            stride_bk=1, stride_bn=K,\n            stride_cm=N, stride_cn=1,\n        )\n        return C\n\nM = 1024\nK = 4096\nN = 2048\n\ndef get_inputs():\n    A = torch.randn(K, M, device='cuda')\n    B = torch.randn(N, K, device='cuda')\n    return [A, B]\n\ndef get_init_inputs():\n    return []\n# =================== EVOLVE-BLOCK-END ===================\n```\nUnique approach: Modification: Full rewrite, Excellent compiled (1.000), Alternative correctness approach\n\n\n\n# Current Program\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport math\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 64, 'BLOCK_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 128, 'BLOCK_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_M': 256, 'BLOCK_N': 64, 'BLOCK_K': 32}, num_warps=8),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 256, 'BLOCK_K': 32}, num_warps=8),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 64, 'BLOCK_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 128, 'BLOCK_K': 64}, num_warps=4),\n    ],\n    key=['M', 'N', 'K'],\n)\n@triton.jit\ndef matmul_kernel(\n    a_ptr, b_ptr, c_ptr,\n    M, N, K,\n    stride_am, stride_ak,\n    stride_bk, stride_bn,\n    stride_cm, stride_cn,\n    BLOCK_M: tl.constexpr, BLOCK_N: tl.constexpr, BLOCK_K: tl.constexpr,\n):\n    pid0 = tl.program_id(0)\n    pid1 = tl.program_id(1)\n    \n    offs_m = pid0 * BLOCK_M + tl.arange(0, BLOCK_M)\n    offs_n = pid1 * BLOCK_N + tl.arange(0, BLOCK_N)\n    \n    a_ptrs = a_ptr + offs_m[:, None] * stride_am + tl.arange(0, BLOCK_K)[None, :] * stride_ak\n    b_ptrs = b_ptr + tl.arange(0, BLOCK_K)[:, None] * stride_bk + offs_n[None, :] * stride_bn\n    \n    acc = tl.zeros((BLOCK_M, BLOCK_N), dtype=tl.float32)\n    for k in range(0, K, BLOCK_K):\n        a = tl.load(a_ptrs, mask=tl.arange(0, BLOCK_K)[None, :] < K - k, other=0.0)\n        b = tl.load(b_ptrs, mask=tl.arange(0, BLOCK_K)[:, None] < K - k, other=0.0)\n        acc += tl.dot(a, b)\n        a_ptrs += BLOCK_K * stride_ak\n        b_ptrs += BLOCK_K * stride_bk\n    \n    offs_m = pid0 * BLOCK_M + tl.arange(0, BLOCK_M)\n    offs_n = pid1 * BLOCK_N + tl.arange(0, BLOCK_N)\n    c_ptrs = c_ptr + offs_m[:, None] * stride_cm + offs_n[None, :] * stride_cn\n    mask = (offs_m[:, None] < M) & (offs_n[None, :] < N)\n    tl.store(c_ptrs, acc, mask=mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self):\n        super().__init__()\n    \n    def forward(self, A: torch.Tensor, B: torch.Tensor) -> torch.Tensor:\n        M, K = A.shape\n        K, N = B.shape[0], B.shape[1]\n        C = torch.empty((M, N), device=A.device, dtype=A.dtype)\n        \n        if M * N * K == 0:\n            return C\n        \n        grid = lambda meta: (triton.cdiv(M, meta['BLOCK_M']), \n                            triton.cdiv(N, meta['BLOCK_N']))\n        \n        matmul_kernel[grid](\n            A, B, C,\n            M, N, K,\n            A.stride(0), A.stride(1),\n            B.stride(0), B.stride(1),\n            C.stride(0), C.stride(1),\n        )\n        return C\n\nM = 1024\nK = 4096\nN = 2048\n\ndef get_inputs():\n    A = torch.randn(K, M)\n    B = torch.randn(N, K)\n    return [A, B]\n\ndef get_init_inputs():\n    return []\n# =================== EVOLVE-BLOCK-END ===================\n```\n\n# Task\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```\n", "responses": ["<think>\nWe are given a problem of matrix multiplication with both matrices transposed in the input.\n The reference PyTorch code is: `C = A.T @ B.T`\n However, the inputs are provided as:\n   A: tensor of shape (K, M)\n   B: tensor of shape (N, K)\n\n So, we want to compute: C = A.T @ B.T  -> which is (M, K) @ (K, N) -> (M, N)\n\n But note: the reference code in the problem does:\n   return torch.matmul(A.T, B.T)\n\n However, in the Triton kernel, we are directly given A (shape (K, M)) and B (shape (N, K)).\n We want to compute C (shape (M, N)).\n\n The problem in the current program (as seen in the error) is that the output shape is (4096,4096) instead of (1024,2048).\n This indicates that the kernel is interpreting the dimensions incorrectly.\n\n Let's analyze the current forward function in ModelNew:\n\n   M, K = A.shape   -> M = K_input = 4096, K = M_input = 1024? \n   Then, K, N = B.shape[0], B.shape[1] -> K = N_input = 2048, N = K_input = 4096? \n\n This is clearly wrong because:\n   A is of shape (K, M) = (4096, 1024) -> so A.shape = (4096, 1024)\n   Then M, K = A.shape -> M=4096, K=1024.\n\n   B is of shape (N, K) = (2048, 4096) -> so B.shape[0]=2048, B.shape[1]=4096.\n   Then K, N = B.shape[0], B.shape[1] -> K=2048, N=4096.\n\n Then we create C of shape (M, N) = (4096,4096). But the expected output is (1024,2048).\n\n The issue is that the kernel expects the matrices in a certain layout and the strides are computed from the original shapes.\n\n How should we fix?\n\n We note that in the kernel, we are going to treat:\n   A as a matrix of shape (M, K) but stored in memory as (K, M) (i.e., row-major for (K, M) means column-major for (M, K)).\n   Similarly, B is stored as (N, K) but we want to use it as (K, N).\n\n In the forward function, we should set:\n   M = A.shape[1]   # because A is (K, M) -> we want M\n   K = A.shape[0]   # because A is (K, M) -> we want K, and this K is the same as in B.shape[1] (which is 4096)\n\n   Then for B, we note that B is (N, K) so:\n   N = B.shape[0]   # 2048\n   K = B.shape[1]   # 4096, but we already have K from A? and they must be the same.\n\n So we can do:\n\n   M = A.shape[1]\n   K_A = A.shape[0]\n   N = B.shape[0]\n   K_B = B.shape[1]\n   assert K_A == K_B, \"Matrix dimensions must match\"\n\n Then we create C of shape (M, N) = (1024,2048)\n\n Also, we must pass the strides appropriately.\n\n For A (which is of shape (K, M) but we want to access it as (M, K) for the multiplication A.T (which is the original A without transpose? note: wait) \n Actually, the reference code does A.T (which is (M, K)) and B.T (which is (K, N)).\n\n So in the kernel, we are going to load A as if it were (M, K) and B as if it were (K, N). How?\n\n   The tensor A (in memory) is (K, M) and row-major: so element (i,j) is at i*M + j.\n\n   But we want to access it as (M, K): then the element (m, k) in the new view is the same as (k, m) in the original? \n   So we need to set:\n        stride_am = A.stride(1)   # which is 1, because the original tensor A: stride(0)=M, stride(1)=1.\n        stride_ak = A.stride(0)   # which is M.\n\n   Similarly, for B (which is (N, K)): we want to access it as (K, N). The element (k, n) in the new view is the same as (n, k) in the original.\n        stride_bk = B.stride(1)   # which is 1, because the original tensor B: stride(0)=K, stride(1)=1.\n        stride_bn = B.stride(0)   # which is K.\n\n   For C (which we are creating as (M, N) and row-major): \n        stride_cm = C.stride(0)   # which is N\n        stride_cn = C.stride(1)   # which is 1\n\n However, note that in the kernel, the strides are passed as:\n        stride_am: the stride for the m dimension in A (which we are using as the first dimension, of size M) -> we set to 1? \n        But wait: in the kernel, the pointer arithmetic for A is:\n            a_ptrs = a_ptr + offs_m[:, None] * stride_am + offs_k[None, :] * stride_ak\n\n        We want: \n            offs_m: along the original dimension of size M (which is the second dimension of A) -> so stride_am should be the stride for the second dimension in the original tensor? \n            Actually, in the original tensor A (K, M), the stride for the second dimension (M) is 1.\n\n        Similarly, the stride for the k dimension in A (which is the first dimension in the original) is M.\n\n        So the above is correct.\n\n Let's rewrite the forward function accordingly:\n\n   M = A.shape[1]   # 1024\n   K = A.shape[0]   # 4096\n   N = B.shape[0]   # 2048\n\n   Check: B.shape[1] must be K? -> 4096.\n\n   Then we set:\n        stride_am = A.stride(1)   # 1\n        stride_ak = A.stride(0)   # 1024 (because A is (4096,1024) and row-major: so the first dimension stride is 1024)\n\n        stride_bk = B.stride(1)   # 1\n        stride_bn = B.stride(0)   # 4096 (because B is (2048,4096) and row-major: first dimension stride is 4096)\n\n        stride_cm = C.stride(0)   # 2048 (because C is (1024,2048) and row-major: first dimension stride is 2048)\n        stride_cn = C.stride(1)   # 1\n\n But note: in the kernel, the output pointer is computed as:\n        c_ptrs = c_ptr + offs_m[:, None] * stride_cm + offs_n[None, :] * stride_cn\n\n   This is correct for row-major (M, N) output.\n\n However, the current kernel code also has an issue in the mask for the loads.\n\n   We are doing:\n        a = tl.load(a_ptrs, mask=tl.arange(0, BLOCK_K)[None, :] < K - k, other=0.0)\n\n   But note: K is the total K dimension (4096). We are iterating k from 0 to K in steps of BLOCK_K.\n\n   The mask condition: we want to load only if the k index (within the current block) is within the remaining columns? \n   Actually, we are at offset k in the K dimension. We are loading a block of BLOCK_K elements in the K dimension.\n\n   The condition should be: the current k index in the block (which is from 0 to BLOCK_K-1) plus k (the start of the block) is less than K.\n\n   So we should do:\n        k_offsets = k + tl.arange(0, BLOCK_K)\n        mask_a = k_offsets[None, :] < K   [for the k dimension] and also we must consider the m dimension? \n        Actually, the m dimension is already bounded by the program grid (we only launch for valid m and n) but we do have a mask for the m dimension? \n\n   However, note that the m dimension is bounded by the program grid, but the k dimension is not. So we must mask the k dimension.\n\n   Similarly for B.\n\n   But note: the current mask condition is: \n        mask=tl.arange(0, BLOCK_K)[None, :] < K - k   -> this is not exactly the same.\n\n   Actually, we want to avoid loading beyond the K dimension. The condition for A is: \n        the current k index in the block (let i) must satisfy: k + i < K.\n\n   So the mask for the k dimension in A is: \n        mask_k = tl.arange(0, BLOCK_K) < (K - k)\n\n   Similarly for B.\n\n   But note: the current mask condition uses `tl.arange(0, BLOCK_K)[None, :] < K - k` for A and similarly for B.\n\n   This condition is equivalent to: for each element in the k dimension of the block, the index is less than (K - k) -> which is the remaining elements in the k dimension.\n\n   However, note that (K - k) might be larger than BLOCK_K? We are stepping by BLOCK_K, so we are at step k = current start. The remaining is (K - k) and we are loading a block of size BLOCK_K. So the condition for the entire block is that the index within the block must be less than min(BLOCK_K, K-k). \n\n   We can express the mask as: \n        mask_k = tl.arange(0, BLOCK_K) < min(BLOCK_K, K - k)   -> but note that (K-k) might be larger than BLOCK_K? Then we don't need to mask? \n\n   Actually, we only need to mask when the block is the last one and (K - k) < BLOCK_K.\n\n   The current condition: \n        mask = (tl.arange(0, BLOCK_K) < (K - k))   -> but note: (K - k) is the total remaining, and we are loading exactly BLOCK_K elements? \n        This condition is correct: we want to avoid loading beyond the K dimension.\n\n   However, the current mask in the kernel for A is:\n        mask=tl.arange(0, BLOCK_K)[None, :] < K - k\n\n   But note: the shape of the mask for A: we are loading a block of (BLOCK_M, BLOCK_K). The mask must be of that shape. We are broadcasting the k mask over the m dimension? \n\n   Actually, the condition for A should be: for every row in the m dimension, the k dimension condition is the same. So we can use:\n        mask_a = (tl.arange(0, BLOCK_K)[None, :] < (K - k))   [shape (1, BLOCK_K)] and then it will be broadcast to (BLOCK_M, BLOCK_K)\n\n   Similarly for B: \n        mask_b = (tl.arange(0, BLOCK_K)[:, None] < (K - k))   [shape (BLOCK_K, 1)] and broadcast to (BLOCK_K, BLOCK_N)\n\n   But note: in the current kernel, the mask for A is set as `mask=tl.arange(0, BLOCK_K)[None, :] < K - k` -> that's (1, BLOCK_K) and then broadcast to (BLOCK_M, BLOCK_K) -> that's correct.\n\n   Similarly for B: `mask=tl.arange(0, BLOCK_K)[:, None] < K - k` -> (BLOCK_K,1) and then broadcast to (BLOCK_K, BLOCK_N) -> correct.\n\n   However, the kernel also has a mask for the output store: \n        mask = (offs_m[:, None] < M) & (offs_n[None, :] < N)\n\n   This is correct: we only store the output for indices within M and N.\n\n   But note: the kernel also recalculates offs_m and offs_n at the end? \n        offs_m = pid0 * BLOCK_M + tl.arange(0, BLOCK_M)   -> same as at the beginning?\n        offs_n = pid1 * BLOCK_N + tl.arange(0, BLOCK_N)\n\n   This is redundant? We already computed them at the beginning. We can reuse the ones from the beginning.\n\n   However, the kernel currently does not save the initial offs_m and offs_n? It overwrites them in the loop? \n\n   Actually, the kernel does:\n        offs_m = ... at the beginning, then in the loop we don't change offs_m and offs_n? \n        Then at the end we do:\n            offs_m = pid0 * BLOCK_M + tl.arange(0, BLOCK_M)   -> same as initial\n            offs_n = ... same.\n\n   So we can remove the recalculation and use the initial ones.\n\n   But note: the kernel also uses offs_m and offs_n in the pointer arithmetic for A and B? \n        a_ptrs = ... offs_m[:, None] ... -> so we use the initial offs_m.\n\n   We can save the initial offs_m and offs_n in variables and then reuse at the end.\n\n   However, for correctness, the current kernel might be okay? \n\n   The main issue is the shape of the output.\n\n   So let's fix the forward function:\n\n        M = A.shape[1]   # 1024\n        K_A = A.shape[0]   # 4096\n        N = B.shape[0]   # 2048\n        K_B = B.shape[1]   # 4096\n        assert K_A == K_B, f\"Shape mismatch: A has {K_A} rows, B has {K_B} columns\"\n\n        C = torch.empty((M, N), device=A.device, dtype=A.dtype)\n\n        grid = ... \n\n        Then we pass:\n            M, N, K = M, N, K_A   (which is 1024,2048,4096)\n\n        And the strides:\n            stride_am = A.stride(1)   # 1\n            stride_ak = A.stride(0)   # 1024\n            stride_bk = B.stride(1)   # 1\n            stride_bn = B.stride(0)   # 4096\n            stride_cm = C.stride(0)   # 2048\n            stride_cn = C.stride(1)   # 1\n\n   We must change the kernel call accordingly.\n\n   Also, note that the kernel uses two program IDs (pid0, pid1) and the grid is (triton.cdiv(M, BLOCK_M), triton.cdiv(N, BLOCK_N))\n\n   This is correct.\n\n   Let's update the forward function accordingly.\n\n   We'll also remove the redundant recomputation of offs_m and offs_n at the end of the kernel? \n        Instead, we can save the initial offs_m and offs_n and use them at the end.\n\n   But to minimize changes, we can just change the forward function and see if the output shape becomes correct.\n\n   Also note: the kernel currently uses `for k in range(0, K, BLOCK_K)`. This is correct? \n        We are stepping through the K dimension in steps of BLOCK_K.\n\n   However, note that the mask condition in the load uses `K - k`? \n        Actually, we are at the block starting at k, so the remaining K is (K - k). We want to mask the last block if it is partial.\n\n   But the condition in the mask is: `tl.arange(0, BLOCK_K) < (K - k)` -> this is the number of valid elements in the current block.\n\n   This is correct.\n\n   Alternatively, we can compute the mask as:\n        k_offsets = k + tl.arange(0, BLOCK_K)\n        mask_a = k_offsets < K   [then broadcast to (BLOCK_M, BLOCK_K)]\n        This is equivalent to: tl.arange(0, BLOCK_K) < (K - k)   because k_offsets < K  => tl.arange(0, BLOCK_K) < (K - k)\n\n   So both are equivalent.\n\n   We'll change the forward function and leave the kernel as is for now.\n\n   Steps:\n\n        In the forward function of ModelNew:\n\n            M = A.shape[1]   # because A is (K, M) -> we want M (1024)\n            K = A.shape[0]    # because A is (K, M) -> we want K (4096)\n            N = B.shape[0]    # because B is (N, K) -> we want N (2048)\n\n            Check: B.shape[1] must be K -> 4096.\n\n            Then set the strides:\n\n                stride_am = A.stride(1)   # the stride for the dimension of size M (which is the second dimension) -> 1\n                stride_ak = A.stride(0)   # the stride for the dimension of size K (first dimension) -> M (which is 1024)\n\n                stride_bk = B.stride(1)   # the stride for the dimension of size K (second dimension) in B -> 1\n                stride_bn = B.stride(0)   # the stride for the dimension of size N (first dimension) in B -> K (which is 4096)\n\n            For C (which is (M, N)): \n                stride_cm = C.stride(0)   # which is N (2048) for the first dimension (M)\n                stride_cn = C.stride(1)   # which is 1 for the second dimension (N)\n\n        Then call the kernel.\n\n   We'll also remove the condition that sets C if M*N*K==0? Because we are creating C as empty and then the kernel will write only within bounds? \n        But if any dimension is zero, then the grid will be (0,0) and the kernel won't run. So it's safe.\n\n   We can remove that condition.\n\n   Let's rewrite the forward function accordingly.\n\n   Also note: the kernel expects the grid to be (triton.cdiv(M, BLOCK_M), triton.cdiv(N, BLOCK_N))\n\n   This is set by: \n        grid = lambda meta: (triton.cdiv(M, meta['BLOCK_M']), triton.cdiv(N, meta['BLOCK_N']))\n\n   This is correct.\n\n   We'll make these changes.\n\n   Additionally, note that the kernel uses `tl.dot` which accumulates in FP32. The input tensors A and B might be FP16? \n        The kernel loads them as whatever they are? But then we do `acc = tl.zeros(..., dtype=tl.float32)` and then `tl.dot(a, b)` which will do FP16 matrix multiplication and accumulate in FP32? \n        Actually, the dot product in Triton: if a and b are FP16, then the dot product will be done in FP16 and then accumulated in FP32? \n\n        The Triton dot operator: \n            If the inputs are FP16, it will use Tensor Cores? And the output is FP32? \n\n        This is correct.\n\n   We don't change that.\n\n   Let's write the new forward function.\n\n   We'll also remove the redundant recomputation of offs_m and offs_n at the end of the kernel? \n        We can use the initial ones. We change the kernel to save the initial offs_m and offs_n and then use them at the end.\n\n   But to minimize changes, we can just remove the recomputation and use the initial ones? \n\n        We'll change the kernel:\n\n            Initially, we compute:\n                offs_m = pid0 * BLOCK_M + tl.arange(0, BLOCK_M)\n                offs_n = pid1 * BLOCK_N + tl.arange(0, BLOCK_N)\n\n            Then at the end, we do:\n                c_ptrs = c_ptr + offs_m[:, None] * stride_cm + offs_n[None, :] * stride_cn\n\n            And the mask: (offs_m[:, None] < M) & (offs_n[None, :] < N) -> same as initial.\n\n        We remove the lines at the end that recompute offs_m and offs_n.\n\n   So in the kernel, we remove:\n\n        offs_m = pid0 * BLOCK_M + tl.arange(0, BLOCK_M)   [at the end]\n        offs_n = pid1 * BLOCK_N + tl.arange(0, BLOCK_N)   [at the end]\n\n   And instead, we use the initial offs_m and offs_n for the store.\n\n   This will save some instructions.\n\n   We'll do that.\n\n   Summary of changes:\n\n   In the forward function of ModelNew:\n\n        Change the way we set M, K, N and the strides.\n\n   In the kernel:\n\n        Remove the recomputation of offs_m and offs_n at the end.\n\n   Let's write the code accordingly.\n\n   We note that the current kernel code in the provided program is:\n\n        @triton.jit\n        def matmul_kernel(...):\n            ...\n            offs_m = pid0 * BLOCK_M + tl.arange(0, BLOCK_M)\n            offs_n = pid1 * BLOCK_N + tl.arange(0, BLOCK_N)\n\n            ... [pointer setup and loop]\n\n            # At the end:\n            offs_m = pid0 * BLOCK_M + tl.arange(0, BLOCK_M)   # <- remove these two lines\n            offs_n = pid1 * BLOCK_N + tl.arange(0, BLOCK_N)   # <- remove\n\n            c_ptrs = ... offs_m ... offs_n ...   # change to use the initial offs_m and offs_n\n\n            mask = ... offs_m ... offs_n ...      # change to use the initial ones.\n\n   So we remove the two lines and use the initial offs_m and offs_n for the store.\n\n   We'll do that.\n\n   Let's write the entire code.\n\n   IMPORTANT: We are only allowed to change the Triton kernel and the ModelNew.forward function? \n        We are in the EVOLVE-BLOCK.\n\n   We output the entire block.\n\n   We also note that the autotuner configs are okay? They use BLOCK_M, BLOCK_N, BLOCK_K. We don't change them.\n\n   We'll write the code accordingly.\n</think>\nTo address the output shape mismatch and improve performance, the key changes involve correctly interpreting the input tensor dimensions and strides, and optimizing the kernel's memory access patterns. The original kernel was interpreting the input tensors as (M, K) and (K, N) but with incorrect dimension sizes. The fix involves:\n\n1. Correctly setting M, K, N dimensions in the forward pass:\n   - M = A.shape[1] (1024)\n   - K = A.shape[0] (4096) = B.shape[1]\n   - N = B.shape[0] (2048)\n\n2. Using proper strides for transposed inputs:\n   - stride_am = A.stride(1) = 1\n   - stride_ak = A.stride(0) = 1024\n   - stride_bk = B.stride(1) = 1\n   - stride_bn = B.stride(0) = 4096\n\n3. Optimizing the kernel by:\n   - Removing redundant offset recalculations\n   - Precomputing k_offsets for boundary checks\n   - Using efficient masking with k_offsets\n   - Maintaining proper tensor core alignment\n\nHere's the complete solution:\n\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport math\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 64, 'BLOCK_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 128, 'BLOCK_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_M': 256, 'BLOCK_N': 64, 'BLOCK_K': 32}, num_warps=8),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 256, 'BLOCK_K': 32}, num_warps=8),\n        triton.Config({'BLOCK_M': 128, 'BLOCK_N': 64, 'BLOCK_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_M': 64, 'BLOCK_N': 128, 'BLOCK_K': 64}, num_warps=4),\n    ],\n    key=['M', 'N', 'K'],\n)\n@triton.jit\ndef matmul_kernel(\n    a_ptr, b_ptr, c_ptr,\n    M, N, K,\n    stride_am, stride_ak,\n    stride_bk, stride_bn,\n    stride_cm, stride_cn,\n    BLOCK_M: tl.constexpr, BLOCK_N: tl.constexpr, BLOCK_K: tl.constexpr,\n):\n    pid0 = tl.program_id(0)\n    pid1 = tl.program_id(1)\n    \n    offs_m = pid0 * BLOCK_M + tl.arange(0, BLOCK_M)\n    offs_n = pid1 * BLOCK_N + tl.arange(0, BLOCK_N)\n    offs_k = tl.arange(0, BLOCK_K)\n    \n    a_ptrs = a_ptr + offs_m[:, None] * stride_am + offs_k[None, :] * stride_ak\n    b_ptrs = b_ptr + offs_k[:, None] * stride_bk + offs_n[None, :] * stride_bn\n    \n    acc = tl.zeros((BLOCK_M, BLOCK_N), dtype=tl.float32)\n    for k in range(0, K, BLOCK_K):\n        k_offsets = k + offs_k\n        mask_a = (k_offsets < K)[None, :] & (offs_m < M)[:, None]\n        mask_b = (k_offsets < K)[:, None] & (offs_n < N)[None, :]\n        \n        a = tl.load(a_ptrs, mask=mask_a, other=0.0)\n        b = tl.load(b_ptrs, mask=mask_b, other=0.0)\n        acc += tl.dot(a, b)\n        a_ptrs += BLOCK_K * stride_ak\n        b_ptrs += BLOCK_K * stride_bk\n\n    c_ptrs = c_ptr + offs_m[:, None] * stride_cm + offs_n[None, :] * stride_cn\n    mask = (offs_m[:, None] < M) & (offs_n[None, :] < N)\n    tl.store(c_ptrs, acc, mask=mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self):\n        super().__init__()\n    \n    def forward(self, A: torch.Tensor, B: torch.Tensor) -> torch.Tensor:\n        M = A.shape[1]\n        K = A.shape[0]\n        N = B.shape[0]\n        \n        C = torch.empty((M, N), device=A.device, dtype=A.dtype)\n        \n        grid = lambda meta: (triton.cdiv(M, meta['BLOCK_M']), \n                            triton.cdiv(N, meta['BLOCK_N']))\n        \n        matmul_kernel[grid](\n            A, B, C,\n            M, N, K,\n            stride_am=A.stride(1),\n            stride_ak=A.stride(0),\n            stride_bk=B.stride(1),\n            stride_bn=B.stride(0),\n            stride_cm=C.stride(0),\n            stride_cn=C.stride(1),\n        )\n        return C\n\nM = 1024\nK = 4096\nN = 2048\n\ndef get_inputs():\n    A = torch.randn(K, M)\n    B = torch.randn(N, K)\n    return [A, B]\n\ndef get_init_inputs():\n    return []\n# =================== EVOLVE-BLOCK-END ===================\n```"]}}}