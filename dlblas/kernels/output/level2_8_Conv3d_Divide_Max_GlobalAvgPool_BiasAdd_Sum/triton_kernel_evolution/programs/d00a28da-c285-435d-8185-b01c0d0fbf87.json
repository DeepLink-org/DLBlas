{"id": "d00a28da-c285-435d-8185-b01c0d0fbf87", "code": "# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_channels, out_channels, kernel_size, divisor, pool_size, bias_shape, sum_dim):\n        super(ModelNew, self).__init__()\n        # Store parameters for convolution\n        self.in_channels = in_channels\n        self.out_channels = out_channels\n        self.kernel_size = kernel_size\n        self.divisor = divisor\n        self.pool_size = pool_size\n        self.bias = nn.Parameter(torch.randn(bias_shape))\n        self.sum_dim = sum_dim\n        \n        # Initialize convolution weights\n        self.weight = nn.Parameter(torch.randn(out_channels, in_channels, *kernel_size))\n        \n    def forward(self, x):\n        # Use Triton for fused convolution and division\n        x = self.triton_conv_forward(x, self.weight, self.divisor)\n        \n        # Continue with PyTorch for remaining operations\n        x = nn.functional.max_pool3d(x, self.pool_size)\n        x = nn.functional.adaptive_avg_pool3d(x, (1, 1, 1))\n        x = x + self.bias\n        x = torch.sum(x, dim=self.sum_dim)\n        return x\n\n    @staticmethod\n    @triton.autotune(\n        configs=[\n            triton.Config({'BLOCK_D': 4, 'BLOCK_H': 16, 'BLOCK_W': 16}, num_warps=4),\n            triton.Config({'BLOCK_D': 4, 'BLOCK_H': 16, 'BLOCK_W': 16}, num_warps=8),\n            triton.Config({'BLOCK_D': 4, 'BLOCK_H': 32, 'BLOCK_W': 16}, num_warps=4),\n            triton.Config({'BLOCK_D': 4, 'BLOCK_H': 32, 'BLOCK_W': 16}, num_warps=8),\n        ],\n        key=['output_depth', 'output_height', 'output_width'],\n    )\n    @triton.jit\n    def _conv3d_forward_kernel(\n        x_ptr, weight_ptr, output_ptr,\n        # Tensor dimensions\n        batch_size, in_channels, input_depth, input_height, input_width,\n        out_channels, kernel_depth, kernel_height, kernel_width,\n        output_depth, output_height, output_width,\n        stride_d, stride_h, stride_w,\n        padding_d, padding_h, padding_w,\n        divisor,\n        # Strides\n        x_batch_stride, x_channel_stride, x_d_stride, x_h_stride, x_w_stride,\n        weight_oc_stride, weight_ic_stride, weight_d_stride, weight_h_stride, weight_w_stride,\n        output_batch_stride, output_oc_stride, output_d_stride, output_h_stride, output_w_stride,\n        BLOCK_D: tl.constexpr, BLOCK_H: tl.constexpr, BLOCK_W: tl.constexpr,\n    ):\n        pid_batch = tl.program_id(0)\n        pid_oc = tl.program_id(1)\n        pid_d = tl.program_id(2)\n        pid_h = tl.program_id(3)\n        pid_w = tl.program_id(4)\n        \n        # Output block indices\n        d0 = pid_d * BLOCK_D\n        h0 = pid_h * BLOCK_H\n        w0 = pid_w * BLOCK_W\n        \n        # Offsets in output block\n        d_offsets = d0 + tl.arange(0, BLOCK_D)\n        h_offsets = h0 + tl.arange(0, BLOCK_H)\n        w_offsets = w0 + tl.arange(0, BLOCK_W)\n        \n        # Boundary check masks\n        d_mask = d_offsets < output_depth\n        h_mask = h_offsets < output_height\n        w_mask = w_offsets < output_width\n        block_mask = d_mask[:, None, None] & h_mask[None, :, None] & w_mask[None, None, :]\n        \n        # Initialize output block\n        output_block = tl.zeros((BLOCK_D, BLOCK_H, BLOCK_W), dtype=tl.float32)\n        \n        # Loop over input channels and kernel dimensions\n        for ic in range(0, in_channels):\n            for kd in range(0, kernel_depth):\n                for kh in range(0, kernel_height):\n                    for kw in range(0, kernel_width):\n                        # Input indices (accounting for padding)\n                        input_d = d0 * stride_d + kd - padding_d\n                        input_h = h0 * stride_h + kh - padding_h\n                        input_w = w0 * stride_w + kw - padding_w\n                        \n                        # Check input boundaries\n                        input_d_valid = (input_d >= 0) & (input_d < input_depth)\n                        input_h_valid = (input_h >= 0) & (input_h < input_height)\n                        input_w_valid = (input_w >= 0) & (input_w < input_width)\n                        valid_mask = input_d_valid & input_h_valid & input_w_valid\n                        \n                        # Load input block\n                        input_ptr_offset = (\n                            pid_batch * x_batch_stride +\n                            ic * x_channel_stride +\n                            input_d * x_d_stride +\n                            input_h * x_h_stride +\n                            input_w * x_w_stride\n                        )\n                        input_block = tl.load(\n                            x_ptr + input_ptr_offset + \n                            tl.arange(0, BLOCK_D)[:, None, None] * x_d_stride +\n                            tl.arange(0, BLOCK_H)[None, :, None] * x_h_stride +\n                            tl.arange(0, BLOCK_W)[None, None, :] * x_w_stride,\n                            mask=block_mask & valid_mask,\n                            other=0.0\n                        )\n                        \n                        # Load weight value\n                        weight_val = tl.load(\n                            weight_ptr +\n                            pid_oc * weight_oc_stride +\n                            ic * weight_ic_stride +\n                            kd * weight_d_stride +\n                            kh * weight_h_stride +\n                            kw * weight_w_stride\n                        )\n                        \n                        # Accumulate\n                        output_block += input_block * weight_val\n        \n        # Apply divisor\n        output_block = output_block / divisor\n        \n        # Store output block\n        output_ptr_offset = (\n            pid_batch * output_batch_stride +\n            pid_oc * output_oc_stride +\n            d0 * output_d_stride +\n            h0 * output_h_stride +\n            w0 * output_w_stride\n        )\n        tl.store(\n            output_ptr + output_ptr_offset +\n            tl.arange(0, BLOCK_D)[:, None, None] * output_d_stride +\n            tl.arange(0, BLOCK_H)[None, :, None] * output_h_stride +\n            tl.arange(0, BLOCK_W)[None, None, :] * output_w_stride,\n            output_block,\n            mask=block_mask\n        )\n    \n    def triton_conv_forward(self, x, weight, divisor):\n        # Compute output dimensions\n        _, _, D_in, H_in, W_in = x.shape\n        K_D, K_H, K_W = self.kernel_size\n        D_out = D_in - K_D + 1\n        H_out = H_in - K_H + 1\n        W_out = W_in - K_W + 1\n        \n        # Preallocate output tensor\n        output = torch.empty(\n            (x.size(0), self.out_channels, D_out, H_out, W_out),\n            device=x.device,\n            dtype=x.dtype\n        )\n        \n        # Launch kernel with appropriate grid\n        grid = (\n            x.size(0),  # batch size\n            self.out_channels,  # output channels\n            triton.cdiv(D_out, 4),  # adjust based on block size\n            triton.cdiv(H_out, 16),\n            triton.cdiv(W_out, 16),\n        )\n        \n        # Call Triton kernel\n        ModelNew._conv3d_forward_kernel[grid](\n            x, weight, output,\n            # Tensor dimensions\n            x.size(0), self.in_channels, D_in, H_in, W_in,\n            self.out_channels, K_D, K_H, K_W,\n            D_out, H_out, W_out,\n            1, 1, 1,  # strides\n            0, 0, 0,  # padding\n            divisor,\n            # Tensor strides\n            x.stride(0), x.stride(1), x.stride(2), x.stride(3), x.stride(4),\n            weight.stride(0), weight.stride(1), weight.stride(2), weight.stride(3), weight.stride(4),\n            output.stride(0), output.stride(1), output.stride(2), output.stride(3), output.stride(4),\n            BLOCK_D=4, BLOCK_H=16, BLOCK_W=16\n        )\n        return output\n\nbatch_size = 128\nin_channels = 3\nout_channels = 16\ndepth, height, width = 16, 32, 32\nkernel_size = (3, 3, 3)\ndivisor = 2.0\npool_size = (2, 2, 2)\nbias_shape = (out_channels, 1, 1, 1)\nsum_dim = 1\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_channels, depth, height, width)]\n\ndef get_init_inputs():\n    return [in_channels, out_channels, kernel_size, divisor, pool_size, bias_shape, sum_dim]\n# =================== EVOLVE-BLOCK-END ===================", "language": "python", "parent_id": "98cdfceb-94b5-4f00-83c9-f5cde542afcd", "generation": 1, "timestamp": 1754577922.0530298, "iteration_found": 2, "metrics": {"compiled": true, "correctness": false, "score": 10, "stage": "wrong_answer", "verify_payload": {"id": "level2_8_Conv3d_Divide_Max_GlobalAvgPool_BiasAdd_Sum", "result": {"compiled": true, "correctness": false, "metadata": {"hardware": "NVIDIA L20Y", "device": "cuda:2", "runtime_error": "Traceback (most recent call last):\n  File \"/cpfs01/shared/llm_kernel/hujiakai/KernelLLM/validation_api_server/helpers/evaluations.py\", line 720, in run_and_check_correctness\n    output_new = model_new(*inputs)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1773, in _wrapped_call_impl\n    return self._call_impl(*args, **kwargs)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1784, in _call_impl\n    return forward_call(*args, **kwargs)\n  File \"/tmp/tmpvat8_qur.py\", line 24, in forward\n    x = self.triton_conv_forward(x, self.weight, self.divisor)\n  File \"/tmp/tmpvat8_qur.py\", line 175, in triton_conv_forward\n    ModelNew._conv3d_forward_kernel[grid](\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 390, in <lambda>\n    return lambda *args, **kwargs: self.run(grid=grid, warmup=False, *args, **kwargs)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 239, in run\n    benchmark()\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 228, in benchmark\n    timings = {config: self._bench(*args, config=config, **kwargs) for config in pruned_configs}\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 228, in <dictcomp>\n    timings = {config: self._bench(*args, config=config, **kwargs) for config in pruned_configs}\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 135, in _bench\n    raise ValueError(f\"Conflicting meta-parameters: {', '.join(conflicts)}.\"\nValueError: Conflicting meta-parameters: BLOCK_H, BLOCK_W, BLOCK_D. Make sure that you don't re-define auto-tuned symbols.\n", "runtime_error_name": "builtins.ValueError", "reference_timing_ms": 0.106, "speed_up": -1.0, "custom_timing": -1.0}, "runtime": -1.0, "runtime_stats": {}}}}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": true, "correctness": true, "stage": "reference code", "passed": false, "score": 0.0, "speed_up": 1.0, "runtime_ms": 0.717, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:1", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.106, "speed_up": 0.148, "custom_timing": 0.717}}, "island": 0}, "artifacts_json": null, "artifact_dir": null}