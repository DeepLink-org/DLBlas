{"id": "74733800-9665-470e-8240-7e7a02e1f598", "code": "# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport triton\nimport triton.language as tl\nimport math\n\n@triton.jit\ndef _inorm_kernel(\n    x_ptr,\n    output_ptr,\n    stride_b,\n    stride_f,\n    stride_h,\n    stride_w,\n    H,\n    W,\n    eps,\n    BLOCK_SIZE: tl.constexpr,\n    P2: tl.constexpr\n):\n    pid_b = tl.program_id(0)\n    pid_f = tl.program_id(1)\n    \n    x_channel_ptr = x_ptr + pid_b * stride_b + pid_f * stride_f\n    output_channel_ptr = output_ptr + pid_b * stride_b + pid_f * stride_f\n    total_elements = H * W\n    \n    # Initialize accumulators\n    sum_val = 0.0\n    sum_sq = 0.0\n    \n    # First pass: compute statistics\n    for offset in range(0, total_elements, BLOCK_SIZE):\n        idx = offset + tl.arange(0, BLOCK_SIZE)\n        mask = idx < total_elements\n        \n        # Calculate 2D indices\n        h_idx = idx // W\n        w_idx = idx % W\n        ptr = x_channel_ptr + h_idx * stride_h + w_idx * stride_w\n        \n        # Vectorized load\n        vals = tl.load(ptr, mask=mask, other=0.0)\n        \n        # Vectorized reductions\n        sum_val += tl.sum(vals, axis=0)\n        sum_sq += tl.sum(vals * vals, axis=0)\n    \n    # Compute mean and variance\n    mean = sum_val / total_elements\n    variance = (sum_sq / total_elements) - (mean * mean)\n    std = tl.sqrt(tl.maximum(variance, 0.0) + eps)\n    \n    # Second pass: normalize and store\n    for offset in range(0, total_elements, BLOCK_SIZE):\n        idx = offset + tl.arange(0, BLOCK_SIZE)\n        mask = idx < total_elements\n        \n        # Calculate 2D indices\n        h_idx = idx // W\n        w_idx = idx % W\n        in_ptr = x_channel_ptr + h_idx * stride_h + w_idx * stride_w\n        out_ptr = output_channel_ptr + h_idx * stride_h + w_idx * stride_w\n        \n        # Load, normalize, and store\n        vals = tl.load(in_ptr, mask=mask, other=0.0)\n        norm_vals = (vals - mean) / std\n        tl.store(out_ptr, norm_vals, mask=mask)\n\nclass ModelNew(torch.nn.Module):\n    def __init__(self, num_features: int):\n        super(ModelNew, self).__init__()\n        self.eps = 1e-5\n        self.num_features = num_features\n\n    def forward(self, x: torch.Tensor) -> torch.Tensor:\n        batch, features, H, W = x.shape\n        output = torch.empty_like(x)\n        \n        BLOCK_SIZE = 1024  # Optimized block size\n        P2 = int(2 ** math.ceil(math.log2(W)))\n        grid = (batch, features)\n        \n        _inorm_kernel[grid](\n            x, output,\n            x.stride(0), x.stride(1), x.stride(2), x.stride(3),\n            H, W, self.eps,\n            BLOCK_SIZE=BLOCK_SIZE,\n            P2=P2\n        )\n        return output\n\nbatch_size = 16\nfeatures = 64\ndim1 = 256\ndim2 = 256\n\ndef get_inputs():\n    x = torch.randn(batch_size, features, dim1, dim2)\n    return [x]\n\ndef get_init_inputs():\n    return [features]\n# =================== EVOLVE-BLOCK-END ===================", "language": "python", "parent_id": "6dfe21db-a794-429e-afc8-b808550f3a7a", "generation": 2, "timestamp": 1754638311.8202178, "iteration_found": 23, "metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": false, "score": 20, "speed_up": 0.13, "runtime_ms": 0.33, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:6", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.043, "speed_up": 0.13, "custom_timing": 0.33}}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": false, "score": 20, "speed_up": 0.056, "runtime_ms": 0.764, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:5", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.043, "speed_up": 0.056, "custom_timing": 0.764}}, "island": 0}, "artifacts_json": null, "artifact_dir": null}