{"id": "6e064dcb-1e63-4b62-a10f-c826e269b5d3", "code": "# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport triton\nimport triton.language as tl\nimport math\n\nclass ModelNew(torch.nn.Module):\n    def __init__(self, num_features: int):\n        super().__init__()\n        self.num_features = num_features\n\n    @triton.jit\n    def _instance_norm_kernel(\n        x_ptr,\n        output_ptr,\n        stride_b,\n        stride_f,\n        stride_h,\n        stride_w,\n        H,\n        W,\n        eps: tl.constexpr,\n        BLOCK_SIZE: tl.constexpr,\n    ):\n        pid_b = tl.program_id(0)\n        pid_f = tl.program_id(1)\n        base_ptr = x_ptr + pid_b * stride_b + pid_f * stride_f\n        output_base = output_ptr + pid_b * stride_b + pid_f * stride_f\n        \n        total_sum = 0.0\n        total_sum_sq = 0.0\n        total_count = 0\n\n        # First pass: accumulate statistics with 2D blocking\n        for h in range(0, H):\n            for w_block in range(0, tl.cdiv(W, BLOCK_SIZE)):\n                w_offsets = w_block * BLOCK_SIZE + tl.arange(0, BLOCK_SIZE)\n                mask = w_offsets < W\n                ptr = base_ptr + h * stride_h + w_offsets * stride_w\n                vals = tl.load(ptr, mask=mask, other=0.0)\n                total_sum += tl.sum(vals, axis=0)\n                total_sum_sq += tl.sum(vals * vals, axis=0)\n                total_count += tl.sum(tl.where(mask, 1, 0), axis=0)\n        \n        mean = total_sum / total_count\n        variance = total_sum_sq / total_count - mean * mean\n        std = tl.sqrt(variance + eps)\n\n        # Second pass: normalize with 2D blocking\n        for h in range(0, H):\n            for w_block in range(0, tl.cdiv(W, BLOCK_SIZE)):\n                w_offsets = w_block * BLOCK_SIZE + tl.arange(0, BLOCK_SIZE)\n                mask = w_offsets < W\n                ptr = base_ptr + h * stride_h + w_offsets * stride_w\n                vals = tl.load(ptr, mask=mask, other=0.0)\n                norm_vals = (vals - mean) / std\n                out_ptr = output_base + h * stride_h + w_offsets * stride_w\n                tl.store(out_ptr, norm_vals, mask=mask)\n\n    def forward(self, x: torch.Tensor) -> torch.Tensor:\n        x = x.contiguous()\n        output = torch.empty_like(x)\n        N, C, H, W = x.shape\n        grid = (N, C)\n        self._instance_norm_kernel[grid](\n            x, output,\n            x.stride(0), x.stride(1), x.stride(2), x.stride(3),\n            H, W, \n            eps=1e-5, BLOCK_SIZE=128\n        )\n        return output\n\nbatch_size = 16\nfeatures = 64\ndim1 = 256\ndim2 = 256\n\ndef get_inputs():\n    x = torch.randn(batch_size, features, dim1, dim2)\n    return [x]\n\ndef get_init_inputs():\n    return [features]\n# =================== EVOLVE-BLOCK-END ===================", "language": "python", "parent_id": "b8680210-4ffe-4935-9c18-9539965355f0", "generation": 4, "timestamp": 1754637701.7878368, "iteration_found": 20, "metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": false, "score": 20, "speed_up": 0.056, "runtime_ms": 0.764, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:1", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.043, "speed_up": 0.056, "custom_timing": 0.764}}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": false, "score": 20, "speed_up": 0.141, "runtime_ms": 0.304, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:7", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.043, "speed_up": 0.141, "custom_timing": 0.304}}, "island": 1}, "artifacts_json": null, "artifact_dir": null}