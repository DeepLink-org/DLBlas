{"id": "084584ed-fbfe-499f-a759-fff97ee15d01", "code": "# ================== EVOLVE-BLOCK-START ==================\nimport math\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef linear_kernel(\n    x_ptr,\n    w_ptr,\n    b_ptr,\n    output_ptr,\n    in_size,\n    out_size,\n    batch_size,\n    apply_relu: tl.constexpr,\n    BLOCK_SIZE_OUT: tl.constexpr,\n    BLOCK_SIZE_K: tl.constexpr,\n):\n    pid = tl.program_id(0)\n    num_blocks_per_row = tl.cdiv(out_size, BLOCK_SIZE_OUT)\n    b_idx = pid // num_blocks_per_row\n    j_block = pid % num_blocks_per_row\n    \n    if b_idx >= batch_size:\n        return\n\n    j_start = j_block * BLOCK_SIZE_OUT\n    offs_j = j_start + tl.arange(0, BLOCK_SIZE_OUT)\n    mask_j = offs_j < out_size\n\n    bias = tl.load(b_ptr + offs_j, mask=mask_j, other=0.0)\n    acc = bias\n\n    for k in range(0, in_size, BLOCK_SIZE_K):\n        offs_k = k + tl.arange(0, BLOCK_SIZE_K)\n        mask_k = offs_k < in_size\n        \n        x_val = tl.load(x_ptr + b_idx * in_size + offs_k, mask=mask_k, other=0.0)\n        \n        w_ptrs = w_ptr + (offs_k[:, None] * out_size + offs_j[None, :])\n        w_val = tl.load(w_ptrs, mask=mask_k[:, None] & mask_j[None, :], other=0.0)\n        \n        partial = tl.sum(w_val * x_val[:, None], axis=0)\n        acc += partial\n\n    if apply_relu:\n        acc = tl.maximum(acc, 0.0)\n    \n    tl.store(output_ptr + b_idx * out_size + offs_j, acc, mask=mask_j)\n\nclass ModelNew(nn.Module):\n    def __init__(self, input_size, hidden_layer_sizes, output_size):\n        super(ModelNew, self).__init__()\n        self.layers = nn.ModuleList()\n        self.activations = []\n        \n        current_size = input_size\n        for hidden_size in hidden_layer_sizes:\n            linear = nn.Linear(current_size, hidden_size)\n            self.layers.append(linear)\n            self.activations.append('relu')\n            current_size = hidden_size\n        \n        output_layer = nn.Linear(current_size, output_size)\n        self.layers.append(output_layer)\n        self.activations.append(None)\n    \n    def forward(self, x):\n        batch_size = x.size(0)\n        for layer, activation in zip(self.layers, self.activations):\n            in_features = layer.weight.size(1)\n            out_features = layer.weight.size(0)\n            \n            out = torch.empty(batch_size, out_features, device=x.device, dtype=x.dtype)\n            weight_t = layer.weight.t().contiguous()\n            \n            BLOCK_SIZE_OUT = 32\n            num_blocks_per_row = (out_features + BLOCK_SIZE_OUT - 1) // BLOCK_SIZE_OUT\n            grid = (batch_size * num_blocks_per_row,)\n            \n            linear_kernel[grid](\n                x, \n                weight_t, \n                layer.bias,\n                out,\n                in_features,\n                out_features,\n                batch_size,\n                activation == 'relu',\n                BLOCK_SIZE_OUT=BLOCK_SIZE_OUT,\n                BLOCK_SIZE_K=256\n            )\n            x = out\n        \n        return x\n\n# Test code\nbatch_size = 1\ninput_size = 1000\nhidden_layer_sizes = [50, 50, 50, 50, 50, 50, 50, 50]\noutput_size = 10\n\ndef get_inputs():\n    return [torch.randn(batch_size, input_size)]\n\ndef get_init_inputs():\n    return [input_size, hidden_layer_sizes, output_size]\n# =================== EVOLVE-BLOCK-END ===================", "language": "python", "parent_id": "3407f0d2-c6bd-4ad5-967e-eba8359a88e4", "generation": 3, "timestamp": 1754595807.7189136, "iteration_found": 21, "metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": false, "score": 20, "speed_up": 0.533, "runtime_ms": 0.426, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:1", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.227, "speed_up": 0.533, "custom_timing": 0.426}}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": false, "score": 20, "speed_up": 0.799, "runtime_ms": 0.284, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:3", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.227, "speed_up": 0.799, "custom_timing": 0.284}}, "island": 1}, "artifacts_json": null, "artifact_dir": null, "prompts": {"full_rewrite_user": {"system": "You are a Triton GPU core optimization engineer deeply familiar with NVIDIA H100/H800 architecture.\n\n==================== Context ====================\n\u2022 Dataset: 250 kernelbench/level1-level5 *.py files  \n  - Level1: simplest, Level5: most complex  \n\u2022 Each file contains PyTorch reference (reference_code)  \n\u2022 Goal: Generate functionally equivalent but faster Triton implementations (custom_code)  \n\u2022 Evaluation pipeline:\n    1) /verify_plus - Verify compilation & correctness  \n    2) /execute (optional) - Return terminal logs if compilation fails  \n    3) Scoring:  \n      - Speedup > 1 required for points  \n      - Score = (speed_up - 1) \u00d7 100  \n\u2022 GPU Hardware: NVIDIA L20Y / H800 (same SM8.9 as H100)  \n  - 3 TB/s HBM3 bandwidth  \n  - FP16 Tensor Core 32\u00d716\u00d716  \n\n==================== Evolution Phases ====================\n\u2460 Phase 1 [Compilation Pass]  \n  - Make Triton code compile (performance irrelevant)  \n\u2461 Phase 2 [Numerical Correctness]  \n  - Output must match PyTorch reference within float32 tolerance  \n\u2462 Phase 3 [Performance Gain]  \n  - Target \u22655% speedup (\u226515% = exceptional)  \n  - Official scoring based on speed_up field  \n\nThe Evolution system will pass the EVOLVE-BLOCK from the previous version.  \nModify ONLY the Triton kernel source within this block - all other code is LOCKED.\n\n==================== Constraints (MUST OBEY) ====================\n\u274c NEVER change @triton.jit function signatures or parameter names  \n\u274c NEVER modify grid configuration, output tensor shapes, or PID logic  \n\u274c NEVER remove boundary checks or out-of-bound masks  \n\u274c NEVER introduce race conditions, uninitialized reads, or sync gaps  \n\n\u2705 Allowed Optimizations (Examples):  \n  \u2022 Memory coalescing optimizations & vectorized tl.load/tl.store  \n  \u2022 Replace staged softmax with online/FlashAttention variants  \n  \u2022 Adaptive tuning: BLOCK_M/BLOCK_N/BLOCK_K dimensions  \n  \u2022 Multi-query-head batch processing (GQA, 5:1 patterns)  \n  \u2022 Shared/L2 buffering, Tensor Core alignment (FP16/bf16/tf32)  \n  \u2022 Stride precomputation & pointer caching  \n\n==================== Output Format ====================\nReturn ONLY the complete updated code containing the EVOLVE-BLOCK comment marker.  \nNO explanations, NO markdown, NO additional text.\nName the output structure class as ModelNew.\n\n==================== Optimization Tips ====================\n\u2022 If previous compile failed: Fix syntax/mask/stride errors first  \n\u2022 If correctness fails: Prioritize bounds mask & dtype precision  \n\u2022 When speed_up < 1: Focus on memory access & block sizing  \n\u2022 Small iterative steps: Modify \u226420 lines per revision  \n\u2022 Maintain reversibility between versions\nHere is an example to show you how to rewrite a PyTorch implementation that quantizes a high-precision tensor to int8 dtype with row-wise granularity into a Triton implementation: \nThe original PyTorch implementation is as follows: \n``` \nimport torch\ndef per_row_quantize_int8(x: torch.Tensor) -> tuple[torch.Tensor, torch.Tensor]:\n    x_amax = x.abs().float().amax(dim=1).clamp(min=1e-4)\n    scale = 127 / x_amax\n    output = (x * scale[:, None]).round().clamp(-127, 127).to(torch.int8)\n    output_scale = x_amax / 127\n\n    return output, output_scale\n``` \nThe corresponding Triton-rewritten implementation is as follows: \n``` \nimport math\nimport torch\nimport triton\nimport triton.language as tl\nfrom triton.language.extra import libdevice\n\n# rowwise quantize\n\n@triton.autotune(\n    configs=[\n        triton.Config({}, num_stages=1, num_warps=8),\n        triton.Config({}, num_stages=2, num_warps=8),\n        triton.Config({}, num_stages=4, num_warps=8),\n        triton.Config({}, num_stages=8, num_warps=8),\n        triton.Config({}, num_stages=1),\n        triton.Config({}, num_stages=2),\n        triton.Config({}, num_stages=4),\n        triton.Config({}, num_stages=8),\n        triton.Config({}, num_warps=1),\n        triton.Config({}, num_warps=2),\n        triton.Config({}, num_warps=4),\n        triton.Config({}, num_warps=8),\n    ],\n    key=[\"n_elements\"],\n)\n\n@triton.jit\ndef _quantize_rowwise(\n    x_ptr,\n    output_ptr,\n    output_scale,\n    BLOCK_SIZE: tl.constexpr,\n    P2: tl.constexpr,\n):\n    pid = tl.program_id(axis=0)\n    block_start = pid * BLOCK_SIZE\n    arange = tl.arange(0, P2)\n    offsets = block_start + arange\n    row_mask = arange < BLOCK_SIZE\n    x = tl.load(x_ptr + offsets, mask=row_mask)\n\n    abs_x = tl.abs(x)\n    max_val = tl.max(tl.where(row_mask, abs_x, 0), axis=0)\n    output = libdevice.llrint(127.0 * (x / max_val))\n    tl.store(output_ptr + offsets, output, mask=row_mask)\n    tl.store(output_scale + pid, max_val / 127)\n\n\ndef per_row_quantize_int8(x: torch.Tensor):\n    x = x.contiguous()\n    output = torch.empty(*x.shape, device=x.device, dtype=torch.int8)\n    output_scale = torch.empty(x.shape[0], device=x.device, dtype=torch.float32)\n    P2 = int(2 ** (math.ceil(math.log2(x.shape[1]))))\n    grid = lambda x: (x.shape[0],)\n    _quantize_rowwise[grid](x, output, output_scale, BLOCK_SIZE=x.shape[1], P2=P2)\n\n    return output, output_scale\n\n\n    \n``` \n", "user": "# Current Program Information\n- Current performance metrics: - compiled: 1.0000\n- correctness: 1.0000\n- stage: success\n- passed: 0.0000\n- score: 20.0000\n- speed_up: 0.7990\n- runtime_ms: 0.2840\n- meta: {'hardware': 'NVIDIA L20Y', 'device': 'cuda:3', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.227, 'speed_up': 0.799, 'custom_timing': 0.284}\n- Areas identified for improvement: - Consider simplifying the code to improve readability and maintainability\n- Metrics showing improvement: speed_up. Consider continuing with similar changes.\n- Metrics showing regression: runtime_ms. Consider reverting or revising recent changes in these areas.\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Unknown changes\n- Performance: compiled: 1.0000, correctness: 1.0000, stage: success, passed: 0.0000, score: 20.0000, speed_up: 0.7960, runtime_ms: 0.2850, meta: {'hardware': 'NVIDIA L20Y', 'device': 'cuda:4', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.227, 'speed_up': 0.796, 'custom_timing': 0.285}\n- Outcome: Mixed results\n\n\n### Attempt 2\n- Changes: Unknown changes\n- Performance: compiled: 1.0000, correctness: 1.0000, stage: success, passed: 0.0000, score: 20.0000, speed_up: 0.7940, runtime_ms: 0.2860, meta: {'hardware': 'NVIDIA L20Y', 'device': 'cuda:4', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.227, 'speed_up': 0.794, 'custom_timing': 0.286}\n- Outcome: Mixed results\n\n\n### Attempt 1\n- Changes: Unknown changes\n- Performance: compiled: 1.0000, correctness: 1.0000, stage: success, passed: 0.0000, score: 20.0000, speed_up: 0.7990, runtime_ms: 0.2840, meta: {'hardware': 'NVIDIA L20Y', 'device': 'cuda:3', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.227, 'speed_up': 0.799, 'custom_timing': 0.284}\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 20.0000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport math\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef _linear_forward(\n    x_ptr,\n    w_ptr,\n    b_ptr,\n    out_ptr,\n    in_features,\n    out_features,\n    batch_size,\n    apply_relu: tl.constexpr,\n    BLOCK_SIZE_K: tl.constexpr,\n):\n    pid = tl.program_id(0)\n    b_idx = pid // out_features\n    o_idx = pid % out_features\n\n    if b_idx >= batch_size or o_idx >= out_features:\n        return\n\n    bias = tl.load(b_ptr + o_idx) if b_ptr is not None else 0.0\n    accumulator = 0.0\n\n    for k in range(0, in_features, BLOCK_SIZE_K):\n        k_offs = k + tl.arange(0, BLOCK_SIZE_K)\n        k_mask = k_offs < in_features\n        \n        x_ptr_offset = b_idx * in_features + k_offs\n        w_ptr_offset = o_idx * in_features + k_offs\n        \n        x_val = tl.load(x_ptr + x_ptr_offset, mask=k_mask, other=0.0)\n        w_val = tl.load(w_ptr + w_ptr_offset, mask=k_mask, other=0.0)\n        \n        accumulator += tl.sum(x_val * w_val)\n\n    result = accumulator + bias\n    if apply_relu:\n        result = tl.maximum(result, 0.0)\n    \n    tl.store(out_ptr + b_idx * out_features + o_idx, result)\n\nclass ModelNew(nn.Module):\n    def __init__(self, input_size, hidden_layer_sizes, output_size):\n        super(ModelNew, self).__init__()\n        self.layers = nn.ModuleList()\n        self.activations = []\n        \n        current_size = input_size\n        for hidden_size in hidden_layer_sizes:\n            linear = nn.Linear(current_size, hidden_size)\n            self.layers.append(linear)\n            self.activations.append('relu')\n            current_size = hidden_size\n        \n        output_layer = nn.Linear(current_size, output_size)\n        self.layers.append(output_layer)\n        self.activations.append(None)\n    \n    def forward(self, x):\n        batch_size = x.size(0)\n        for layer, activation in zip(self.layers, self.activations):\n            in_features = layer.weight.size(1)\n            out_features = layer.weight.size(0)\n            \n            out = torch.empty(batch_size, out_features, device=x.device, dtype=x.dtype)\n            grid = (batch_size * out_features,)\n            \n            _linear_forward[grid](\n                x, \n                layer.weight, \n                layer.bias,\n                out,\n                in_features,\n                out_features,\n                batch_size,\n                activation == 'relu',\n                BLOCK_SIZE_K=256\n            )\n            x = out\n        \n        return x\n\n# Test code\nbatch_size = 1\ninput_size = 1000\nhidden_layer_sizes = [50, 50, 50, 50, 50, 50, 50, 50]\noutput_size = 10\n\ndef get_inputs():\n    return [torch.randn(batch_size, input_size)]\n\ndef get_init_inputs():\n    return [input_size, hidden_layer_sizes, output_size]\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Performs well on compiled (1.0000), Performs well on correctness (1.0000), Performs well on stage (success), Performs well on passed (0.0000), Performs well on score (20.0000), Performs well on speed_up (0.7990), Performs well on runtime_ms (0.2840), Performs well on meta ({'hardware': 'NVIDIA L20Y', 'device': 'cuda:3', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.227, 'speed_up': 0.799, 'custom_timing': 0.284})\n\n\n### Program 2 (Score: 20.0000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport math\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef _linear_forward(\n    x_ptr,\n    w_ptr,\n    b_ptr,\n    out_ptr,\n    in_features,\n    out_features,\n    batch_size,\n    apply_relu: tl.constexpr,\n    BLOCK_SIZE_K: tl.constexpr,\n):\n    pid = tl.program_id(0)\n    b_idx = pid // out_features\n    o_idx = pid % out_features\n\n    if b_idx >= batch_size or o_idx >= out_features:\n        return\n\n    bias = tl.load(b_ptr + o_idx) if b_ptr is not None else 0.0\n    accumulator = 0.0\n\n    for k in range(0, in_features, BLOCK_SIZE_K):\n        k_offs = k + tl.arange(0, BLOCK_SIZE_K)\n        k_mask = k_offs < in_features\n        \n        x_ptr_offset = b_idx * in_features + k_offs\n        w_ptr_offset = o_idx * in_features + k_offs\n        \n        x_val = tl.load(x_ptr + x_ptr_offset, mask=k_mask, other=0.0)\n        w_val = tl.load(w_ptr + w_ptr_offset, mask=k_mask, other=0.0)\n        \n        accumulator += tl.sum(x_val * w_val)\n\n    result = accumulator + bias\n    if apply_relu:\n        result = tl.maximum(result, 0.0)\n    \n    tl.store(out_ptr + b_idx * out_features + o_idx, result)\n\nclass ModelNew(nn.Module):\n    def __init__(self, input_size, hidden_layer_sizes, output_size):\n        super(ModelNew, self).__init__()\n        self.layers = nn.ModuleList()\n        self.activations = []\n        \n        current_size = input_size\n        for hidden_size in hidden_layer_sizes:\n            linear = nn.Linear(current_size, hidden_size)\n            self.layers.append(linear)\n            self.activations.append('relu')\n            current_size = hidden_size\n        \n        output_layer = nn.Linear(current_size, output_size)\n        self.layers.append(output_layer)\n        self.activations.append(None)\n    \n    def forward(self, x):\n        batch_size = x.size(0)\n        for layer, activation in zip(self.layers, self.activations):\n            in_features = layer.weight.size(1)\n            out_features = layer.weight.size(0)\n            \n            out = torch.empty(batch_size, out_features, device=x.device, dtype=x.dtype)\n            grid = (batch_size * out_features,)\n            \n            _linear_forward[grid](\n                x, \n                layer.weight, \n                layer.bias,\n                out,\n                in_features,\n                out_features,\n                batch_size,\n                activation == 'relu',\n                BLOCK_SIZE_K=256\n            )\n            x = out\n        \n        return x\n\n# Test code\nbatch_size = 1\ninput_size = 1000\nhidden_layer_sizes = [50, 50, 50, 50, 50, 50, 50, 50]\noutput_size = 10\n\ndef get_inputs():\n    return [torch.randn(batch_size, input_size)]\n\ndef get_init_inputs():\n    return [input_size, hidden_layer_sizes, output_size]\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Performs well on compiled (1.0000), Performs well on correctness (1.0000), Performs well on stage (success), Performs well on passed (0.0000), Performs well on score (20.0000), Performs well on speed_up (0.7940), Performs well on runtime_ms (0.2860), Performs well on meta ({'hardware': 'NVIDIA L20Y', 'device': 'cuda:4', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.227, 'speed_up': 0.794, 'custom_timing': 0.286})\n\n\n### Program 3 (Score: 20.0000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport math\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef _linear_relu_forward(\n    x_ptr,\n    w_ptr,\n    b_ptr,\n    out_ptr,\n    in_features,\n    out_features,\n    BLOCK_SIZE_IN: tl.constexpr,\n    BLOCK_SIZE_OUT: tl.constexpr,\n):\n    pid_out = tl.program_id(0)\n    pid_in = tl.program_id(1)\n    \n    in_offs = pid_in * BLOCK_SIZE_IN + tl.arange(0, BLOCK_SIZE_IN)\n    out_offs = pid_out * BLOCK_SIZE_OUT + tl.arange(0, BLOCK_SIZE_OUT)\n    \n    in_mask = in_offs < in_features\n    out_mask = out_offs < out_features\n    \n    acc = tl.zeros((BLOCK_SIZE_OUT,), dtype=tl.float32)\n    \n    for i in range(0, tl.cdiv(in_features, BLOCK_SIZE_IN)):\n        in_idx = i * BLOCK_SIZE_IN + tl.arange(0, BLOCK_SIZE_IN)\n        in_mask_cur = in_idx < in_features\n        \n        w_ptrs = w_ptr + (out_offs[:, None] * in_features + in_idx[None, :])\n        x_ptrs = x_ptr + in_idx\n        \n        x = tl.load(x_ptrs, mask=in_mask_cur, other=0.0)\n        w = tl.load(w_ptrs, mask=out_mask[:, None] & in_mask_cur[None, :], other=0.0)\n        \n        acc += tl.sum(x[None, :] * w, axis=1)\n    \n    if b_ptr is not None:\n        b = tl.load(b_ptr + out_offs, mask=out_mask, other=0.0)\n        acc += b\n    \n    acc = tl.maximum(acc, 0.0)\n    tl.store(out_ptr + out_offs, acc, mask=out_mask)\n\n@triton.jit\ndef _linear_forward(\n    x_ptr,\n    w_ptr,\n    b_ptr,\n    out_ptr,\n    in_features,\n    out_features,\n    BLOCK_SIZE_IN: tl.constexpr,\n    BLOCK_SIZE_OUT: tl.constexpr,\n):\n    pid_out = tl.program_id(0)\n    pid_in = tl.program_id(1)\n    \n    in_offs = pid_in * BLOCK_SIZE_IN + tl.arange(0, BLOCK_SIZE_IN)\n    out_offs = pid_out * BLOCK_SIZE_OUT + tl.arange(0, BLOCK_SIZE_OUT)\n    \n    in_mask = in_offs < in_features\n    out_mask = out_offs < out_features\n    \n    acc = tl.zeros((BLOCK_SIZE_OUT,), dtype=tl.float32)\n    \n    for i in range(0, tl.cdiv(in_features, BLOCK_SIZE_IN)):\n        in_idx = i * BLOCK_SIZE_IN + tl.arange(0, BLOCK_SIZE_IN)\n        in_mask_cur = in_idx < in_features\n        \n        w_ptrs = w_ptr + (out_offs[:, None] * in_features + in_idx[None, :])\n        x_ptrs = x_ptr + in_idx\n        \n        x = tl.load(x_ptrs, mask=in_mask_cur, other=0.0)\n        w = tl.load(w_ptrs, mask=out_mask[:, None] & in_mask_cur[None, :], other=0.0)\n        \n        acc += tl.sum(x[None, :] * w, axis=1)\n    \n    if b_ptr is not None:\n        b = tl.load(b_ptr + out_offs, mask=out_mask, other=0.0)\n        acc += b\n    \n    tl.store(out_ptr + out_offs, acc, mask=out_mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, input_size, hidden_layer_sizes, output_size):\n        super(ModelNew, self).__init__()\n        self.layers = nn.ModuleList()\n        self.activations = []\n        \n        current_size = input_size\n        for hidden_size in hidden_layer_sizes:\n            linear = nn.Linear(current_size, hidden_size)\n            self.layers.append(linear)\n            self.activations.append('relu')\n            current_size = hidden_size\n        \n        output_layer = nn.Linear(current_size, output_size)\n        self.layers.append(output_layer)\n        self.activations.append(None)\n    \n    def forward(self, x):\n        BLOCK_SIZE_IN = 128\n        BLOCK_SIZE_OUT = 32\n        \n        for layer, activation in zip(self.layers, self.activations):\n            in_features = layer.weight.size(1)\n            out_features = layer.weight.size(0)\n            \n            out = torch.empty(x.size(0), out_features, device=x.device, dtype=x.dtype)\n            \n            grid = lambda meta: (\n                triton.cdiv(out_features, BLOCK_SIZE_OUT),\n                triton.cdiv(in_features, BLOCK_SIZE_IN),\n            )\n            \n            if activation == 'relu':\n                _linear_relu_forward[grid](\n                    x, \n                    layer.weight, \n                    layer.bias,\n                    out,\n                    in_features,\n                    out_features,\n                    BLOCK_SIZE_IN,\n                    BLOCK_SIZE_OUT\n                )\n            else:\n                _linear_forward[grid](\n                    x, \n                    layer.weight, \n                    layer.bias,\n                    out,\n                    in_features,\n                    out_features,\n                    BLOCK_SIZE_IN,\n                    BLOCK_SIZE_OUT\n                )\n            x = out\n        \n        return x\n\n# Test code\nbatch_size = 1\ninput_size = 1000\nhidden_layer_sizes = [50, 50, 50, 50, 50, 50, 50, 50]\noutput_size = 10\n\ndef get_inputs():\n    return [torch.randn(batch_size, input_size)]\n\ndef get_init_inputs():\n    return [input_size, hidden_layer_sizes, output_size]\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Performs well on compiled (1.0000), Performs well on correctness (1.0000), Performs well on stage (success), Performs well on passed (0.0000), Performs well on score (20.0000), Performs well on speed_up (0.7960), Performs well on runtime_ms (0.2850), Performs well on meta ({'hardware': 'NVIDIA L20Y', 'device': 'cuda:4', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.227, 'speed_up': 0.796, 'custom_timing': 0.285})\n\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 20.0000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport triton\nimport triton.language as tl\nimport math\n\n@triton.jit\ndef linear_kernel(\n    x_ptr,\n    w_ptr,\n    b_ptr,\n    output_ptr,\n    in_size,\n    out_size,\n    batch_size,\n    BLOCK_SIZE_OUT: tl.constexpr,\n    BLOCK_SIZE_K: tl.constexpr,\n):\n    # Calculate block indices\n    pid = tl.program_id(0)\n    num_blocks_per_row = tl.cdiv(out_size, BLOCK_SIZE_OUT)\n    b = pid // num_blocks_per_row\n    j_block = pid % num_blocks_per_row\n    \n    if b >= batch_size:\n        return\n\n    # Calculate output feature indices\n    j_start = j_block * BLOCK_SIZE_OUT\n    offs_j = j_start + tl.arange(0, BLOCK_SIZE_OUT)\n    mask_j = offs_j < out_size\n\n    # Initialize accumulator with bias values\n    bias = tl.load(b_ptr + offs_j, mask=mask_j, other=0.0)\n    acc = bias\n\n    # Process input features in blocks\n    for k in range(0, in_size, BLOCK_SIZE_K):\n        # Load input vector block\n        offs_k = k + tl.arange(0, BLOCK_SIZE_K)\n        mask_k = offs_k < in_size\n        x_val = tl.load(x_ptr + b * in_size + offs_k, mask=mask_k, other=0.0)\n\n        # Load weight block with coalesced access\n        w_ptrs = w_ptr + (offs_k[:, None] * out_size + offs_j[None, :])\n        w_val = tl.load(w_ptrs, mask=mask_k[:, None] & mask_j[None, :], other=0.0)\n\n        # Compute partial dot product\n        partial = tl.sum(w_val * x_val[:, None], axis=0)\n        acc += partial\n\n    # Store results\n    out_ptrs = output_ptr + b * out_size + offs_j\n    tl.store(out_ptrs, acc, mask=mask_j)\n\nclass TritonLinear(nn.Module):\n    def __init__(self, in_features, out_features):\n        super().__init__()\n        self.weight = nn.Parameter(torch.Tensor(out_features, in_features))\n        self.bias = nn.Parameter(torch.Tensor(out_features))\n        self.reset_parameters()\n    \n    def reset_parameters(self):\n        nn.init.kaiming_uniform_(self.weight, a=math.sqrt(5))\n        if self.bias is not None:\n            fan_in, _ = nn.init._calculate_fan_in_and_fan_out(self.weight)\n            bound = 1 / math.sqrt(fan_in) if fan_in > 0 else 0\n            nn.init.uniform_(self.bias, -bound, bound)\n    \n    def forward(self, x):\n        batch_size = x.shape[0]\n        in_size = self.weight.shape[1]\n        out_size = self.weight.shape[0]\n        output = torch.empty(batch_size, out_size, device=x.device, dtype=x.dtype)\n        \n        # Transpose weight matrix for coalesced accesses\n        weight_t = self.weight.t().contiguous()\n        \n        # Configure kernel launch parameters\n        BLOCK_SIZE_OUT = 32  # Optimized for narrow layers\n        BLOCK_SIZE_K = 256   # Larger block for input features\n        num_blocks_per_row = (out_size + BLOCK_SIZE_OUT - 1) // BLOCK_SIZE_OUT\n        grid = (batch_size * num_blocks_per_row,)\n        \n        linear_kernel[grid](\n            x, \n            weight_t, \n            self.bias, \n            output, \n            in_size, \n            out_size, \n            batch_size, \n            BLOCK_SIZE_OUT=BLOCK_SIZE_OUT,\n            BLOCK_SIZE_K=BLOCK_SIZE_K\n        )\n        return output\n\nclass ModelNew(nn.Module):\n    def __init__(self, input_size, hidden_layer_sizes, output_size):\n        super(ModelNew, self).__init__()\n        layers = []\n        current_input_size = input_size\n        \n        for hidden_size in hidden_layer_sizes:\n            layers.append(TritonLinear(current_input_size, hidden_size))\n            layers.append(nn.ReLU())\n            current_input_size = hidden_size\n        \n        layers.append(TritonLinear(current_input_size, output_size))\n        self.network = nn.Sequential(*layers)\n    \n    def forward(self, x):\n        return self.network(x)\n\n# Test code\nbatch_size = 1\ninput_size = 1000\nhidden_layer_sizes = [50, 50, 50, 50, 50, 50, 50, 50]\noutput_size = 10\n\ndef get_inputs():\n    return [torch.randn(batch_size, input_size)]\n\ndef get_init_inputs():\n    return [input_size, hidden_layer_sizes, output_size]\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Alternative approach to compiled, Alternative approach to correctness\n\n\n### Program D2 (Score: 10.0000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport math\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef _linear_forward(\n    x_ptr,\n    w_ptr,\n    b_ptr,\n    out_ptr,\n    in_features,\n    out_features,\n    batch_size,\n    apply_relu: tl.constexpr,\n    BLOCK_SIZE_K: tl.constexpr,\n):\n    pid = tl.program_id(0)\n    b_idx = pid // out_features\n    o_idx = pid % out_features\n\n    if b_idx >= batch_size or o_idx >= out_features:\n        return\n\n    bias = tl.load(b_ptr + o_idx) if b_ptr is not None else 0.0\n    accumulator = 0.0\n    VEC_SIZE = 8\n\n    for k in range(0, in_features, BLOCK_SIZE_K):\n        for v in range(0, BLOCK_SIZE_K, VEC_SIZE):\n            k_offs = k + v + tl.arange(0, VEC_SIZE)\n            v_mask = k_offs < in_features\n            \n            x_ptr_offset = b_idx * in_features + k_offs\n            w_ptr_offset = o_idx * in_features + k_offs\n            \n            x_val = tl.load(x_ptr + x_ptr_offset, mask=v_mask, other=0.0)\n            w_val = tl.load(w_ptr + w_ptr_offset, mask=v_mask, other=0.0)\n            \n            accumulator += tl.sum(x_val * w_val)\n\n    result = accumulator + bias\n    if apply_relu:\n        result = tl.maximum(result, 0.0)\n    \n    tl.store(out_ptr + b_idx * out_features + o_idx, result)\n\nclass ModelNew(nn.Module):\n    def __init__(self, input_size, hidden_layer_sizes, output_size):\n        super(ModelNew, self).__init__()\n        self.layers = nn.ModuleList()\n        self.activations = []\n        \n        current_size = input_size\n        for hidden_size in hidden_layer_sizes:\n            linear = nn.Linear(current_size, hidden_size)\n            self.layers.append(linear)\n            self.activations.append('relu')\n            current_size = hidden_size\n        \n        output_layer = nn.Linear(current_size, output_size)\n        self.layers.append(output_layer)\n        self.activations.append(None)\n    \n    def forward(self, x):\n        batch_size = x.size(0)\n        for layer, activation in zip(self.layers, self.activations):\n            in_features = layer.weight.size(1)\n            out_features = layer.weight.size(0)\n            \n            out = torch.empty(batch_size, out_features, device=x.device, dtype=x.dtype)\n            grid = (batch_size * out_features,)\n            \n            _linear_forward[grid](\n                x, \n                layer.weight, \n                layer.bias,\n                out,\n                in_features,\n                out_features,\n                batch_size,\n                activation == 'relu',\n                BLOCK_SIZE_K=256\n            )\n            x = out\n        \n        return x\n\n# Test code\nbatch_size = 1\ninput_size = 1000\nhidden_layer_sizes = [50, 50, 50, 50, 50, 50, 50, 50]\noutput_size = 10\n\ndef get_inputs():\n    return [torch.randn(batch_size, input_size)]\n\ndef get_init_inputs():\n    return [input_size, hidden_layer_sizes, output_size]\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Alternative approach to compiled, Alternative approach to correctness\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 20.0000, Type: High-Performer)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport triton\nimport triton.language as tl\nimport math\n\n@triton.jit\ndef linear_kernel(\n    x_ptr,\n    w_ptr,\n    b_ptr,\n    output_ptr,\n    in_size,\n    out_size,\n    batch_size,\n    BLOCK_SIZE_OUT: tl.constexpr,\n    BLOCK_SIZE_K: tl.constexpr,\n):\n    # Calculate block indices\n    pid = tl.program_id(0)\n    num_blocks_per_row = tl.cdiv(out_size, BLOCK_SIZE_OUT)\n    b = pid // num_blocks_per_row\n    j_block = pid % num_blocks_per_row\n    \n    if b >= batch_size:\n        return\n\n    # Calculate output feature indices\n    j_start = j_block * BLOCK_SIZE_OUT\n    offs_j = j_start + tl.arange(0, BLOCK_SIZE_OUT)\n    mask_j = offs_j < out_size\n\n    # Initialize accumulator with bias values\n    bias = tl.load(b_ptr + offs_j, mask=mask_j, other=0.0)\n    acc = bias\n\n    # Process input features in blocks\n    for k in range(0, in_size, BLOCK_SIZE_K):\n        # Load input vector block\n        offs_k = k + tl.arange(0, BLOCK_SIZE_K)\n        mask_k = offs_k < in_size\n        x_val = tl.load(x_ptr + b * in_size + offs_k, mask=mask_k, other=0.0)\n\n        # Load weight block with coalesced access\n        w_ptrs = w_ptr + (offs_k[:, None] * out_size + offs_j[None, :])\n        w_val = tl.load(w_ptrs, mask=mask_k[:, None] & mask_j[None, :], other=0.0)\n\n        # Compute partial dot product\n        partial = tl.sum(w_val * x_val[:, None], axis=0)\n        acc += partial\n\n    # Store results\n    out_ptrs = output_ptr + b * out_size + offs_j\n    tl.store(out_ptrs, acc, mask=mask_j)\n\nclass TritonLinear(nn.Module):\n    def __init__(self, in_features, out_features):\n        super().__init__()\n        self.weight = nn.Parameter(torch.Tensor(out_features, in_features))\n        self.bias = nn.Parameter(torch.Tensor(out_features))\n        self.reset_parameters()\n    \n    def reset_parameters(self):\n        nn.init.kaiming_uniform_(self.weight, a=math.sqrt(5))\n        if self.bias is not None:\n            fan_in, _ = nn.init._calculate_fan_in_and_fan_out(self.weight)\n            bound = 1 / math.sqrt(fan_in) if fan_in > 0 else 0\n            nn.init.uniform_(self.bias, -bound, bound)\n    \n    def forward(self, x):\n        batch_size = x.shape[0]\n        in_size = self.weight.shape[1]\n        out_size = self.weight.shape[0]\n        output = torch.empty(batch_size, out_size, device=x.device, dtype=x.dtype)\n        \n        # Transpose weight matrix for coalesced accesses\n        weight_t = self.weight.t().contiguous()\n        \n        # Configure kernel launch parameters\n        BLOCK_SIZE_OUT = 32  # Optimized for narrow layers\n        BLOCK_SIZE_K = 256   # Larger block for input features\n        num_blocks_per_row = (out_size + BLOCK_SIZE_OUT - 1) // BLOCK_SIZE_OUT\n        grid = (batch_size * num_blocks_per_row,)\n        \n        linear_kernel[grid](\n            x, \n            weight_t, \n            self.bias, \n            output, \n            in_size, \n            out_size, \n            batch_size, \n            BLOCK_SIZE_OUT=BLOCK_SIZE_OUT,\n            BLOCK_SIZE_K=BLOCK_SIZE_K\n        )\n        return output\n\nclass ModelNew(nn.Module):\n    def __init__(self, input_size, hidden_layer_sizes, output_size):\n        super(ModelNew, self).__init__()\n        layers = []\n        current_input_size = input_size\n        \n        for hidden_size in hidden_layer_sizes:\n            layers.append(TritonLinear(current_input_size, hidden_size))\n            layers.append(nn.ReLU())\n            current_input_size = hidden_size\n        \n        layers.append(TritonLinear(current_input_size, output_size))\n        self.network = nn.Sequential(*layers)\n    \n    def forward(self, x):\n        return self.network(x)\n\n# Test code\nbatch_size = 1\ninput_size = 1000\nhidden_layer_sizes = [50, 50, 50, 50, 50, 50, 50, 50]\noutput_size = 10\n\ndef get_inputs():\n    return [torch.randn(batch_size, input_size)]\n\ndef get_init_inputs():\n    return [input_size, hidden_layer_sizes, output_size]\n# =================== EVOLVE-BLOCK-END ===================\n```\nUnique approach: Modification: Full rewrite, Excellent compiled (1.000), Excellent correctness (1.000)\n\n\n### Inspiration 2 (Score: 10.0000, Type: High-Performer)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport math\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_SIZE_OUT': 64, 'BLOCK_SIZE_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_OUT': 128, 'BLOCK_SIZE_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_OUT': 128, 'BLOCK_SIZE_K': 128}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_OUT': 64, 'BLOCK_SIZE_K': 128}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_OUT': 256, 'BLOCK_SIZE_K': 64}, num_warps=8),\n        triton.Config({'BLOCK_SIZE_OUT': 256, 'BLOCK_SIZE_K': 128}, num_warps=8),\n    ],\n    key=['in_features', 'out_features'],\n)\n@triton.jit\ndef _linear_relu_forward(\n    x_ptr,\n    w_ptr,\n    b_ptr,\n    out_ptr,\n    in_features,\n    out_features,\n    BLOCK_SIZE_OUT: tl.constexpr,\n    BLOCK_SIZE_K: tl.constexpr,\n):\n    pid = tl.program_id(0)\n    out_offs = pid * BLOCK_SIZE_OUT + tl.arange(0, BLOCK_SIZE_OUT)\n    mask_out = out_offs < out_features\n    \n    acc = tl.zeros((BLOCK_SIZE_OUT,), dtype=tl.float32)\n    \n    for i in range(0, in_features, BLOCK_SIZE_K):\n        k_offs = i + tl.arange(0, BLOCK_SIZE_K)\n        mask_k = k_offs < in_features\n        \n        x = tl.load(x_ptr + k_offs, mask=mask_k, other=0.0)\n        w_ptrs = w_ptr + (out_offs[:, None] * in_features + k_offs[None, :])\n        w = tl.load(w_ptrs, mask=mask_out[:, None] & mask_k[None, :], other=0.0)\n        \n        acc += tl.sum(w * x[None, :], axis=1)\n    \n    if b_ptr is not None:\n        b = tl.load(b_ptr + out_offs, mask=mask_out, other=0.0)\n        acc += b\n    \n    acc = tl.maximum(acc, 0.0)\n    tl.store(out_ptr + out_offs, acc, mask=mask_out)\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_SIZE_OUT': 64, 'BLOCK_SIZE_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_OUT': 128, 'BLOCK_SIZE_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_OUT': 128, 'BLOCK_SIZE_K': 128}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_OUT': 64, 'BLOCK_SIZE_K': 128}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_OUT': 256, 'BLOCK_SIZE_K': 64}, num_warps=8),\n        triton.Config({'BLOCK_SIZE_OUT': 256, 'BLOCK_SIZE_K': 128}, num_warps=8),\n    ],\n    key=['in_features', 'out_features'],\n)\n@triton.jit\ndef _linear_forward(\n    x_ptr,\n    w_ptr,\n    b_ptr,\n    out_ptr,\n    in_features,\n    out_features,\n    BLOCK_SIZE_OUT: tl.constexpr,\n    BLOCK_SIZE_K: tl.constexpr,\n):\n    pid = tl.program_id(0)\n    out_offs = pid * BLOCK_SIZE_OUT + tl.arange(0, BLOCK_SIZE_OUT)\n    mask_out = out_offs < out_features\n    \n    acc = tl.zeros((BLOCK_SIZE_OUT,), dtype=tl.float32)\n    \n    for i in range(0, in_features, BLOCK_SIZE_K):\n        k_offs = i + tl.arange(0, BLOCK_SIZE_K)\n        mask_k = k_offs < in_features\n        \n        x = tl.load(x_ptr + k_offs, mask=mask_k, other=0.0)\n        w_ptrs = w_ptr + (out_offs[:, None] * in_features + k_offs[None, :])\n        w = tl.load(w_ptrs, mask=mask_out[:, None] & mask_k[None, :], other=0.0)\n        \n        acc += tl.sum(w * x[None, :], axis=1)\n    \n    if b_ptr is not None:\n        b = tl.load(b_ptr + out_offs, mask=mask_out, other=0.0)\n        acc += b\n    \n    tl.store(out_ptr + out_offs, acc, mask=mask_out)\n\nclass ModelNew(nn.Module):\n    def __init__(self, input_size, hidden_layer_sizes, output_size):\n        super(ModelNew, self).__init__()\n        self.layers = nn.ModuleList()\n        self.activations = []\n        \n        current_size = input_size\n        for hidden_size in hidden_layer_sizes:\n            linear = nn.Linear(current_size, hidden_size)\n            self.layers.append(linear)\n            self.activations.append('relu')\n            current_size = hidden_size\n        \n        output_layer = nn.Linear(current_size, output_size)\n        self.layers.append(output_layer)\n        self.activations.append(None)\n    \n    def forward(self, x):\n        for layer, activation in zip(self.layers, self.activations):\n            in_features = layer.weight.size(1)\n            out_features = layer.weight.size(0)\n            \n            out = torch.empty(x.size(0), out_features, device=x.device, dtype=x.dtype)\n            \n            grid = lambda meta: (triton.cdiv(out_features, meta['BLOCK_SIZE_OUT']),)\n            \n            if activation == 'relu':\n                _linear_relu_forward[grid](\n                    x, \n                    layer.weight, \n                    layer.bias,\n                    out,\n                    in_features,\n                    out_features,\n                    BLOCK_SIZE_K=triton.next_power_of_2(in_features),\n                )\n            else:\n                _linear_forward[grid](\n                    x, \n                    layer.weight, \n                    layer.bias,\n                    out,\n                    in_features,\n                    out_features,\n                    BLOCK_SIZE_K=triton.next_power_of_2(in_features),\n                )\n            x = out\n        \n        return x\n\n# Test code\nbatch_size = 1\ninput_size = 1000\nhidden_layer_sizes = [50, 50, 50, 50, 50, 50, 50, 50]\noutput_size = 10\n\ndef get_inputs():\n    return [torch.randn(batch_size, input_size)]\n\ndef get_init_inputs():\n    return [input_size, hidden_layer_sizes, output_size]\n# =================== EVOLVE-BLOCK-END ===================\n```\nUnique approach: Modification: Full rewrite, Excellent compiled (1.000), Alternative correctness approach\n\n\n### Inspiration 3 (Score: 20.0000, Type: High-Performer)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport math\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef _linear_forward(\n    x_ptr,\n    w_ptr,\n    b_ptr,\n    out_ptr,\n    in_features,\n    out_features,\n    batch_size,\n    apply_relu: tl.constexpr,\n    BLOCK_SIZE_K: tl.constexpr,\n):\n    pid = tl.program_id(0)\n    b_idx = pid // out_features\n    o_idx = pid % out_features\n\n    if b_idx >= batch_size or o_idx >= out_features:\n        return\n\n    bias = tl.load(b_ptr + o_idx) if b_ptr is not None else 0.0\n    accumulator = 0.0\n\n    for k in range(0, in_features, BLOCK_SIZE_K):\n        k_offs = k + tl.arange(0, BLOCK_SIZE_K)\n        k_mask = k_offs < in_features\n        \n        x_ptr_offset = b_idx * in_features + k_offs\n        w_ptr_offset = o_idx * in_features + k_offs\n        \n        x_val = tl.load(x_ptr + x_ptr_offset, mask=k_mask, other=0.0)\n        w_val = tl.load(w_ptr + w_ptr_offset, mask=k_mask, other=0.0)\n        \n        accumulator += tl.sum(x_val * w_val)\n\n    result = accumulator + bias\n    if apply_relu:\n        result = tl.maximum(result, 0.0)\n    \n    tl.store(out_ptr + b_idx * out_features + o_idx, result)\n\nclass ModelNew(nn.Module):\n    def __init__(self, input_size, hidden_layer_sizes, output_size):\n        super(ModelNew, self).__init__()\n        self.layers = nn.ModuleList()\n        self.activations = []\n        \n        current_size = input_size\n        for hidden_size in hidden_layer_sizes:\n            linear = nn.Linear(current_size, hidden_size)\n            self.layers.append(linear)\n            self.activations.append('relu')\n            current_size = hidden_size\n        \n        output_layer = nn.Linear(current_size, output_size)\n        self.layers.append(output_layer)\n        self.activations.append(None)\n    \n    def forward(self, x):\n        batch_size = x.size(0)\n        for layer, activation in zip(self.layers, self.activations):\n            in_features = layer.weight.size(1)\n            out_features = layer.weight.size(0)\n            \n            out = torch.empty(batch_size, out_features, device=x.device, dtype=x.dtype)\n            grid = (batch_size * out_features,)\n            \n            _linear_forward[grid](\n                x, \n                layer.weight, \n                layer.bias,\n                out,\n                in_features,\n                out_features,\n                batch_size,\n                activation == 'relu',\n                BLOCK_SIZE_K=256\n            )\n            x = out\n        \n        return x\n\n# Test code\nbatch_size = 1\ninput_size = 1000\nhidden_layer_sizes = [50, 50, 50, 50, 50, 50, 50, 50]\noutput_size = 10\n\ndef get_inputs():\n    return [torch.randn(batch_size, input_size)]\n\ndef get_init_inputs():\n    return [input_size, hidden_layer_sizes, output_size]\n# =================== EVOLVE-BLOCK-END ===================\n```\nUnique approach: Modification: Full rewrite, Excellent compiled (1.000), Excellent correctness (1.000)\n\n\n### Inspiration 4 (Score: 10.0000, Type: High-Performer)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport math\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef _linear_forward(\n    x_ptr,\n    w_ptr,\n    b_ptr,\n    out_ptr,\n    in_features,\n    out_features,\n    batch_size,\n    apply_relu: tl.constexpr,\n    BLOCK_SIZE_K: tl.constexpr,\n):\n    pid = tl.program_id(0)\n    b_idx = pid // out_features\n    o_idx = pid % out_features\n\n    if b_idx >= batch_size or o_idx >= out_features:\n        return\n\n    bias = tl.load(b_ptr + o_idx) if b_ptr is not None else 0.0\n    accumulator = 0.0\n    VEC_SIZE = 8\n\n    for k in range(0, in_features, BLOCK_SIZE_K):\n        for v in range(0, BLOCK_SIZE_K, VEC_SIZE):\n            k_offs = k + v + tl.arange(0, VEC_SIZE)\n            v_mask = k_offs < in_features\n            \n            x_ptr_offset = b_idx * in_features + k_offs\n            w_ptr_offset = o_idx * in_features + k_offs\n            \n            x_val = tl.load(x_ptr + x_ptr_offset, mask=v_mask, other=0.0)\n            w_val = tl.load(w_ptr + w_ptr_offset, mask=v_mask, other=0.0)\n            \n            accumulator += tl.sum(x_val * w_val)\n\n    result = accumulator + bias\n    if apply_relu:\n        result = tl.maximum(result, 0.0)\n    \n    tl.store(out_ptr + b_idx * out_features + o_idx, result)\n\nclass ModelNew(nn.Module):\n    def __init__(self, input_size, hidden_layer_sizes, output_size):\n        super(ModelNew, self).__init__()\n        self.layers = nn.ModuleList()\n        self.activations = []\n        \n        current_size = input_size\n        for hidden_size in hidden_layer_sizes:\n            linear = nn.Linear(current_size, hidden_size)\n            self.layers.append(linear)\n            self.activations.append('relu')\n            current_size = hidden_size\n        \n        output_layer = nn.Linear(current_size, output_size)\n        self.layers.append(output_layer)\n        self.activations.append(None)\n    \n    def forward(self, x):\n        batch_size = x.size(0)\n        for layer, activation in zip(self.layers, self.activations):\n            in_features = layer.weight.size(1)\n            out_features = layer.weight.size(0)\n            \n            out = torch.empty(batch_size, out_features, device=x.device, dtype=x.dtype)\n            grid = (batch_size * out_features,)\n            \n            _linear_forward[grid](\n                x, \n                layer.weight, \n                layer.bias,\n                out,\n                in_features,\n                out_features,\n                batch_size,\n                activation == 'relu',\n                BLOCK_SIZE_K=256\n            )\n            x = out\n        \n        return x\n\n# Test code\nbatch_size = 1\ninput_size = 1000\nhidden_layer_sizes = [50, 50, 50, 50, 50, 50, 50, 50]\noutput_size = 10\n\ndef get_inputs():\n    return [torch.randn(batch_size, input_size)]\n\ndef get_init_inputs():\n    return [input_size, hidden_layer_sizes, output_size]\n# =================== EVOLVE-BLOCK-END ===================\n```\nUnique approach: Modification: Full rewrite, Excellent compiled (1.000), Alternative correctness approach\n\n\n### Inspiration 5 (Score: 20.0000, Type: High-Performer)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport math\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef _linear_relu_forward(\n    x_ptr,\n    w_ptr,\n    b_ptr,\n    out_ptr,\n    in_features,\n    out_features,\n    BLOCK_SIZE_IN: tl.constexpr,\n    BLOCK_SIZE_OUT: tl.constexpr,\n):\n    pid_out = tl.program_id(0)\n    pid_in = tl.program_id(1)\n    \n    in_offs = pid_in * BLOCK_SIZE_IN + tl.arange(0, BLOCK_SIZE_IN)\n    out_offs = pid_out * BLOCK_SIZE_OUT + tl.arange(0, BLOCK_SIZE_OUT)\n    \n    in_mask = in_offs < in_features\n    out_mask = out_offs < out_features\n    \n    acc = tl.zeros((BLOCK_SIZE_OUT,), dtype=tl.float32)\n    \n    for i in range(0, tl.cdiv(in_features, BLOCK_SIZE_IN)):\n        in_idx = i * BLOCK_SIZE_IN + tl.arange(0, BLOCK_SIZE_IN)\n        in_mask_cur = in_idx < in_features\n        \n        w_ptrs = w_ptr + (out_offs[:, None] * in_features + in_idx[None, :])\n        x_ptrs = x_ptr + in_idx\n        \n        x = tl.load(x_ptrs, mask=in_mask_cur, other=0.0)\n        w = tl.load(w_ptrs, mask=out_mask[:, None] & in_mask_cur[None, :], other=0.0)\n        \n        acc += tl.sum(x[None, :] * w, axis=1)\n    \n    if b_ptr is not None:\n        b = tl.load(b_ptr + out_offs, mask=out_mask, other=0.0)\n        acc += b\n    \n    acc = tl.maximum(acc, 0.0)\n    tl.store(out_ptr + out_offs, acc, mask=out_mask)\n\n@triton.jit\ndef _linear_forward(\n    x_ptr,\n    w_ptr,\n    b_ptr,\n    out_ptr,\n    in_features,\n    out_features,\n    BLOCK_SIZE_IN: tl.constexpr,\n    BLOCK_SIZE_OUT: tl.constexpr,\n):\n    pid_out = tl.program_id(0)\n    pid_in = tl.program_id(1)\n    \n    in_offs = pid_in * BLOCK_SIZE_IN + tl.arange(0, BLOCK_SIZE_IN)\n    out_offs = pid_out * BLOCK_SIZE_OUT + tl.arange(0, BLOCK_SIZE_OUT)\n    \n    in_mask = in_offs < in_features\n    out_mask = out_offs < out_features\n    \n    acc = tl.zeros((BLOCK_SIZE_OUT,), dtype=tl.float32)\n    \n    for i in range(0, tl.cdiv(in_features, BLOCK_SIZE_IN)):\n        in_idx = i * BLOCK_SIZE_IN + tl.arange(0, BLOCK_SIZE_IN)\n        in_mask_cur = in_idx < in_features\n        \n        w_ptrs = w_ptr + (out_offs[:, None] * in_features + in_idx[None, :])\n        x_ptrs = x_ptr + in_idx\n        \n        x = tl.load(x_ptrs, mask=in_mask_cur, other=0.0)\n        w = tl.load(w_ptrs, mask=out_mask[:, None] & in_mask_cur[None, :], other=0.0)\n        \n        acc += tl.sum(x[None, :] * w, axis=1)\n    \n    if b_ptr is not None:\n        b = tl.load(b_ptr + out_offs, mask=out_mask, other=0.0)\n        acc += b\n    \n    tl.store(out_ptr + out_offs, acc, mask=out_mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, input_size, hidden_layer_sizes, output_size):\n        super(ModelNew, self).__init__()\n        self.layers = nn.ModuleList()\n        self.activations = []\n        \n        current_size = input_size\n        for hidden_size in hidden_layer_sizes:\n            linear = nn.Linear(current_size, hidden_size)\n            self.layers.append(linear)\n            self.activations.append('relu')\n            current_size = hidden_size\n        \n        output_layer = nn.Linear(current_size, output_size)\n        self.layers.append(output_layer)\n        self.activations.append(None)\n    \n    def forward(self, x):\n        BLOCK_SIZE_IN = 128\n        BLOCK_SIZE_OUT = 32\n        \n        for layer, activation in zip(self.layers, self.activations):\n            in_features = layer.weight.size(1)\n            out_features = layer.weight.size(0)\n            \n            out = torch.empty(x.size(0), out_features, device=x.device, dtype=x.dtype)\n            \n            grid = lambda meta: (\n                triton.cdiv(out_features, BLOCK_SIZE_OUT),\n                triton.cdiv(in_features, BLOCK_SIZE_IN),\n            )\n            \n            if activation == 'relu':\n                _linear_relu_forward[grid](\n                    x, \n                    layer.weight, \n                    layer.bias,\n                    out,\n                    in_features,\n                    out_features,\n                    BLOCK_SIZE_IN,\n                    BLOCK_SIZE_OUT\n                )\n            else:\n                _linear_forward[grid](\n                    x, \n                    layer.weight, \n                    layer.bias,\n                    out,\n                    in_features,\n                    out_features,\n                    BLOCK_SIZE_IN,\n                    BLOCK_SIZE_OUT\n                )\n            x = out\n        \n        return x\n\n# Test code\nbatch_size = 1\ninput_size = 1000\nhidden_layer_sizes = [50, 50, 50, 50, 50, 50, 50, 50]\noutput_size = 10\n\ndef get_inputs():\n    return [torch.randn(batch_size, input_size)]\n\ndef get_init_inputs():\n    return [input_size, hidden_layer_sizes, output_size]\n# =================== EVOLVE-BLOCK-END ===================\n```\nUnique approach: Modification: Full rewrite, Excellent compiled (1.000), Excellent correctness (1.000)\n\n\n\n# Current Program\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport math\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef _linear_forward(\n    x_ptr,\n    w_ptr,\n    b_ptr,\n    out_ptr,\n    in_features,\n    out_features,\n    batch_size,\n    apply_relu: tl.constexpr,\n    BLOCK_SIZE_K: tl.constexpr,\n):\n    pid = tl.program_id(0)\n    b_idx = pid // out_features\n    o_idx = pid % out_features\n\n    if b_idx >= batch_size or o_idx >= out_features:\n        return\n\n    bias = tl.load(b_ptr + o_idx) if b_ptr is not None else 0.0\n    accumulator = 0.0\n\n    for k in range(0, in_features, BLOCK_SIZE_K):\n        k_offs = k + tl.arange(0, BLOCK_SIZE_K)\n        k_mask = k_offs < in_features\n        \n        x_ptr_offset = b_idx * in_features + k_offs\n        w_ptr_offset = o_idx * in_features + k_offs\n        \n        x_val = tl.load(x_ptr + x_ptr_offset, mask=k_mask, other=0.0)\n        w_val = tl.load(w_ptr + w_ptr_offset, mask=k_mask, other=0.0)\n        \n        accumulator += tl.sum(x_val * w_val)\n\n    result = accumulator + bias\n    if apply_relu:\n        result = tl.maximum(result, 0.0)\n    \n    tl.store(out_ptr + b_idx * out_features + o_idx, result)\n\nclass ModelNew(nn.Module):\n    def __init__(self, input_size, hidden_layer_sizes, output_size):\n        super(ModelNew, self).__init__()\n        self.layers = nn.ModuleList()\n        self.activations = []\n        \n        current_size = input_size\n        for hidden_size in hidden_layer_sizes:\n            linear = nn.Linear(current_size, hidden_size)\n            self.layers.append(linear)\n            self.activations.append('relu')\n            current_size = hidden_size\n        \n        output_layer = nn.Linear(current_size, output_size)\n        self.layers.append(output_layer)\n        self.activations.append(None)\n    \n    def forward(self, x):\n        batch_size = x.size(0)\n        for layer, activation in zip(self.layers, self.activations):\n            in_features = layer.weight.size(1)\n            out_features = layer.weight.size(0)\n            \n            out = torch.empty(batch_size, out_features, device=x.device, dtype=x.dtype)\n            grid = (batch_size * out_features,)\n            \n            _linear_forward[grid](\n                x, \n                layer.weight, \n                layer.bias,\n                out,\n                in_features,\n                out_features,\n                batch_size,\n                activation == 'relu',\n                BLOCK_SIZE_K=256\n            )\n            x = out\n        \n        return x\n\n# Test code\nbatch_size = 1\ninput_size = 1000\nhidden_layer_sizes = [50, 50, 50, 50, 50, 50, 50, 50]\noutput_size = 10\n\ndef get_inputs():\n    return [torch.randn(batch_size, input_size)]\n\ndef get_init_inputs():\n    return [input_size, hidden_layer_sizes, output_size]\n# =================== EVOLVE-BLOCK-END ===================\n```\n\n# Task\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```\n", "responses": ["<think>\nWe are given the current program which uses a Triton kernel for linear layers with ReLU activation.\n The current performance shows a speed_up of 0.799 (which is less than 1, meaning slower than reference).\n We are to improve the performance (speed_up) while maintaining correctness.\n\n The current kernel uses a 1D grid of size (batch_size * out_features). Each program computes one output element.\n It loads a block of input features (BLOCK_SIZE_K) and the corresponding weights, then accumulates the dot product.\n\n Potential issues with the current approach:\n   - The memory access pattern for the weight matrix is not coalesced because each program (output element) accesses a contiguous block of weights for one output feature. However, when multiple programs (in the same warp) are accessing different output features, they are accessing non-contiguous memory locations in the weight matrix. This can lead to poor memory bandwidth utilization.\n\n   - The current kernel does not use vectorized loads/stores.\n\n   - The current kernel does not utilize shared memory or tensor cores.\n\n   - The block size (BLOCK_SIZE_K=256) might not be optimal.\n\n Proposed improvements:\n  1. Change the memory access pattern to be more coalesced. One common approach is to transpose the weight matrix so that the access to the weight matrix is contiguous for a warp. However, note that the current kernel accesses the weight matrix by rows (each output feature is a row). If we transpose the weight matrix, then we can access the weight matrix by columns and then use a reduction across the input features.\n\n  2. Alternatively, we can restructure the kernel to have each program compute a block of output features for one example (or a block of examples and a block of output features). This would allow more efficient memory access.\n\n  3. We note that the hidden layers are very narrow (50 features). The current grid has (batch_size * out_features) programs. With batch_size=1 and out_features=50, that's 50 programs. This is very small and might not fully utilize the GPU. We should try to have more parallelism.\n\n  4. We can try to use a block-wise approach where each block computes multiple output features for multiple examples. However, given the narrow layers, it might be better to have each warp compute multiple output features for one example.\n\n  5. We can also try to use vectorized loads to load multiple elements at a time.\n\n  6. Since the current kernel is slow (speed_up < 1), we need to make significant changes.\n\n After reviewing the inspiration programs, note that the \"Inspiration 1\" (TritonLinear) uses a different approach:\n   - It transposes the weight matrix so that the access to the weight matrix is contiguous (each program accesses a contiguous block of weights for a set of output features).\n   - It uses a grid of (batch_size * num_blocks_per_row), where num_blocks_per_row = ceil(out_features / BLOCK_SIZE_OUT). Each program computes a block of output features for one example.\n\n We can adopt this approach. Steps for the kernel in Inspiration 1:\n\n   pid = program_id(0)\n   num_blocks_per_row = ceil(out_features / BLOCK_SIZE_OUT)\n   b = pid // num_blocks_per_row   # batch index\n   j_block = pid % num_blocks_per_row  # block index in the output features\n\n   Then, the program computes the output features from [j_block * BLOCK_SIZE_OUT, (j_block+1)*BLOCK_SIZE_OUT) for the example `b`.\n\n   It initializes the accumulator with the bias for that block of features.\n\n   Then, it iterates over the input features in blocks of size BLOCK_SIZE_K. For each block:\n        - Loads a block of input features for example `b` (contiguous, so coalesced).\n        - Loads a block of weights (of size [BLOCK_SIZE_K, BLOCK_SIZE_OUT]) from the transposed weight matrix. The weight block is stored in a contiguous memory region (because we transposed and then stored in row-major for the transposed matrix) so that the access is coalesced.\n        - Does a matrix-vector product (actually, the input block is a vector of length BLOCK_SIZE_K, and the weight block is a matrix of [BLOCK_SIZE_K, BLOCK_SIZE_OUT], so the product is a vector of length BLOCK_SIZE_OUT).\n\n   Then, it stores the result.\n\n However, note that the original weight matrix in the linear layer is of shape [out_features, in_features]. We transpose it to [in_features, out_features] so that we can access a block of weights for multiple output features contiguously.\n\n We will create a new kernel using this approach.\n\n Steps to change the current program:\n\n  1. Replace the kernel with the one from Inspiration 1 (with adjustments for ReLU).\n  2. Change the ModelNew's forward method to use the transposed weight and the new kernel.\n\n But note: The current program uses the same kernel for both ReLU and non-ReLU layers. We have to conditionally apply ReLU. However, in the new kernel we are going to write, we can pass a flag for ReLU.\n\n  3. We must also adjust the grid configuration.\n\n However, note that the current program has multiple layers (with ReLU activation for hidden layers and none for the output). We are going to write a kernel that conditionally applies ReLU.\n\n Let's design the kernel:\n\n   We'll call it `linear_kernel` and it will have an `apply_relu` argument.\n\n   The kernel will have the following parameters:\n        x_ptr, w_ptr, b_ptr, output_ptr, in_size, out_size, batch_size, apply_relu, BLOCK_SIZE_OUT, BLOCK_SIZE_K\n\n   We note that the weight matrix we pass is the transposed one (shape [in_features, out_features]).\n\n   We can do:\n\n        if apply_relu:\n            result = tl.maximum(acc, 0.0)\n\n  4. In the forward pass, for each layer, we will:\n        - Transpose the weight matrix (and make it contiguous) for that layer.\n        - Compute the grid as (batch_size * num_blocks_per_row, ) where num_blocks_per_row = ceil(out_features / BLOCK_SIZE_OUT)\n\n  5. We must choose BLOCK_SIZE_OUT and BLOCK_SIZE_K. Since the hidden layers are only 50 features, we can set BLOCK_SIZE_OUT to 32 (or 64, but 50 is less than 64) and BLOCK_SIZE_K to 256.\n\n  6. We also note that the input tensor `x` for the next layer is the output of the previous layer. We don't need to change that.\n\n  7. We must be cautious: the current kernel in Inspiration 1 does not apply ReLU. We will add that.\n\n  8. Also, the current kernel in Inspiration 1 does not condition on the activation. We will add the `apply_relu` condition.\n\n  9. We note that the original kernel in Inspiration 1 did not have the ReLU condition. We are adding it.\n\n Let's write the new kernel:\n\n   We'll keep the same kernel structure as in Inspiration 1, but add the ReLU step at the end.\n\n   Steps in the kernel:\n\n        pid = ...\n        ... (as above)\n\n        # Initialize accumulator with bias (for the block of output features)\n        bias = tl.load(b_ptr + offs_j, mask=mask_j, other=0.0)\n        acc = bias\n\n        for k in ...:\n            ... (load input block and weight block)\n            partial = tl.sum(w_val * x_val[:, None], axis=0)\n            acc += partial\n\n        if apply_relu:\n            acc = tl.maximum(acc, 0.0)\n\n        tl.store(...)\n\n 10. We must also adjust the TritonLinear class? Actually, in the current program we don't have a TritonLinear class. We are using the standard nn.Linear and then calling the kernel in the forward. We will continue to do so, but we will transpose the weight matrix for the kernel call.\n\n 11. We must be cautious: the current program uses the same kernel for all layers. We are replacing the kernel with a new one that expects a transposed weight matrix.\n\n 12. We will change the kernel call in the forward pass to pass the transposed weight.\n\n 13. We note that the weight matrix of the linear layer is of shape [out_features, in_features]. We need to transpose it to [in_features, out_features] and make it contiguous.\n\n Implementation in the forward pass:\n\n        weight_t = layer.weight.t().contiguous()\n\n        Then call the kernel with weight_t.\n\n 14. We also note that the kernel uses two block sizes: BLOCK_SIZE_OUT and BLOCK_SIZE_K. We will set them as tunable parameters. For now, we can set:\n        BLOCK_SIZE_OUT = 32   (because 50 is small, and 32 is the next power of two below 50, but we can also use 64 and mask the extra)\n        BLOCK_SIZE_K = 256\n\n 15. We must adjust the grid: grid = (batch_size * num_blocks_per_row, ) where num_blocks_per_row = (out_features + BLOCK_SIZE_OUT - 1) // BLOCK_SIZE_OUT\n\n 16. We will keep the same kernel for both ReLU and non-ReLU, controlled by the `apply_relu` flag.\n\n 17. We must update the kernel to conditionally apply ReLU.\n\n 18. We note that the current kernel does not have the `apply_relu` argument. We will add it.\n\n 19. We also note that the kernel in Inspiration 1 did not have the batch_size as an explicit argument? Actually, it did. It had `batch_size` and used it to check bounds.\n\n 20. We will write the kernel accordingly.\n\n Let's rewrite the kernel and the forward method accordingly.\n\n Since the problem requires that we only output the code within the EVOLVE-BLOCK, we will write the entire block.\n\n We are going to replace the current kernel and the forward method of ModelNew to use the new kernel.\n\n However, note that the current program has a test code at the bottom. We must leave that unchanged.\n\n We are going to:\n\n   - Replace the kernel function.\n   - In the forward method of ModelNew, for each layer, we will:\n        - Compute the transposed weight.\n        - Compute the grid as (batch_size * num_blocks_per_row, )\n        - Call the new kernel with the transposed weight and the new parameters.\n\n   - We will set BLOCK_SIZE_OUT to 32 and BLOCK_SIZE_K to 256.\n\n   - We will conditionally apply ReLU in the kernel.\n\n But note: the current program has a batch dimension. The kernel in Inspiration 1 uses the batch index to load the input.\n\n Let's write the new code.\n\n IMPORTANT: We must not change the class name (ModelNew) and the test code.\n\n We are going to output the entire code block within the EVOLVE-BLOCK markers.\n</think>\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport math\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef linear_kernel(\n    x_ptr,\n    w_ptr,\n    b_ptr,\n    output_ptr,\n    in_size,\n    out_size,\n    batch_size,\n    apply_relu: tl.constexpr,\n    BLOCK_SIZE_OUT: tl.constexpr,\n    BLOCK_SIZE_K: tl.constexpr,\n):\n    pid = tl.program_id(0)\n    num_blocks_per_row = tl.cdiv(out_size, BLOCK_SIZE_OUT)\n    b_idx = pid // num_blocks_per_row\n    j_block = pid % num_blocks_per_row\n    \n    if b_idx >= batch_size:\n        return\n\n    j_start = j_block * BLOCK_SIZE_OUT\n    offs_j = j_start + tl.arange(0, BLOCK_SIZE_OUT)\n    mask_j = offs_j < out_size\n\n    bias = tl.load(b_ptr + offs_j, mask=mask_j, other=0.0)\n    acc = bias\n\n    for k in range(0, in_size, BLOCK_SIZE_K):\n        offs_k = k + tl.arange(0, BLOCK_SIZE_K)\n        mask_k = offs_k < in_size\n        \n        x_val = tl.load(x_ptr + b_idx * in_size + offs_k, mask=mask_k, other=0.0)\n        \n        w_ptrs = w_ptr + (offs_k[:, None] * out_size + offs_j[None, :])\n        w_val = tl.load(w_ptrs, mask=mask_k[:, None] & mask_j[None, :], other=0.0)\n        \n        partial = tl.sum(w_val * x_val[:, None], axis=0)\n        acc += partial\n\n    if apply_relu:\n        acc = tl.maximum(acc, 0.0)\n    \n    tl.store(output_ptr + b_idx * out_size + offs_j, acc, mask=mask_j)\n\nclass ModelNew(nn.Module):\n    def __init__(self, input_size, hidden_layer_sizes, output_size):\n        super(ModelNew, self).__init__()\n        self.layers = nn.ModuleList()\n        self.activations = []\n        \n        current_size = input_size\n        for hidden_size in hidden_layer_sizes:\n            linear = nn.Linear(current_size, hidden_size)\n            self.layers.append(linear)\n            self.activations.append('relu')\n            current_size = hidden_size\n        \n        output_layer = nn.Linear(current_size, output_size)\n        self.layers.append(output_layer)\n        self.activations.append(None)\n    \n    def forward(self, x):\n        batch_size = x.size(0)\n        for layer, activation in zip(self.layers, self.activations):\n            in_features = layer.weight.size(1)\n            out_features = layer.weight.size(0)\n            \n            out = torch.empty(batch_size, out_features, device=x.device, dtype=x.dtype)\n            weight_t = layer.weight.t().contiguous()\n            \n            BLOCK_SIZE_OUT = 32\n            num_blocks_per_row = (out_features + BLOCK_SIZE_OUT - 1) // BLOCK_SIZE_OUT\n            grid = (batch_size * num_blocks_per_row,)\n            \n            linear_kernel[grid](\n                x, \n                weight_t, \n                layer.bias,\n                out,\n                in_features,\n                out_features,\n                batch_size,\n                activation == 'relu',\n                BLOCK_SIZE_OUT=BLOCK_SIZE_OUT,\n                BLOCK_SIZE_K=256\n            )\n            x = out\n        \n        return x\n\n# Test code\nbatch_size = 1\ninput_size = 1000\nhidden_layer_sizes = [50, 50, 50, 50, 50, 50, 50, 50]\noutput_size = 10\n\ndef get_inputs():\n    return [torch.randn(batch_size, input_size)]\n\ndef get_init_inputs():\n    return [input_size, hidden_layer_sizes, output_size]\n# =================== EVOLVE-BLOCK-END ===================\n```"]}}}