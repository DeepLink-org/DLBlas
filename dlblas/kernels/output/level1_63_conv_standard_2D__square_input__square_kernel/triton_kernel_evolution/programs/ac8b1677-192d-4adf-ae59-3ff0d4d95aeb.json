{"id": "ac8b1677-192d-4adf-ae59-3ff0d4d95aeb", "code": "# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport triton\nimport triton.language as tl\nimport math\n\nclass ModelNew(torch.nn.Module):\n    def __init__(self, in_channels: int, out_channels: int, kernel_size: int, \n                 stride: int = 1, padding: int = 0, dilation: int = 1, \n                 groups: int = 1, bias: bool = False):\n        super().__init__()\n        self.in_channels = in_channels\n        self.out_channels = out_channels\n        self.kernel_size = kernel_size\n        self.stride = stride\n        self.padding = padding\n        self.dilation = dilation\n        self.groups = groups\n        \n        self.weight = torch.nn.Parameter(\n            torch.empty(out_channels, in_channels, kernel_size, kernel_size)\n        )\n        if bias:\n            self.bias = torch.nn.Parameter(torch.empty(out_channels))\n        else:\n            self.register_parameter('bias', None)\n            \n        self.reset_parameters()\n        \n    def reset_parameters(self):\n        torch.nn.init.kaiming_uniform_(self.weight, a=math.sqrt(5))\n        if self.bias is not None:\n            fan_in, _ = torch.nn.init._calculate_fan_in_and_fan_out(self.weight)\n            bound = 1 / math.sqrt(fan_in)\n            torch.nn.init.uniform_(self.bias, -bound, bound)\n    \n    def forward(self, x: torch.Tensor) -> torch.Tensor:\n        batch_size, _, in_h, in_w = x.shape\n        out_h = (in_h + 2 * self.padding - self.dilation * (self.kernel_size - 1) - 1) // self.stride + 1\n        out_w = (in_w + 2 * self.padding - self.dilation * (self.kernel_size - 1) - 1) // self.stride + 1\n        output = torch.empty((batch_size, self.out_channels, out_h, out_w), \n                             device=x.device, dtype=x.dtype)\n        \n        # Compute grid size with combined spatial dimension\n        grid_batch = batch_size\n        grid_oc = triton.cdiv(self.out_channels, 32)\n        grid_spatial = triton.cdiv(out_h * out_w, 256)\n        grid = (grid_batch, grid_oc, grid_spatial)\n        \n        # Launch kernel with optimized inner loop\n        _conv2d_forward_kernel[grid](\n            x, self.weight, output,\n            self.stride, self.padding, self.dilation,\n            batch_size, self.in_channels, self.out_channels, \n            in_h, in_w, out_h, out_w,\n            self.kernel_size,\n            x.stride(0), x.stride(1), x.stride(2), x.stride(3),\n            self.weight.stride(0), self.weight.stride(1), self.weight.stride(2), self.weight.stride(3),\n            output.stride(0), output.stride(1), output.stride(2), output.stride(3),\n            BLOCK_OC=32, BLOCK_SPATIAL=256, BLOCK_IC=32\n        )\n        \n        if self.bias is not None:\n            output += self.bias.view(1, -1, 1, 1)\n            \n        return output\n\n@triton.jit\ndef _conv2d_forward_kernel(\n    input_ptr, weight_ptr, output_ptr,\n    stride, padding, dilation,\n    batch_size, in_channels, out_channels, \n    in_h, in_w, out_h, out_w,\n    kernel_size,\n    stride_b, stride_ic, stride_h, stride_w,\n    stride_oc, stride_ic_w, stride_kh, stride_kw,\n    stride_ob, stride_oc_out, stride_oh, stride_ow,\n    BLOCK_OC: tl.constexpr, BLOCK_SPATIAL: tl.constexpr, BLOCK_IC: tl.constexpr,\n):\n    pid_b = tl.program_id(0)\n    pid_oc = tl.program_id(1)\n    pid_s = tl.program_id(2)\n    \n    # Compute spatial block index\n    spatial_size = out_h * out_w\n    spatial_start = pid_s * BLOCK_SPATIAL\n    spatial_offsets = spatial_start + tl.arange(0, BLOCK_SPATIAL)\n    spatial_mask = spatial_offsets < spatial_size\n    \n    # Compute oh and ow indices\n    ow = spatial_offsets % out_w\n    oh = spatial_offsets // out_w\n    \n    # Compute starting indices for channels\n    oc_start = pid_oc * BLOCK_OC\n    oc_offsets = oc_start + tl.arange(0, BLOCK_OC)\n    oc_mask = oc_offsets < out_channels\n    \n    # Initialize accumulator\n    acc = tl.zeros((BLOCK_OC, BLOCK_SPATIAL), dtype=tl.float32)\n    \n    # Precompute input positions for kernel offsets\n    h_base = oh * stride - padding\n    w_base = ow * stride - padding\n    \n    # Loop over kernel height and width\n    for kh in range(kernel_size):\n        for kw in range(kernel_size):\n            # Compute input positions with dilation\n            h = h_base + kh * dilation\n            w = w_base + kw * dilation\n            \n            # Create boundary mask\n            h_mask = (h >= 0) & (h < in_h)\n            w_mask = (w >= 0) & (w < in_w)\n            spatial_kernel_mask = spatial_mask & h_mask & w_mask\n            \n            # Loop over input channels in blocks\n            for ic in range(0, in_channels, BLOCK_IC):\n                ic_offsets = ic + tl.arange(0, BLOCK_IC)\n                ic_mask = ic_offsets < in_channels\n                \n                # Load input block: [BLOCK_IC, BLOCK_SPATIAL]\n                input_offsets = (\n                    pid_b * stride_b +\n                    ic_offsets[:, None] * stride_ic +\n                    h[None, :] * stride_h +\n                    w[None, :] * stride_w\n                )\n                input_val = tl.load(\n                    input_ptr + input_offsets,\n                    mask=ic_mask[:, None] & spatial_kernel_mask[None, :],\n                    other=0.0\n                )\n                \n                # Load weight block: [BLOCK_OC, BLOCK_IC]\n                weight_offsets = (\n                    oc_offsets[:, None] * stride_oc +\n                    ic_offsets[None, :] * stride_ic_w +\n                    kh * stride_kh +\n                    kw * stride_kw\n                )\n                weight_val = tl.load(\n                    weight_ptr + weight_offsets,\n                    mask=oc_mask[:, None] & ic_mask[None, :],\n                    other=0.0\n                )\n                \n                # Matrix multiplication using tensor cores\n                acc += tl.dot(weight_val, input_val, allow_tf32=True)\n    \n    # Prepare output offsets\n    output_offsets = (\n        pid_b * stride_ob +\n        oc_offsets[:, None] * stride_oc_out +\n        oh[None, :] * stride_oh +\n        ow[None, :] * stride_ow\n    )\n    \n    # Store results with boundary mask\n    store_mask = oc_mask[:, None] & spatial_mask[None, :]\n    tl.store(output_ptr + output_offsets, acc, mask=store_mask)\n\n# Test code\nbatch_size = 16\nin_channels = 3\nout_channels = 64\nkernel_size = 3\nwidth = 256\nheight = 256\n\ndef get_inputs():\n    x = torch.randn(batch_size, in_channels, height, width)\n    return [x]\n\ndef get_init_inputs():\n    return [in_channels, out_channels, kernel_size]\n# =================== EVOLVE-BLOCK-END ===================", "language": "python", "parent_id": "85171a61-d691-41ab-824c-f778f949ba4f", "generation": 3, "timestamp": 1754644666.6091897, "iteration_found": 18, "metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": false, "score": 20, "speed_up": 0.006, "runtime_ms": 6.67, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:4", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.0418, "speed_up": 0.006, "custom_timing": 6.67}}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": false, "score": 20, "speed_up": 0.033, "runtime_ms": 1.25, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:2", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.0418, "speed_up": 0.033, "custom_timing": 1.25}}, "island": 1}, "artifacts_json": null, "artifact_dir": null}