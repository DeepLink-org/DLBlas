{"id": "7f87af5d-9bdb-43de-968a-2a9e6d633eeb", "code": "# ================== EVOLVE-BLOCK-START ==================\nimport math\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef _conv_forward_kernel(\n    input_ptr, weight_ptr, bias_ptr, output_ptr,\n    inner_dim, out_channels, out_height, out_width, \n    height, width, stride_h, stride_w, padding_h, padding_w, \n    dilation_h, dilation_w, kernel_h, kernel_w,\n    input_batch_stride, input_channel_stride, input_height_stride, input_width_stride,\n    weight_inner_stride, weight_out_stride,\n    output_batch_stride, output_channel_stride, output_height_stride, output_width_stride,\n    has_bias: tl.constexpr,\n    BLOCK_OC: tl.constexpr, BLOCK_K: tl.constexpr\n):\n    pid = tl.program_id(0)\n    pid_oc_block = tl.program_id(1)\n    \n    out_hw = out_height * out_width\n    batch_idx = pid // out_hw\n    hw_idx = pid % out_hw\n    oh = hw_idx // out_width\n    ow = hw_idx % out_width\n    \n    oc_offsets = pid_oc_block * BLOCK_OC + tl.arange(0, BLOCK_OC)\n    oc_mask = oc_offsets < out_channels\n    \n    acc = tl.zeros((BLOCK_OC,), dtype=tl.float32)\n    kernel_inner = kernel_h * kernel_w\n    \n    for k in range(0, inner_dim, BLOCK_K):\n        k_offsets = k + tl.arange(0, BLOCK_K)\n        k_mask = k_offsets < inner_dim\n        \n        c_in = k_offsets // kernel_inner\n        khw = k_offsets % kernel_inner\n        kh = khw // kernel_w\n        kw = khw % kernel_w\n        \n        i = oh * stride_h - padding_h + kh * dilation_h\n        j = ow * stride_w - padding_w + kw * dilation_w\n        \n        in_bounds = (i >= 0) & (i < height) & (j >= 0) & (j < width)\n        input_offsets = batch_idx * input_batch_stride + c_in * input_channel_stride + i * input_height_stride + j * input_width_stride\n        input_vals = tl.load(input_ptr + input_offsets, mask=k_mask & in_bounds, other=0.0)\n        \n        weight_offsets = k_offsets[:, None] * weight_inner_stride + oc_offsets[None, :]\n        weight_vals = tl.load(\n            weight_ptr + weight_offsets, \n            mask=k_mask[:, None] & oc_mask[None, :], \n            other=0.0\n        )\n        \n        acc += tl.sum(input_vals[:, None] * weight_vals, axis=0)\n    \n    if has_bias:\n        bias_vals = tl.load(bias_ptr + oc_offsets, mask=oc_mask, other=0.0)\n        acc += bias_vals\n    \n    output_offsets = batch_idx * output_batch_stride + oc_offsets * output_channel_stride + oh * output_height_stride + ow * output_width_stride\n    tl.store(output_ptr + output_offsets, acc, mask=oc_mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_channels: int, out_channels: int, kernel_size: tuple, stride: tuple = (1, 1), \n                 padding: tuple = (0, 0), dilation: tuple = (1, 1), groups: int = 1, bias: bool = False):\n        super(ModelNew, self).__init__()\n        if groups != 1:\n            raise ValueError(\"Only groups=1 is supported\")\n            \n        self.in_channels = in_channels\n        self.out_channels = out_channels\n        self.kernel_size = kernel_size\n        self.stride = stride\n        self.padding = padding\n        self.dilation = dilation\n        \n        self.weight = nn.Parameter(torch.empty(out_channels, in_channels, *kernel_size))\n        if bias:\n            self.bias = nn.Parameter(torch.empty(out_channels))\n        else:\n            self.register_parameter('bias', None)\n            \n        nn.init.kaiming_uniform_(self.weight, a=math.sqrt(5))\n        if self.bias is not None:\n            fan_in, _ = nn.init._calculate_fan_in_and_fan_out(self.weight)\n            bound = 1 / math.sqrt(fan_in) if fan_in > 0 else 0\n            nn.init.uniform_(self.bias, -bound, bound)\n        \n    def forward(self, x: torch.Tensor) -> torch.Tensor:\n        _, _, height, width = x.shape\n        out_height = (height + 2*self.padding[0] - self.dilation[0]*(self.kernel_size[0]-1) - 1) // self.stride[0] + 1\n        out_width = (width + 2*self.padding[1] - self.dilation[1]*(self.kernel_size[1]-1) - 1) // self.stride[1] + 1\n        \n        inner_dim = self.in_channels * self.kernel_size[0] * self.kernel_size[1]\n        weight_2d = self.weight.reshape(self.out_channels, inner_dim).t().contiguous()\n        \n        output = torch.empty((x.size(0), self.out_channels, out_height, out_width), \n                            device=x.device, dtype=x.dtype)\n        \n        input_strides = x.stride()\n        output_strides = output.stride()\n        weight_strides = weight_2d.stride()\n        \n        grid1 = x.size(0) * out_height * out_width\n        grid2 = triton.cdiv(self.out_channels, 16)\n        \n        _conv_forward_kernel[(grid1, grid2)](\n            x, weight_2d, self.bias if self.bias is not None else None, output,\n            inner_dim, self.out_channels, out_height, out_width, \n            height, width, self.stride[0], self.stride[1], \n            self.padding[0], self.padding[1], self.dilation[0], self.dilation[1], \n            self.kernel_size[0], self.kernel_size[1],\n            input_strides[0], input_strides[1], input_strides[2], input_strides[3],\n            weight_strides[0], weight_strides[1],\n            output_strides[0], output_strides[1], output_strides[2], output_strides[3],\n            has_bias=(self.bias is not None),\n            BLOCK_OC=16, BLOCK_K=16\n        )\n        \n        return output\n\n# Test code\nbatch_size = 16\nin_channels = 3\nout_channels = 64\nkernel_size = (3, 5)  # Asymmetric kernel\nheight = 256\nwidth = 128  # Asymmetric input dimensions\n\ndef get_inputs():\n    x = torch.randn(batch_size, in_channels, height, width)\n    return [x]\n\ndef get_init_inputs():\n    return [in_channels, out_channels, kernel_size]  # Provide in_channels, out_channels, kernel_size for initialization\n# =================== EVOLVE-BLOCK-END ===================", "language": "python", "parent_id": "d527d2cb-73c6-4ed2-b384-04e62e256355", "generation": 3, "timestamp": 1754645131.407093, "iteration_found": 29, "metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": false, "score": 20, "speed_up": 0.038, "runtime_ms": 4.1, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:4", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.155, "speed_up": 0.038, "custom_timing": 4.1}}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": false, "score": 20, "speed_up": 0.038, "runtime_ms": 4.12, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:1", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.155, "speed_up": 0.038, "custom_timing": 4.12}}, "island": 1}, "artifacts_json": null, "artifact_dir": null}