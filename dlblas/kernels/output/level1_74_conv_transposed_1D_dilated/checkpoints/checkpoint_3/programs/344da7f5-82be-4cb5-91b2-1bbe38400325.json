{"id": "344da7f5-82be-4cb5-91b2-1bbe38400325", "code": "# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_channels: int, out_channels: int, kernel_size: int, stride: int = 1, padding: int = 0, dilation: int = 1, bias: bool = False):\n        super(ModelNew, self).__init__()\n        self.in_channels = in_channels\n        self.out_channels = out_channels\n        self.kernel_size = kernel_size\n        self.stride = stride\n        self.padding = padding\n        self.dilation = dilation\n        \n        # Initialize weights and bias\n        self.weight = nn.Parameter(torch.empty(in_channels, out_channels, kernel_size))\n        if bias:\n            self.bias = nn.Parameter(torch.empty(out_channels))\n        else:\n            self.register_parameter('bias', None)\n            \n        # Initialize parameters\n        nn.init.kaiming_uniform_(self.weight, a=math.sqrt(5))\n        if self.bias is not None:\n            fan_in, _ = nn.init._calculate_fan_in_and_fan_out(self.weight)\n            bound = 1 / math.sqrt(fan_in) if fan_in > 0 else 0\n            nn.init.uniform_(self.bias, -bound, bound)\n    \n    def forward(self, x: torch.Tensor) -> torch.Tensor:\n        batch_size, _, length = x.shape\n        # Compute output length\n        output_length = (length - 1) * self.stride - 2 * self.padding + self.dilation * (self.kernel_size - 1) + 1\n        output = torch.zeros(batch_size, self.out_channels, output_length, device=x.device, dtype=x.dtype)\n        \n        # Launch Triton kernel\n        grid = lambda meta: (triton.cdiv(output_length, meta['BLOCK_SIZE']), batch_size, self.out_channels)\n        \n        @triton.jit\n        def conv_transpose_kernel(\n            x_ptr, weight_ptr, output_ptr,\n            in_channels, out_channels, kernel_size, stride, padding, dilation, length, output_length,\n            BLOCK_SIZE: tl.constexpr\n        ):\n            # Parallelize over output channels, batches, and output length\n            pid_b = tl.program_id(1)\n            pid_oc = tl.program_id(2)\n            pid_ol = tl.program_id(0)\n            \n            # Offsets for output length dimension\n            ol_offsets = pid_ol * BLOCK_SIZE + tl.arange(0, BLOCK_SIZE)\n            ol_mask = ol_offsets < output_length\n            \n            # Initialize accumulator\n            acc = tl.zeros(BLOCK_SIZE, dtype=tl.float32)\n            \n            # Iterate over input channels\n            for ic in range(in_channels):\n                # Load kernel weights for this input channel and output channel\n                w_offsets = ic * out_channels * kernel_size + pid_oc * kernel_size + tl.arange(0, kernel_size)\n                weights = tl.load(weight_ptr + w_offsets, mask=tl.arange(0, kernel_size) < kernel_size)\n                \n                # Iterate over kernel positions\n                for k in range(kernel_size):\n                    # Compute corresponding input positions\n                    input_pos = (ol_offsets - k * dilation + padding) // stride\n                    valid = (ol_offsets - k * dilation + padding) % stride == 0\n                    in_bounds = (input_pos >= 0) & (input_pos < length)\n                    mask = valid & in_bounds & ol_mask\n                    \n                    # Load input values\n                    x_offsets = pid_b * in_channels * length + ic * length + input_pos\n                    x_vals = tl.load(x_ptr + x_offsets, mask=mask, other=0.0)\n                    \n                    # Accumulate\n                    acc += x_vals * weights[k]\n            \n            # Store results\n            output_offsets = pid_b * out_channels * output_length + pid_oc * output_length + ol_offsets\n            tl.store(output_ptr + output_offsets, acc, mask=ol_mask)\n        \n        # Launch kernel\n        conv_transpose_kernel[grid](\n            x, self.weight, output,\n            self.in_channels, self.out_channels, self.kernel_size, self.stride, self.padding, self.dilation, length, output_length,\n            BLOCK_SIZE=128\n        )\n        \n        # Add bias if present\n        if self.bias is not None:\n            output += self.bias.view(1, -1, 1)\n            \n        return output\n\n# Test code\nbatch_size = 16\nin_channels = 3\nout_channels = 64\nkernel_size = 5\nlength = 256\nstride = 1\npadding = 0\ndilation = 3\n\ndef get_inputs():\n    x = torch.randn(batch_size, in_channels, length)\n    return [x]\n\ndef get_init_inputs():\n    return [in_channels, out_channels, kernel_size, stride, padding, dilation]\n# =================== EVOLVE-BLOCK-END ===================", "language": "python", "parent_id": "927e0d6d-bfeb-477e-a470-241000fd5ff2", "generation": 1, "timestamp": 1754646798.0295942, "iteration_found": 2, "metrics": {"compiled": false, "correctness": false, "score": 1, "stage": "compile_error", "compile_log": "name 'math' is not defined\nTraceback (most recent call last):\n  File \"/cpfs01/shared/llm_kernel/hujiakai/KernelLLM/validation_api_server/evaluator.py\", line 173, in _verification_worker\n    result: KernelExecResult = eval_kernel_against_ref(\n  File \"/cpfs01/shared/llm_kernel/hujiakai/KernelLLM/validation_api_server/helpers/evaluations.py\", line 484, in eval_kernel_against_ref\n    custom_model = ModelNew(*init_args, **init_kwargs)\n  File \"/tmp/tmp82do41gf.py\", line 25, in __init__\n    nn.init.kaiming_uniform_(self.weight, a=math.sqrt(5))\nNameError: name 'math' is not defined\n", "exec_log": "[Child] \u7ed1\u5b9a GPU 4, torch sees 1 device(s)\n\n[Exception]\nTraceback (most recent call last):\n  File \"/cpfs01/shared/llm_kernel/hujiakai/KernelLLM/validation_api_server/code_executor.py\", line 77, in _exec_worker\n    raise RuntimeError(\nRuntimeError: \u7f3a\u5c11 Model / get_init_inputs / get_inputs \u5b9a\u4e49\uff0c\u65e0\u6cd5 KernelBench\n", "exit_code": "1"}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": true, "correctness": true, "stage": "reference code", "passed": false, "score": 0.0, "speed_up": 1.0, "runtime_ms": 0.0491, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:0", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.0612, "speed_up": 1.246, "custom_timing": 0.0491}}, "island": 0}, "artifacts_json": null, "artifact_dir": null}