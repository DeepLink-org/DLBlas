{"id": "47756ace-c23f-421c-a345-71ebf1698842", "code": "# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport triton\nimport triton.language as tl\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_SIZE': 1024, 'VEC_SIZE': 4}, num_warps=4),\n        triton.Config({'BLOCK_SIZE': 2048, 'VEC_SIZE': 4}, num_warps=4),\n        triton.Config({'BLOCK_SIZE': 4096, 'VEC_SIZE': 4}, num_warps=8),\n        triton.Config({'BLOCK_SIZE': 8192, 'VEC_SIZE': 8}, num_warps=8),\n        triton.Config({'BLOCK_SIZE': 16384, 'VEC_SIZE': 16}, num_warps=8),\n    ],\n    key=['n_elements'],\n)\n@triton.jit\ndef relu6_kernel(\n    x_ptr,\n    output_ptr,\n    n_elements,\n    BLOCK_SIZE: tl.constexpr,\n    VEC_SIZE: tl.constexpr,\n):\n    pid = tl.program_id(axis=0)\n    block_start = pid * BLOCK_SIZE\n    # Process in vectors\n    for i in range(0, BLOCK_SIZE, VEC_SIZE):\n        vec_offsets = block_start + i + tl.arange(0, VEC_SIZE)\n        vec_mask = vec_offsets < n_elements\n        x_vec = tl.load(x_ptr + vec_offsets, mask=vec_mask, other=0.0)\n        # Efficient clamping using min/max\n        x_vec = tl.maximum(x_vec, 0.0)\n        x_vec = tl.minimum(x_vec, 6.0)\n        tl.store(output_ptr + vec_offsets, x_vec, mask=vec_mask)\n\ndef relu6_triton(x):\n    output = torch.empty_like(x)\n    n_elements = output.numel()\n    grid = lambda meta: (triton.cdiv(n_elements, meta['BLOCK_SIZE']),)\n    relu6_kernel[grid](x, output, n_elements)\n    return output\n\nclass ModelNew(nn.Module):\n    def __init__(self, num_classes=1000):\n        super(ModelNew, self).__init__()\n        self.conv1 = nn.Conv2d(3, 32, kernel_size=3, stride=2, padding=1, bias=False)\n        self.bn1 = nn.BatchNorm2d(32)\n        \n        self.blocks = nn.Sequential(\n            MBConv(32, 16, kernel_size=3, stride=1, expand_ratio=1),\n            MBConv(16, 24, kernel_size=3, stride=2, expand_ratio=6),\n            MBConv(24, 24, kernel_size=3, stride=1, expand_ratio=6),\n            MBConv(24, 40, kernel_size=5, stride=2, expand_ratio=6),\n            MBConv(40, 40, kernel_size=5, stride=1, expand_ratio=6),\n            MBConv(40, 80, kernel_size=3, stride=2, expand_ratio=6),\n            MBConv(80, 80, kernel_size=3, stride=1, expand_ratio=6),\n            MBConv(80, 112, kernel_size=5, stride=1, expand_ratio=6),\n            MBConv(112, 112, kernel_size=5, stride=1, expand_ratio=6),\n            MBConv(112, 192, kernel_size=5, stride=2, expand_ratio=6),\n            MBConv(192, 192, kernel_size=5, stride=1, expand_ratio=6),\n            MBConv(192, 192, kernel_size=5, stride=1, expand_ratio=6),\n            MBConv(192, 320, kernel_size=3, stride=1, expand_ratio=6)\n        )\n        \n        self.conv2 = nn.Conv2d(320, 1280, kernel_size=1, stride=1, padding=0, bias=False)\n        self.bn2 = nn.BatchNorm2d(1280)\n        self.fc = nn.Linear(1280, num_classes)\n    \n    def forward(self, x):\n        x = F.relu(self.bn1(self.conv1(x)))\n        x = self.blocks(x)\n        x = F.relu(self.bn2(self.conv2(x)))\n        x = F.adaptive_avg_pool2d(x, (1, 1))\n        x = x.view(x.size(0), -1)\n        x = self.fc(x)\n        return x\n\nclass MBConv(nn.Module):\n    def __init__(self, in_channels, out_channels, kernel_size, stride, expand_ratio):\n        super(MBConv, self).__init__()\n        self.use_residual = (stride == 1 and in_channels == out_channels)\n        hidden_dim = in_channels * expand_ratio\n        \n        if expand_ratio != 1:\n            self.expand_conv = nn.Sequential(\n                nn.Conv2d(in_channels, hidden_dim, kernel_size=1, stride=1, padding=0, bias=False),\n                nn.BatchNorm2d(hidden_dim)\n            )\n        \n        self.depthwise_conv = nn.Sequential(\n            nn.Conv2d(hidden_dim, hidden_dim, kernel_size=kernel_size, stride=stride, \n                     padding=(kernel_size-1)//2, groups=hidden_dim, bias=False),\n            nn.BatchNorm2d(hidden_dim)\n        )\n        \n        self.project_conv = nn.Sequential(\n            nn.Conv2d(hidden_dim, out_channels, kernel_size=1, stride=1, padding=0, bias=False),\n            nn.BatchNorm2d(out_channels)\n        )\n    \n    def forward(self, x):\n        identity = x\n        \n        if hasattr(self, 'expand_conv'):\n            x = self.expand_conv(x)\n            x = relu6_triton(x)\n        \n        x = self.depthwise_conv(x)\n        x = relu6_triton(x)\n        x = self.project_conv(x)\n        \n        if self.use_residual:\n            x += identity\n        \n        return x\n\nbatch_size = 10\nnum_classes = 1000\n\ndef get_inputs():\n    return [torch.randn(batch_size, 3, 224, 224)]\n\ndef get_init_inputs():\n    return [num_classes]\n# =================== EVOLVE-BLOCK-END ===================", "language": "python", "parent_id": "ab65e931-3d57-4deb-b6b1-a6774f892dca", "generation": 2, "timestamp": 1754591610.7206354, "iteration_found": 21, "metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": false, "score": 20, "speed_up": 0.653, "runtime_ms": 3.78, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:3", "correctness_trials": "(5 / 5)", "reference_timing_ms": 2.47, "speed_up": 0.653, "custom_timing": 3.78}}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": true, "correctness": false, "score": 10, "stage": "wrong_answer", "verify_payload": {"id": "level3_22_EfficientNetB0", "result": {"compiled": true, "correctness": false, "metadata": {"hardware": "NVIDIA L20Y", "device": "cuda:7", "max_difference": ["0.620679", "0.462164", "nan", "nan", "nan"], "avg_difference": ["0.077530", "0.075703", "nan", "nan", "nan"], "correctness_issue": "Output mismatch", "correctness_trials": "(0 / 5)", "reference_timing_ms": 2.47, "speed_up": -1.0, "custom_timing": -1.0}, "runtime": -1.0, "runtime_stats": {}}}}, "island": 1}, "artifacts_json": null, "artifact_dir": null}