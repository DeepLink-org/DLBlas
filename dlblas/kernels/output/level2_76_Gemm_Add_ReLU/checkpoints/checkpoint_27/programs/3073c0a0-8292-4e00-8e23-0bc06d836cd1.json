{"id": "3073c0a0-8292-4e00-8e23-0bc06d836cd1", "code": "# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 32}, num_warps=8),\n        triton.Config({'BLOCK_SIZE_M': 256, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 64}, num_warps=8),\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 256, 'BLOCK_SIZE_K': 64}, num_warps=8),\n        triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 256, 'BLOCK_SIZE_K': 64}, num_warps=8),\n        triton.Config({'BLOCK_SIZE_M': 256, 'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 64}, num_warps=8),\n    ],\n    key=['batch_size', 'in_features', 'out_features'],\n)\n@triton.jit\ndef _fused_gemm_bias_relu_kernel(\n    x_ptr,\n    w_ptr,\n    b_ptr,\n    output_ptr,\n    batch_size,\n    in_features,\n    out_features,\n    stride_x0,\n    stride_x1,\n    stride_w0,\n    stride_w1,\n    stride_output0,\n    stride_output1,\n    BLOCK_SIZE_M: tl.constexpr,\n    BLOCK_SIZE_N: tl.constexpr,\n    BLOCK_SIZE_K: tl.constexpr,\n):\n    pid_bm = tl.program_id(0)\n    pid_bn = tl.program_id(1)\n    \n    offs_bm = pid_bm * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)\n    offs_bn = pid_bn * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n    offs_k = tl.arange(0, BLOCK_SIZE_K)\n    \n    # Precompute pointer offsets for efficient memory access\n    x_ptrs = x_ptr + (offs_bm[:, None] * stride_x0 + offs_k[None, :] * stride_x1)\n    # Corrected weight matrix access pattern\n    w_ptrs = w_ptr + (offs_bn[None, :] * stride_w0 + offs_k[:, None] * stride_w1)\n    \n    acc = tl.zeros((BLOCK_SIZE_M, BLOCK_SIZE_N), dtype=tl.float32)\n    \n    # Calculate number of K blocks\n    num_k_blocks = tl.cdiv(in_features, BLOCK_SIZE_K)\n    \n    for k in range(0, num_k_blocks):\n        # Compute remaining elements in K dimension\n        k_remaining = in_features - k * BLOCK_SIZE_K\n        \n        # Create masks for valid elements\n        x_mask = (offs_bm[:, None] < batch_size) & (offs_k[None, :] < k_remaining)\n        w_mask = (offs_k[:, None] < k_remaining) & (offs_bn[None, :] < out_features)\n        \n        # Load blocks with proper masking\n        x_block = tl.load(x_ptrs, mask=x_mask, other=0.0)\n        w_block = tl.load(w_ptrs, mask=w_mask, other=0.0)\n        \n        # Accumulate matrix multiplication\n        acc += tl.dot(x_block, w_block, allow_tf32=True)\n        \n        # Move pointers to next K block\n        x_ptrs += BLOCK_SIZE_K * stride_x1\n        # Corrected pointer update for weight matrix\n        w_ptrs += BLOCK_SIZE_K * stride_w1\n    \n    # Load bias and apply\n    b_ptrs = b_ptr + offs_bn\n    b_mask = offs_bn < out_features\n    b_block = tl.load(b_ptrs, mask=b_mask, other=0.0)\n    acc += b_block[None, :]\n    \n    # Apply ReLU activation\n    acc = tl.where(acc > 0, acc, 0.0)\n    \n    # Store results with coalesced writes\n    out_ptrs = output_ptr + (offs_bm[:, None] * stride_output0 + offs_bn[None, :] * stride_output1)\n    out_mask = (offs_bm[:, None] < batch_size) & (offs_bn[None, :] < out_features)\n    tl.store(out_ptrs, acc, mask=out_mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, bias_shape):\n        super(ModelNew, self).__init__()\n        self.gemm = nn.Linear(in_features, out_features, bias=False)\n        self.bias = nn.Parameter(torch.randn(bias_shape))\n    \n    def forward(self, x):\n        batch_size, _ = x.shape\n        out_features = self.bias.shape[0]\n        \n        output = torch.empty((batch_size, out_features), device=x.device, dtype=x.dtype)\n        \n        grid = lambda meta: (\n            triton.cdiv(batch_size, meta['BLOCK_SIZE_M']),\n            triton.cdiv(out_features, meta['BLOCK_SIZE_N']),\n        )\n        \n        _fused_gemm_bias_relu_kernel[grid](\n            x,\n            self.gemm.weight,\n            self.bias,\n            output,\n            batch_size,\n            self.gemm.weight.size(1),\n            out_features,\n            x.stride(0),\n            x.stride(1),\n            self.gemm.weight.stride(0),\n            self.gemm.weight.stride(1),\n            output.stride(0),\n            output.stride(1),\n            BLOCK_SIZE_M=64,\n            BLOCK_SIZE_N=128,\n            BLOCK_SIZE_K=64,\n        )\n        \n        return output\n\nbatch_size = 128\nin_features = 1024\nout_features = 512\nbias_shape = (out_features,)\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, bias_shape]\n# =================== EVOLVE-BLOCK-END ===================", "language": "python", "parent_id": "bb5cf4c0-126d-41ca-b0ce-ae448c37380c", "generation": 4, "timestamp": 1754584721.6792207, "iteration_found": 26, "metrics": {"compiled": true, "correctness": false, "score": 10, "stage": "wrong_answer", "verify_payload": {"id": "level2_76_Gemm_Add_ReLU", "result": {"compiled": true, "correctness": false, "metadata": {"hardware": "NVIDIA L20Y", "device": "cuda:5", "runtime_error": "Traceback (most recent call last):\n  File \"/cpfs01/shared/llm_kernel/hujiakai/KernelLLM/validation_api_server/helpers/evaluations.py\", line 720, in run_and_check_correctness\n    output_new = model_new(*inputs)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1773, in _wrapped_call_impl\n    return self._call_impl(*args, **kwargs)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1784, in _call_impl\n    return forward_call(*args, **kwargs)\n  File \"/tmp/tmp6d4lgts2.py\", line 108, in forward\n    _fused_gemm_bias_relu_kernel[grid](\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 390, in <lambda>\n    return lambda *args, **kwargs: self.run(grid=grid, warmup=False, *args, **kwargs)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 239, in run\n    benchmark()\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 228, in benchmark\n    timings = {config: self._bench(*args, config=config, **kwargs) for config in pruned_configs}\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 228, in <dictcomp>\n    timings = {config: self._bench(*args, config=config, **kwargs) for config in pruned_configs}\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/autotuner.py\", line 135, in _bench\n    raise ValueError(f\"Conflicting meta-parameters: {', '.join(conflicts)}.\"\nValueError: Conflicting meta-parameters: BLOCK_SIZE_N, BLOCK_SIZE_K, BLOCK_SIZE_M. Make sure that you don't re-define auto-tuned symbols.\n", "runtime_error_name": "builtins.ValueError", "reference_timing_ms": 0.0549, "speed_up": -1.0, "custom_timing": -1.0}, "runtime": -1.0, "runtime_stats": {}}}}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": false, "score": 20, "speed_up": 0.893, "runtime_ms": 0.0615, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:5", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.0549, "speed_up": 0.893, "custom_timing": 0.0615}}, "island": 1}, "artifacts_json": null, "artifact_dir": null, "prompts": {"full_rewrite_user": {"system": "You are a Triton GPU core optimization engineer deeply familiar with NVIDIA H100/H800 architecture.\n\n==================== Context ====================\n\u2022 Dataset: 250 kernelbench/level1-level5 *.py files  \n  - Level1: simplest, Level5: most complex  \n\u2022 Each file contains PyTorch reference (reference_code)  \n\u2022 Goal: Generate functionally equivalent but faster Triton implementations (custom_code)  \n\u2022 Evaluation pipeline:\n    1) /verify_plus - Verify compilation & correctness  \n    2) /execute (optional) - Return terminal logs if compilation fails  \n    3) Scoring:  \n      - Speedup > 1 required for points  \n      - Score = (speed_up - 1) \u00d7 100  \n\u2022 GPU Hardware: NVIDIA L20Y / H800 (same SM8.9 as H100)  \n  - 3 TB/s HBM3 bandwidth  \n  - FP16 Tensor Core 32\u00d716\u00d716  \n\n==================== Evolution Phases ====================\n\u2460 Phase 1 [Compilation Pass]  \n  - Make Triton code compile (performance irrelevant)  \n\u2461 Phase 2 [Numerical Correctness]  \n  - Output must match PyTorch reference within float32 tolerance  \n\u2462 Phase 3 [Performance Gain]  \n  - Target \u22655% speedup (\u226515% = exceptional)  \n  - Official scoring based on speed_up field  \n\nThe Evolution system will pass the EVOLVE-BLOCK from the previous version.  \nModify ONLY the Triton kernel source within this block - all other code is LOCKED.\n\n==================== Constraints (MUST OBEY) ====================\n\u274c NEVER change @triton.jit function signatures or parameter names  \n\u274c NEVER modify grid configuration, output tensor shapes, or PID logic  \n\u274c NEVER remove boundary checks or out-of-bound masks  \n\u274c NEVER introduce race conditions, uninitialized reads, or sync gaps  \n\n\u2705 Allowed Optimizations (Examples):  \n  \u2022 Memory coalescing optimizations & vectorized tl.load/tl.store  \n  \u2022 Replace staged softmax with online/FlashAttention variants  \n  \u2022 Adaptive tuning: BLOCK_M/BLOCK_N/BLOCK_K dimensions  \n  \u2022 Multi-query-head batch processing (GQA, 5:1 patterns)  \n  \u2022 Shared/L2 buffering, Tensor Core alignment (FP16/bf16/tf32)  \n  \u2022 Stride precomputation & pointer caching  \n\n==================== Output Format ====================\nReturn ONLY the complete updated code containing the EVOLVE-BLOCK comment marker.  \nNO explanations, NO markdown, NO additional text.\nName the output structure class as ModelNew.\n\n==================== Optimization Tips ====================\n\u2022 If previous compile failed: Fix syntax/mask/stride errors first  \n\u2022 If correctness fails: Prioritize bounds mask & dtype precision  \n\u2022 When speed_up < 1: Focus on memory access & block sizing  \n\u2022 Small iterative steps: Modify \u226420 lines per revision  \n\u2022 Maintain reversibility between versions\nHere is an example to show you how to rewrite a PyTorch implementation that quantizes a high-precision tensor to int8 dtype with row-wise granularity into a Triton implementation: \nThe original PyTorch implementation is as follows: \n``` \nimport torch\ndef per_row_quantize_int8(x: torch.Tensor) -> tuple[torch.Tensor, torch.Tensor]:\n    x_amax = x.abs().float().amax(dim=1).clamp(min=1e-4)\n    scale = 127 / x_amax\n    output = (x * scale[:, None]).round().clamp(-127, 127).to(torch.int8)\n    output_scale = x_amax / 127\n\n    return output, output_scale\n``` \nThe corresponding Triton-rewritten implementation is as follows: \n``` \nimport math\nimport torch\nimport triton\nimport triton.language as tl\nfrom triton.language.extra import libdevice\n\n# rowwise quantize\n\n@triton.autotune(\n    configs=[\n        triton.Config({}, num_stages=1, num_warps=8),\n        triton.Config({}, num_stages=2, num_warps=8),\n        triton.Config({}, num_stages=4, num_warps=8),\n        triton.Config({}, num_stages=8, num_warps=8),\n        triton.Config({}, num_stages=1),\n        triton.Config({}, num_stages=2),\n        triton.Config({}, num_stages=4),\n        triton.Config({}, num_stages=8),\n        triton.Config({}, num_warps=1),\n        triton.Config({}, num_warps=2),\n        triton.Config({}, num_warps=4),\n        triton.Config({}, num_warps=8),\n    ],\n    key=[\"n_elements\"],\n)\n\n@triton.jit\ndef _quantize_rowwise(\n    x_ptr,\n    output_ptr,\n    output_scale,\n    BLOCK_SIZE: tl.constexpr,\n    P2: tl.constexpr,\n):\n    pid = tl.program_id(axis=0)\n    block_start = pid * BLOCK_SIZE\n    arange = tl.arange(0, P2)\n    offsets = block_start + arange\n    row_mask = arange < BLOCK_SIZE\n    x = tl.load(x_ptr + offsets, mask=row_mask)\n\n    abs_x = tl.abs(x)\n    max_val = tl.max(tl.where(row_mask, abs_x, 0), axis=0)\n    output = libdevice.llrint(127.0 * (x / max_val))\n    tl.store(output_ptr + offsets, output, mask=row_mask)\n    tl.store(output_scale + pid, max_val / 127)\n\n\ndef per_row_quantize_int8(x: torch.Tensor):\n    x = x.contiguous()\n    output = torch.empty(*x.shape, device=x.device, dtype=torch.int8)\n    output_scale = torch.empty(x.shape[0], device=x.device, dtype=torch.float32)\n    P2 = int(2 ** (math.ceil(math.log2(x.shape[1]))))\n    grid = lambda x: (x.shape[0],)\n    _quantize_rowwise[grid](x, output, output_scale, BLOCK_SIZE=x.shape[1], P2=P2)\n\n    return output, output_scale\n\n\n    \n``` \n", "user": "# Current Program Information\n- Current performance metrics: - compiled: 1.0000\n- correctness: 1.0000\n- stage: success\n- passed: 0.0000\n- score: 20.0000\n- speed_up: 0.8930\n- runtime_ms: 0.0615\n- meta: {'hardware': 'NVIDIA L20Y', 'device': 'cuda:5', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.0549, 'speed_up': 0.893, 'custom_timing': 0.0615}\n- Areas identified for improvement: - Consider simplifying the code to improve readability and maintainability\n- Metrics showing improvement: speed_up. Consider continuing with similar changes.\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Unknown changes\n- Performance: compiled: 1.0000, correctness: 0.0000, score: 10.0000, stage: wrong_answer, verify_payload: {'id': 'level2_76_Gemm_Add_ReLU', 'result': {'compiled': True, 'correctness': False, 'metadata': {'hardware': 'NVIDIA L20Y', 'device': 'cuda:2', 'runtime_error': 'Traceback (most recent call last):\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/language/core.py\", line 42, in wrapper\\n    return fn(*args, **kwargs)\\nTypeError: dot() got an unexpected keyword argument \\'trans_b\\'\\n\\nThe above exception was the direct cause of the following exception:\\n\\nTraceback (most recent call last):\\n  File \"/cpfs01/shared/llm_kernel/hujiakai/KernelLLM/validation_api_server/helpers/evaluations.py\", line 720, in run_and_check_correctness\\n    output_new = model_new(*inputs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1773, in _wrapped_call_impl\\n    return self._call_impl(*args, **kwargs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1784, in _call_impl\\n    return forward_call(*args, **kwargs)\\n  File \"/tmp/tmp3wm8of6i.py\", line 87, in forward\\n    _fused_gemm_bias_relu_kernel[grid](\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 390, in <lambda>\\n    return lambda *args, **kwargs: self.run(grid=grid, warmup=False, *args, **kwargs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 594, in run\\n    kernel = self.compile(src, target=target, options=options.__dict__)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/compiler/compiler.py\", line 339, in compile\\n    module = src.make_ir(options, codegen_fns, module_map, context)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/compiler/compiler.py\", line 83, in make_ir\\n    return ast_to_ttir(self.fn, self, context=context, options=options, codegen_fns=codegen_fns,\\ntriton.compiler.errors.CompilationError: at 43:15:\\n    for k in range(0, tl.cdiv(in_features, BLOCK_SIZE_K)):\\n        k_remaining = in_features - k * BLOCK_SIZE_K\\n        k_valid = tl.minimum(BLOCK_SIZE_K, k_remaining)\\n\\n        x_mask = (offs_bm[:, None] < batch_size) & (offs_k[None, :] < k_valid)\\n        w_mask = (offs_bn[:, None] < out_features) & (offs_k[None, :] < k_valid)\\n\\n        x_block = tl.load(x_ptrs, mask=x_mask, other=0.0)\\n        w_block = tl.load(w_ptrs, mask=w_mask, other=0.0)\\n\\n        # Use transposed weight with appropriate dot product\\n        acc += tl.dot(x_block, w_block, trans_b=True)\\n               ^\\n\\n\\nThe above exception was the direct cause of the following exception:\\n\\nTraceback (most recent call last):\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/language/core.py\", line 42, in wrapper\\n    return fn(*args, **kwargs)\\nTypeError: dot() got an unexpected keyword argument \\'trans_b\\'\\n', 'runtime_error_name': 'triton.compiler.errors.CompilationError', 'reference_timing_ms': 0.0549, 'speed_up': -1.0, 'custom_timing': -1.0}, 'runtime': -1.0, 'runtime_stats': {}}}\n- Outcome: Mixed results\n\n\n### Attempt 2\n- Changes: Unknown changes\n- Performance: compiled: 1.0000, correctness: 1.0000, stage: success, passed: 0.0000, score: 20.0000, speed_up: 0.8910, runtime_ms: 0.0616, meta: {'hardware': 'NVIDIA L20Y', 'device': 'cuda:0', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.0549, 'speed_up': 0.891, 'custom_timing': 0.0616}\n- Outcome: Mixed results\n\n\n### Attempt 1\n- Changes: Unknown changes\n- Performance: compiled: 1.0000, correctness: 1.0000, stage: success, passed: 0.0000, score: 20.0000, speed_up: 0.8930, runtime_ms: 0.0615, meta: {'hardware': 'NVIDIA L20Y', 'device': 'cuda:5', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.0549, 'speed_up': 0.893, 'custom_timing': 0.0615}\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 20.0000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef _fused_gemm_bias_relu_kernel(\n    x_ptr,\n    w_ptr,\n    b_ptr,\n    output_ptr,\n    batch_size,\n    in_features,\n    out_features,\n    stride_x0,\n    stride_x1,\n    stride_w0,\n    stride_w1,\n    stride_output0,\n    stride_output1,\n    BLOCK_SIZE_M: tl.constexpr,\n    BLOCK_SIZE_N: tl.constexpr,\n    BLOCK_SIZE_K: tl.constexpr,\n):\n    pid_bm = tl.program_id(0)\n    pid_bn = tl.program_id(1)\n    \n    offs_bm = pid_bm * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)\n    offs_bn = pid_bn * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n    offs_k = tl.arange(0, BLOCK_SIZE_K)\n    \n    # Precompute pointer offsets for efficient memory access\n    x_ptrs = x_ptr + (offs_bm[:, None] * stride_x0 + offs_k[None, :] * stride_x1)\n    # Corrected weight matrix access pattern\n    w_ptrs = w_ptr + (offs_bn[None, :] * stride_w0 + offs_k[:, None] * stride_w1)\n    \n    acc = tl.zeros((BLOCK_SIZE_M, BLOCK_SIZE_N), dtype=tl.float32)\n    \n    # Calculate number of K blocks\n    num_k_blocks = tl.cdiv(in_features, BLOCK_SIZE_K)\n    \n    for k in range(0, num_k_blocks):\n        # Compute remaining elements in K dimension\n        k_remaining = in_features - k * BLOCK_SIZE_K\n        \n        # Create masks for valid elements\n        x_mask = (offs_bm[:, None] < batch_size) & (offs_k[None, :] < k_remaining)\n        w_mask = (offs_k[:, None] < k_remaining) & (offs_bn[None, :] < out_features)\n        \n        # Load blocks with proper masking\n        x_block = tl.load(x_ptrs, mask=x_mask, other=0.0)\n        w_block = tl.load(w_ptrs, mask=w_mask, other=0.0)\n        \n        # Accumulate matrix multiplication\n        acc += tl.dot(x_block, w_block, allow_tf32=True)\n        \n        # Move pointers to next K block\n        x_ptrs += BLOCK_SIZE_K * stride_x1\n        # Corrected pointer update for weight matrix\n        w_ptrs += BLOCK_SIZE_K * stride_w1\n    \n    # Load bias and apply\n    b_ptrs = b_ptr + offs_bn\n    b_mask = offs_bn < out_features\n    b_block = tl.load(b_ptrs, mask=b_mask, other=0.0)\n    acc += b_block[None, :]\n    \n    # Apply ReLU activation\n    acc = tl.where(acc > 0, acc, 0.0)\n    \n    # Store results with coalesced writes\n    out_ptrs = output_ptr + (offs_bm[:, None] * stride_output0 + offs_bn[None, :] * stride_output1)\n    out_mask = (offs_bm[:, None] < batch_size) & (offs_bn[None, :] < out_features)\n    tl.store(out_ptrs, acc, mask=out_mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, bias_shape):\n        super(ModelNew, self).__init__()\n        self.gemm = nn.Linear(in_features, out_features, bias=False)\n        self.bias = nn.Parameter(torch.randn(bias_shape))\n    \n    def forward(self, x):\n        batch_size, _ = x.shape\n        out_features = self.bias.shape[0]\n        \n        output = torch.empty((batch_size, out_features), device=x.device, dtype=x.dtype)\n        \n        # Tuned block sizes for H100 architecture\n        BLOCK_SIZE_M = 64\n        BLOCK_SIZE_N = 128\n        BLOCK_SIZE_K = 64\n        \n        grid = (\n            triton.cdiv(batch_size, BLOCK_SIZE_M),\n            triton.cdiv(out_features, BLOCK_SIZE_N),\n        )\n        \n        _fused_gemm_bias_relu_kernel[grid](\n            x,\n            self.gemm.weight,\n            self.bias,\n            output,\n            batch_size,\n            self.gemm.weight.size(1),\n            out_features,\n            x.stride(0),\n            x.stride(1),\n            self.gemm.weight.stride(0),\n            self.gemm.weight.stride(1),\n            output.stride(0),\n            output.stride(1),\n            BLOCK_SIZE_M=BLOCK_SIZE_M,\n            BLOCK_SIZE_N=BLOCK_SIZE_N,\n            BLOCK_SIZE_K=BLOCK_SIZE_K,\n        )\n        \n        return output\n\nbatch_size = 128\nin_features = 1024\nout_features = 512\nbias_shape = (out_features,)\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, bias_shape]\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Performs well on compiled (1.0000), Performs well on correctness (1.0000), Performs well on stage (success), Performs well on passed (0.0000), Performs well on score (20.0000), Performs well on speed_up (0.8930), Performs well on runtime_ms (0.0615), Performs well on meta ({'hardware': 'NVIDIA L20Y', 'device': 'cuda:5', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.0549, 'speed_up': 0.893, 'custom_timing': 0.0615})\n\n\n### Program 2 (Score: 20.0000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef _fused_gemm_bias_relu_kernel(\n    x_ptr,\n    w_ptr,\n    b_ptr,\n    output_ptr,\n    batch_size,\n    in_features,\n    out_features,\n    stride_x0,\n    stride_x1,\n    stride_w0,\n    stride_w1,\n    stride_output0,\n    stride_output1,\n    BLOCK_SIZE_M: tl.constexpr,\n    BLOCK_SIZE_N: tl.constexpr,\n    BLOCK_SIZE_K: tl.constexpr,\n):\n    pid_bm = tl.program_id(0)\n    pid_bn = tl.program_id(1)\n    \n    offs_bm = pid_bm * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)\n    offs_bn = pid_bn * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n    offs_k = tl.arange(0, BLOCK_SIZE_K)\n    \n    x_ptrs = x_ptr + offs_bm[:, None] * stride_x0 + offs_k[None, :] * stride_x1\n    w_ptrs = w_ptr + offs_k[:, None] * stride_w0 + offs_bn[None, :] * stride_w1\n    \n    acc = tl.zeros((BLOCK_SIZE_M, BLOCK_SIZE_N), dtype=tl.float32)\n    \n    for k in range(0, tl.cdiv(in_features, BLOCK_SIZE_K)):\n        k_remaining = in_features - k * BLOCK_SIZE_K\n        k_valid = tl.minimum(BLOCK_SIZE_K, k_remaining)\n        \n        x_mask = (offs_bm[:, None] < batch_size) & (offs_k[None, :] < k_valid)\n        w_mask = (offs_k[:, None] < k_valid) & (offs_bn[None, :] < out_features)\n        \n        x_block = tl.load(x_ptrs, mask=x_mask, other=0.0)\n        w_block = tl.load(w_ptrs, mask=w_mask, other=0.0)\n        \n        acc += tl.dot(x_block, w_block)\n        \n        x_ptrs += BLOCK_SIZE_K * stride_x1\n        w_ptrs += BLOCK_SIZE_K * stride_w0\n    \n    b_ptrs = b_ptr + offs_bn\n    b_mask = offs_bn < out_features\n    b_block = tl.load(b_ptrs, mask=b_mask, other=0.0)\n    \n    acc += b_block[None, :]\n    acc = tl.maximum(acc, 0.0)\n    \n    offs_output = offs_bm[:, None] * stride_output0 + offs_bn[None, :] * stride_output1\n    output_mask = (offs_bm[:, None] < batch_size) & (offs_bn[None, :] < out_features)\n    tl.store(output_ptr + offs_output, acc, mask=output_mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, bias_shape):\n        super(ModelNew, self).__init__()\n        self.gemm = nn.Linear(in_features, out_features, bias=False)\n        self.bias = nn.Parameter(torch.randn(bias_shape))\n    \n    def forward(self, x):\n        batch_size, _ = x.shape\n        out_features = self.bias.shape[0]\n        \n        output = torch.empty((batch_size, out_features), device=x.device, dtype=x.dtype)\n        \n        BLOCK_SIZE_M = 32\n        BLOCK_SIZE_N = 64\n        BLOCK_SIZE_K = 32\n        \n        grid = (\n            triton.cdiv(batch_size, BLOCK_SIZE_M),\n            triton.cdiv(out_features, BLOCK_SIZE_N),\n        )\n        \n        _fused_gemm_bias_relu_kernel[grid](\n            x,\n            self.gemm.weight,\n            self.bias,\n            output,\n            batch_size,\n            self.gemm.weight.size(1),\n            out_features,\n            x.stride(0),\n            x.stride(1),\n            self.gemm.weight.stride(1),  # Swapped stride dimensions\n            self.gemm.weight.stride(0),  # Swapped stride dimensions\n            output.stride(0),\n            output.stride(1),\n            BLOCK_SIZE_M=BLOCK_SIZE_M,\n            BLOCK_SIZE_N=BLOCK_SIZE_N,\n            BLOCK_SIZE_K=BLOCK_SIZE_K,\n        )\n        \n        return output\n\nbatch_size = 128\nin_features = 1024\nout_features = 512\nbias_shape = (out_features,)\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, bias_shape]\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Performs well on compiled (1.0000), Performs well on correctness (1.0000), Performs well on stage (success), Performs well on passed (0.0000), Performs well on score (20.0000), Performs well on speed_up (0.8910), Performs well on runtime_ms (0.0616), Performs well on meta ({'hardware': 'NVIDIA L20Y', 'device': 'cuda:0', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.0549, 'speed_up': 0.891, 'custom_timing': 0.0616})\n\n\n### Program 3 (Score: 10.0000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef _fused_gemm_bias_relu_kernel(\n    x_ptr,\n    w_ptr,\n    b_ptr,\n    output_ptr,\n    batch_size,\n    in_features,\n    out_features,\n    stride_x0,\n    stride_x1,\n    stride_w0,\n    stride_w1,\n    stride_output0,\n    stride_output1,\n    BLOCK_SIZE_M: tl.constexpr,\n    BLOCK_SIZE_N: tl.constexpr,\n    BLOCK_SIZE_K: tl.constexpr,\n):\n    pid_bm = tl.program_id(0)\n    pid_bn = tl.program_id(1)\n    \n    offs_bm = pid_bm * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)\n    offs_bn = pid_bn * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n    offs_k = tl.arange(0, BLOCK_SIZE_K)\n    \n    # Fixed weight pointer calculation (swapped indices)\n    x_ptrs = x_ptr + offs_bm[:, None] * stride_x0 + offs_k[None, :] * stride_x1\n    w_ptrs = w_ptr + offs_bn[:, None] * stride_w0 + offs_k[None, :] * stride_w1\n    \n    acc = tl.zeros((BLOCK_SIZE_M, BLOCK_SIZE_N), dtype=tl.float32)\n    \n    for k in range(0, tl.cdiv(in_features, BLOCK_SIZE_K)):\n        k_remaining = in_features - k * BLOCK_SIZE_K\n        k_valid = tl.minimum(BLOCK_SIZE_K, k_remaining)\n        \n        x_mask = (offs_bm[:, None] < batch_size) & (offs_k[None, :] < k_valid)\n        w_mask = (offs_bn[:, None] < out_features) & (offs_k[None, :] < k_valid)\n        \n        x_block = tl.load(x_ptrs, mask=x_mask, other=0.0)\n        w_block = tl.load(w_ptrs, mask=w_mask, other=0.0)\n        \n        # Use transposed weight with appropriate dot product\n        acc += tl.dot(x_block, w_block, trans_b=True)\n        \n        x_ptrs += BLOCK_SIZE_K * stride_x1\n        w_ptrs += BLOCK_SIZE_K * stride_w1\n    \n    b_ptrs = b_ptr + offs_bn\n    b_mask = offs_bn < out_features\n    b_block = tl.load(b_ptrs, mask=b_mask, other=0.0)\n    \n    acc += b_block[None, :]\n    acc = tl.maximum(acc, 0.0)\n    \n    offs_output = offs_bm[:, None] * stride_output0 + offs_bn[None, :] * stride_output1\n    output_mask = (offs_bm[:, None] < batch_size) & (offs_bn[None, :] < out_features)\n    tl.store(output_ptr + offs_output, acc, mask=output_mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, bias_shape):\n        super(ModelNew, self).__init__()\n        self.gemm = nn.Linear(in_features, out_features, bias=False)\n        self.bias = nn.Parameter(torch.randn(bias_shape))\n    \n    def forward(self, x):\n        batch_size, _ = x.shape\n        out_features = self.bias.shape[0]\n        \n        output = torch.empty((batch_size, out_features), device=x.device, dtype=x.dtype)\n        \n        BLOCK_SIZE_M = 32\n        BLOCK_SIZE_N = 64\n        BLOCK_SIZE_K = 32\n        \n        grid = (\n            triton.cdiv(batch_size, BLOCK_SIZE_M),\n            triton.cdiv(out_features, BLOCK_SIZE_N),\n        )\n        \n        _fused_gemm_bias_relu_kernel[grid](\n            x,\n            self.gemm.weight,\n            self.bias,\n            output,\n            batch_size,\n            self.gemm.weight.size(1),\n            out_features,\n            x.stride(0),\n            x.stride(1),\n            self.gemm.weight.stride(0),\n            self.gemm.weight.stride(1),\n            output.stride(0),\n            output.stride(1),\n            BLOCK_SIZE_M=BLOCK_SIZE_M,\n            BLOCK_SIZE_N=BLOCK_SIZE_N,\n            BLOCK_SIZE_K=BLOCK_SIZE_K,\n        )\n        \n        return output\n\nbatch_size = 128\nin_features = 1024\nout_features = 512\nbias_shape = (out_features,)\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, bias_shape]\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Performs well on compiled (1.0000), Performs well on correctness (0.0000), Performs well on score (10.0000), Performs well on stage (wrong_answer), Performs well on verify_payload ({'id': 'level2_76_Gemm_Add_ReLU', 'result': {'compiled': True, 'correctness': False, 'metadata': {'hardware': 'NVIDIA L20Y', 'device': 'cuda:2', 'runtime_error': 'Traceback (most recent call last):\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/language/core.py\", line 42, in wrapper\\n    return fn(*args, **kwargs)\\nTypeError: dot() got an unexpected keyword argument \\'trans_b\\'\\n\\nThe above exception was the direct cause of the following exception:\\n\\nTraceback (most recent call last):\\n  File \"/cpfs01/shared/llm_kernel/hujiakai/KernelLLM/validation_api_server/helpers/evaluations.py\", line 720, in run_and_check_correctness\\n    output_new = model_new(*inputs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1773, in _wrapped_call_impl\\n    return self._call_impl(*args, **kwargs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1784, in _call_impl\\n    return forward_call(*args, **kwargs)\\n  File \"/tmp/tmp3wm8of6i.py\", line 87, in forward\\n    _fused_gemm_bias_relu_kernel[grid](\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 390, in <lambda>\\n    return lambda *args, **kwargs: self.run(grid=grid, warmup=False, *args, **kwargs)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 594, in run\\n    kernel = self.compile(src, target=target, options=options.__dict__)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/compiler/compiler.py\", line 339, in compile\\n    module = src.make_ir(options, codegen_fns, module_map, context)\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/compiler/compiler.py\", line 83, in make_ir\\n    return ast_to_ttir(self.fn, self, context=context, options=options, codegen_fns=codegen_fns,\\ntriton.compiler.errors.CompilationError: at 43:15:\\n    for k in range(0, tl.cdiv(in_features, BLOCK_SIZE_K)):\\n        k_remaining = in_features - k * BLOCK_SIZE_K\\n        k_valid = tl.minimum(BLOCK_SIZE_K, k_remaining)\\n\\n        x_mask = (offs_bm[:, None] < batch_size) & (offs_k[None, :] < k_valid)\\n        w_mask = (offs_bn[:, None] < out_features) & (offs_k[None, :] < k_valid)\\n\\n        x_block = tl.load(x_ptrs, mask=x_mask, other=0.0)\\n        w_block = tl.load(w_ptrs, mask=w_mask, other=0.0)\\n\\n        # Use transposed weight with appropriate dot product\\n        acc += tl.dot(x_block, w_block, trans_b=True)\\n               ^\\n\\n\\nThe above exception was the direct cause of the following exception:\\n\\nTraceback (most recent call last):\\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/language/core.py\", line 42, in wrapper\\n    return fn(*args, **kwargs)\\nTypeError: dot() got an unexpected keyword argument \\'trans_b\\'\\n', 'runtime_error_name': 'triton.compiler.errors.CompilationError', 'reference_timing_ms': 0.0549, 'speed_up': -1.0, 'custom_timing': -1.0}, 'runtime': -1.0, 'runtime_stats': {}}})\n\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 10.0000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef _fused_gemm_bias_relu_kernel(\n    x_ptr,\n    w_ptr,\n    b_ptr,\n    output_ptr,\n    batch_size,\n    in_features,\n    out_features,\n    stride_x0,\n    stride_x1,\n    stride_w0,\n    stride_w1,\n    stride_output0,\n    stride_output1,\n    BLOCK_SIZE_M: tl.constexpr,\n    BLOCK_SIZE_N: tl.constexpr,\n    BLOCK_SIZE_K: tl.constexpr,\n):\n    pid_bm = tl.program_id(0)\n    pid_bn = tl.program_id(1)\n    \n    offs_bm = pid_bm * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)\n    offs_bn = pid_bn * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n    offs_k = tl.arange(0, BLOCK_SIZE_K)\n    \n    x_ptrs = x_ptr + offs_bm[:, None] * stride_x0 + offs_k[None, :] * stride_x1\n    w_ptrs = w_ptr + offs_k[:, None] * stride_w0 + offs_bn[None, :] * stride_w1\n    \n    acc = tl.zeros((BLOCK_SIZE_M, BLOCK_SIZE_N), dtype=tl.float32)\n    \n    for k in range(0, tl.cdiv(in_features, BLOCK_SIZE_K)):\n        k_remaining = in_features - k * BLOCK_SIZE_K\n        \n        x_mask = (offs_bm[:, None] < batch_size) & (offs_k[None, :] < k_remaining)\n        w_mask = (offs_k[:, None] < k_remaining) & (offs_bn[None, :] < out_features)\n        \n        x_block = tl.load(x_ptrs, mask=x_mask, other=0.0)\n        w_block = tl.load(w_ptrs, mask=w_mask, other=0.0)\n        \n        acc += tl.dot(x_block, w_block)\n        \n        x_ptrs += BLOCK_SIZE_K * stride_x1\n        w_ptrs += BLOCK_SIZE_K * stride_w0\n    \n    b_ptrs = b_ptr + offs_bn\n    b_mask = offs_bn < out_features\n    b_block = tl.load(b_ptrs, mask=b_mask, other=0.0)\n    \n    acc += b_block[None, :]\n    acc = tl.maximum(acc, 0.0)\n    \n    offs_output = offs_bm[:, None] * stride_output0 + offs_bn[None, :] * stride_output1\n    output_mask = (offs_bm[:, None] < batch_size) & (offs_bn[None, :] < out_features)\n    tl.store(output_ptr + offs_output, acc, mask=output_mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, bias_shape):\n        super(ModelNew, self).__init__()\n        self.gemm = nn.Linear(in_features, out_features, bias=False)\n        self.bias = nn.Parameter(torch.randn(bias_shape))\n    \n    def forward(self, x):\n        batch_size, _ = x.shape\n        out_features = self.bias.shape[0]\n        \n        output = torch.empty((batch_size, out_features), device=x.device, dtype=x.dtype)\n        \n        BLOCK_SIZE_M = 32\n        BLOCK_SIZE_N = 64\n        BLOCK_SIZE_K = 32\n        \n        grid = (\n            triton.cdiv(batch_size, BLOCK_SIZE_M),\n            triton.cdiv(out_features, BLOCK_SIZE_N),\n        )\n        \n        _fused_gemm_bias_relu_kernel[grid](\n            x,\n            self.gemm.weight,\n            self.bias,\n            output,\n            batch_size,\n            self.gemm.weight.size(1),\n            out_features,\n            x.stride(0),\n            x.stride(1),\n            self.gemm.weight.stride(0),\n            self.gemm.weight.stride(1),\n            output.stride(0),\n            output.stride(1),\n            BLOCK_SIZE_M=BLOCK_SIZE_M,\n            BLOCK_SIZE_N=BLOCK_SIZE_N,\n            BLOCK_SIZE_K=BLOCK_SIZE_K,\n        )\n        \n        return output\n\nbatch_size = 128\nin_features = 1024\nout_features = 512\nbias_shape = (out_features,)\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, bias_shape]\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Alternative approach to compiled, Alternative approach to correctness\n\n\n### Program D2 (Score: 10.0000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_SIZE': 64, 'BLOCK_K': 128}, num_warps=4),\n        triton.Config({'BLOCK_SIZE': 128, 'BLOCK_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_SIZE': 256, 'BLOCK_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_SIZE': 128, 'BLOCK_K': 128}, num_warps=8),\n        triton.Config({'BLOCK_SIZE': 256, 'BLOCK_K': 64}, num_warps=8),\n    ],\n    key=['in_features', 'out_features'],\n)\n@triton.jit\ndef fused_linear_relu_kernel(\n    x_ptr,\n    weight_ptr,\n    bias_ptr,\n    output_ptr,\n    in_features,\n    out_features,\n    stride_xb,\n    stride_xh,\n    stride_wout,\n    stride_win,\n    stride_bb,\n    stride_ob,\n    stride_oh,\n    BLOCK_SIZE: tl.constexpr,\n    BLOCK_K: tl.constexpr,\n):\n    pid_batch = tl.program_id(0)\n    pid_col = tl.program_id(1)\n    \n    col_offsets = pid_col * BLOCK_SIZE + tl.arange(0, BLOCK_SIZE)\n    col_mask = col_offsets < out_features\n    \n    accumulator = tl.zeros((BLOCK_SIZE,), dtype=tl.float32)\n    \n    num_blocks_k = tl.cdiv(in_features, BLOCK_K)\n    for k_block in range(0, num_blocks_k):\n        k_offsets = k_block * BLOCK_K + tl.arange(0, BLOCK_K)\n        k_mask = k_offsets < in_features\n        \n        x_offsets = pid_batch * stride_xb + k_offsets * stride_xh\n        x_val = tl.load(x_ptr + x_offsets, mask=k_mask, other=0.0)\n        \n        w_offsets = col_offsets[:, None] * stride_wout + k_offsets[None, :] * stride_win\n        w_val = tl.load(weight_ptr + w_offsets, mask=col_mask[:, None] & k_mask[None, :], other=0.0)\n        \n        x_vec = tl.reshape(x_val, (1, BLOCK_K))\n        w_mat = tl.reshape(w_val, (BLOCK_SIZE, BLOCK_K))\n        partial = tl.dot(w_mat, x_vec, allow_tf32=True)\n        accumulator += tl.reshape(partial, (BLOCK_SIZE,))\n    \n    b_offsets = col_offsets * stride_bb\n    bias = tl.load(bias_ptr + b_offsets, mask=col_mask, other=0.0)\n    result = accumulator + bias\n    result = tl.where(result > 0, result, 0.0)\n    \n    out_offsets = pid_batch * stride_ob + col_offsets * stride_oh\n    tl.store(output_ptr + out_offsets, result, mask=col_mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, bias_shape):\n        super(ModelNew, self).__init__()\n        self.in_features = in_features\n        self.out_features = out_features\n        self.weight = nn.Parameter(torch.randn(out_features, in_features))\n        self.bias = nn.Parameter(torch.randn(bias_shape))\n\n    def forward(self, x):\n        batch_size, _ = x.shape\n        output = torch.empty((batch_size, self.out_features), device=x.device, dtype=x.dtype)\n        \n        grid = lambda meta: (batch_size, triton.cdiv(self.out_features, meta['BLOCK_SIZE']))\n        \n        fused_linear_relu_kernel[grid](\n            x, self.weight, self.bias, output,\n            self.in_features, self.out_features,\n            x.stride(0), x.stride(1),\n            self.weight.stride(0), self.weight.stride(1),\n            self.bias.stride(0),\n            output.stride(0), output.stride(1),\n            BLOCK_SIZE=128,  # Default value will be overridden by autotuner\n            BLOCK_K=64       # Default value will be overridden by autotuner\n        )\n        return output\n\nbatch_size = 128\nin_features = 1024\nout_features = 512\nbias_shape = (out_features,)\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, bias_shape]\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Alternative approach to compiled, Alternative approach to correctness\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 20.0000, Type: High-Performer)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef _fused_gemm_bias_relu_kernel(\n    x_ptr,\n    w_ptr,\n    b_ptr,\n    output_ptr,\n    batch_size,\n    in_features,\n    out_features,\n    stride_x0,\n    stride_x1,\n    stride_w0,\n    stride_w1,\n    stride_output0,\n    stride_output1,\n    BLOCK_SIZE_M: tl.constexpr,\n    BLOCK_SIZE_N: tl.constexpr,\n    BLOCK_SIZE_K: tl.constexpr,\n):\n    pid_bm = tl.program_id(0)\n    pid_bn = tl.program_id(1)\n    \n    offs_bm = pid_bm * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)\n    offs_bn = pid_bn * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n    offs_k = tl.arange(0, BLOCK_SIZE_K)\n    \n    x_ptrs = x_ptr + offs_bm[:, None] * stride_x0 + offs_k[None, :] * stride_x1\n    w_ptrs = w_ptr + offs_k[:, None] * stride_w0 + offs_bn[None, :] * stride_w1\n    \n    acc = tl.zeros((BLOCK_SIZE_M, BLOCK_SIZE_N), dtype=tl.float32)\n    \n    for k in range(0, tl.cdiv(in_features, BLOCK_SIZE_K)):\n        k_remaining = in_features - k * BLOCK_SIZE_K\n        k_valid = tl.minimum(BLOCK_SIZE_K, k_remaining)\n        \n        x_mask = (offs_bm[:, None] < batch_size) & (offs_k[None, :] < k_valid)\n        w_mask = (offs_k[:, None] < k_valid) & (offs_bn[None, :] < out_features)\n        \n        x_block = tl.load(x_ptrs, mask=x_mask, other=0.0)\n        w_block = tl.load(w_ptrs, mask=w_mask, other=0.0)\n        \n        acc += tl.dot(x_block, w_block)\n        \n        x_ptrs += BLOCK_SIZE_K * stride_x1\n        w_ptrs += BLOCK_SIZE_K * stride_w0\n    \n    b_ptrs = b_ptr + offs_bn\n    b_mask = offs_bn < out_features\n    b_block = tl.load(b_ptrs, mask=b_mask, other=0.0)\n    \n    acc += b_block[None, :]\n    acc = tl.maximum(acc, 0.0)\n    \n    offs_output = offs_bm[:, None] * stride_output0 + offs_bn[None, :] * stride_output1\n    output_mask = (offs_bm[:, None] < batch_size) & (offs_bn[None, :] < out_features)\n    tl.store(output_ptr + offs_output, acc, mask=output_mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, bias_shape):\n        super(ModelNew, self).__init__()\n        self.gemm = nn.Linear(in_features, out_features, bias=False)\n        self.bias = nn.Parameter(torch.randn(bias_shape))\n    \n    def forward(self, x):\n        batch_size, _ = x.shape\n        out_features = self.bias.shape[0]\n        \n        output = torch.empty((batch_size, out_features), device=x.device, dtype=x.dtype)\n        \n        BLOCK_SIZE_M = 32\n        BLOCK_SIZE_N = 64\n        BLOCK_SIZE_K = 32\n        \n        grid = (\n            triton.cdiv(batch_size, BLOCK_SIZE_M),\n            triton.cdiv(out_features, BLOCK_SIZE_N),\n        )\n        \n        _fused_gemm_bias_relu_kernel[grid](\n            x,\n            self.gemm.weight,\n            self.bias,\n            output,\n            batch_size,\n            self.gemm.weight.size(1),\n            out_features,\n            x.stride(0),\n            x.stride(1),\n            self.gemm.weight.stride(1),  # Swapped stride dimensions\n            self.gemm.weight.stride(0),  # Swapped stride dimensions\n            output.stride(0),\n            output.stride(1),\n            BLOCK_SIZE_M=BLOCK_SIZE_M,\n            BLOCK_SIZE_N=BLOCK_SIZE_N,\n            BLOCK_SIZE_K=BLOCK_SIZE_K,\n        )\n        \n        return output\n\nbatch_size = 128\nin_features = 1024\nout_features = 512\nbias_shape = (out_features,)\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, bias_shape]\n# =================== EVOLVE-BLOCK-END ===================\n```\nUnique approach: Modification: Full rewrite, Excellent compiled (1.000), Excellent correctness (1.000)\n\n\n### Inspiration 2 (Score: 10.0000, Type: High-Performer)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef _fused_gemm_bias_relu_kernel(\n    x_ptr,\n    w_ptr,\n    b_ptr,\n    output_ptr,\n    batch_size,\n    in_features,\n    out_features,\n    stride_x0,\n    stride_x1,\n    stride_w0,\n    stride_w1,\n    stride_output0,\n    stride_output1,\n    BLOCK_SIZE_M: tl.constexpr,\n    BLOCK_SIZE_N: tl.constexpr,\n    BLOCK_SIZE_K: tl.constexpr,\n):\n    pid_bm = tl.program_id(0)\n    pid_bn = tl.program_id(1)\n    \n    offs_bm = pid_bm * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)\n    offs_bn = pid_bn * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n    offs_k = tl.arange(0, BLOCK_SIZE_K)\n    \n    # Precompute pointer offsets for efficient memory access\n    x_ptrs = x_ptr + (offs_bm[:, None] * stride_x0 + offs_k[None, :] * stride_x1)\n    w_ptrs = w_ptr + (offs_k[:, None] * stride_w0 + offs_bn[None, :] * stride_w1)\n    \n    acc = tl.zeros((BLOCK_SIZE_M, BLOCK_SIZE_N), dtype=tl.float32)\n    \n    # Calculate number of K blocks\n    num_k_blocks = tl.cdiv(in_features, BLOCK_SIZE_K)\n    \n    for k in range(0, num_k_blocks):\n        # Compute remaining elements in K dimension\n        k_remaining = in_features - k * BLOCK_SIZE_K\n        \n        # Create masks for valid elements\n        x_mask = (offs_bm[:, None] < batch_size) & (offs_k[None, :] < k_remaining)\n        w_mask = (offs_k[:, None] < k_remaining) & (offs_bn[None, :] < out_features)\n        \n        # Load blocks with proper masking\n        x_block = tl.load(x_ptrs, mask=x_mask, other=0.0)\n        w_block = tl.load(w_ptrs, mask=w_mask, other=0.0)\n        \n        # Accumulate matrix multiplication\n        acc += tl.dot(x_block, w_block, allow_tf32=True)\n        \n        # Move pointers to next K block\n        x_ptrs += BLOCK_SIZE_K * stride_x1\n        w_ptrs += BLOCK_SIZE_K * stride_w0\n    \n    # Load bias and apply\n    b_ptrs = b_ptr + offs_bn\n    b_mask = offs_bn < out_features\n    b_block = tl.load(b_ptrs, mask=b_mask, other=0.0)\n    acc += b_block[None, :]\n    \n    # Apply ReLU activation\n    acc = tl.where(acc > 0, acc, 0.0)\n    \n    # Store results with coalesced writes\n    out_ptrs = output_ptr + (offs_bm[:, None] * stride_output0 + offs_bn[None, :] * stride_output1)\n    out_mask = (offs_bm[:, None] < batch_size) & (offs_bn[None, :] < out_features)\n    tl.store(out_ptrs, acc, mask=out_mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, bias_shape):\n        super(ModelNew, self).__init__()\n        self.gemm = nn.Linear(in_features, out_features, bias=False)\n        self.bias = nn.Parameter(torch.randn(bias_shape))\n    \n    def forward(self, x):\n        batch_size, _ = x.shape\n        out_features = self.bias.shape[0]\n        \n        output = torch.empty((batch_size, out_features), device=x.device, dtype=x.dtype)\n        \n        # Tuned block sizes for H100 architecture\n        BLOCK_SIZE_M = 64\n        BLOCK_SIZE_N = 128\n        BLOCK_SIZE_K = 64\n        \n        grid = (\n            triton.cdiv(batch_size, BLOCK_SIZE_M),\n            triton.cdiv(out_features, BLOCK_SIZE_N),\n        )\n        \n        _fused_gemm_bias_relu_kernel[grid](\n            x,\n            self.gemm.weight,\n            self.bias,\n            output,\n            batch_size,\n            self.gemm.weight.size(1),\n            out_features,\n            x.stride(0),\n            x.stride(1),\n            self.gemm.weight.stride(0),\n            self.gemm.weight.stride(1),\n            output.stride(0),\n            output.stride(1),\n            BLOCK_SIZE_M=BLOCK_SIZE_M,\n            BLOCK_SIZE_N=BLOCK_SIZE_N,\n            BLOCK_SIZE_K=BLOCK_SIZE_K,\n        )\n        \n        return output\n\nbatch_size = 128\nin_features = 1024\nout_features = 512\nbias_shape = (out_features,)\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, bias_shape]\n# =================== EVOLVE-BLOCK-END ===================\n```\nUnique approach: Modification: Full rewrite, Excellent compiled (1.000), Alternative correctness approach\n\n\n### Inspiration 3 (Score: 10.0000, Type: High-Performer)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef _fused_gemm_bias_relu_kernel(\n    x_ptr,\n    w_ptr,\n    b_ptr,\n    output_ptr,\n    batch_size,\n    in_features,\n    out_features,\n    stride_x0,\n    stride_x1,\n    stride_w0,\n    stride_w1,\n    stride_output0,\n    stride_output1,\n    BLOCK_SIZE_M: tl.constexpr,\n    BLOCK_SIZE_N: tl.constexpr,\n    BLOCK_SIZE_K: tl.constexpr,\n):\n    pid_bm = tl.program_id(0)\n    pid_bn = tl.program_id(1)\n    \n    offs_bm = pid_bm * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)\n    offs_bn = pid_bn * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n    offs_k = tl.arange(0, BLOCK_SIZE_K)\n    \n    x_ptrs = x_ptr + offs_bm[:, None] * stride_x0 + offs_k[None, :] * stride_x1\n    w_ptrs = w_ptr + offs_k[:, None] * stride_w0 + offs_bn[None, :] * stride_w1\n    \n    acc = tl.zeros((BLOCK_SIZE_M, BLOCK_SIZE_N), dtype=tl.float32)\n    \n    for k in range(0, tl.cdiv(in_features, BLOCK_SIZE_K)):\n        k_remaining = in_features - k * BLOCK_SIZE_K\n        k_valid = tl.min(BLOCK_SIZE_K, k_remaining)\n        \n        x_mask = (offs_bm[:, None] < batch_size) & (offs_k[None, :] < k_valid)\n        w_mask = (offs_k[:, None] < k_valid) & (offs_bn[None, :] < out_features)\n        \n        x_block = tl.load(x_ptrs, mask=x_mask, other=0.0)\n        w_block = tl.load(w_ptrs, mask=w_mask, other=0.0)\n        \n        acc += tl.dot(x_block, w_block)\n        \n        x_ptrs += BLOCK_SIZE_K * stride_x1\n        w_ptrs += BLOCK_SIZE_K * stride_w0\n    \n    b_ptrs = b_ptr + offs_bn\n    b_mask = offs_bn < out_features\n    b_block = tl.load(b_ptrs, mask=b_mask, other=0.0)\n    \n    acc += b_block[None, :]\n    acc = tl.maximum(acc, 0.0)\n    \n    offs_output = offs_bm[:, None] * stride_output0 + offs_bn[None, :] * stride_output1\n    output_mask = (offs_bm[:, None] < batch_size) & (offs_bn[None, :] < out_features)\n    tl.store(output_ptr + offs_output, acc, mask=output_mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, bias_shape):\n        super(ModelNew, self).__init__()\n        self.gemm = nn.Linear(in_features, out_features, bias=False)\n        self.bias = nn.Parameter(torch.randn(bias_shape))\n    \n    def forward(self, x):\n        batch_size, _ = x.shape\n        out_features = self.bias.shape[0]\n        \n        output = torch.empty((batch_size, out_features), device=x.device, dtype=x.dtype)\n        \n        BLOCK_SIZE_M = 32\n        BLOCK_SIZE_N = 64\n        BLOCK_SIZE_K = 32\n        \n        grid = (\n            triton.cdiv(batch_size, BLOCK_SIZE_M),\n            triton.cdiv(out_features, BLOCK_SIZE_N),\n        )\n        \n        _fused_gemm_bias_relu_kernel[grid](\n            x,\n            self.gemm.weight,\n            self.bias,\n            output,\n            batch_size,\n            self.gemm.weight.size(1),\n            out_features,\n            x.stride(0),\n            x.stride(1),\n            self.gemm.weight.stride(0),\n            self.gemm.weight.stride(1),\n            output.stride(0),\n            output.stride(1),\n            BLOCK_SIZE_M=BLOCK_SIZE_M,\n            BLOCK_SIZE_N=BLOCK_SIZE_N,\n            BLOCK_SIZE_K=BLOCK_SIZE_K,\n        )\n        \n        return output\n\nbatch_size = 128\nin_features = 1024\nout_features = 512\nbias_shape = (out_features,)\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, bias_shape]\n# =================== EVOLVE-BLOCK-END ===================\n```\nUnique approach: Modification: Full rewrite, Excellent compiled (1.000), Alternative correctness approach\n\n\n### Inspiration 4 (Score: 10.0000, Type: High-Performer)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_SIZE': 64, 'BLOCK_K': 128}, num_warps=4),\n        triton.Config({'BLOCK_SIZE': 128, 'BLOCK_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_SIZE': 256, 'BLOCK_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_SIZE': 128, 'BLOCK_K': 128}, num_warps=8),\n        triton.Config({'BLOCK_SIZE': 256, 'BLOCK_K': 64}, num_warps=8),\n    ],\n    key=['in_features', 'out_features'],\n)\n@triton.jit\ndef fused_linear_relu_kernel(\n    x_ptr,\n    weight_ptr,\n    bias_ptr,\n    output_ptr,\n    in_features,\n    out_features,\n    stride_xb,\n    stride_xh,\n    stride_wout,\n    stride_win,\n    stride_bb,\n    stride_ob,\n    stride_oh,\n    BLOCK_SIZE: tl.constexpr,\n    BLOCK_K: tl.constexpr,\n):\n    pid_batch = tl.program_id(0)\n    pid_col = tl.program_id(1)\n    \n    col_offsets = pid_col * BLOCK_SIZE + tl.arange(0, BLOCK_SIZE)\n    col_mask = col_offsets < out_features\n    \n    accumulator = tl.zeros((BLOCK_SIZE,), dtype=tl.float32)\n    \n    num_blocks_k = tl.cdiv(in_features, BLOCK_K)\n    for k_block in range(0, num_blocks_k):\n        k_offsets = k_block * BLOCK_K + tl.arange(0, BLOCK_K)\n        k_mask = k_offsets < in_features\n        \n        x_offsets = pid_batch * stride_xb + k_offsets * stride_xh\n        x_val = tl.load(x_ptr + x_offsets, mask=k_mask, other=0.0)\n        \n        w_offsets = col_offsets[:, None] * stride_wout + k_offsets[None, :] * stride_win\n        w_val = tl.load(weight_ptr + w_offsets, mask=col_mask[:, None] & k_mask[None, :], other=0.0)\n        \n        x_vec = tl.reshape(x_val, (1, BLOCK_K))\n        w_mat = tl.reshape(w_val, (BLOCK_SIZE, BLOCK_K))\n        partial = tl.dot(w_mat, x_vec, allow_tf32=True)\n        accumulator += tl.reshape(partial, (BLOCK_SIZE,))\n    \n    b_offsets = col_offsets * stride_bb\n    bias = tl.load(bias_ptr + b_offsets, mask=col_mask, other=0.0)\n    result = accumulator + bias\n    result = tl.where(result > 0, result, 0.0)\n    \n    out_offsets = pid_batch * stride_ob + col_offsets * stride_oh\n    tl.store(output_ptr + out_offsets, result, mask=col_mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, bias_shape):\n        super(ModelNew, self).__init__()\n        self.in_features = in_features\n        self.out_features = out_features\n        self.weight = nn.Parameter(torch.randn(out_features, in_features))\n        self.bias = nn.Parameter(torch.randn(bias_shape))\n\n    def forward(self, x):\n        batch_size, _ = x.shape\n        output = torch.empty((batch_size, self.out_features), device=x.device, dtype=x.dtype)\n        \n        grid = lambda meta: (batch_size, triton.cdiv(self.out_features, meta['BLOCK_SIZE']))\n        \n        fused_linear_relu_kernel[grid](\n            x, self.weight, self.bias, output,\n            self.in_features, self.out_features,\n            x.stride(0), x.stride(1),\n            self.weight.stride(0), self.weight.stride(1),\n            self.bias.stride(0),\n            output.stride(0), output.stride(1),\n            BLOCK_SIZE=128,  # Default value will be overridden by autotuner\n            BLOCK_K=64       # Default value will be overridden by autotuner\n        )\n        return output\n\nbatch_size = 128\nin_features = 1024\nout_features = 512\nbias_shape = (out_features,)\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, bias_shape]\n# =================== EVOLVE-BLOCK-END ===================\n```\nUnique approach: Modification: Full rewrite, Excellent compiled (1.000), Alternative correctness approach\n\n\n### Inspiration 5 (Score: 10.0000, Type: High-Performer)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef _fused_gemm_bias_relu_kernel(\n    x_ptr,\n    w_ptr,\n    b_ptr,\n    output_ptr,\n    batch_size,\n    in_features,\n    out_features,\n    stride_x0,\n    stride_x1,\n    stride_w0,\n    stride_w1,\n    stride_output0,\n    stride_output1,\n    BLOCK_SIZE_M: tl.constexpr,\n    BLOCK_SIZE_N: tl.constexpr,\n    BLOCK_SIZE_K: tl.constexpr,\n):\n    pid_bm = tl.program_id(0)\n    pid_bn = tl.program_id(1)\n    \n    offs_bm = pid_bm * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)\n    offs_bn = pid_bn * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n    offs_k = tl.arange(0, BLOCK_SIZE_K)\n    \n    # Fixed weight pointer calculation (swapped indices)\n    x_ptrs = x_ptr + offs_bm[:, None] * stride_x0 + offs_k[None, :] * stride_x1\n    w_ptrs = w_ptr + offs_bn[:, None] * stride_w0 + offs_k[None, :] * stride_w1\n    \n    acc = tl.zeros((BLOCK_SIZE_M, BLOCK_SIZE_N), dtype=tl.float32)\n    \n    for k in range(0, tl.cdiv(in_features, BLOCK_SIZE_K)):\n        k_remaining = in_features - k * BLOCK_SIZE_K\n        k_valid = tl.minimum(BLOCK_SIZE_K, k_remaining)\n        \n        x_mask = (offs_bm[:, None] < batch_size) & (offs_k[None, :] < k_valid)\n        w_mask = (offs_bn[:, None] < out_features) & (offs_k[None, :] < k_valid)\n        \n        x_block = tl.load(x_ptrs, mask=x_mask, other=0.0)\n        w_block = tl.load(w_ptrs, mask=w_mask, other=0.0)\n        \n        # Use transposed weight with appropriate dot product\n        acc += tl.dot(x_block, w_block, trans_b=True)\n        \n        x_ptrs += BLOCK_SIZE_K * stride_x1\n        w_ptrs += BLOCK_SIZE_K * stride_w1\n    \n    b_ptrs = b_ptr + offs_bn\n    b_mask = offs_bn < out_features\n    b_block = tl.load(b_ptrs, mask=b_mask, other=0.0)\n    \n    acc += b_block[None, :]\n    acc = tl.maximum(acc, 0.0)\n    \n    offs_output = offs_bm[:, None] * stride_output0 + offs_bn[None, :] * stride_output1\n    output_mask = (offs_bm[:, None] < batch_size) & (offs_bn[None, :] < out_features)\n    tl.store(output_ptr + offs_output, acc, mask=output_mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, bias_shape):\n        super(ModelNew, self).__init__()\n        self.gemm = nn.Linear(in_features, out_features, bias=False)\n        self.bias = nn.Parameter(torch.randn(bias_shape))\n    \n    def forward(self, x):\n        batch_size, _ = x.shape\n        out_features = self.bias.shape[0]\n        \n        output = torch.empty((batch_size, out_features), device=x.device, dtype=x.dtype)\n        \n        BLOCK_SIZE_M = 32\n        BLOCK_SIZE_N = 64\n        BLOCK_SIZE_K = 32\n        \n        grid = (\n            triton.cdiv(batch_size, BLOCK_SIZE_M),\n            triton.cdiv(out_features, BLOCK_SIZE_N),\n        )\n        \n        _fused_gemm_bias_relu_kernel[grid](\n            x,\n            self.gemm.weight,\n            self.bias,\n            output,\n            batch_size,\n            self.gemm.weight.size(1),\n            out_features,\n            x.stride(0),\n            x.stride(1),\n            self.gemm.weight.stride(0),\n            self.gemm.weight.stride(1),\n            output.stride(0),\n            output.stride(1),\n            BLOCK_SIZE_M=BLOCK_SIZE_M,\n            BLOCK_SIZE_N=BLOCK_SIZE_N,\n            BLOCK_SIZE_K=BLOCK_SIZE_K,\n        )\n        \n        return output\n\nbatch_size = 128\nin_features = 1024\nout_features = 512\nbias_shape = (out_features,)\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, bias_shape]\n# =================== EVOLVE-BLOCK-END ===================\n```\nUnique approach: Modification: Full rewrite, Excellent compiled (1.000), Alternative correctness approach\n\n\n\n# Current Program\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef _fused_gemm_bias_relu_kernel(\n    x_ptr,\n    w_ptr,\n    b_ptr,\n    output_ptr,\n    batch_size,\n    in_features,\n    out_features,\n    stride_x0,\n    stride_x1,\n    stride_w0,\n    stride_w1,\n    stride_output0,\n    stride_output1,\n    BLOCK_SIZE_M: tl.constexpr,\n    BLOCK_SIZE_N: tl.constexpr,\n    BLOCK_SIZE_K: tl.constexpr,\n):\n    pid_bm = tl.program_id(0)\n    pid_bn = tl.program_id(1)\n    \n    offs_bm = pid_bm * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)\n    offs_bn = pid_bn * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n    offs_k = tl.arange(0, BLOCK_SIZE_K)\n    \n    # Precompute pointer offsets for efficient memory access\n    x_ptrs = x_ptr + (offs_bm[:, None] * stride_x0 + offs_k[None, :] * stride_x1)\n    # Corrected weight matrix access pattern\n    w_ptrs = w_ptr + (offs_bn[None, :] * stride_w0 + offs_k[:, None] * stride_w1)\n    \n    acc = tl.zeros((BLOCK_SIZE_M, BLOCK_SIZE_N), dtype=tl.float32)\n    \n    # Calculate number of K blocks\n    num_k_blocks = tl.cdiv(in_features, BLOCK_SIZE_K)\n    \n    for k in range(0, num_k_blocks):\n        # Compute remaining elements in K dimension\n        k_remaining = in_features - k * BLOCK_SIZE_K\n        \n        # Create masks for valid elements\n        x_mask = (offs_bm[:, None] < batch_size) & (offs_k[None, :] < k_remaining)\n        w_mask = (offs_k[:, None] < k_remaining) & (offs_bn[None, :] < out_features)\n        \n        # Load blocks with proper masking\n        x_block = tl.load(x_ptrs, mask=x_mask, other=0.0)\n        w_block = tl.load(w_ptrs, mask=w_mask, other=0.0)\n        \n        # Accumulate matrix multiplication\n        acc += tl.dot(x_block, w_block, allow_tf32=True)\n        \n        # Move pointers to next K block\n        x_ptrs += BLOCK_SIZE_K * stride_x1\n        # Corrected pointer update for weight matrix\n        w_ptrs += BLOCK_SIZE_K * stride_w1\n    \n    # Load bias and apply\n    b_ptrs = b_ptr + offs_bn\n    b_mask = offs_bn < out_features\n    b_block = tl.load(b_ptrs, mask=b_mask, other=0.0)\n    acc += b_block[None, :]\n    \n    # Apply ReLU activation\n    acc = tl.where(acc > 0, acc, 0.0)\n    \n    # Store results with coalesced writes\n    out_ptrs = output_ptr + (offs_bm[:, None] * stride_output0 + offs_bn[None, :] * stride_output1)\n    out_mask = (offs_bm[:, None] < batch_size) & (offs_bn[None, :] < out_features)\n    tl.store(out_ptrs, acc, mask=out_mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, bias_shape):\n        super(ModelNew, self).__init__()\n        self.gemm = nn.Linear(in_features, out_features, bias=False)\n        self.bias = nn.Parameter(torch.randn(bias_shape))\n    \n    def forward(self, x):\n        batch_size, _ = x.shape\n        out_features = self.bias.shape[0]\n        \n        output = torch.empty((batch_size, out_features), device=x.device, dtype=x.dtype)\n        \n        # Tuned block sizes for H100 architecture\n        BLOCK_SIZE_M = 64\n        BLOCK_SIZE_N = 128\n        BLOCK_SIZE_K = 64\n        \n        grid = (\n            triton.cdiv(batch_size, BLOCK_SIZE_M),\n            triton.cdiv(out_features, BLOCK_SIZE_N),\n        )\n        \n        _fused_gemm_bias_relu_kernel[grid](\n            x,\n            self.gemm.weight,\n            self.bias,\n            output,\n            batch_size,\n            self.gemm.weight.size(1),\n            out_features,\n            x.stride(0),\n            x.stride(1),\n            self.gemm.weight.stride(0),\n            self.gemm.weight.stride(1),\n            output.stride(0),\n            output.stride(1),\n            BLOCK_SIZE_M=BLOCK_SIZE_M,\n            BLOCK_SIZE_N=BLOCK_SIZE_N,\n            BLOCK_SIZE_K=BLOCK_SIZE_K,\n        )\n        \n        return output\n\nbatch_size = 128\nin_features = 1024\nout_features = 512\nbias_shape = (out_features,)\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, bias_shape]\n# =================== EVOLVE-BLOCK-END ===================\n```\n\n# Task\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```\n", "responses": ["<think>\nWe are given a Triton kernel that performs a fused GEMM, add bias, and ReLU operation.\n The current implementation has a speed_up of 0.893 (which is less than 1, meaning slower than the reference).\n We need to improve the performance.\n\n Observations from the current program:\n  - The kernel uses two-dimensional grid: (batch_size / BLOCK_SIZE_M, out_features / BLOCK_SIZE_N)\n  - The inner loop iterates over the K dimension (in_features) in blocks of BLOCK_SIZE_K.\n  - The current block sizes are: BLOCK_SIZE_M=64, BLOCK_SIZE_N=128, BLOCK_SIZE_K=64.\n\n However, note that the current kernel has a potential issue in the weight matrix access pattern:\n   w_ptrs = w_ptr + (offs_bn[None, :] * stride_w0 + offs_k[:, None] * stride_w1)\n This is because the weight matrix is typically stored as [out_features, in_features]. \n In the current code, the weight is being accessed with:\n   row index: offs_bn (which corresponds to output feature) and column index: offs_k (which corresponds to input feature).\n But note that in the inner product, we are doing:\n   acc += tl.dot(x_block, w_block, allow_tf32=True)\n Here, x_block is of shape [BLOCK_SIZE_M, BLOCK_SIZE_K] and w_block is of shape [BLOCK_SIZE_K, BLOCK_SIZE_N]?\n Actually, the way we set up w_ptrs: \n   w_ptrs = w_ptr + (offs_bn[None, :] * stride_w0 + offs_k[:, None] * stride_w1)\n This gives a block of weight that is of shape [BLOCK_SIZE_K, BLOCK_SIZE_N] (because offs_k is the first dimension and offs_bn the second).\n\n However, the dot product in Triton expects the second matrix to be in row-major by default? \n But note: the Triton dot operation expects two matrices of shapes (M, K) and (K, N) to produce (M, N). \n So the current w_block is of shape (K, N) which is correct.\n\n But wait: the strides are passed as self.gemm.weight.stride(0) and self.gemm.weight.stride(1). \n Since the weight is [out_features, in_features], then:\n   stride_w0 = stride(0) = in_features (if it's row-major) -> but actually, PyTorch uses row-major for 2D tensors? \n   Actually, the stride for the weight matrix: \n        weight.stride(0) = in_features (if row-major) because to move one row we skip in_features elements?\n        weight.stride(1) = 1.\n\n However, in the kernel, we are using:\n   w_ptrs = w_ptr + (offs_bn[None, :] * stride_w0 + offs_k[:, None] * stride_w1)\n This would be:\n   element at [i, j] = w_ptr + j * stride_w0 + i * stride_w1.\n If stride_w0 = in_features and stride_w1 = 1, then we are accessing the weight matrix in column-major order? \n Because the inner dimension (k) is contiguous? \n\n Actually, the weight matrix in PyTorch is stored as row-major: \n   weight[out_feature_idx, in_feature_idx] = base + out_feature_idx * in_features + in_feature_idx.\n\n In the kernel, we are doing:\n   w_ptr + offs_bn[None, :] * stride_w0 (which is the row stride) and then offs_k[:, None] * stride_w1 (which is the column stride).\n But note: we are iterating over the in_features (k) dimension. So for a fixed output feature (offs_bn) and varying in_feature (offs_k), we are accessing consecutive elements? \n However, the way we set the pointer: \n   For a fixed offs_bn (say j) and varying offs_k (i from 0 to BLOCK_SIZE_K-1), the address is:\n        w_ptr + j * stride_w0 + i * stride_w1.\n   Since stride_w1=1, then for a fixed j, we get consecutive addresses -> so we are reading a contiguous block of the j-th row? \n\n But wait: the weight matrix is stored in row-major. The j-th row is contiguous. So we are reading a contiguous block of the j-th row? \n However, the block we are reading is of size [BLOCK_SIZE_K, BLOCK_SIZE_N] and we are reading for multiple j (offs_bn) at once? \n Actually, we are reading a block that spans multiple rows (for a fixed set of columns) and then we move the pointer by BLOCK_SIZE_K in the column dimension? \n\n But note: the inner loop moves w_ptrs by BLOCK_SIZE_K * stride_w1. Since stride_w1=1, that moves the column index by BLOCK_SIZE_K. \n\n This is correct.\n\n However, the problem might be that the current block sizes are not optimal? \n We are using M=64, N=128, K=64. \n\n Since the H100 has Tensor Cores that support FP16 with 32x16x16 (or 16x16x16 for FP16), we might want to adjust the block sizes to be multiples of 16 in each dimension? \n Also, note that the current kernel uses allow_tf32=True which is good for Tensor Cores.\n\n But the current speedup is 0.893, which is less than 1. We need to get at least 5% improvement.\n\n What can we try?\n  - Change the block sizes to be multiples of 16 and also consider the hardware constraints for Tensor Cores.\n  - Alternatively, we can try to use a different tiling strategy.\n\n Looking at the top programs, we see that one program (Program 2) had a speed_up of 0.891 and used M=32, N=64, K=32. \n But our current M=64, N=128, K=64 is larger and might be better for reducing the number of blocks? \n\n However, we are not achieving the desired performance. \n\n Another idea: we are not using any shared memory or software pipelining. But Triton handles that automatically? \n\n Alternatively, we can try to use the autotuner to find the best block sizes.\n\n But note: the problem says we are not allowed to change the grid configuration. However, we are allowed to change the block sizes (BLOCK_M, BLOCK_N, BLOCK_K) and use autotuning.\n\n We are going to:\n   - Add an autotuner to the kernel to try different block sizes and number of warps.\n   - We will keep the same kernel structure but let Triton choose the best configuration.\n\n Also, note that the current kernel does not use vectorized loads. We can try to add that.\n\n Steps for optimization:\n\n 1. Autotuning: We will define several configurations for BLOCK_SIZE_M, BLOCK_SIZE_N, BLOCK_SIZE_K and num_warps.\n\n 2. Vectorized loads: We can try to load contiguous blocks of data with a single instruction. For that, we can use the `tl.dot` instruction which already expects blocks, but we can also try to hint the compiler by using vectorized loads? Actually, the Triton compiler might already optimize the memory access. \n\n However, we can try to change the way we load by using `tl.load(..., cache_modifier=tl.cache_modifier.'.cg')` or something? But that is advanced.\n\n Given the constraints, let's focus on autotuning and block sizes.\n\n We note that the H100 has 128KB shared memory per SM. The block sizes we choose must fit in shared memory? But Triton handles that.\n\n Proposed changes:\n\n   - Add the `@triton.autotune` decorator above the kernel.\n   - Define a set of configs that we want to try.\n\n We are going to try block sizes that are multiples of 16 and that are known to work well for Tensor Cores.\n\n Example configs:\n\n   triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 64}, num_warps=4),\n   triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 32}, num_warps=4),\n   triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 32}, num_warps=4),\n   triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 32}, num_warps=4),\n   triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 256, 'BLOCK_SIZE_K': 64}, num_warps=8),\n   ... etc.\n\n We also note that the kernel uses a lot of registers? So we might want to try different numbers of warps.\n\n However, note: the current kernel uses the same block sizes for M and N? But we are using a 2D grid.\n\n We are going to define an autotuner with several configurations.\n\n Also, note: we must not change the kernel signature. We are only changing the block sizes via the autotuner.\n\n Let's write the autotuner:\n\n   @triton.autotune(\n        configs=[\n            triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 32}, num_warps=4),\n            triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 32}, num_warps=4),\n            triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 32}, num_warps=4),\n            triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 32}, num_warps=4),\n            triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 64}, num_warps=4),\n            triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 64}, num_warps=4),\n            triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 64}, num_warps=4),\n            triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 64}, num_warps=8),\n            triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 256, 'BLOCK_SIZE_K': 64}, num_warps=8),\n            triton.Config({'BLOCK_SIZE_M': 256, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 64}, num_warps=8),\n        ],\n        key=['batch_size', 'in_features', 'out_features'],\n    )\n\n We put this decorator above the kernel.\n\n However, note that the kernel parameters must be the same. The autotuner will override the BLOCK_SIZE_* constants.\n\n Also, we remove the hard-coded block sizes in the forward function and instead pass them as kernel arguments (they are already in the kernel signature as constexpr). But we must set them in the kernel launch.\n\n How do we set them? The autotuner will choose the best config and set the values for BLOCK_SIZE_M, BLOCK_SIZE_N, BLOCK_SIZE_K. So in the forward function, we don't set them. We just pass them as the ones from the config.\n\n But note: the grid is computed based on the block sizes. So we have to compute the grid dynamically.\n\n We can do:\n\n   grid = (triton.cdiv(batch_size, BLOCK_SIZE_M), triton.cdiv(out_features, BLOCK_SIZE_N))\n\n However, we cannot know BLOCK_SIZE_M and BLOCK_SIZE_N until the autotuner chooses a config? \n\n How does autotuner work? The autotuner will run multiple configurations and choose the best one. For each configuration, it will set the block sizes and then run the kernel. The grid must be computed per configuration.\n\n We can define the grid as a lambda function that takes the config as input? \n\n Actually, the grid can be a function of the kernel parameters. We can write:\n\n   grid = lambda meta: (\n        triton.cdiv(batch_size, meta['BLOCK_SIZE_M']),\n        triton.cdiv(out_features, meta['BLOCK_SIZE_N']),\n   )\n\n And then when launching the kernel, we do:\n\n   _fused_gemm_bias_relu_kernel[grid](\n        ...,\n        BLOCK_SIZE_M=meta['BLOCK_SIZE_M'],   # but wait, we don't have meta here?\n   )\n\n Actually, the autotuner will handle this. We just pass the grid as a function and the kernel arguments as usual. The autotuner will pass the meta dictionary to the grid function.\n\n So we change the forward function:\n\n   grid = lambda meta: (\n        triton.cdiv(batch_size, meta['BLOCK_SIZE_M']),\n        triton.cdiv(out_features, meta['BLOCK_SIZE_N']),\n   )\n\n   # Then we remove the hard-coded block sizes and pass them as kernel arguments without specifying the value? \n   # Actually, we don't need to pass them by name? They are in the kernel signature and the autotuner will set them.\n\n   But note: the kernel launch must pass the block sizes as keyword arguments? \n\n   We do:\n\n        _fused_gemm_bias_relu_kernel[grid](\n            ...,\n            BLOCK_SIZE_M=...,   # but we don't know the value? \n        )\n\n   Actually, the autotuner will override the values. We can pass them as the ones from the meta? \n\n   However, the Triton documentation says that we can pass the parameters that are being tuned as keyword arguments and they will be set by the autotuner. We don't need to set them explicitly.\n\n   So we can remove the BLOCK_SIZE_M, BLOCK_SIZE_N, BLOCK_SIZE_K from the kernel call? \n\n   But note: the kernel expects them. And the autotuner will set them. So we can just omit them? \n\n   Alternatively, we can pass them as the ones from the meta? \n\n   Actually, we don't have to. The autotuner will fill them.\n\n   So we can call:\n\n        _fused_gemm_bias_relu_kernel[grid](\n            x,\n            self.gemm.weight,\n            self.bias,\n            output,\n            batch_size,\n            self.gemm.weight.size(1),\n            out_features,\n            x.stride(0),\n            x.stride(1),\n            self.gemm.weight.stride(0),\n            self.gemm.weight.stride(1),\n            output.stride(0),\n            output.stride(1),\n        )\n\n   But note: the kernel signature requires BLOCK_SIZE_M, BLOCK_SIZE_N, BLOCK_SIZE_K. However, they are `constexpr` and the autotuner will set them. So we don't pass them in the call.\n\n   However, the Triton kernel call requires that all arguments are passed. So we must pass them? \n\n   Actually, the autotuner will pass the ones from the config. So we can skip them in the call? \n\n   Let me check: in the example above (the example with the autotuner in the provided programs) they did:\n\n        fused_linear_relu_kernel[grid](\n            ...,\n            BLOCK_SIZE=128,  # Default value will be overridden by autotuner\n            BLOCK_K=64       # Default value will be overridden by autotuner\n        )\n\n   So we can pass default values? But they will be overridden. We can pass any value? \n\n   Actually, the autotuner will override them. So we can pass the ones we used before as default? \n\n   Alternatively, we can remove them? \n\n   But the kernel requires them. So we must pass something. We can pass the ones that are in the autotuner config? \n\n   However, the autotuner will override. So we can pass dummy values? \n\n   Actually, we can pass the values that we had previously (64,128,64) as the default? \n\n   But note: the grid function uses the meta dictionary to compute the grid. The meta dictionary will have the values from the autotuner config. So we don't need to pass the block sizes explicitly? \n\n   However, the kernel call expects them. We can do:\n\n        _fused_gemm_bias_relu_kernel[grid](\n            ...,\n            BLOCK_SIZE_M=64, \n            BLOCK_SIZE_N=128, \n            BLOCK_SIZE_K=64,\n        )\n\n   But then the autotuner will override these values? \n\n   Actually, the autotuner will run the kernel multiple times with the different configs. The default we pass will be overridden by the autotuner.\n\n   So we can keep the same call but remove the hard-coded block sizes? \n\n   Alternatively, we can set them to None? \n\n   The Triton documentation says: the autotuner will set them. So we must not pass them? \n\n   But the kernel requires them. We can pass them as the ones from the meta? \n\n   Actually, the grid function is passed the meta dictionary. We can use the same meta dictionary to set the block sizes? \n\n   However, the Triton kernel call does not allow to pass a meta dictionary. \n\n   After checking the Triton autotuning example: they pass the parameters as keyword arguments and the autotuner will override them. So we pass the default values and the autotuner will replace them.\n\n   So we do:\n\n        _fused_gemm_bias_relu_kernel[grid](\n            ...,\n            BLOCK_SIZE_M=64, \n            BLOCK_SIZE_N=128, \n            BLOCK_SIZE_K=64,\n        )\n\n   But note: the autotuner will run with the configs we provided and ignore these 64,128,64? \n\n   Yes.\n\n Implementation:\n\n   Step 1: Add the autotune decorator above the kernel.\n   Step 2: Change the grid to a lambda function that uses the meta dictionary.\n   Step 3: In the kernel launch, remove the hard-coded block sizes and instead pass the same as before (but they will be overridden by the autotuner).\n\n   However, note: the kernel uses the block sizes in the loop bound? \n        num_k_blocks = tl.cdiv(in_features, BLOCK_SIZE_K)\n   This is already using the constexpr BLOCK_SIZE_K, so it will be set by the autotuner.\n\n   So we don't need to change the kernel.\n\n   Step 4: Remove the hard-coded block sizes in the forward function and pass them as kernel arguments (with default values that will be overridden).\n\n Let's rewrite the code accordingly.\n\n But note: the autotuner might increase the compilation time? But that is acceptable in this context.\n\n Let's write the new kernel with autotuning.\n\n Important: We must not break the correctness.\n\n We are going to change:\n\n   - Add the autotuner decorator.\n   - Change the grid to a lambda that uses meta.\n   - Change the kernel call to pass the block sizes as the ones we used to have (as defaults) but they will be overridden.\n\n However, note: the kernel call must pass the block sizes? Because they are required by the kernel. We pass them as the same as the current ones (64,128,64) as defaults.\n\n But the autotuner will run multiple configurations and choose the best one.\n\n We hope that the autotuner will find a configuration that gives a speedup.\n\n Let's write the code accordingly.\n\n Also, note: we are not allowed to change the function signature of the kernel. We are only changing the decorator and the way we call it.\n\n We are going to output the entire block with the changes.\n\n Note: We are only allowed to change the Triton kernel source within the block? But the block includes the entire class. So we can change the forward function as well.\n\n We are going to:\n\n   - Add the autotuner decorator to the kernel.\n   - Change the grid in the forward function to a lambda that uses meta.\n   - In the kernel launch, we pass the block sizes as the current ones (64,128,64) but they are just placeholders.\n\n We also note that the kernel uses `tl.dot(..., allow_tf32=True)`. That is good for Tensor Cores.\n\n Let's hope that the autotuner finds a better configuration.\n\n We'll also try to add more configs that are multiples of 16 and 32 for Tensor Cores.\n\n We note that the H100 Tensor Core requires the dimensions to be multiples of 16 for FP16? But our kernel uses float32? \n Actually, the input and output are of dtype x.dtype (which is not specified, but the reference uses float32?).\n\n The problem says: the reference is PyTorch. We are using float32? Then the tensor core in tf32 mode requires multiples of 16? \n\n But the Triton dot product with allow_tf32=True will use tf32 which is 10-bit mantissa. And the block sizes should be multiples of 16 for the best performance.\n\n We have already set the block sizes to multiples of 16 in the configs.\n\n Let's write the new code.\n</think>\nI'll optimize the Triton kernel by adding autotuning to find the best block sizes and warp configurations for the H100 architecture. The key changes include:\n\n1. Adding an autotuner with configurations optimized for Tensor Cores\n2. Using grid as a lambda function to dynamically adjust based on block sizes\n3. Removing hardcoded block sizes to allow autotuning\n4. Keeping all other kernel logic unchanged for correctness\n\nHere's the optimized implementation:\n\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 64}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 32}, num_warps=8),\n        triton.Config({'BLOCK_SIZE_M': 256, 'BLOCK_SIZE_N': 64, 'BLOCK_SIZE_K': 64}, num_warps=8),\n        triton.Config({'BLOCK_SIZE_M': 64, 'BLOCK_SIZE_N': 256, 'BLOCK_SIZE_K': 64}, num_warps=8),\n        triton.Config({'BLOCK_SIZE_M': 128, 'BLOCK_SIZE_N': 256, 'BLOCK_SIZE_K': 64}, num_warps=8),\n        triton.Config({'BLOCK_SIZE_M': 256, 'BLOCK_SIZE_N': 128, 'BLOCK_SIZE_K': 64}, num_warps=8),\n    ],\n    key=['batch_size', 'in_features', 'out_features'],\n)\n@triton.jit\ndef _fused_gemm_bias_relu_kernel(\n    x_ptr,\n    w_ptr,\n    b_ptr,\n    output_ptr,\n    batch_size,\n    in_features,\n    out_features,\n    stride_x0,\n    stride_x1,\n    stride_w0,\n    stride_w1,\n    stride_output0,\n    stride_output1,\n    BLOCK_SIZE_M: tl.constexpr,\n    BLOCK_SIZE_N: tl.constexpr,\n    BLOCK_SIZE_K: tl.constexpr,\n):\n    pid_bm = tl.program_id(0)\n    pid_bn = tl.program_id(1)\n    \n    offs_bm = pid_bm * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)\n    offs_bn = pid_bn * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n    offs_k = tl.arange(0, BLOCK_SIZE_K)\n    \n    # Precompute pointer offsets for efficient memory access\n    x_ptrs = x_ptr + (offs_bm[:, None] * stride_x0 + offs_k[None, :] * stride_x1)\n    # Corrected weight matrix access pattern\n    w_ptrs = w_ptr + (offs_bn[None, :] * stride_w0 + offs_k[:, None] * stride_w1)\n    \n    acc = tl.zeros((BLOCK_SIZE_M, BLOCK_SIZE_N), dtype=tl.float32)\n    \n    # Calculate number of K blocks\n    num_k_blocks = tl.cdiv(in_features, BLOCK_SIZE_K)\n    \n    for k in range(0, num_k_blocks):\n        # Compute remaining elements in K dimension\n        k_remaining = in_features - k * BLOCK_SIZE_K\n        \n        # Create masks for valid elements\n        x_mask = (offs_bm[:, None] < batch_size) & (offs_k[None, :] < k_remaining)\n        w_mask = (offs_k[:, None] < k_remaining) & (offs_bn[None, :] < out_features)\n        \n        # Load blocks with proper masking\n        x_block = tl.load(x_ptrs, mask=x_mask, other=0.0)\n        w_block = tl.load(w_ptrs, mask=w_mask, other=0.0)\n        \n        # Accumulate matrix multiplication\n        acc += tl.dot(x_block, w_block, allow_tf32=True)\n        \n        # Move pointers to next K block\n        x_ptrs += BLOCK_SIZE_K * stride_x1\n        # Corrected pointer update for weight matrix\n        w_ptrs += BLOCK_SIZE_K * stride_w1\n    \n    # Load bias and apply\n    b_ptrs = b_ptr + offs_bn\n    b_mask = offs_bn < out_features\n    b_block = tl.load(b_ptrs, mask=b_mask, other=0.0)\n    acc += b_block[None, :]\n    \n    # Apply ReLU activation\n    acc = tl.where(acc > 0, acc, 0.0)\n    \n    # Store results with coalesced writes\n    out_ptrs = output_ptr + (offs_bm[:, None] * stride_output0 + offs_bn[None, :] * stride_output1)\n    out_mask = (offs_bm[:, None] < batch_size) & (offs_bn[None, :] < out_features)\n    tl.store(out_ptrs, acc, mask=out_mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, bias_shape):\n        super(ModelNew, self).__init__()\n        self.gemm = nn.Linear(in_features, out_features, bias=False)\n        self.bias = nn.Parameter(torch.randn(bias_shape))\n    \n    def forward(self, x):\n        batch_size, _ = x.shape\n        out_features = self.bias.shape[0]\n        \n        output = torch.empty((batch_size, out_features), device=x.device, dtype=x.dtype)\n        \n        grid = lambda meta: (\n            triton.cdiv(batch_size, meta['BLOCK_SIZE_M']),\n            triton.cdiv(out_features, meta['BLOCK_SIZE_N']),\n        )\n        \n        _fused_gemm_bias_relu_kernel[grid](\n            x,\n            self.gemm.weight,\n            self.bias,\n            output,\n            batch_size,\n            self.gemm.weight.size(1),\n            out_features,\n            x.stride(0),\n            x.stride(1),\n            self.gemm.weight.stride(0),\n            self.gemm.weight.stride(1),\n            output.stride(0),\n            output.stride(1),\n            BLOCK_SIZE_M=64,\n            BLOCK_SIZE_N=128,\n            BLOCK_SIZE_K=64,\n        )\n        \n        return output\n\nbatch_size = 128\nin_features = 1024\nout_features = 512\nbias_shape = (out_features,)\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, bias_shape]\n# =================== EVOLVE-BLOCK-END ===================\n```"]}}}