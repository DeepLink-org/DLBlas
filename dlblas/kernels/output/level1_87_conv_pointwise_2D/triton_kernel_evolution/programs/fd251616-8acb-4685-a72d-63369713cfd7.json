{"id": "fd251616-8acb-4685-a72d-63369713cfd7", "code": "# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_SIZE_C': 64, 'BLOCK_SIZE_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_C': 128, 'BLOCK_SIZE_K': 32}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_C': 256, 'BLOCK_SIZE_K': 64}, num_warps=8),\n        triton.Config({'BLOCK_SIZE_C': 128, 'BLOCK_SIZE_K': 64}, num_warps=4),\n    ],\n    key=['C_in', 'C_out'],\n)\n@triton.jit\ndef _pointwise_conv(\n    input_ptr, weight_ptr, bias_ptr, output_ptr,\n    n, C_in, C_out,\n    stride_input_n, stride_input_k,\n    stride_weight_c, stride_weight_k,\n    stride_output_n, stride_output_c,\n    BLOCK_SIZE_C: tl.constexpr, BLOCK_SIZE_K: tl.constexpr\n):\n    pid0 = tl.program_id(0)   # over n (batch * height * width)\n    pid1 = tl.program_id(1)   # over output channels in blocks\n    \n    # Compute block of output channels\n    c_block_start = pid1 * BLOCK_SIZE_C\n    c_offsets = c_block_start + tl.arange(0, BLOCK_SIZE_C)\n    c_mask = c_offsets < C_out\n    \n    # Initialize accumulator\n    acc = tl.zeros((BLOCK_SIZE_C,), dtype=tl.float32)\n    \n    # Loop over input channels in blocks\n    for k in range(0, C_in, BLOCK_SIZE_K):\n        k_offsets = k + tl.arange(0, BLOCK_SIZE_K)\n        k_mask = k_offsets < C_in\n        \n        # Load input block\n        a = tl.load(\n            input_ptr + pid0 * stride_input_n + k_offsets,\n            mask=k_mask, other=0.0\n        )\n        \n        # Load weight block with double masking\n        w_ptr = weight_ptr + c_offsets[:, None] * stride_weight_c + k_offsets[None, :] * stride_weight_k\n        w = tl.load(\n            w_ptr,\n            mask=c_mask[:, None] & k_mask[None, :],\n            other=0.0\n        )\n        \n        # Compute partial dot product\n        partial = tl.sum(a[None, :] * w, axis=1)\n        acc += partial\n    \n    # Add bias if present\n    if bias_ptr != 0:\n        b = tl.load(bias_ptr + c_offsets, mask=c_mask, other=0.0)\n        acc += b\n    \n    # Store results\n    out_ptr = output_ptr + pid0 * stride_output_n + c_offsets\n    tl.store(out_ptr, acc, mask=c_mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_channels: int, out_channels: int, bias: bool = False):\n        super(ModelNew, self).__init__()\n        self.in_channels = in_channels\n        self.out_channels = out_channels\n        self.weight = nn.Parameter(torch.empty(out_channels, in_channels))\n        if bias:\n            self.bias = nn.Parameter(torch.empty(out_channels))\n        else:\n            self.register_parameter('bias', None)\n        \n        # Initialize parameters\n        nn.init.kaiming_uniform_(self.weight, a=math.sqrt(5))\n        if self.bias is not None:\n            fan_in, _ = nn.init._calculate_fan_in_and_fan_out(self.weight)\n            bound = 1 / math.sqrt(fan_in) if fan_in > 0 else 0\n            nn.init.uniform_(self.bias, -bound, bound)\n    \n    def forward(self, x: torch.Tensor) -> torch.Tensor:\n        B, C_in, H, W = x.shape\n        n = B * H * W\n        \n        # Prepare tensors\n        x_2d = x.reshape(n, C_in).contiguous()\n        output = torch.empty((n, self.out_channels), device=x.device, dtype=x.dtype)\n        \n        # Get bias pointer (0 if None)\n        bias_ptr = self.bias.data_ptr() if self.bias is not None else 0\n        \n        # Grid configuration\n        grid = lambda meta: (n, triton.cdiv(self.out_channels, meta['BLOCK_SIZE_C']))\n        \n        # Launch kernel\n        _pointwise_conv[grid](\n            x_2d, self.weight, bias_ptr, output,\n            n, C_in, self.out_channels,\n            x_2d.stride(0), x_2d.stride(1),\n            self.weight.stride(0), self.weight.stride(1),\n            output.stride(0), output.stride(1)\n        )\n        \n        return output.reshape(B, self.out_channels, H, W)\n\n# Test code\nbatch_size = 16\nin_channels = 3\nout_channels = 64\nwidth = 256\nheight = 256\n\ndef get_inputs():\n    x = torch.randn(batch_size, in_channels, height, width)\n    return [x]\n\ndef get_init_inputs():\n    return [in_channels, out_channels]\n# =================== EVOLVE-BLOCK-END ===================", "language": "python", "parent_id": "14382ed7-fb69-4f61-bf4e-951a30accc44", "generation": 1, "timestamp": 1754645164.2078128, "iteration_found": 3, "metrics": {"compiled": false, "correctness": false, "score": 1, "stage": "compile_error", "compile_log": "name 'math' is not defined\nTraceback (most recent call last):\n  File \"/cpfs01/shared/llm_kernel/hujiakai/KernelLLM/validation_api_server/evaluator.py\", line 173, in _verification_worker\n    result: KernelExecResult = eval_kernel_against_ref(\n  File \"/cpfs01/shared/llm_kernel/hujiakai/KernelLLM/validation_api_server/helpers/evaluations.py\", line 484, in eval_kernel_against_ref\n    custom_model = ModelNew(*init_args, **init_kwargs)\n  File \"/tmp/tmpafn7dc98.py\", line 80, in __init__\n    nn.init.kaiming_uniform_(self.weight, a=math.sqrt(5))\nNameError: name 'math' is not defined\n", "exec_log": "[Child] \u7ed1\u5b9a GPU 1, torch sees 1 device(s)\n\n[Exception]\nTraceback (most recent call last):\n  File \"/cpfs01/shared/llm_kernel/hujiakai/KernelLLM/validation_api_server/code_executor.py\", line 71, in _exec_worker\n    exec(textwrap.dedent(code_src), mod.__dict__)\n  File \"<string>\", line 17, in <module>\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 844, in jit\n    return decorator(fn)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 832, in decorator\n    return JITFunction(\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 635, in __init__\n    self.starting_line_number = inspect.getsourcelines(fn)[1]\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/inspect.py\", line 1121, in getsourcelines\n    lines, lnum = findsource(object)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/inspect.py\", line 958, in findsource\n    raise OSError('could not get source code')\nOSError: could not get source code\n", "exit_code": "1"}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": true, "correctness": true, "stage": "reference code", "passed": false, "score": 0.0, "speed_up": 1.0, "runtime_ms": 0.126, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:1", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.0379, "speed_up": 0.301, "custom_timing": 0.126}}, "island": 0}, "artifacts_json": null, "artifact_dir": null}