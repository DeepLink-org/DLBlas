{"id": "36a1343e-ffce-476c-bed7-8792d7a7d5fe", "code": "# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\nimport math\n\n@triton.jit\ndef separable_conv_forward_kernel(\n    # Input tensor pointers\n    x_ptr,\n    depthwise_weight_ptr,\n    pointwise_weight_ptr,\n    bias_ptr,\n    output_ptr,\n    # Tensor dimensions\n    batch_size, in_channels, height, width,\n    kernel_size, stride, padding, dilation,\n    out_channels, height_out, width_out,\n    # Stride information\n    x_batch_stride, x_channel_stride, x_h_stride, x_w_stride,\n    dw_channel_stride, dw_kh_stride, dw_kw_stride,\n    pw_out_stride, pw_in_stride,\n    bias_stride,\n    output_batch_stride, output_channel_stride, output_h_stride, output_w_stride,\n    # Kernel configuration\n    BLOCK_SIZE: tl.constexpr\n):\n    # Compute global thread ID\n    pid = tl.program_id(0)\n    num_elems = batch_size * out_channels * height_out * width_out\n    \n    # Exit if out of bounds\n    if pid * BLOCK_SIZE >= num_elems:\n        return\n    \n    # Generate offsets for this block\n    offsets = pid * BLOCK_SIZE + tl.arange(0, BLOCK_SIZE)\n    mask = offsets < num_elems\n    \n    # Decompose offsets into output tensor indices\n    w_out = offsets % width_out\n    offsets = tl.math.floor(offsets / width_out)\n    h_out = offsets % height_out\n    offsets = tl.math.floor(offsets / height_out)\n    oc = offsets % out_channels\n    b = tl.math.floor(offsets / out_channels)\n    \n    # Compute input window start positions\n    h_start = h_out * stride - padding\n    w_start = w_out * stride - padding\n    \n    # Initialize accumulator\n    acc = tl.zeros((BLOCK_SIZE,), dtype=tl.float32)\n    \n    # Depthwise convolution loop\n    for kh in range(0, kernel_size):\n        for kw in range(0, kernel_size):\n            h_in = h_start + kh * dilation\n            w_in = w_start + kw * dilation\n            \n            # Boundary check\n            h_in_bound = (h_in >= 0) & (h_in < height)\n            w_in_bound = (w_in >= 0) & (w_in < width)\n            in_bounds = h_in_bound & w_in_bound\n            \n            # Process each input channel\n            for c in range(0, in_channels):\n                # Calculate input pointer offsets\n                x_offset = (b * x_batch_stride + \n                           c * x_channel_stride + \n                           h_in * x_h_stride + \n                           w_in * x_w_stride)\n                \n                # Load input value with boundary masking\n                x_val = tl.load(x_ptr + x_offset, mask=in_bounds & mask, other=0.0)\n                \n                # Load depthwise weight\n                dw_offset = c * dw_channel_stride + kh * dw_kh_stride + kw * dw_kw_stride\n                dw_val = tl.load(depthwise_weight_ptr + dw_offset)\n                \n                # Multiply-accumulate\n                acc += x_val * dw_val\n    \n    # Pointwise convolution\n    pointwise_acc = tl.zeros((BLOCK_SIZE,), dtype=tl.float32)\n    for c in range(0, in_channels):\n        # Load pointwise weight for this channel\n        pw_offset = oc * pw_out_stride + c * pw_in_stride\n        pw_val = tl.load(pointwise_weight_ptr + pw_offset)\n        pointwise_acc += acc * pw_val\n    \n    # Add bias if present\n    if bias_ptr is not None:\n        bias_val = tl.load(bias_ptr + oc * bias_stride)\n        pointwise_acc += bias_val\n    \n    # Calculate output pointer offset\n    output_offset = (b * output_batch_stride + \n                    oc * output_channel_stride + \n                    h_out * output_h_stride + \n                    w_out * output_w_stride)\n    \n    # Store result\n    tl.store(output_ptr + output_offset, pointwise_acc, mask=mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_channels: int, out_channels: int, kernel_size: int, \n                 stride: int = 1, padding: int = 0, dilation: int = 1, bias: bool = False):\n        super(ModelNew, self).__init__()\n        self.in_channels = in_channels\n        self.out_channels = out_channels\n        self.kernel_size = kernel_size\n        self.stride = stride\n        self.padding = padding\n        self.dilation = dilation\n        \n        # Depthwise convolution parameters\n        self.depthwise_weight = nn.Parameter(\n            torch.empty(in_channels, 1, kernel_size, kernel_size)\n        )\n        # Pointwise convolution parameters\n        self.pointwise_weight = nn.Parameter(\n            torch.empty(out_channels, in_channels, 1, 1)\n        )\n        # Bias parameter\n        if bias:\n            self.bias = nn.Parameter(torch.empty(out_channels))\n        else:\n            self.register_parameter('bias', None)\n            \n        # Initialize parameters\n        nn.init.kaiming_uniform_(self.depthwise_weight, a=math.sqrt(5))\n        nn.init.kaiming_uniform_(self.pointwise_weight, a=math.sqrt(5))\n        if self.bias is not None:\n            fan_in, _ = nn.init._calculate_fan_in_and_fan_out(self.pointwise_weight)\n            bound = 1 / math.sqrt(fan_in) if fan_in > 0 else 0\n            nn.init.uniform_(self.bias, -bound, bound)\n        \n    def forward(self, x: torch.Tensor) -> torch.Tensor:\n        batch_size, _, height, width = x.shape\n        \n        # Calculate output dimensions\n        height_out = (height + 2 * self.padding - \n                     self.dilation * (self.kernel_size - 1) - 1) // self.stride + 1\n        width_out = (width + 2 * self.padding - \n                    self.dilation * (self.kernel_size - 1) - 1) // self.stride + 1\n        \n        # Create output tensor\n        output = torch.empty(\n            (batch_size, self.out_channels, height_out, width_out),\n            device=x.device, dtype=x.dtype\n        )\n        \n        # Compute total number of output elements\n        total_elems = batch_size * self.out_channels * height_out * width_out\n        \n        # Setup kernel grid\n        grid = lambda meta: (triton.cdiv(total_elems, meta['BLOCK_SIZE']),)\n        \n        # Get tensor strides\n        x_strides = (x.stride(0), x.stride(1), x.stride(2), x.stride(3))\n        dw_strides = (\n            self.depthwise_weight.stride(0),\n            self.depthwise_weight.stride(2),\n            self.depthwise_weight.stride(3)\n        )\n        pw_strides = (\n            self.pointwise_weight.stride(0),\n            self.pointwise_weight.stride(1)\n        )\n        bias_stride = self.bias.stride(0) if self.bias is not None else 0\n        output_strides = (\n            output.stride(0), output.stride(1), output.stride(2), output.stride(3)\n        )\n        \n        # Kernel parameters\n        kernel_params = [\n            x, self.depthwise_weight, self.pointwise_weight,\n            self.bias if self.bias is not None else None, output,\n            # Dimensions\n            batch_size, self.in_channels, height, width,\n            self.kernel_size, self.stride, self.padding, self.dilation,\n            self.out_channels, height_out, width_out,\n            # Strides\n            *x_strides,\n            *dw_strides,\n            *pw_strides,\n            bias_stride,\n            *output_strides,\n            # Block size\n            BLOCK_SIZE=1024\n        ]\n        \n        # Launch kernel\n        separable_conv_forward_kernel[grid](*kernel_params)\n        \n        return output\n\n# Test code\nbatch_size = 16\nin_channels = 3\nout_channels = 64\nkernel_size = 3\nwidth = 256\nheight = 256\nstride = 1\npadding = 0\ndilation = 1\n\ndef get_inputs():\n    x = torch.randn(batch_size, in_channels, height, width)\n    return [x]\n\ndef get_init_inputs():\n    return [in_channels, out_channels, kernel_size, stride, padding, dilation]\n# =================== EVOLVE-BLOCK-END ===================", "language": "python", "parent_id": "3ba1f3f9-8a6b-4ce4-87ad-871a39e62fca", "generation": 1, "timestamp": 1754647913.8178358, "iteration_found": 3, "metrics": {"compiled": false, "correctness": false, "score": 1, "stage": "compile_error", "compile_log": "", "exec_log": "[Child] \u7ed1\u5b9a GPU 4, torch sees 1 device(s)\n\n[Exception]\nTraceback (most recent call last):\n  File \"/cpfs01/shared/llm_kernel/hujiakai/KernelLLM/validation_api_server/code_executor.py\", line 71, in _exec_worker\n    exec(textwrap.dedent(code_src), mod.__dict__)\n  File \"<string>\", line 192\n    BLOCK_SIZE=1024\n    ^^^^^^^^^^^^^^^\nSyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?\n", "exit_code": "1"}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": true, "correctness": true, "stage": "reference code", "passed": false, "score": 0.0, "speed_up": 1.0, "runtime_ms": 0.157, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:4", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.0541, "speed_up": 0.345, "custom_timing": 0.157}}, "island": 1}, "artifacts_json": null, "artifact_dir": null}