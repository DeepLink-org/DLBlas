{"id": "cf24098c-f18b-42f7-8750-bdad49a6c629", "code": "# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport triton\nimport triton.language as tl\nimport math\n\n@triton.jit\ndef _attn_kernel(\n    Q, K, V, Out,\n    stride_qb, stride_qh, stride_qm, stride_qk,\n    stride_kb, stride_kh, stride_kn, stride_kk,\n    stride_vb, stride_vh, stride_vn, stride_vk,\n    stride_ob, stride_oh, stride_om, stride_ok,\n    B, H, M, N, K_dim,\n    scale: tl.constexpr,\n    BLOCK_M: tl.constexpr, BLOCK_N: tl.constexpr,\n    BLOCK_K: tl.constexpr\n):\n    pid_b = tl.program_id(0)\n    pid_h = tl.program_id(1)\n    pid_m = tl.program_id(2)\n    \n    offs_m = pid_m * BLOCK_M + tl.arange(0, BLOCK_M)\n    offs_n = tl.arange(0, BLOCK_N)\n    offs_k = tl.arange(0, BLOCK_K)\n    \n    # Load Q block with proper masking\n    mask_m = offs_m < M\n    q_ptrs = Q + pid_b * stride_qb + pid_h * stride_qh + (offs_m[:, None] * stride_qm + offs_k[None, :] * stride_qk)\n    q = tl.load(q_ptrs, mask=mask_m[:, None], other=0.0)\n    q = (q * scale).to(tl.float32)\n    \n    # Initialize accumulators and state variables\n    acc = tl.zeros((BLOCK_M, BLOCK_K), dtype=tl.float32)\n    m_i = tl.zeros((BLOCK_M,), dtype=tl.float32) - float('inf')\n    l_i = tl.zeros((BLOCK_M,), dtype=tl.float32)\n    \n    # Loop over key/value blocks\n    for block_n in range(0, tl.cdiv(N, BLOCK_N)):\n        offs_n_curr = block_n * BLOCK_N + offs_n\n        mask_n = offs_n_curr < N\n        \n        # Load K block\n        k_ptrs = K + pid_b * stride_kb + pid_h * stride_kh + (offs_n_curr[:, None] * stride_kn + offs_k[None, :] * stride_kk)\n        k = tl.load(k_ptrs, mask=mask_n[:, None], other=0.0).to(tl.float32)\n        \n        # Compute QK scores\n        qk = tl.dot(q, tl.trans(k))\n        \n        # Update max and exponential sums\n        m_ij = tl.max(qk, axis=1)\n        m_ij = tl.where(mask_m, m_ij, -float('inf'))\n        m_i_new = tl.maximum(m_i, m_ij)\n        alpha = tl.exp(m_i - m_i_new)\n        p = tl.exp(qk - m_i_new[:, None])\n        \n        # Scale current values and update accumulators\n        acc = acc * alpha[:, None]\n        l_i = l_i * alpha\n        l_ij = tl.sum(p, axis=1)\n        l_i = l_i + l_ij\n        \n        # Load V block and update output\n        v_ptrs = V + pid_b * stride_vb + pid_h * stride_vh + (offs_n_curr[:, None] * stride_vn + offs_k[None, :] * stride_vk)\n        v = tl.load(v_ptrs, mask=mask_n[:, None], other=0.0).to(tl.float32)\n        pv = tl.dot(p, v)\n        acc = acc + pv\n        m_i = m_i_new\n    \n    # Normalize and store results\n    acc = acc / l_i[:, None]\n    acc = acc.to(q.dtype)\n    \n    out_ptrs = Out + pid_b * stride_ob + pid_h * stride_oh + (offs_m[:, None] * stride_om + offs_k[None, :] * stride_ok)\n    tl.store(out_ptrs, acc, mask=mask_m[:, None])\n\nclass ModelNew(nn.Module):\n    def __init__(self, embed_dim, num_heads):\n        super().__init__()\n        self.embed_dim = embed_dim\n        self.num_heads = num_heads\n        self.head_dim = embed_dim // num_heads\n        \n        self.q_proj = nn.Linear(embed_dim, embed_dim)\n        self.k_proj = nn.Linear(embed_dim, embed_dim)\n        self.v_proj = nn.Linear(embed_dim, embed_dim)\n        self.out_proj = nn.Linear(embed_dim, embed_dim)\n        self.norm = nn.LayerNorm(embed_dim)\n\n    def forward(self, x):\n        B, C, H, W = x.shape\n        M = H * W\n        x = x.view(B, C, M).permute(2, 0, 1)  # (M, B, C)\n        \n        q = self.q_proj(x)  # (M, B, C)\n        k = self.k_proj(x)  # (M, B, C)\n        v = self.v_proj(x)  # (M, B, C)\n        \n        # Reshape to (B, H, M, D)\n        q = q.permute(1, 0, 2).reshape(B, M, self.num_heads, self.head_dim).permute(0, 2, 1, 3)\n        k = k.permute(1, 0, 2).reshape(B, M, self.num_heads, self.head_dim).permute(0, 2, 1, 3)\n        v = v.permute(1, 0, 2).reshape(B, M, self.num_heads, self.head_dim).permute(0, 2, 1, 3)\n        \n        out = torch.empty_like(q)\n        scale = 1.0 / math.sqrt(self.head_dim)\n        \n        BLOCK_M = 64\n        BLOCK_N = 32\n        BLOCK_K = self.head_dim\n        \n        grid = lambda META: (B, self.num_heads, triton.cdiv(M, BLOCK_M))\n        _attn_kernel[grid](\n            q, k, v, out,\n            q.stride(0), q.stride(1), q.stride(2), q.stride(3),\n            k.stride(0), k.stride(1), k.stride(2), k.stride(3),\n            v.stride(0), v.stride(1), v.stride(2), v.stride(3),\n            out.stride(0), out.stride(1), out.stride(2), out.stride(3),\n            B, self.num_heads, M, M, self.head_dim,\n            scale,\n            BLOCK_M=BLOCK_M, BLOCK_N=BLOCK_N, BLOCK_K=BLOCK_K\n        )\n        \n        out = out.permute(0, 2, 1, 3).reshape(B, M, C)\n        out = self.out_proj(out)\n        \n        residual = x.permute(1, 0, 2)\n        out = self.norm(out + residual)\n        out = out.permute(1, 0, 2).reshape(B, C, H, W)\n        return out\n\nembed_dim = 128\nnum_heads = 4\nbatch_size = 2\nnum_channels = embed_dim\nimage_height = 128\nimage_width = 128\n\ndef get_inputs():\n    return [torch.randn(batch_size, num_channels, image_height, image_width)]\n\ndef get_init_inputs():\n    return [embed_dim, num_heads]\n# =================== EVOLVE-BLOCK-END ===================", "language": "python", "parent_id": "22cd5b56-9619-4476-b8af-e0d2a3ccbc70", "generation": 2, "timestamp": 1754593788.8731518, "iteration_found": 7, "metrics": {"compiled": true, "correctness": false, "score": 10, "stage": "wrong_answer", "verify_payload": {"id": "level3_31_VisionAttention", "result": {"compiled": true, "correctness": false, "metadata": {"hardware": "NVIDIA L20Y", "device": "cuda:4", "max_difference": ["6.869098", "7.314764", "7.408036", "8.816509", "7.283052"], "avg_difference": ["1.129559", "1.130014", "1.129334", "1.128960", "1.129562"], "correctness_issue": "Output mismatch", "correctness_trials": "(0 / 5)", "reference_timing_ms": 0.335, "speed_up": -1.0, "custom_timing": -1.0}, "runtime": -1.0, "runtime_stats": {}}}}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": true, "correctness": false, "score": 10, "stage": "wrong_answer", "verify_payload": {"id": "level3_31_VisionAttention", "result": {"compiled": true, "correctness": false, "metadata": {"hardware": "NVIDIA L20Y", "device": "cuda:1", "max_difference": ["6.771070", "7.354507", "7.481483", "8.807193", "7.226679"], "avg_difference": ["1.129560", "1.129993", "1.129336", "1.128959", "1.129563"], "correctness_issue": "Output mismatch", "correctness_trials": "(0 / 5)", "reference_timing_ms": 0.335, "speed_up": -1.0, "custom_timing": -1.0}, "runtime": -1.0, "runtime_stats": {}}}}, "island": 0}, "artifacts_json": null, "artifact_dir": null}