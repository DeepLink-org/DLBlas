{"id": "3ee8b488-b1a9-4eba-8ece-5672f6d36928", "code": "import triton\nimport triton.language as tl\n\n@triton.jit\ndef conv2d_7x7_naive(\n    x_ptr, weight_ptr, output_ptr,\n    batch_size, in_channels, in_h, in_w,\n    out_channels, out_h, out_w,\n    stride, padding,\n    BLOCK_SIZE_BATCH: tl.constexpr, BLOCK_SIZE_OUT_CH: tl.constexpr, BLOCK_SIZE_H: tl.constexpr, BLOCK_SIZE_W: tl.constexpr,\n):\n    pid_batch = tl.program_id(0)\n    pid_out_ch = tl.program_id(1)\n    pid_h = tl.program_id(2)\n    pid_w = tl.program_id(3)\n\n    if pid_batch >= batch_size or pid_out_ch >= out_channels or pid_h >= out_h or pid_w >= out_w:\n        return\n\n    out_offset = pid_batch * out_channels * out_h * out_w + pid_out_ch * out_h * out_w + pid_h * out_w + pid_w\n    output = 0.0\n\n    # Precompute base offsets\n    input_batch_offset = pid_batch * in_channels * in_h * in_w\n    weight_oc_offset = pid_out_ch * in_channels * 7 * 7\n    VEC = 4  # Vector length for channel dimension\n\n    # Loop over kernel positions with static unrolling\n    for kh in tl.static_range(7):\n        for kw in tl.static_range(7):\n            h_in = pid_h * stride - padding + kh\n            w_in = pid_w * stride - padding + kw\n            \n            # Check spatial boundaries once per kernel position\n            if h_in >= 0 and h_in < in_h and w_in >= 0 and w_in < in_w:\n                # Vectorized loop over channels\n                for c in range(0, in_channels, VEC):\n                    # Create mask for vector load\n                    mask = c + tl.arange(0, VEC) < in_channels\n                    \n                    # Compute base positions\n                    input_offset = input_batch_offset + c * in_h * in_w + h_in * in_w + w_in\n                    weight_offset = weight_oc_offset + c * 49 + kh * 7 + kw\n                    \n                    # Vectorized loads\n                    x_vals = tl.load(\n                        x_ptr + input_offset + tl.arange(0, VEC) * in_h * in_w,\n                        mask=mask, other=0.0\n                    )\n                    w_vals = tl.load(\n                        weight_ptr + weight_offset + tl.arange(0, VEC) * 49,\n                        mask=mask, other=0.0\n                    )\n                    \n                    # Fused multiply-add\n                    output += tl.sum(x_vals * w_vals)\n\n    tl.store(output_ptr + out_offset, output)", "language": "python", "parent_id": "6f38c9eb-ebbd-49ac-92c5-25555055673c", "generation": 2, "timestamp": 1754595670.2059488, "iteration_found": 14, "metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": false, "score": 20, "speed_up": 0.86, "runtime_ms": 1.57, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:7", "correctness_trials": "(5 / 5)", "reference_timing_ms": 1.35, "speed_up": 0.86, "custom_timing": 1.57}}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": false, "score": 20, "speed_up": 0.854, "runtime_ms": 1.58, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:0", "correctness_trials": "(5 / 5)", "reference_timing_ms": 1.35, "speed_up": 0.854, "custom_timing": 1.58}}, "island": 0}, "artifacts_json": null, "artifact_dir": null}