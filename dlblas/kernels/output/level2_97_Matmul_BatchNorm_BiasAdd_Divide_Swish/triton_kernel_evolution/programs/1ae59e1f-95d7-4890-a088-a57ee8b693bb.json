{"id": "1ae59e1f-95d7-4890-a088-a57ee8b693bb", "code": "# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef _forward_kernel(\n    input_ptr, weight_ptr, bias_ptr, output_ptr,\n    M, N, K,\n    stride_im, stride_ik,\n    stride_wn, stride_wk,\n    stride_bn,\n    stride_om, stride_on,\n    divide_value: tl.constexpr,\n    BLOCK_M: tl.constexpr, BLOCK_N: tl.constexpr, BLOCK_K: tl.constexpr\n):\n    pid = tl.program_id(0)\n    num_pid_n = tl.cdiv(N, BLOCK_N)\n    pid_m = pid // num_pid_n\n    pid_n = pid % num_pid_n\n\n    offs_m = pid_m * BLOCK_M + tl.arange(0, BLOCK_M)\n    offs_n = pid_n * BLOCK_N + tl.arange(0, BLOCK_N)\n    offs_k = tl.arange(0, BLOCK_K)\n\n    input_ptrs = input_ptr + offs_m[:, None] * stride_im + offs_k[None, :] * stride_ik\n    weight_ptrs = weight_ptr + offs_n[:, None] * stride_wn + offs_k[None, :] * stride_wk\n\n    acc = tl.zeros((BLOCK_M, BLOCK_N), dtype=tl.float32)\n    for k in range(0, tl.cdiv(K, BLOCK_K)):\n        k_remaining = K - k * BLOCK_K\n        k_mask = offs_k < k_remaining\n        a = tl.load(input_ptrs, mask=k_mask[None, :] & (offs_m[:, None] < M), other=0.0)\n        b = tl.load(weight_ptrs, mask=k_mask[None, :] & (offs_n[:, None] < N), other=0.0)\n        acc += tl.dot(a, tl.trans(b))\n        input_ptrs += BLOCK_K * stride_ik\n        weight_ptrs += BLOCK_K * stride_wk\n\n    bias_vals = tl.load(bias_ptr + offs_n, mask=offs_n < N, other=0.0)\n    acc += bias_vals[None, :]\n    acc = acc / divide_value\n    sig = tl.sigmoid(acc)\n    acc = acc * sig\n\n    offs_m = pid_m * BLOCK_M + tl.arange(0, BLOCK_M)\n    offs_n = pid_n * BLOCK_N + tl.arange(0, BLOCK_N)\n    output_ptrs = output_ptr + stride_om * offs_m[:, None] + stride_on * offs_n[None, :]\n    output_mask = (offs_m[:, None] < M) & (offs_n[None, :] < N)\n    tl.store(output_ptrs, acc, mask=output_mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, bn_eps=1e-5, bn_momentum=0.1, bias_shape=(1,), divide_value=1.0):\n        super(ModelNew, self).__init__()\n        self.matmul = nn.Linear(in_features, out_features)\n        self.bn = nn.BatchNorm1d(out_features, eps=bn_eps, momentum=bn_momentum)\n        self.bias = nn.Parameter(torch.randn(bias_shape))\n        self.divide_value = divide_value\n        self.fused_weight = None\n        self.fused_bias = None\n\n    def _precompute_fused_params(self):\n        weight = self.matmul.weight.data\n        linear_bias = self.matmul.bias.data if self.matmul.bias is not None else 0\n        bn_weight = self.bn.weight.data\n        bn_bias = self.bn.bias.data\n        running_mean = self.bn.running_mean\n        running_var = self.bn.running_var\n        eps = self.bn.eps\n\n        denom = 1.0 / torch.sqrt(running_var + eps)\n        fused_w = weight * (bn_weight * denom).view(-1, 1)\n        fused_b = (linear_bias - running_mean) * (bn_weight * denom) + bn_bias + self.bias\n        return fused_w, fused_b\n\n    def forward(self, x):\n        if self.training:\n            x = self.matmul(x)\n            x = self.bn(x)\n            x = x + self.bias\n            x = x / self.divide_value\n            return x * torch.sigmoid(x)\n        else:\n            if self.fused_weight is None or self.fused_bias is None:\n                self.fused_weight, self.fused_bias = self._precompute_fused_params()\n            \n            M, K = x.shape\n            N = self.fused_weight.shape[0]\n            output = torch.empty((M, N), device=x.device, dtype=x.dtype)\n            \n            grid = lambda opt: (triton.cdiv(M, opt.BLOCK_M) * triton.cdiv(N, opt.BLOCK_N),)\n            _forward_kernel[grid](\n                x, self.fused_weight, self.fused_bias, output,\n                M, N, K,\n                x.stride(0), x.stride(1),\n                self.fused_weight.stride(0), self.fused_weight.stride(1),\n                self.fused_bias.stride(0),\n                output.stride(0), output.stride(1),\n                self.divide_value,\n                BLOCK_M=128, BLOCK_N=128, BLOCK_K=32\n            )\n            return output\n\nbatch_size = 128\nin_features = 1024\nout_features = 512\nbn_eps = 1e-5\nbn_momentum = 0.1\nbias_shape = (1,)\ndivide_value = 1.0\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, bn_eps, bn_momentum, bias_shape, divide_value]\n# =================== EVOLVE-BLOCK-END ===================", "language": "python", "parent_id": "5bb50a77-0cec-420e-ae58-4f2c86edc0a7", "generation": 2, "timestamp": 1754591531.7389157, "iteration_found": 28, "metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": true, "score": 20.89999999999999, "speed_up": 1.009, "runtime_ms": 0.109, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:0", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.11, "speed_up": 1.009, "custom_timing": 0.109}}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": true, "score": 24.800000000000004, "speed_up": 1.048, "runtime_ms": 0.105, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:2", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.11, "speed_up": 1.048, "custom_timing": 0.105}}, "island": 1}, "artifacts_json": null, "artifact_dir": null}