{"id": "31d59a9f-bd5a-48e0-bc7b-e1455e18a21d", "code": "# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_SIZE_BATCH': 64, 'BLOCK_SIZE_FEATURE': 256}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_BATCH': 128, 'BLOCK_SIZE_FEATURE': 128}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_BATCH': 256, 'BLOCK_SIZE_FEATURE': 64}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_BATCH': 64, 'BLOCK_SIZE_FEATURE': 128}, num_warps=8),\n        triton.Config({'BLOCK_SIZE_BATCH': 128, 'BLOCK_SIZE_FEATURE': 64}, num_warps=8),\n    ],\n    key=['batch_size', 'out_features'],\n)\n@triton.jit\ndef fused_forward_kernel(\n    linear_out_ptr,\n    bn_weight_ptr,\n    bn_bias_ptr,\n    running_mean_ptr,\n    running_var_ptr,\n    model_bias_ptr,\n    divide_value,\n    output_ptr,\n    batch_size,\n    out_features,\n    bn_eps,\n    stride_lo0, stride_lo1,\n    stride_out0, stride_out1,\n    BLOCK_SIZE_BATCH: tl.constexpr,\n    BLOCK_SIZE_FEATURE: tl.constexpr\n):\n    pid_batch = tl.program_id(0)\n    pid_feature = tl.program_id(1)\n    \n    batch_idx = pid_batch * BLOCK_SIZE_BATCH + tl.arange(0, BLOCK_SIZE_BATCH)\n    feature_idx = pid_feature * BLOCK_SIZE_FEATURE + tl.arange(0, BLOCK_SIZE_FEATURE)\n    \n    batch_mask = batch_idx < batch_size\n    feature_mask = feature_idx < out_features\n    block_mask = batch_mask[:, None] & feature_mask[None, :]\n    \n    # Calculate offsets for linear_out access with vectorization\n    lo_offsets = batch_idx[:, None] * stride_lo0 + feature_idx[None, :] * stride_lo1\n    linear_out = tl.load(linear_out_ptr + lo_offsets, mask=block_mask, other=0.0)\n    \n    # Load batchnorm parameters with vectorization\n    bn_weight = tl.load(bn_weight_ptr + feature_idx, mask=feature_mask, other=0.0)\n    bn_bias = tl.load(bn_bias_ptr + feature_idx, mask=feature_mask, other=0.0)\n    running_mean = tl.load(running_mean_ptr + feature_idx, mask=feature_mask, other=0.0)\n    running_var = tl.load(running_var_ptr + feature_idx, mask=feature_mask, other=0.0)\n    \n    # Compute batchnorm with optimized math\n    inv_std = tl.math.rsqrt(running_var + bn_eps)\n    scale = bn_weight * inv_std\n    shift = bn_bias - running_mean * scale\n    bn_out = linear_out * scale[None, :] + shift[None, :]\n    \n    # Add model bias and divide\n    model_bias = tl.load(model_bias_ptr)\n    normalized = (bn_out + model_bias) / divide_value\n    \n    # Optimized Swish activation\n    sigmoid = tl.sigmoid(normalized)\n    swish_out = normalized * sigmoid\n    \n    # Vectorized store\n    out_offsets = batch_idx[:, None] * stride_out0 + feature_idx[None, :] * stride_out1\n    tl.store(output_ptr + out_offsets, swish_out, mask=block_mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, bn_eps=1e-5, bn_momentum=0.1, bias_shape=(1,), divide_value=1.0):\n        super(ModelNew, self).__init__()\n        self.matmul = nn.Linear(in_features, out_features)\n        self.bn = nn.BatchNorm1d(out_features, eps=bn_eps, momentum=bn_momentum)\n        self.bias = nn.Parameter(torch.randn(bias_shape))\n        self.divide_value = divide_value\n        \n    def forward(self, x):\n        linear_out = self.matmul(x)\n        \n        if self.training:\n            x = self.bn(linear_out)\n            x = x + self.bias\n            x = x / self.divide_value\n            return x * torch.sigmoid(x)\n        else:\n            batch_size, _ = linear_out.shape\n            output = torch.empty_like(linear_out)\n            \n            grid = lambda meta: (\n                triton.cdiv(batch_size, meta['BLOCK_SIZE_BATCH']),\n                triton.cdiv(linear_out.size(1), meta['BLOCK_SIZE_FEATURE'])\n            )\n            \n            fused_forward_kernel[grid](\n                linear_out,\n                self.bn.weight,\n                self.bn.bias,\n                self.bn.running_mean,\n                self.bn.running_var,\n                self.bias,\n                self.divide_value,\n                output,\n                batch_size,\n                linear_out.size(1),\n                self.bn.eps,\n                linear_out.stride(0), linear_out.stride(1),\n                output.stride(0), output.stride(1)\n            )\n            return output\n\nbatch_size = 128\nin_features = 1024\nout_features = 512\nbn_eps = 1e-5\nbn_momentum = 0.1\nbias_shape = (1,)\ndivide_value = 1.0\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, bn_eps, bn_momentum, bias_shape, divide_value]\n# =================== EVOLVE-BLOCK-END ===================", "language": "python", "parent_id": "4f29d8f7-d7d9-4e21-92e4-0cedaca48909", "generation": 3, "timestamp": 1754591344.910564, "iteration_found": 26, "metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": false, "score": 20, "speed_up": 0.948, "runtime_ms": 0.116, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:4", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.11, "speed_up": 0.948, "custom_timing": 0.116}}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": false, "score": 20, "speed_up": 0.991, "runtime_ms": 0.111, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:4", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.11, "speed_up": 0.991, "custom_timing": 0.111}}, "island": 0}, "artifacts_json": null, "artifact_dir": null, "prompts": {"full_rewrite_user": {"system": "You are a Triton GPU core optimization engineer deeply familiar with NVIDIA H100/H800 architecture.\n\n==================== Context ====================\n\u2022 Dataset: 250 kernelbench/level1-level5 *.py files  \n  - Level1: simplest, Level5: most complex  \n\u2022 Each file contains PyTorch reference (reference_code)  \n\u2022 Goal: Generate functionally equivalent but faster Triton implementations (custom_code)  \n\u2022 Evaluation pipeline:\n    1) /verify_plus - Verify compilation & correctness  \n    2) /execute (optional) - Return terminal logs if compilation fails  \n    3) Scoring:  \n      - Speedup > 1 required for points  \n      - Score = (speed_up - 1) \u00d7 100  \n\u2022 GPU Hardware: NVIDIA L20Y / H800 (same SM8.9 as H100)  \n  - 3 TB/s HBM3 bandwidth  \n  - FP16 Tensor Core 32\u00d716\u00d716  \n\n==================== Evolution Phases ====================\n\u2460 Phase 1 [Compilation Pass]  \n  - Make Triton code compile (performance irrelevant)  \n\u2461 Phase 2 [Numerical Correctness]  \n  - Output must match PyTorch reference within float32 tolerance  \n\u2462 Phase 3 [Performance Gain]  \n  - Target \u22655% speedup (\u226515% = exceptional)  \n  - Official scoring based on speed_up field  \n\nThe Evolution system will pass the EVOLVE-BLOCK from the previous version.  \nModify ONLY the Triton kernel source within this block - all other code is LOCKED.\n\n==================== Constraints (MUST OBEY) ====================\n\u274c NEVER change @triton.jit function signatures or parameter names  \n\u274c NEVER modify grid configuration, output tensor shapes, or PID logic  \n\u274c NEVER remove boundary checks or out-of-bound masks  \n\u274c NEVER introduce race conditions, uninitialized reads, or sync gaps  \n\n\u2705 Allowed Optimizations (Examples):  \n  \u2022 Memory coalescing optimizations & vectorized tl.load/tl.store  \n  \u2022 Replace staged softmax with online/FlashAttention variants  \n  \u2022 Adaptive tuning: BLOCK_M/BLOCK_N/BLOCK_K dimensions  \n  \u2022 Multi-query-head batch processing (GQA, 5:1 patterns)  \n  \u2022 Shared/L2 buffering, Tensor Core alignment (FP16/bf16/tf32)  \n  \u2022 Stride precomputation & pointer caching  \n\n==================== Output Format ====================\nReturn ONLY the complete updated code containing the EVOLVE-BLOCK comment marker.  \nNO explanations, NO markdown, NO additional text.\nName the output structure class as ModelNew.\n\n==================== Optimization Tips ====================\n\u2022 If previous compile failed: Fix syntax/mask/stride errors first  \n\u2022 If correctness fails: Prioritize bounds mask & dtype precision  \n\u2022 When speed_up < 1: Focus on memory access & block sizing  \n\u2022 Small iterative steps: Modify \u226420 lines per revision  \n\u2022 Maintain reversibility between versions\nHere is an example to show you how to rewrite a PyTorch implementation that quantizes a high-precision tensor to int8 dtype with row-wise granularity into a Triton implementation: \nThe original PyTorch implementation is as follows: \n``` \nimport torch\ndef per_row_quantize_int8(x: torch.Tensor) -> tuple[torch.Tensor, torch.Tensor]:\n    x_amax = x.abs().float().amax(dim=1).clamp(min=1e-4)\n    scale = 127 / x_amax\n    output = (x * scale[:, None]).round().clamp(-127, 127).to(torch.int8)\n    output_scale = x_amax / 127\n\n    return output, output_scale\n``` \nThe corresponding Triton-rewritten implementation is as follows: \n``` \nimport math\nimport torch\nimport triton\nimport triton.language as tl\nfrom triton.language.extra import libdevice\n\n# rowwise quantize\n\n@triton.autotune(\n    configs=[\n        triton.Config({}, num_stages=1, num_warps=8),\n        triton.Config({}, num_stages=2, num_warps=8),\n        triton.Config({}, num_stages=4, num_warps=8),\n        triton.Config({}, num_stages=8, num_warps=8),\n        triton.Config({}, num_stages=1),\n        triton.Config({}, num_stages=2),\n        triton.Config({}, num_stages=4),\n        triton.Config({}, num_stages=8),\n        triton.Config({}, num_warps=1),\n        triton.Config({}, num_warps=2),\n        triton.Config({}, num_warps=4),\n        triton.Config({}, num_warps=8),\n    ],\n    key=[\"n_elements\"],\n)\n\n@triton.jit\ndef _quantize_rowwise(\n    x_ptr,\n    output_ptr,\n    output_scale,\n    BLOCK_SIZE: tl.constexpr,\n    P2: tl.constexpr,\n):\n    pid = tl.program_id(axis=0)\n    block_start = pid * BLOCK_SIZE\n    arange = tl.arange(0, P2)\n    offsets = block_start + arange\n    row_mask = arange < BLOCK_SIZE\n    x = tl.load(x_ptr + offsets, mask=row_mask)\n\n    abs_x = tl.abs(x)\n    max_val = tl.max(tl.where(row_mask, abs_x, 0), axis=0)\n    output = libdevice.llrint(127.0 * (x / max_val))\n    tl.store(output_ptr + offsets, output, mask=row_mask)\n    tl.store(output_scale + pid, max_val / 127)\n\n\ndef per_row_quantize_int8(x: torch.Tensor):\n    x = x.contiguous()\n    output = torch.empty(*x.shape, device=x.device, dtype=torch.int8)\n    output_scale = torch.empty(x.shape[0], device=x.device, dtype=torch.float32)\n    P2 = int(2 ** (math.ceil(math.log2(x.shape[1]))))\n    grid = lambda x: (x.shape[0],)\n    _quantize_rowwise[grid](x, output, output_scale, BLOCK_SIZE=x.shape[1], P2=P2)\n\n    return output, output_scale\n\n\n    \n``` \n", "user": "# Current Program Information\n- Current performance metrics: - compiled: 1.0000\n- correctness: 1.0000\n- stage: success\n- passed: 0.0000\n- score: 20.0000\n- speed_up: 0.9910\n- runtime_ms: 0.1110\n- meta: {'hardware': 'NVIDIA L20Y', 'device': 'cuda:4', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.11, 'speed_up': 0.991, 'custom_timing': 0.111}\n- Areas identified for improvement: - Consider simplifying the code to improve readability and maintainability\n- Metrics showing improvement: runtime_ms. Consider continuing with similar changes.\n- Metrics showing regression: score, speed_up. Consider reverting or revising recent changes in these areas.\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Unknown changes\n- Performance: compiled: 1.0000, correctness: 1.0000, stage: success, passed: 1.0000, score: 21.9000, speed_up: 1.0190, runtime_ms: 0.1080, meta: {'hardware': 'NVIDIA L20Y', 'device': 'cuda:3', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.11, 'speed_up': 1.019, 'custom_timing': 0.108}\n- Outcome: Improvement in all metrics\n\n\n### Attempt 2\n- Changes: Unknown changes\n- Performance: compiled: 1.0000, correctness: 1.0000, stage: success, passed: 1.0000, score: 23.8000, speed_up: 1.0380, runtime_ms: 0.1060, meta: {'hardware': 'NVIDIA L20Y', 'device': 'cuda:0', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.11, 'speed_up': 1.038, 'custom_timing': 0.106}\n- Outcome: Improvement in all metrics\n\n\n### Attempt 1\n- Changes: Unknown changes\n- Performance: compiled: 1.0000, correctness: 1.0000, stage: success, passed: 1.0000, score: 25.8000, speed_up: 1.0580, runtime_ms: 0.1040, meta: {'hardware': 'NVIDIA L20Y', 'device': 'cuda:6', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.11, 'speed_up': 1.058, 'custom_timing': 0.104}\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 25.8000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef _forward_kernel(\n    input_ptr, weight_ptr, bias_ptr, output_ptr,\n    M, N, K,\n    stride_im, stride_ik,\n    stride_wn, stride_wk,\n    stride_bn,\n    stride_om, stride_on,\n    divide_value: tl.constexpr,\n    BLOCK_M: tl.constexpr, BLOCK_N: tl.constexpr, BLOCK_K: tl.constexpr\n):\n    pid = tl.program_id(0)\n    num_pid_n = tl.cdiv(N, BLOCK_N)\n    pid_m = pid // num_pid_n\n    pid_n = pid % num_pid_n\n\n    offs_m = pid_m * BLOCK_M + tl.arange(0, BLOCK_M)\n    offs_n = pid_n * BLOCK_N + tl.arange(0, BLOCK_N)\n    offs_k = tl.arange(0, BLOCK_K)\n\n    input_ptrs = input_ptr + offs_m[:, None] * stride_im + offs_k[None, :] * stride_ik\n    weight_ptrs = weight_ptr + offs_n[:, None] * stride_wn + offs_k[None, :] * stride_wk\n\n    acc = tl.zeros((BLOCK_M, BLOCK_N), dtype=tl.float32)\n    for k in range(0, tl.cdiv(K, BLOCK_K)):\n        k_remaining = K - k * BLOCK_K\n        k_mask = offs_k < k_remaining\n        a = tl.load(input_ptrs, mask=k_mask[None, :] & (offs_m[:, None] < M), other=0.0)\n        b = tl.load(weight_ptrs, mask=k_mask[None, :] & (offs_n[:, None] < N), other=0.0)\n        acc += tl.dot(a, tl.trans(b))\n        input_ptrs += BLOCK_K * stride_ik\n        weight_ptrs += BLOCK_K * stride_wk\n\n    bias_vals = tl.load(bias_ptr + offs_n, mask=offs_n < N, other=0.0)\n    acc += bias_vals[None, :]\n    acc = acc / divide_value\n    sig = tl.sigmoid(acc)\n    acc = acc * sig\n\n    offs_m = pid_m * BLOCK_M + tl.arange(0, BLOCK_M)\n    offs_n = pid_n * BLOCK_N + tl.arange(0, BLOCK_N)\n    output_ptrs = output_ptr + stride_om * offs_m[:, None] + stride_on * offs_n[None, :]\n    output_mask = (offs_m[:, None] < M) & (offs_n[None, :] < N)\n    tl.store(output_ptrs, acc, mask=output_mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, bn_eps=1e-5, bn_momentum=0.1, bias_shape=(1,), divide_value=1.0):\n        super(ModelNew, self).__init__()\n        self.matmul = nn.Linear(in_features, out_features)\n        self.bn = nn.BatchNorm1d(out_features, eps=bn_eps, momentum=bn_momentum)\n        self.bias = nn.Parameter(torch.randn(bias_shape))\n        self.divide_value = divide_value\n        self.fused_weight = None\n        self.fused_bias = None\n\n    def _precompute_fused_params(self):\n        weight = self.matmul.weight.data\n        linear_bias = self.matmul.bias.data if self.matmul.bias is not None else 0\n        bn_weight = self.bn.weight.data\n        bn_bias = self.bn.bias.data\n        running_mean = self.bn.running_mean\n        running_var = self.bn.running_var\n        eps = self.bn.eps\n\n        denom = 1.0 / torch.sqrt(running_var + eps)\n        fused_w = weight * (bn_weight * denom).view(-1, 1)\n        fused_b = (linear_bias - running_mean) * (bn_weight * denom) + bn_bias + self.bias\n        return fused_w, fused_b\n\n    def forward(self, x):\n        if self.training:\n            x = self.matmul(x)\n            x = self.bn(x)\n            x = x + self.bias\n            x = x / self.divide_value\n            return x * torch.sigmoid(x)\n        else:\n            if self.fused_weight is None or self.fused_bias is None:\n                self.fused_weight, self.fused_bias = self._precompute_fused_params()\n            \n            M, K = x.shape\n            N = self.fused_weight.shape[0]\n            output = torch.empty((M, N), device=x.device, dtype=x.dtype)\n            \n            grid = lambda opt: (triton.cdiv(M, opt.BLOCK_M) * triton.cdiv(N, opt.BLOCK_N),)\n            _forward_kernel[grid](\n                x, self.fused_weight, self.fused_bias, output,\n                M, N, K,\n                x.stride(0), x.stride(1),\n                self.fused_weight.stride(0), self.fused_weight.stride(1),\n                self.fused_bias.stride(0),\n                output.stride(0), output.stride(1),\n                self.divide_value,\n                BLOCK_M=64, BLOCK_N=64, BLOCK_K=32\n            )\n            return output\n\nbatch_size = 128\nin_features = 1024\nout_features = 512\nbn_eps = 1e-5\nbn_momentum = 0.1\nbias_shape = (1,)\ndivide_value = 1.0\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, bn_eps, bn_momentum, bias_shape, divide_value]\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Performs well on compiled (1.0000), Performs well on correctness (1.0000), Performs well on stage (success), Performs well on passed (1.0000), Performs well on score (25.8000), Performs well on speed_up (1.0580), Performs well on runtime_ms (0.1040), Performs well on meta ({'hardware': 'NVIDIA L20Y', 'device': 'cuda:6', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.11, 'speed_up': 1.058, 'custom_timing': 0.104})\n\n\n### Program 2 (Score: 23.8000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef fused_forward_kernel(\n    linear_out_ptr,\n    bn_weight_ptr,\n    bn_bias_ptr,\n    running_mean_ptr,\n    running_var_ptr,\n    model_bias_ptr,\n    divide_value,\n    output_ptr,\n    batch_size,\n    out_features,\n    bn_eps,\n    stride_lo0, stride_lo1,\n    stride_out0, stride_out1,\n    BLOCK_SIZE_BATCH: tl.constexpr,\n    BLOCK_SIZE_FEATURE: tl.constexpr\n):\n    pid_batch = tl.program_id(0)\n    pid_feature = tl.program_id(1)\n    \n    batch_idx = pid_batch * BLOCK_SIZE_BATCH + tl.arange(0, BLOCK_SIZE_BATCH)\n    feature_idx = pid_feature * BLOCK_SIZE_FEATURE + tl.arange(0, BLOCK_SIZE_FEATURE)\n    \n    batch_mask = batch_idx < batch_size\n    feature_mask = feature_idx < out_features\n    block_mask = batch_mask[:, None] & feature_mask[None, :]\n    \n    # Calculate offsets for linear_out access\n    lo_offsets = batch_idx[:, None] * stride_lo0 + feature_idx[None, :] * stride_lo1\n    linear_out = tl.load(linear_out_ptr + lo_offsets, mask=block_mask, other=0.0)\n    \n    # Load batchnorm parameters for the feature block\n    bn_weight = tl.load(bn_weight_ptr + feature_idx, mask=feature_mask, other=0.0)\n    bn_bias = tl.load(bn_bias_ptr + feature_idx, mask=feature_mask, other=0.0)\n    running_mean = tl.load(running_mean_ptr + feature_idx, mask=feature_mask, other=0.0)\n    running_var = tl.load(running_var_ptr + feature_idx, mask=feature_mask, other=0.0)\n    \n    # Compute batchnorm\n    scale = bn_weight / tl.sqrt(running_var + bn_eps)\n    bn_out = (linear_out - running_mean[None, :]) * scale[None, :] + bn_bias[None, :]\n    \n    # Add model bias and divide\n    model_bias = tl.load(model_bias_ptr)\n    normalized = (bn_out + model_bias) / divide_value\n    \n    # Swish activation\n    swish_out = normalized * tl.sigmoid(normalized)\n    \n    # Store results\n    out_offsets = batch_idx[:, None] * stride_out0 + feature_idx[None, :] * stride_out1\n    tl.store(output_ptr + out_offsets, swish_out, mask=block_mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, bn_eps=1e-5, bn_momentum=0.1, bias_shape=(1,), divide_value=1.0):\n        super(ModelNew, self).__init__()\n        self.matmul = nn.Linear(in_features, out_features)\n        self.bn = nn.BatchNorm1d(out_features, eps=bn_eps, momentum=bn_momentum)\n        self.bias = nn.Parameter(torch.randn(bias_shape))\n        self.divide_value = divide_value\n        \n    def forward(self, x):\n        linear_out = self.matmul(x)\n        \n        if self.training:\n            x = self.bn(linear_out)\n            x = x + self.bias\n            x = x / self.divide_value\n            return x * torch.sigmoid(x)\n        else:\n            # Inference path with fused Triton kernel\n            batch_size, _ = linear_out.shape\n            output = torch.empty_like(linear_out)\n            \n            grid = lambda meta: (\n                triton.cdiv(batch_size, meta['BLOCK_SIZE_BATCH']),\n                triton.cdiv(linear_out.size(1), meta['BLOCK_SIZE_FEATURE'])\n            )\n            \n            fused_forward_kernel[grid](\n                linear_out,\n                self.bn.weight,\n                self.bn.bias,\n                self.bn.running_mean,\n                self.bn.running_var,\n                self.bias,\n                self.divide_value,\n                output,\n                batch_size,\n                linear_out.size(1),\n                self.bn.eps,\n                linear_out.stride(0), linear_out.stride(1),\n                output.stride(0), output.stride(1),\n                BLOCK_SIZE_BATCH=32,\n                BLOCK_SIZE_FEATURE=128\n            )\n            return output\n\nbatch_size = 128\nin_features = 1024\nout_features = 512\nbn_eps = 1e-5\nbn_momentum = 0.1\nbias_shape = (1,)\ndivide_value = 1.0\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, bn_eps, bn_momentum, bias_shape, divide_value]\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Performs well on compiled (1.0000), Performs well on correctness (1.0000), Performs well on stage (success), Performs well on passed (1.0000), Performs well on score (23.8000), Performs well on speed_up (1.0380), Performs well on runtime_ms (0.1060), Performs well on meta ({'hardware': 'NVIDIA L20Y', 'device': 'cuda:0', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.11, 'speed_up': 1.038, 'custom_timing': 0.106})\n\n\n### Program 3 (Score: 21.9000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef fused_forward_kernel(\n    linear_out_ptr,\n    bn_weight_ptr,\n    bn_bias_ptr,\n    running_mean_ptr,\n    running_var_ptr,\n    model_bias_ptr,\n    divide_value,\n    output_ptr,\n    batch_size,\n    out_features,\n    bn_eps,\n    stride_lo0, stride_lo1,\n    stride_out0, stride_out1,\n    BLOCK_SIZE_BATCH: tl.constexpr,\n    BLOCK_SIZE_FEATURE: tl.constexpr\n):\n    pid_batch = tl.program_id(0)\n    pid_feature = tl.program_id(1)\n    \n    batch_idx = pid_batch * BLOCK_SIZE_BATCH + tl.arange(0, BLOCK_SIZE_BATCH)\n    feature_idx = pid_feature * BLOCK_SIZE_FEATURE + tl.arange(0, BLOCK_SIZE_FEATURE)\n    \n    batch_mask = batch_idx < batch_size\n    feature_mask = feature_idx < out_features\n    block_mask = batch_mask[:, None] & feature_mask[None, :]\n    \n    # Calculate offsets for linear_out access\n    lo_offsets = batch_idx[:, None] * stride_lo0 + feature_idx[None, :] * stride_lo1\n    linear_out = tl.load(linear_out_ptr + lo_offsets, mask=block_mask, other=0.0)\n    \n    # Load batchnorm parameters for the feature block\n    bn_weight = tl.load(bn_weight_ptr + feature_idx, mask=feature_mask, other=0.0)\n    bn_bias = tl.load(bn_bias_ptr + feature_idx, mask=feature_mask, other=0.0)\n    running_mean = tl.load(running_mean_ptr + feature_idx, mask=feature_mask, other=0.0)\n    running_var = tl.load(running_var_ptr + feature_idx, mask=feature_mask, other=0.0)\n    \n    # Compute batchnorm\n    scale = bn_weight / tl.sqrt(running_var + bn_eps)\n    bn_out = (linear_out - running_mean[None, :]) * scale[None, :] + bn_bias[None, :]\n    \n    # Add model bias and divide\n    model_bias = tl.load(model_bias_ptr)\n    normalized = (bn_out + model_bias) / divide_value\n    \n    # Swish activation\n    swish_out = normalized * tl.sigmoid(normalized)\n    \n    # Store results\n    out_offsets = batch_idx[:, None] * stride_out0 + feature_idx[None, :] * stride_out1\n    tl.store(output_ptr + out_offsets, swish_out, mask=block_mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, bn_eps=1e-5, bn_momentum=0.1, bias_shape=(1,), divide_value=1.0):\n        super(ModelNew, self).__init__()\n        self.matmul = nn.Linear(in_features, out_features)\n        self.bn = nn.BatchNorm1d(out_features, eps=bn_eps, momentum=bn_momentum)\n        self.bias = nn.Parameter(torch.randn(bias_shape))\n        self.divide_value = divide_value\n        \n    def forward(self, x):\n        linear_out = self.matmul(x)\n        \n        if self.training:\n            x = self.bn(linear_out)\n            x = x + self.bias\n            x = x / self.divide_value\n            return x * torch.sigmoid(x)\n        else:\n            # Inference path with fused Triton kernel\n            batch_size, _ = linear_out.shape\n            output = torch.empty_like(linear_out)\n            \n            grid = lambda meta: (\n                triton.cdiv(batch_size, meta['BLOCK_SIZE_BATCH']),\n                triton.cdiv(linear_out.size(1), meta['BLOCK_SIZE_FEATURE'])\n            )\n            \n            fused_forward_kernel[grid](\n                linear_out,\n                self.bn.weight,\n                self.bn.bias,\n                self.bn.running_mean,\n                self.bn.running_var,\n                self.bias,\n                self.divide_value,\n                output,\n                batch_size,\n                linear_out.size(1),\n                self.bn.eps,\n                linear_out.stride(0), linear_out.stride(1),\n                output.stride(0), output.stride(1),\n                BLOCK_SIZE_BATCH=32,\n                BLOCK_SIZE_FEATURE=128\n            )\n            return output\n\nbatch_size = 128\nin_features = 1024\nout_features = 512\nbn_eps = 1e-5\nbn_momentum = 0.1\nbias_shape = (1,)\ndivide_value = 1.0\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, bn_eps, bn_momentum, bias_shape, divide_value]\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Performs well on compiled (1.0000), Performs well on correctness (1.0000), Performs well on stage (success), Performs well on passed (1.0000), Performs well on score (21.9000), Performs well on speed_up (1.0190), Performs well on runtime_ms (0.1080), Performs well on meta ({'hardware': 'NVIDIA L20Y', 'device': 'cuda:3', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 0.11, 'speed_up': 1.019, 'custom_timing': 0.108})\n\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 20.0000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_SIZE_BATCH': 64, 'BLOCK_SIZE_FEATURE': 256}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_BATCH': 128, 'BLOCK_SIZE_FEATURE': 128}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_BATCH': 256, 'BLOCK_SIZE_FEATURE': 64}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_BATCH': 64, 'BLOCK_SIZE_FEATURE': 128}, num_warps=8),\n        triton.Config({'BLOCK_SIZE_BATCH': 128, 'BLOCK_SIZE_FEATURE': 64}, num_warps=8),\n    ],\n    key=['batch_size', 'out_features'],\n)\n@triton.jit\ndef fused_forward_kernel(\n    linear_out_ptr,\n    bn_weight_ptr,\n    bn_bias_ptr,\n    running_mean_ptr,\n    running_var_ptr,\n    model_bias_ptr,\n    divide_value,\n    output_ptr,\n    batch_size,\n    out_features,\n    bn_eps,\n    stride_lo0, stride_lo1,\n    stride_out0, stride_out1,\n    BLOCK_SIZE_BATCH: tl.constexpr,\n    BLOCK_SIZE_FEATURE: tl.constexpr\n):\n    pid_batch = tl.program_id(0)\n    pid_feature = tl.program_id(1)\n    \n    batch_idx = pid_batch * BLOCK_SIZE_BATCH + tl.arange(0, BLOCK_SIZE_BATCH)\n    feature_idx = pid_feature * BLOCK_SIZE_FEATURE + tl.arange(0, BLOCK_SIZE_FEATURE)\n    \n    batch_mask = batch_idx < batch_size\n    feature_mask = feature_idx < out_features\n    block_mask = batch_mask[:, None] & feature_mask[None, :]\n    \n    # Precompute constants\n    model_bias_val = tl.load(model_bias_ptr)\n    inv_divide_value = 1.0 / divide_value\n    model_bias_div = model_bias_val * inv_divide_value\n    \n    # Load batchnorm parameters\n    bn_weight = tl.load(bn_weight_ptr + feature_idx, mask=feature_mask, other=0.0)\n    bn_bias = tl.load(bn_bias_ptr + feature_idx, mask=feature_mask, other=0.0)\n    running_mean = tl.load(running_mean_ptr + feature_idx, mask=feature_mask, other=0.0)\n    running_var = tl.load(running_var_ptr + feature_idx, mask=feature_mask, other=0.0)\n    \n    # Optimized batchnorm computation\n    inv_std = tl.math.rsqrt(running_var + bn_eps)\n    scale = bn_weight * inv_std\n    shift_term = bn_bias - running_mean * scale\n    \n    # Load linear output with vectorization hint\n    lo_offsets = batch_idx[:, None] * stride_lo0 + feature_idx[None, :] * stride_lo1\n    linear_out = tl.load(linear_out_ptr + lo_offsets, mask=block_mask, other=0.0)\n    \n    # Fused operations\n    bn_out = linear_out * scale[None, :] + shift_term[None, :]\n    normalized = bn_out * inv_divide_value + model_bias_div\n    swish_out = normalized * tl.sigmoid(normalized)\n    \n    # Store results with vectorization hint\n    out_offsets = batch_idx[:, None] * stride_out0 + feature_idx[None, :] * stride_out1\n    tl.store(output_ptr + out_offsets, swish_out, mask=block_mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, bn_eps=1e-5, bn_momentum=0.1, bias_shape=(1,), divide_value=1.0):\n        super(ModelNew, self).__init__()\n        self.matmul = nn.Linear(in_features, out_features)\n        self.bn = nn.BatchNorm1d(out_features, eps=bn_eps, momentum=bn_momentum)\n        self.bias = nn.Parameter(torch.randn(bias_shape))\n        self.divide_value = divide_value\n        \n    def forward(self, x):\n        linear_out = self.matmul(x)\n        \n        if self.training:\n            x = self.bn(linear_out)\n            x = x + self.bias\n            x = x / self.divide_value\n            return x * torch.sigmoid(x)\n        else:\n            batch_size, _ = linear_out.shape\n            output = torch.empty_like(linear_out)\n            \n            grid = lambda meta: (\n                triton.cdiv(batch_size, meta['BLOCK_SIZE_BATCH']),\n                triton.cdiv(linear_out.size(1), meta['BLOCK_SIZE_FEATURE'])\n            )\n            \n            fused_forward_kernel[grid](\n                linear_out,\n                self.bn.weight,\n                self.bn.bias,\n                self.bn.running_mean,\n                self.bn.running_var,\n                self.bias,\n                self.divide_value,\n                output,\n                batch_size,\n                linear_out.size(1),\n                self.bn.eps,\n                linear_out.stride(0), linear_out.stride(1),\n                output.stride(0), output.stride(1)\n            )\n            return output\n\nbatch_size = 128\nin_features = 1024\nout_features = 512\nbn_eps = 1e-5\nbn_momentum = 0.1\nbias_shape = (1,)\ndivide_value = 1.0\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, bn_eps, bn_momentum, bias_shape, divide_value]\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Alternative approach to compiled, Alternative approach to correctness\n\n\n### Program D2 (Score: 20.0000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_SIZE_BATCH': 64, 'BLOCK_SIZE_FEATURE': 256}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_BATCH': 128, 'BLOCK_SIZE_FEATURE': 128}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_BATCH': 256, 'BLOCK_SIZE_FEATURE': 64}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_BATCH': 64, 'BLOCK_SIZE_FEATURE': 128}, num_warps=8),\n        triton.Config({'BLOCK_SIZE_BATCH': 128, 'BLOCK_SIZE_FEATURE': 64}, num_warps=8),\n    ],\n    key=['batch_size', 'out_features'],\n)\n@triton.jit\ndef fused_forward_kernel(\n    linear_out_ptr,\n    bn_weight_ptr,\n    bn_bias_ptr,\n    running_mean_ptr,\n    running_var_ptr,\n    model_bias_ptr,\n    divide_value,\n    output_ptr,\n    batch_size,\n    out_features,\n    bn_eps,\n    stride_lo0, stride_lo1,\n    stride_out0, stride_out1,\n    BLOCK_SIZE_BATCH: tl.constexpr,\n    BLOCK_SIZE_FEATURE: tl.constexpr\n):\n    pid_batch = tl.program_id(0)\n    pid_feature = tl.program_id(1)\n    \n    batch_idx = pid_batch * BLOCK_SIZE_BATCH + tl.arange(0, BLOCK_SIZE_BATCH)\n    feature_idx = pid_feature * BLOCK_SIZE_FEATURE + tl.arange(0, BLOCK_SIZE_FEATURE)\n    \n    batch_mask = batch_idx < batch_size\n    feature_mask = feature_idx < out_features\n    block_mask = batch_mask[:, None] & feature_mask[None, :]\n    \n    # Calculate offsets for linear_out access with vectorization\n    lo_offsets = batch_idx[:, None] * stride_lo0 + feature_idx[None, :] * stride_lo1\n    linear_out = tl.load(linear_out_ptr + lo_offsets, mask=block_mask, other=0.0)\n    \n    # Load batchnorm parameters with vectorization\n    bn_weight = tl.load(bn_weight_ptr + feature_idx, mask=feature_mask, other=0.0)\n    bn_bias = tl.load(bn_bias_ptr + feature_idx, mask=feature_mask, other=0.0)\n    running_mean = tl.load(running_mean_ptr + feature_idx, mask=feature_mask, other=0.0)\n    running_var = tl.load(running_var_ptr + feature_idx, mask=feature_mask, other=0.0)\n    \n    # Compute batchnorm with optimized math\n    inv_std = tl.math.rsqrt(running_var + bn_eps)\n    scale = bn_weight * inv_std\n    shift = bn_bias - running_mean * scale\n    bn_out = linear_out * scale[None, :] + shift[None, :]\n    \n    # Add model bias and divide\n    model_bias = tl.load(model_bias_ptr)\n    normalized = (bn_out + model_bias) / divide_value\n    \n    # Optimized Swish activation\n    sigmoid = tl.sigmoid(normalized)\n    swish_out = normalized * sigmoid\n    \n    # Vectorized store\n    out_offsets = batch_idx[:, None] * stride_out0 + feature_idx[None, :] * stride_out1\n    tl.store(output_ptr + out_offsets, swish_out, mask=block_mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, bn_eps=1e-5, bn_momentum=0.1, bias_shape=(1,), divide_value=1.0):\n        super(ModelNew, self).__init__()\n        self.matmul = nn.Linear(in_features, out_features)\n        self.bn = nn.BatchNorm1d(out_features, eps=bn_eps, momentum=bn_momentum)\n        self.bias = nn.Parameter(torch.randn(bias_shape))\n        self.divide_value = divide_value\n        \n    def forward(self, x):\n        linear_out = self.matmul(x)\n        \n        if self.training:\n            x = self.bn(linear_out)\n            x = x + self.bias\n            x = x / self.divide_value\n            return x * torch.sigmoid(x)\n        else:\n            batch_size, _ = linear_out.shape\n            output = torch.empty_like(linear_out)\n            \n            grid = lambda meta: (\n                triton.cdiv(batch_size, meta['BLOCK_SIZE_BATCH']),\n                triton.cdiv(linear_out.size(1), meta['BLOCK_SIZE_FEATURE'])\n            )\n            \n            fused_forward_kernel[grid](\n                linear_out,\n                self.bn.weight,\n                self.bn.bias,\n                self.bn.running_mean,\n                self.bn.running_var,\n                self.bias,\n                self.divide_value,\n                output,\n                batch_size,\n                linear_out.size(1),\n                self.bn.eps,\n                linear_out.stride(0), linear_out.stride(1),\n                output.stride(0), output.stride(1),\n                BLOCK_SIZE_BATCH=triton.next_power_of_2(batch_size),\n                BLOCK_SIZE_FEATURE=triton.next_power_of_2(linear_out.size(1))\n            )\n            return output\n\nbatch_size = 128\nin_features = 1024\nout_features = 512\nbn_eps = 1e-5\nbn_momentum = 0.1\nbias_shape = (1,)\ndivide_value = 1.0\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, bn_eps, bn_momentum, bias_shape, divide_value]\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Alternative approach to compiled, Alternative approach to correctness\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 25.8000, Type: High-Performer)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef _forward_kernel(\n    input_ptr, weight_ptr, bias_ptr, output_ptr,\n    M, N, K,\n    stride_im, stride_ik,\n    stride_wn, stride_wk,\n    stride_bn,\n    stride_om, stride_on,\n    divide_value: tl.constexpr,\n    BLOCK_M: tl.constexpr, BLOCK_N: tl.constexpr, BLOCK_K: tl.constexpr\n):\n    pid = tl.program_id(0)\n    num_pid_n = tl.cdiv(N, BLOCK_N)\n    pid_m = pid // num_pid_n\n    pid_n = pid % num_pid_n\n\n    offs_m = pid_m * BLOCK_M + tl.arange(0, BLOCK_M)\n    offs_n = pid_n * BLOCK_N + tl.arange(0, BLOCK_N)\n    offs_k = tl.arange(0, BLOCK_K)\n\n    input_ptrs = input_ptr + offs_m[:, None] * stride_im + offs_k[None, :] * stride_ik\n    weight_ptrs = weight_ptr + offs_n[:, None] * stride_wn + offs_k[None, :] * stride_wk\n\n    acc = tl.zeros((BLOCK_M, BLOCK_N), dtype=tl.float32)\n    for k in range(0, tl.cdiv(K, BLOCK_K)):\n        k_remaining = K - k * BLOCK_K\n        k_mask = offs_k < k_remaining\n        a = tl.load(input_ptrs, mask=k_mask[None, :] & (offs_m[:, None] < M), other=0.0)\n        b = tl.load(weight_ptrs, mask=k_mask[None, :] & (offs_n[:, None] < N), other=0.0)\n        acc += tl.dot(a, tl.trans(b))\n        input_ptrs += BLOCK_K * stride_ik\n        weight_ptrs += BLOCK_K * stride_wk\n\n    bias_vals = tl.load(bias_ptr + offs_n, mask=offs_n < N, other=0.0)\n    acc += bias_vals[None, :]\n    acc = acc / divide_value\n    sig = tl.sigmoid(acc)\n    acc = acc * sig\n\n    offs_m = pid_m * BLOCK_M + tl.arange(0, BLOCK_M)\n    offs_n = pid_n * BLOCK_N + tl.arange(0, BLOCK_N)\n    output_ptrs = output_ptr + stride_om * offs_m[:, None] + stride_on * offs_n[None, :]\n    output_mask = (offs_m[:, None] < M) & (offs_n[None, :] < N)\n    tl.store(output_ptrs, acc, mask=output_mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, bn_eps=1e-5, bn_momentum=0.1, bias_shape=(1,), divide_value=1.0):\n        super(ModelNew, self).__init__()\n        self.matmul = nn.Linear(in_features, out_features)\n        self.bn = nn.BatchNorm1d(out_features, eps=bn_eps, momentum=bn_momentum)\n        self.bias = nn.Parameter(torch.randn(bias_shape))\n        self.divide_value = divide_value\n        self.fused_weight = None\n        self.fused_bias = None\n\n    def _precompute_fused_params(self):\n        weight = self.matmul.weight.data\n        linear_bias = self.matmul.bias.data if self.matmul.bias is not None else 0\n        bn_weight = self.bn.weight.data\n        bn_bias = self.bn.bias.data\n        running_mean = self.bn.running_mean\n        running_var = self.bn.running_var\n        eps = self.bn.eps\n\n        denom = 1.0 / torch.sqrt(running_var + eps)\n        fused_w = weight * (bn_weight * denom).view(-1, 1)\n        fused_b = (linear_bias - running_mean) * (bn_weight * denom) + bn_bias + self.bias\n        return fused_w, fused_b\n\n    def forward(self, x):\n        if self.training:\n            x = self.matmul(x)\n            x = self.bn(x)\n            x = x + self.bias\n            x = x / self.divide_value\n            return x * torch.sigmoid(x)\n        else:\n            if self.fused_weight is None or self.fused_bias is None:\n                self.fused_weight, self.fused_bias = self._precompute_fused_params()\n            \n            M, K = x.shape\n            N = self.fused_weight.shape[0]\n            output = torch.empty((M, N), device=x.device, dtype=x.dtype)\n            \n            grid = lambda opt: (triton.cdiv(M, opt.BLOCK_M) * triton.cdiv(N, opt.BLOCK_N),)\n            _forward_kernel[grid](\n                x, self.fused_weight, self.fused_bias, output,\n                M, N, K,\n                x.stride(0), x.stride(1),\n                self.fused_weight.stride(0), self.fused_weight.stride(1),\n                self.fused_bias.stride(0),\n                output.stride(0), output.stride(1),\n                self.divide_value,\n                BLOCK_M=64, BLOCK_N=64, BLOCK_K=32\n            )\n            return output\n\nbatch_size = 128\nin_features = 1024\nout_features = 512\nbn_eps = 1e-5\nbn_momentum = 0.1\nbias_shape = (1,)\ndivide_value = 1.0\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, bn_eps, bn_momentum, bias_shape, divide_value]\n# =================== EVOLVE-BLOCK-END ===================\n```\nUnique approach: Modification: Full rewrite, Excellent compiled (1.000), Excellent correctness (1.000)\n\n\n### Inspiration 2 (Score: 10.0000, Type: High-Performer)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef fused_forward_kernel(\n    x_ptr, \n    weight_ptr, \n    total_scale_ptr, \n    total_shift_ptr, \n    output_ptr,\n    stride_x0, stride_x1,\n    stride_w0, stride_w1,\n    stride_out0, stride_out1,\n    batch_size, \n    in_features, \n    out_features,\n    BLOCK_ROW: tl.constexpr,\n    BLOCK_FEATURE: tl.constexpr,\n    BLOCK_K: tl.constexpr,\n):\n    pid_batch = tl.program_id(0)\n    pid_feature = tl.program_id(1)\n    \n    row_start = pid_batch * BLOCK_ROW\n    feature_start = pid_feature * BLOCK_FEATURE\n    \n    row_offsets = row_start + tl.arange(0, BLOCK_ROW)\n    feature_offsets = feature_start + tl.arange(0, BLOCK_FEATURE)\n    \n    row_mask = row_offsets < batch_size\n    feature_mask = feature_offsets < out_features\n    \n    acc = tl.zeros((BLOCK_ROW, BLOCK_FEATURE), dtype=tl.float32)\n    \n    for k in range(0, in_features, BLOCK_K):\n        k_offsets = k + tl.arange(0, BLOCK_K)\n        k_mask = k_offsets < in_features\n        \n        x_ptrs = x_ptr + row_offsets[:, None] * stride_x0 + k_offsets[None, :] * stride_x1\n        x_vals = tl.load(x_ptrs, mask=row_mask[:, None] & k_mask[None, :], other=0.0)\n        \n        w_ptrs = weight_ptr + feature_offsets[:, None] * stride_w0 + k_offsets[None, :] * stride_w1\n        w_vals = tl.load(w_ptrs, mask=feature_mask[:, None] & k_mask[None, :], other=0.0)\n        \n        acc += tl.dot(x_vals, w_vals, allow_tf32=True)\n    \n    ts_ptrs = total_scale_ptr + feature_offsets\n    total_scale = tl.load(ts_ptrs, mask=feature_mask, other=0.0)\n    \n    tsh_ptrs = total_shift_ptr + feature_offsets\n    total_shift = tl.load(tsh_ptrs, mask=feature_mask, other=0.0)\n    \n    output_block = acc * total_scale[None, :] + total_shift[None, :]\n    output_block = output_block * tl.sigmoid(output_block)\n    \n    out_ptrs = output_ptr + row_offsets[:, None] * stride_out0 + feature_offsets[None, :] * stride_out1\n    tl.store(out_ptrs, output_block, mask=row_mask[:, None] & feature_mask[None, :])\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, bn_eps=1e-5, bn_momentum=0.1, bias_shape=(1,), divide_value=1.0):\n        super(ModelNew, self).__init__()\n        self.matmul = nn.Linear(in_features, out_features)\n        self.bn = nn.BatchNorm1d(out_features, eps=bn_eps, momentum=bn_momentum)\n        self.bias = nn.Parameter(torch.randn(bias_shape))\n        self.divide_value = divide_value\n\n    def forward(self, x):\n        with torch.no_grad():\n            scale_bn = self.bn.weight / torch.sqrt(self.bn.running_var + self.bn.eps)\n            shift_bn = self.bn.bias - self.bn.running_mean * scale_bn\n            total_scale = scale_bn / self.divide_value\n            total_shift = (self.matmul.bias * scale_bn + shift_bn + self.bias) / self.divide_value\n\n        x = x.contiguous()\n        batch_size, _ = x.shape\n        output = torch.empty((batch_size, self.matmul.out_features), device=x.device, dtype=x.dtype)\n        \n        grid = lambda meta: (\n            triton.cdiv(batch_size, meta['BLOCK_ROW']), \n            triton.cdiv(self.matmul.out_features, meta['BLOCK_FEATURE'])\n        )\n        \n        fused_forward_kernel[grid](\n            x, \n            self.matmul.weight, \n            total_scale, \n            total_shift, \n            output,\n            x.stride(0), x.stride(1),\n            self.matmul.weight.stride(0), self.matmul.weight.stride(1),\n            output.stride(0), output.stride(1),\n            batch_size, \n            x.size(1), \n            self.matmul.out_features,\n            BLOCK_ROW=32, \n            BLOCK_FEATURE=32, \n            BLOCK_K=64\n        )\n        return output\n\nbatch_size = 128\nin_features = 1024\nout_features = 512\nbn_eps = 1e-5\nbn_momentum = 0.1\nbias_shape = (1,)\ndivide_value = 1.0\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, bn_eps, bn_momentum, bias_shape, divide_value]\n# =================== EVOLVE-BLOCK-END ===================\n```\nUnique approach: Modification: Full rewrite, Excellent compiled (1.000), Alternative correctness approach\n\n\n### Inspiration 3 (Score: -100.0000, Type: Exploratory)\n```python\n@triton.jit\ndef fused_forward_kernel(\n    linear_out_ptr,\n    bn_weight_ptr,\n    bn_bias_ptr,\n    running_mean_ptr,\n    running_var_ptr,\n    model_bias_ptr,\n    divide_value,\n    output_ptr,\n    batch_size,\n    out_features,\n    bn_eps,\n    stride_lo0, stride_lo1,\n    stride_out0, stride_out1,\n    BLOCK_SIZE_BATCH: tl.constexpr,\n    BLOCK_SIZE_FEATURE: tl.constexpr\n):\n    pid_batch = tl.program_id(0)\n    pid_feature = tl.program_id(1)\n    \n    batch_idx = pid_batch * BLOCK_SIZE_BATCH + tl.arange(0, BLOCK_SIZE_BATCH)\n    feature_idx = pid_feature * BLOCK_SIZE_FEATURE + tl.arange(0, BLOCK_SIZE_FEATURE)\n    \n    batch_mask = batch_idx < batch_size\n    feature_mask = feature_idx < out_features\n    block_mask = batch_mask[:, None] & feature_mask[None, :]\n    \n    # Calculate offsets for linear_out access\n    lo_offsets = batch_idx[:, None] * stride_lo0 + feature_idx[None, :] * stride_lo1\n    linear_out = tl.load(linear_out_ptr + lo_offsets, mask=block_mask, other=0.0)\n    \n    # Load batchnorm parameters for the feature block\n    bn_weight = tl.load(bn_weight_ptr + feature_idx, mask=feature_mask, other=0.0)\n    bn_bias = tl.load(bn_bias_ptr + feature_idx, mask=feature_mask, other=0.0)\n    running_mean = tl.load(running_mean_ptr + feature_idx, mask=feature_mask, other=0.0)\n    running_var = tl.load(running_var_ptr + feature_idx, mask=feature_mask, other=0.0)\n    \n    # Compute batchnorm\n    scale = bn_weight / tl.sqrt(running_var + bn_eps)\n    bn_out = (linear_out - running_mean[None, :]) * scale[None, :] + bn_bias[None, :]\n    \n    # Add model bias and divide\n    model_bias = tl.load(model_bias_ptr)\n    normalized = (bn_out + model_bias) / divide_value\n    \n    # Swish activation\n    swish_out = normalized * tl.sigmoid(normalized)\n    \n    # Store results\n    out_offsets = batch_idx[:, None] * stride_out0 + feature_idx[None, :] * stride_out1\n    tl.store(output_ptr + out_offsets, swish_out, mask=block_mask)\n```\nUnique approach: Modification: Full rewrite, Alternative compiled approach, Alternative correctness approach\n\n\n### Inspiration 4 (Score: 10.0000, Type: High-Performer)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef _fused_post_linear_kernel(\n    x_ptr,\n    scale_ptr,\n    shift_ptr,\n    output_ptr,\n    bias,\n    divide_value,\n    n_cols,\n    stride_x,\n    stride_scale,\n    stride_shift,\n    stride_out,\n    BLOCK_SIZE: tl.constexpr,\n):\n    row_idx = tl.program_id(0)\n    col_block = tl.program_id(1)\n    col_offsets = col_block * BLOCK_SIZE + tl.arange(0, BLOCK_SIZE)\n    mask = col_offsets < n_cols\n    \n    # Calculate pointers\n    x_row_ptr = x_ptr + row_idx * stride_x\n    out_row_ptr = output_ptr + row_idx * stride_out\n    \n    # Load data\n    x = tl.load(x_row_ptr + col_offsets, mask=mask, other=0.0)\n    scale = tl.load(scale_ptr + col_offsets * stride_scale, mask=mask, other=0.0)\n    shift = tl.load(shift_ptr + col_offsets * stride_shift, mask=mask, other=0.0)\n    \n    # Fused operations\n    y = x * scale + shift + bias\n    y = y / divide_value\n    sig_y = tl.sigmoid(y)\n    y = y * sig_y\n    \n    # Store result\n    tl.store(out_row_ptr + col_offsets, y, mask=mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, bn_eps=1e-5, bn_momentum=0.1, bias_shape=(1,), divide_value=1.0):\n        super(ModelNew, self).__init__()\n        self.matmul = nn.Linear(in_features, out_features)\n        self.bn = nn.BatchNorm1d(out_features, eps=bn_eps, momentum=bn_momentum)\n        self.bias = nn.Parameter(torch.randn(bias_shape))\n        self.divide_value = divide_value\n        self.out_features = out_features\n        \n    def forward(self, x):\n        x = self.matmul(x)\n        \n        # Precompute BN scale/shift\n        if self.training:\n            mean = x.mean(dim=0)\n            var = x.var(dim=0, unbiased=False)\n            with torch.no_grad():\n                self.bn.running_mean = (1 - self.bn.momentum) * self.bn.running_mean + self.bn.momentum * mean\n                self.bn.running_var = (1 - self.bn.momentum) * self.bn.running_var + self.bn.momentum * var\n        else:\n            mean = self.bn.running_mean\n            var = self.bn.running_var\n            \n        inv_std = 1.0 / torch.sqrt(var + self.bn.eps)\n        scale = self.bn.weight * inv_std\n        shift = self.bn.bias - mean * scale\n        \n        # Prepare output tensor\n        output = torch.empty_like(x)\n        batch_size, n_cols = x.shape\n        \n        # Launch fused kernel\n        BLOCK_SIZE = 128\n        grid = (batch_size, triton.cdiv(n_cols, BLOCK_SIZE))\n        _fused_post_linear_kernel[grid](\n            x, scale, shift, output, \n            self.bias, self.divide_value,\n            n_cols,\n            x.stride(0), scale.stride(0), shift.stride(0), output.stride(0),\n            BLOCK_SIZE=BLOCK_SIZE\n        )\n        \n        return output\n\nbatch_size = 128\nin_features = 1024\nout_features = 512\nbn_eps = 1e-5\nbn_momentum = 0.1\nbias_shape = (1,)\ndivide_value = 1.0\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, bn_eps, bn_momentum, bias_shape, divide_value]\n# =================== EVOLVE-BLOCK-END ===================\n```\nUnique approach: Modification: Full rewrite, Excellent compiled (1.000), Alternative correctness approach\n\n\n### Inspiration 5 (Score: 0.0000, Type: Exploratory)\n```python\n\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\n\nclass ModelNew(nn.Module):\n    \"\"\"\n    Model that performs a matrix multiplication, batch normalization, bias addition, division, and Swish activation.\n    \"\"\"\n    def __init__(self, in_features, out_features, bn_eps=1e-5, bn_momentum=0.1, bias_shape=(1,), divide_value=1.0):\n        super(ModelNew, self).__init__()\n        self.matmul = nn.Linear(in_features, out_features)\n        self.bn = nn.BatchNorm1d(out_features, eps=bn_eps, momentum=bn_momentum)\n        self.bias = nn.Parameter(torch.randn(bias_shape))\n        self.divide_value = divide_value\n\n    def forward(self, x):\n        x = self.matmul(x)\n        x = self.bn(x)\n        x = x + self.bias\n        x = x / self.divide_value\n        x = x * torch.sigmoid(x)\n        return x\n\nbatch_size = 128\nin_features = 1024\nout_features = 512\nbn_eps = 1e-5\nbn_momentum = 0.1\nbias_shape = (1,)\ndivide_value = 1.0\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, bn_eps, bn_momentum, bias_shape, divide_value]\n# =================== EVOLVE-BLOCK-END ===================\n\n```\nUnique approach: Excellent compiled (1.000), Excellent correctness (1.000), Alternative passed approach\n\n\n\n# Current Program\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_SIZE_BATCH': 64, 'BLOCK_SIZE_FEATURE': 256}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_BATCH': 128, 'BLOCK_SIZE_FEATURE': 128}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_BATCH': 256, 'BLOCK_SIZE_FEATURE': 64}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_BATCH': 64, 'BLOCK_SIZE_FEATURE': 128}, num_warps=8),\n        triton.Config({'BLOCK_SIZE_BATCH': 128, 'BLOCK_SIZE_FEATURE': 64}, num_warps=8),\n    ],\n    key=['batch_size', 'out_features'],\n)\n@triton.jit\ndef fused_forward_kernel(\n    linear_out_ptr,\n    bn_weight_ptr,\n    bn_bias_ptr,\n    running_mean_ptr,\n    running_var_ptr,\n    model_bias_ptr,\n    divide_value,\n    output_ptr,\n    batch_size,\n    out_features,\n    bn_eps,\n    stride_lo0, stride_lo1,\n    stride_out0, stride_out1,\n    BLOCK_SIZE_BATCH: tl.constexpr,\n    BLOCK_SIZE_FEATURE: tl.constexpr\n):\n    pid_batch = tl.program_id(0)\n    pid_feature = tl.program_id(1)\n    \n    batch_idx = pid_batch * BLOCK_SIZE_BATCH + tl.arange(0, BLOCK_SIZE_BATCH)\n    feature_idx = pid_feature * BLOCK_SIZE_FEATURE + tl.arange(0, BLOCK_SIZE_FEATURE)\n    \n    batch_mask = batch_idx < batch_size\n    feature_mask = feature_idx < out_features\n    block_mask = batch_mask[:, None] & feature_mask[None, :]\n    \n    # Calculate offsets for linear_out access with vectorization\n    lo_offsets = batch_idx[:, None] * stride_lo0 + feature_idx[None, :] * stride_lo1\n    linear_out = tl.load(linear_out_ptr + lo_offsets, mask=block_mask, other=0.0)\n    \n    # Load batchnorm parameters with vectorization\n    bn_weight = tl.load(bn_weight_ptr + feature_idx, mask=feature_mask, other=0.0)\n    bn_bias = tl.load(bn_bias_ptr + feature_idx, mask=feature_mask, other=0.0)\n    running_mean = tl.load(running_mean_ptr + feature_idx, mask=feature_mask, other=0.0)\n    running_var = tl.load(running_var_ptr + feature_idx, mask=feature_mask, other=0.0)\n    \n    # Compute batchnorm with optimized math\n    inv_std = tl.math.rsqrt(running_var + bn_eps)\n    scale = bn_weight * inv_std\n    shift = bn_bias - running_mean * scale\n    bn_out = linear_out * scale[None, :] + shift[None, :]\n    \n    # Add model bias and divide\n    model_bias = tl.load(model_bias_ptr)\n    normalized = (bn_out + model_bias) / divide_value\n    \n    # Optimized Swish activation\n    sigmoid = tl.sigmoid(normalized)\n    swish_out = normalized * sigmoid\n    \n    # Vectorized store\n    out_offsets = batch_idx[:, None] * stride_out0 + feature_idx[None, :] * stride_out1\n    tl.store(output_ptr + out_offsets, swish_out, mask=block_mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, bn_eps=1e-5, bn_momentum=0.1, bias_shape=(1,), divide_value=1.0):\n        super(ModelNew, self).__init__()\n        self.matmul = nn.Linear(in_features, out_features)\n        self.bn = nn.BatchNorm1d(out_features, eps=bn_eps, momentum=bn_momentum)\n        self.bias = nn.Parameter(torch.randn(bias_shape))\n        self.divide_value = divide_value\n        \n    def forward(self, x):\n        linear_out = self.matmul(x)\n        \n        if self.training:\n            x = self.bn(linear_out)\n            x = x + self.bias\n            x = x / self.divide_value\n            return x * torch.sigmoid(x)\n        else:\n            batch_size, _ = linear_out.shape\n            output = torch.empty_like(linear_out)\n            \n            grid = lambda meta: (\n                triton.cdiv(batch_size, meta['BLOCK_SIZE_BATCH']),\n                triton.cdiv(linear_out.size(1), meta['BLOCK_SIZE_FEATURE'])\n            )\n            \n            fused_forward_kernel[grid](\n                linear_out,\n                self.bn.weight,\n                self.bn.bias,\n                self.bn.running_mean,\n                self.bn.running_var,\n                self.bias,\n                self.divide_value,\n                output,\n                batch_size,\n                linear_out.size(1),\n                self.bn.eps,\n                linear_out.stride(0), linear_out.stride(1),\n                output.stride(0), output.stride(1),\n                BLOCK_SIZE_BATCH=triton.next_power_of_2(batch_size),\n                BLOCK_SIZE_FEATURE=triton.next_power_of_2(linear_out.size(1))\n            )\n            return output\n\nbatch_size = 128\nin_features = 1024\nout_features = 512\nbn_eps = 1e-5\nbn_momentum = 0.1\nbias_shape = (1,)\ndivide_value = 1.0\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, bn_eps, bn_momentum, bias_shape, divide_value]\n# =================== EVOLVE-BLOCK-END ===================\n```\n\n# Task\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```\n", "responses": ["<think>\nWe are given the current program and we notice that the current speedup is 0.991 (which is less than 1) and we want to improve it.\n The current program uses a Triton kernel for inference that fuses batch normalization, bias addition, scaling, and Swish activation.\n\n The current kernel has two program IDs (for batch and feature) and loads a block of the linear output, then applies:\n   bn_out = (linear_out - running_mean) * scale + bn_bias   [where scale = bn_weight / sqrt(running_var + eps)]\n   normalized = (bn_out + model_bias) / divide_value\n   swish_out = normalized * sigmoid(normalized)\n\n However, note that the current kernel uses:\n   BLOCK_SIZE_BATCH = triton.next_power_of_2(batch_size)\n   BLOCK_SIZE_FEATURE = triton.next_power_of_2(linear_out.size(1))\n\n This might not be optimal because:\n   - The block sizes might be too large, leading to inefficient use of shared memory and registers.\n   - We are using autotune, but the provided block sizes in the autotune configs are fixed and we are overriding them with next_power_of_2.\n\n Also, note that in the kernel, we are loading the entire row (or column) of batchnorm parameters for each feature block. \n This is efficient because the batchnorm parameters are reused across the batch dimension.\n\n However, the current performance is slightly worse than the reference (speed_up=0.991). We need to improve.\n\n Let's analyze the kernel:\n\n 1. We are loading a block of `linear_out` of size [BLOCK_SIZE_BATCH, BLOCK_SIZE_FEATURE]. \n 2. Then we load batchnorm parameters (bn_weight, bn_bias, running_mean, running_var) of size [BLOCK_SIZE_FEATURE].\n 3. Then we compute the batchnorm and the rest.\n\n The memory access pattern for linear_out is coalesced? We are loading with:\n    lo_offsets = batch_idx[:, None] * stride_lo0 + feature_idx[None, :] * stride_lo1\n This is a row-major load. Since the batch index is contiguous in the inner loop? Actually, note that the batch_idx is a vector of length BLOCK_SIZE_BATCH and feature_idx of length BLOCK_SIZE_FEATURE. Then we form a matrix of offsets. This leads to a block that is contiguous in the feature dimension? \n\n But note: the linear_out tensor is of shape [batch_size, out_features]. The stride_lo0 is the stride for the batch dimension (which is out_features) and stride_lo1 is 1. So when we load with:\n    linear_out_ptr + batch_idx[:, None] * stride_lo0 + feature_idx[None, :] * stride_lo1\n we are loading a block that is non-contiguous in the batch dimension (because the batch_idx are consecutive, but the stride_lo0 is large) and contiguous in the feature dimension? Actually, for a fixed row, we are loading a contiguous block of features. But the rows are non-adjacent.\n\n However, we have a grid that covers the batch dimension in blocks and the feature dimension in blocks. This might lead to non-coalesced access.\n\n We can try to change the kernel to use a 1D grid and have each block handle a fixed set of rows and columns? But the current structure is 2D.\n\n Alternatively, note that the top-performing program (Program 1) uses a fused kernel that includes the matrix multiplication and the rest. But our current program only fuses the post-linear operations.\n\n However, the problem states that we are not allowed to change the grid configuration or the function signatures arbitrarily. But note the constraints:\n\n   \u274c NEVER change @triton.jit function signatures or parameter names  \n   \u274c NEVER modify grid configuration, output tensor shapes, or PID logic  \n\n We are allowed to change the internal implementation as long as we don't break the constraints.\n\n Since the current kernel is for the post-linear part, and we are in the inference path, we might try:\n\n   a) Optimizing the block sizes: Instead of setting BLOCK_SIZE_BATCH to the next power of two of the entire batch, we should use a fixed block size that is efficient (like 32, 64, 128) and let the autotuner choose.\n\n   b) We are currently using autotune, but we are overriding the block sizes by passing `BLOCK_SIZE_BATCH=triton.next_power_of_2(batch_size)` and similarly for feature. This is likely the problem because it forces the kernel to use a very large block (if batch_size is 128, then next_power_of_2 is 128, and if out_features is 512, then next_power_of_2 is 512). This would require a block of 128*512=65536 elements, which is too big and might cause register spilling.\n\n   c) Instead, we should remove the override and let the autotuner choose from the provided configs.\n\n   d) Also, note that the autotune configs are provided with `BLOCK_SIZE_BATCH` and `BLOCK_SIZE_FEATURE` as parameters. We should not override them.\n\n So, in the kernel launch, we are currently passing:\n        BLOCK_SIZE_BATCH=triton.next_power_of_2(batch_size),\n        BLOCK_SIZE_FEATURE=triton.next_power_of_2(linear_out.size(1))\n\n Instead, we should not pass these at all? Because the autotuner will set them via the meta-parameters.\n\n How does the autotuner work? It will set the `BLOCK_SIZE_BATCH` and `BLOCK_SIZE_FEATURE` based on the config that is chosen. We are not supposed to pass them as arguments.\n\n The kernel launch in Triton is done by specifying the grid and then the kernel arguments. The autotuner will replace the meta-parameters (like `BLOCK_SIZE_BATCH`) by the values in the config.\n\n Therefore, we should remove the arguments for `BLOCK_SIZE_BATCH` and `BLOCK_SIZE_FEATURE` in the kernel launch.\n\n Let's change the kernel launch to:\n\n            fused_forward_kernel[grid](\n                linear_out,\n                self.bn.weight,\n                self.bn.bias,\n                self.bn.running_mean,\n                self.bn.running_var,\n                self.bias,\n                self.divide_value,\n                output,\n                batch_size,\n                linear_out.size(1),\n                self.bn.eps,\n                linear_out.stride(0), linear_out.stride(1),\n                output.stride(0), output.stride(1)\n            )\n\n And remove the two lines that set the block sizes.\n\n Additionally, we note that the autotuner might not be triggered if we override the block sizes. So by removing the override, we let the autotuner choose.\n\n We also note that the current kernel has an autotune decorator that provides several configs. So we rely on that.\n\n Another potential issue: the kernel does not use any shared memory? The batchnorm parameters are loaded per feature and then broadcasted. This is efficient.\n\n But we can try to optimize the Swish activation by using an approximation? However, the problem says we must be numerically correct within float32 tolerance, so we should stick with `tl.sigmoid`.\n\n Alternatively, we can try to use the `tl.math.rsqrt` which we are already using for inv_std.\n\n Let's change the kernel launch and remove the block size overrides.\n\n We are only changing the kernel launch in the ModelNew.forward method.\n\n Since we are only allowed to change the Triton kernel source within the EVOLVE-BLOCK, but note that the kernel source includes the autotuner and the kernel function. However, the problem says we can change the Triton kernel source. But note that the current EVOLVE-BLOCK also includes the class and the helper functions. We are allowed to change the entire block.\n\n But note: the constraints say we cannot change the function signatures of the @triton.jit function. We are not changing the kernel signature, only the way we launch it.\n\n However, the current program includes the kernel and the class. We are going to change the class's forward method (the part that launches the kernel) to remove the two arguments.\n\n Specifically, we change:\n\n            fused_forward_kernel[grid](\n                ...,\n                BLOCK_SIZE_BATCH=triton.next_power_of_2(batch_size),\n                BLOCK_SIZE_FEATURE=triton.next_power_of_2(linear_out.size(1))\n            )\n\n to:\n\n            fused_forward_kernel[grid](\n                ...   # without the two block size arguments\n            )\n\n We also note that the kernel definition has these two parameters as `tl.constexpr`, and they are provided by the autotuner.\n\n Let's write the new code accordingly.\n\n But note: the autotuner configs are defined with specific block sizes (like 64, 128, 256 for batch and feature). We are now relying on the autotuner to pick the best.\n\n We also note that the current program has an autotune decorator that uses the key ['batch_size', 'out_features'].\n\n We hope that with the autotuner choosing the block sizes, the performance will improve.\n\n Since the current speedup is 0.991 (which is less than 1), we hope that this change will bring it above 1.\n\n Let's output the entire block with this change.\n</think>\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_SIZE_BATCH': 64, 'BLOCK_SIZE_FEATURE': 256}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_BATCH': 128, 'BLOCK_SIZE_FEATURE': 128}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_BATCH': 256, 'BLOCK_SIZE_FEATURE': 64}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_BATCH': 64, 'BLOCK_SIZE_FEATURE': 128}, num_warps=8),\n        triton.Config({'BLOCK_SIZE_BATCH': 128, 'BLOCK_SIZE_FEATURE': 64}, num_warps=8),\n    ],\n    key=['batch_size', 'out_features'],\n)\n@triton.jit\ndef fused_forward_kernel(\n    linear_out_ptr,\n    bn_weight_ptr,\n    bn_bias_ptr,\n    running_mean_ptr,\n    running_var_ptr,\n    model_bias_ptr,\n    divide_value,\n    output_ptr,\n    batch_size,\n    out_features,\n    bn_eps,\n    stride_lo0, stride_lo1,\n    stride_out0, stride_out1,\n    BLOCK_SIZE_BATCH: tl.constexpr,\n    BLOCK_SIZE_FEATURE: tl.constexpr\n):\n    pid_batch = tl.program_id(0)\n    pid_feature = tl.program_id(1)\n    \n    batch_idx = pid_batch * BLOCK_SIZE_BATCH + tl.arange(0, BLOCK_SIZE_BATCH)\n    feature_idx = pid_feature * BLOCK_SIZE_FEATURE + tl.arange(0, BLOCK_SIZE_FEATURE)\n    \n    batch_mask = batch_idx < batch_size\n    feature_mask = feature_idx < out_features\n    block_mask = batch_mask[:, None] & feature_mask[None, :]\n    \n    # Calculate offsets for linear_out access with vectorization\n    lo_offsets = batch_idx[:, None] * stride_lo0 + feature_idx[None, :] * stride_lo1\n    linear_out = tl.load(linear_out_ptr + lo_offsets, mask=block_mask, other=0.0)\n    \n    # Load batchnorm parameters with vectorization\n    bn_weight = tl.load(bn_weight_ptr + feature_idx, mask=feature_mask, other=0.0)\n    bn_bias = tl.load(bn_bias_ptr + feature_idx, mask=feature_mask, other=0.0)\n    running_mean = tl.load(running_mean_ptr + feature_idx, mask=feature_mask, other=0.0)\n    running_var = tl.load(running_var_ptr + feature_idx, mask=feature_mask, other=0.0)\n    \n    # Compute batchnorm with optimized math\n    inv_std = tl.math.rsqrt(running_var + bn_eps)\n    scale = bn_weight * inv_std\n    shift = bn_bias - running_mean * scale\n    bn_out = linear_out * scale[None, :] + shift[None, :]\n    \n    # Add model bias and divide\n    model_bias = tl.load(model_bias_ptr)\n    normalized = (bn_out + model_bias) / divide_value\n    \n    # Optimized Swish activation\n    sigmoid = tl.sigmoid(normalized)\n    swish_out = normalized * sigmoid\n    \n    # Vectorized store\n    out_offsets = batch_idx[:, None] * stride_out0 + feature_idx[None, :] * stride_out1\n    tl.store(output_ptr + out_offsets, swish_out, mask=block_mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_features, out_features, bn_eps=1e-5, bn_momentum=0.1, bias_shape=(1,), divide_value=1.0):\n        super(ModelNew, self).__init__()\n        self.matmul = nn.Linear(in_features, out_features)\n        self.bn = nn.BatchNorm1d(out_features, eps=bn_eps, momentum=bn_momentum)\n        self.bias = nn.Parameter(torch.randn(bias_shape))\n        self.divide_value = divide_value\n        \n    def forward(self, x):\n        linear_out = self.matmul(x)\n        \n        if self.training:\n            x = self.bn(linear_out)\n            x = x + self.bias\n            x = x / self.divide_value\n            return x * torch.sigmoid(x)\n        else:\n            batch_size, _ = linear_out.shape\n            output = torch.empty_like(linear_out)\n            \n            grid = lambda meta: (\n                triton.cdiv(batch_size, meta['BLOCK_SIZE_BATCH']),\n                triton.cdiv(linear_out.size(1), meta['BLOCK_SIZE_FEATURE'])\n            )\n            \n            fused_forward_kernel[grid](\n                linear_out,\n                self.bn.weight,\n                self.bn.bias,\n                self.bn.running_mean,\n                self.bn.running_var,\n                self.bias,\n                self.divide_value,\n                output,\n                batch_size,\n                linear_out.size(1),\n                self.bn.eps,\n                linear_out.stride(0), linear_out.stride(1),\n                output.stride(0), output.stride(1)\n            )\n            return output\n\nbatch_size = 128\nin_features = 1024\nout_features = 512\nbn_eps = 1e-5\nbn_momentum = 0.1\nbias_shape = (1,)\ndivide_value = 1.0\n\ndef get_inputs():\n    return [torch.randn(batch_size, in_features)]\n\ndef get_init_inputs():\n    return [in_features, out_features, bn_eps, bn_momentum, bias_shape, divide_value]\n# =================== EVOLVE-BLOCK-END ===================\n```"]}}}