{"id": "6e33a133-de30-444e-a24e-32e752cc1124", "code": "# ================== EVOLVE-BLOCK-START ==================\nimport math\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef _conv_transpose3d_kernel(\n    # Pointers to tensors\n    input_ptr, weight_ptr, bias_ptr, output_ptr,\n    # Input dimensions\n    batch_size, in_channels, D_in, H_in, W_in,\n    # Output dimensions\n    D_out, H_out, W_out,\n    # Kernel parameters\n    kernel_size, stride, padding, dilation, groups,\n    # Tensor strides\n    stride_xb, stride_xc, stride_xd, stride_xh, stride_xw,\n    stride_wic, stride_woc, stride_wd, stride_wh, stride_ww,\n    stride_ob, stride_oc, stride_od, stride_oh, stride_ow,\n    # Tile sizes\n    BLOCK_D: tl.constexpr, BLOCK_H: tl.constexpr, BLOCK_W: tl.constexpr\n):\n    # 3D grid indices\n    pid_b = tl.program_id(0)              # Batch index\n    pid_oc = tl.program_id(1)              # Output channel index\n    pid_tile = tl.program_id(2)            # Spatial tile index\n    \n    # Calculate number of tiles in each spatial dimension\n    tiles_d = tl.cdiv(D_out, BLOCK_D)\n    tiles_h = tl.cdiv(H_out, BLOCK_H)\n    tiles_w = tl.cdiv(W_out, BLOCK_W)\n    tiles_hw = tiles_h * tiles_w\n    \n    # Decompose spatial tile index into d, h, w components\n    tile_d = pid_tile // tiles_hw\n    tile_hw = pid_tile % tiles_hw\n    tile_h = tile_hw // tiles_w\n    tile_w = tile_hw % tiles_w\n    \n    # Calculate starting indices for the current tile\n    d_start = tile_d * BLOCK_D\n    h_start = tile_h * BLOCK_H\n    w_start = tile_w * BLOCK_W\n    \n    # Create position offsets within the tile\n    d_offsets = d_start + tl.arange(0, BLOCK_D)\n    h_offsets = h_start + tl.arange(0, BLOCK_H)\n    w_offsets = w_start + tl.arange(0, BLOCK_W)\n    \n    # Create masks for boundary checks\n    d_mask = d_offsets < D_out\n    h_mask = h_offsets < H_out\n    w_mask = w_offsets < W_out\n    block_mask = d_mask[:, None, None] & h_mask[None, :, None] & w_mask[None, None, :]\n    \n    # Initialize accumulator\n    acc = tl.zeros((BLOCK_D, BLOCK_H, BLOCK_W), dtype=tl.float32)\n    \n    # Group handling (assuming groups=1 for simplicity)\n    # For groups>1, we would adjust the input channel range\n    c_start = 0\n    c_end = in_channels\n    \n    # Loop over input channels\n    for c_in in range(c_start, c_end):\n        # Loop over kernel dimensions\n        for kd in range(kernel_size):\n            for kh in range(kernel_size):\n                for kw in range(kernel_size):\n                    # Calculate input positions\n                    d_in = (d_offsets[:, None, None] - kd * dilation + padding) // stride\n                    h_in = (h_offsets[None, :, None] - kh * dilation + padding) // stride\n                    w_in = (w_offsets[None, None, :] - kw * dilation + padding) // stride\n                    \n                    # Check divisibility and bounds\n                    d_div = (d_offsets[:, None, None] - kd * dilation + padding) % stride == 0\n                    h_div = (h_offsets[None, :, None] - kh * dilation + padding) % stride == 0\n                    w_div = (w_offsets[None, None, :] - kw * dilation + padding) % stride == 0\n                    valid = d_div & h_div & w_div\n                    \n                    d_in_bound = (d_in >= 0) & (d_in < D_in)\n                    h_in_bound = (h_in >= 0) & (h_in < H_in)\n                    w_in_bound = (w_in >= 0) & (w_in < W_in)\n                    in_bound = d_in_bound & h_in_bound & w_in_bound\n                    \n                    mask = valid & in_bound & block_mask\n                    \n                    # Compute input pointer offsets\n                    input_offsets = (\n                        pid_b * stride_xb + \n                        c_in * stride_xc + \n                        d_in * stride_xd + \n                        h_in * stride_xh + \n                        w_in * stride_xw\n                    )\n                    \n                    # Load input values with masking\n                    input_vals = tl.load(input_ptr + input_offsets, mask=mask, other=0.0)\n                    \n                    # Load weight value\n                    weight_val = tl.load(\n                        weight_ptr + \n                        c_in * stride_wic + \n                        pid_oc * stride_woc + \n                        kd * stride_wd + \n                        kh * stride_wh + \n                        kw * stride_ww\n                    )\n                    \n                    # Accumulate\n                    acc += input_vals * weight_val\n    \n    # Add bias if present\n    if bias_ptr is not None:\n        bias_val = tl.load(bias_ptr + pid_oc)\n        acc += bias_val\n    \n    # Compute output pointer offsets\n    output_offsets = (\n        pid_b * stride_ob + \n        pid_oc * stride_oc + \n        d_offsets[:, None, None] * stride_od + \n        h_offsets[None, :, None] * stride_oh + \n        w_offsets[None, None, :] * stride_ow\n    )\n    \n    # Store results\n    tl.store(output_ptr + output_offsets, acc, mask=block_mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_channels: int, out_channels: int, kernel_size: int, stride: int = 1, padding: int = 0, \n                 output_padding: int = 0, dilation: int = 1, groups: int = 1, bias: bool = False):\n        super(ModelNew, self).__init__()\n        self.in_channels = in_channels\n        self.out_channels = out_channels\n        self.kernel_size = kernel_size\n        self.stride = stride\n        self.padding = padding\n        self.output_padding = output_padding\n        self.dilation = dilation\n        self.groups = groups\n        \n        # Weight parameters\n        self.weight = nn.Parameter(torch.empty(\n            in_channels, \n            out_channels, \n            kernel_size, \n            kernel_size, \n            kernel_size\n        ))\n        \n        # Bias parameter\n        if bias:\n            self.bias = nn.Parameter(torch.empty(out_channels))\n        else:\n            self.register_parameter('bias', None)\n        \n        # Initialize parameters\n        nn.init.kaiming_uniform_(self.weight, a=math.sqrt(5))\n        if self.bias is not None:\n            fan_in, _ = nn.init._calculate_fan_in_and_fan_out(self.weight)\n            bound = 1 / math.sqrt(fan_in)\n            nn.init.uniform_(self.bias, -bound, bound)\n    \n    def forward(self, x: torch.Tensor) -> torch.Tensor:\n        batch_size, in_channels, D_in, H_in, W_in = x.shape\n        \n        # Calculate output dimensions\n        D_out = (D_in - 1) * self.stride - 2 * self.padding + self.dilation * (self.kernel_size - 1) + self.output_padding + 1\n        H_out = (H_in - 1) * self.stride - 2 * self.padding + self.dilation * (self.kernel_size - 1) + self.output_padding + 1\n        W_out = (W_in - 1) * self.stride - 2 * self.padding + self.dilation * (self.kernel_size - 1) + self.output_padding + 1\n        \n        # Create output tensor\n        output = torch.empty(\n            batch_size, \n            self.out_channels, \n            D_out, \n            H_out, \n            W_out, \n            device=x.device, \n            dtype=x.dtype\n        )\n        \n        # Calculate number of tiles with optimized block sizes\n        BLOCK_D, BLOCK_H, BLOCK_W = 8, 4, 4  # Optimized tile size\n        tiles_d = (D_out + BLOCK_D - 1) // BLOCK_D\n        tiles_h = (H_out + BLOCK_H - 1) // BLOCK_H\n        tiles_w = (W_out + BLOCK_W - 1) // BLOCK_W\n        tiles_hw = tiles_h * tiles_w\n        total_tiles = tiles_d * tiles_hw\n        \n        # Grid configuration\n        grid = (batch_size, self.out_channels, total_tiles)\n        \n        # Launch kernel\n        _conv_transpose3d_kernel[grid](\n            x, self.weight, self.bias, output,\n            batch_size, in_channels, D_in, H_in, W_in,\n            D_out, H_out, W_out,\n            self.kernel_size, self.stride, self.padding, self.dilation, self.groups,\n            x.stride(0), x.stride(1), x.stride(2), x.stride(3), x.stride(4),\n            self.weight.stride(0), self.weight.stride(1), self.weight.stride(2), self.weight.stride(3), self.weight.stride(4),\n            output.stride(0), output.stride(1), output.stride(2), output.stride(3), output.stride(4),\n            BLOCK_D, BLOCK_H, BLOCK_W\n        )\n        \n        return output\n\n# Test code\nbatch_size = 16\nin_channels = 32\nout_channels = 16\nkernel_size = 3\ndepth = 16\nheight = 32\nwidth = 64\n\ndef get_inputs():\n    x = torch.randn(batch_size, in_channels, depth, height, width)\n    return [x]\n\ndef get_init_inputs():\n    return [in_channels, out_channels, kernel_size]\n# =================== EVOLVE-BLOCK-END ===================", "language": "python", "parent_id": "597a62e3-7fcd-46db-a236-a4b2956aae88", "generation": 4, "timestamp": 1754993097.291503, "iteration_found": 9, "metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": false, "score": 20, "speed_up": 0.003, "runtime_ms": 14.9, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:0", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.0497, "speed_up": 0.003, "custom_timing": 14.9}}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": false, "correctness": false, "score": -100.0, "stage": "no_valid_triton_code", "feedback": "You need to generate real and valid triton code for the core function. The key word 'import triton' is not found."}, "island": 2}, "artifacts_json": null, "artifact_dir": null}