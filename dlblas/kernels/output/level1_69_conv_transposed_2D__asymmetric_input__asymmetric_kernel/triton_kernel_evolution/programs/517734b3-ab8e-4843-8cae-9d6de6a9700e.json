{"id": "517734b3-ab8e-4843-8cae-9d6de6a9700e", "code": "# ================== EVOLVE-BLOCK-START ==================\nimport math\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef _conv_transpose2d_kernel(\n    x_ptr,\n    weight_ptr,\n    bias_ptr,\n    output_ptr,\n    height_in,\n    width_in,\n    height_out,\n    width_out,\n    stride_h,\n    stride_w,\n    padding_h,\n    padding_w,\n    dilation_h,\n    dilation_w,\n    kernel_h,\n    kernel_w,\n    in_channels,\n    out_channels,\n    groups,\n    x_batch_stride,\n    x_channel_stride,\n    x_height_stride,\n    x_width_stride,\n    weight_channel_stride,\n    weight_out_stride,\n    weight_kh_stride,\n    weight_kw_stride,\n    output_batch_stride,\n    output_channel_stride,\n    output_height_stride,\n    output_width_stride,\n    BLOCK_H: tl.constexpr,\n    BLOCK_W: tl.constexpr,\n):\n    pid_b = tl.program_id(0)\n    pid_c = tl.program_id(1)\n    pid_hw = tl.program_id(2)\n    \n    # Calculate spatial block indices\n    block_idx = pid_hw\n    num_blocks_w = tl.cdiv(width_out, BLOCK_W)\n    block_h = block_idx // num_blocks_w\n    block_w = block_idx % num_blocks_w\n    h_start = block_h * BLOCK_H\n    w_start = block_w * BLOCK_W\n    \n    # Create spatial ranges\n    h_offsets = h_start + tl.arange(0, BLOCK_H)\n    w_offsets = w_start + tl.arange(0, BLOCK_W)\n    h_mask = h_offsets < height_out\n    w_mask = w_offsets < width_out\n    spatial_mask = h_mask[:, None] & w_mask[None, :]\n    \n    group_id = pid_c // (out_channels // groups)\n    in_channels_per_group = in_channels // groups\n    c_out_local = pid_c % (out_channels // groups)\n    \n    # Initialize accumulator\n    acc = tl.zeros((BLOCK_H, BLOCK_W), dtype=tl.float32)\n    \n    # Process each input channel in the group\n    for c_in in range(group_id * in_channels_per_group, (group_id + 1) * in_channels_per_group):\n        # Process each kernel position\n        for k in range(kernel_h):\n            for l in range(kernel_w):\n                # Calculate input positions with vector operations\n                base_h = (h_offsets + padding_h - k * dilation_h)\n                base_w = (w_offsets + padding_w - l * dilation_w)\n                \n                # Compute divisibility conditions\n                cond_h = (base_h % stride_h == 0)\n                cond_w = (base_w % stride_w == 0)\n                cond_div = cond_h[:, None] & cond_w[None, :]\n                \n                # Compute input coordinates\n                h_in = tl.where(cond_h, base_h // stride_h, -1)\n                w_in = tl.where(cond_w, base_w // stride_w, -1)\n                \n                # Check boundaries\n                in_bounds = (h_in >= 0) & (h_in < height_in) & (w_in >= 0) & (w_in < width_in)\n                valid_mask = cond_div & in_bounds\n                \n                # Compute input pointer offsets\n                input_offset = (\n                    pid_b * x_batch_stride + \n                    c_in * x_channel_stride + \n                    h_in[:, None] * x_height_stride + \n                    w_in[None, :] * x_width_stride\n                )\n                \n                # Load input values with masking\n                x_val = tl.load(x_ptr + input_offset, mask=valid_mask, other=0.0)\n                \n                # Load weight value\n                weight_offset = (\n                    c_in * weight_channel_stride +\n                    c_out_local * weight_out_stride +\n                    k * weight_kh_stride +\n                    l * weight_kw_stride\n                )\n                weight_val = tl.load(weight_ptr + weight_offset)\n                \n                # Accumulate\n                acc += x_val * weight_val\n\n    # Add bias if present\n    if bias_ptr is not None:\n        bias_val = tl.load(bias_ptr + pid_c)\n        acc += bias_val\n\n    # Compute output offsets and store results\n    output_offset = (\n        pid_b * output_batch_stride +\n        pid_c * output_channel_stride +\n        h_offsets[:, None] * output_height_stride +\n        w_offsets[None, :] * output_width_stride\n    )\n    tl.store(output_ptr + output_offset, acc, mask=spatial_mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_channels: int, out_channels: int, kernel_size: tuple, stride: tuple = (1, 1), padding: tuple = (0, 0), output_padding: tuple = (0, 0), dilation: tuple = (1, 1), groups: int = 1, bias: bool = False):\n        super(ModelNew, self).__init__()\n        self.in_channels = in_channels\n        self.out_channels = out_channels\n        self.kernel_size = kernel_size\n        self.stride = stride\n        self.padding = padding\n        self.output_padding = output_padding\n        self.dilation = dilation\n        self.groups = groups\n        \n        self.weight = nn.Parameter(torch.empty(\n            in_channels,\n            out_channels // groups,\n            kernel_size[0],\n            kernel_size[1]\n        ))\n        \n        if bias:\n            self.bias = nn.Parameter(torch.empty(out_channels))\n        else:\n            self.register_parameter('bias', None)\n            \n        nn.init.kaiming_uniform_(self.weight, a=math.sqrt(5))\n        if self.bias is not None:\n            fan_in, _ = nn.init._calculate_fan_in_and_fan_out(self.weight)\n            bound = 1 / math.sqrt(fan_in) if fan_in > 0 else 0\n            nn.init.uniform_(self.bias, -bound, bound)\n    \n    def forward(self, x: torch.Tensor) -> torch.Tensor:\n        batch_size, _, height_in, width_in = x.shape\n        kernel_h, kernel_w = self.kernel_size\n        stride_h, stride_w = self.stride\n        padding_h, padding_w = self.padding\n        dilation_h, dilation_w = self.dilation\n        output_padding_h, output_padding_w = self.output_padding\n        \n        height_out = (height_in - 1) * stride_h - 2 * padding_h + dilation_h * (kernel_h - 1) + output_padding_h + 1\n        width_out = (width_in - 1) * stride_w - 2 * padding_w + dilation_w * (kernel_w - 1) + output_padding_w + 1\n        \n        output = torch.empty(\n            (batch_size, self.out_channels, height_out, width_out),\n            device=x.device,\n            dtype=x.dtype\n        )\n        \n        # Calculate number of blocks\n        BLOCK_H = 16\n        BLOCK_W = 16\n        num_blocks_h = (height_out + BLOCK_H - 1) // BLOCK_H\n        num_blocks_w = (width_out + BLOCK_W - 1) // BLOCK_W\n        num_blocks = num_blocks_h * num_blocks_w\n        \n        grid = (batch_size, self.out_channels, num_blocks)\n        \n        _conv_transpose2d_kernel[grid](\n            x,\n            self.weight,\n            self.bias if self.bias is not None else None,\n            output,\n            height_in,\n            width_in,\n            height_out,\n            width_out,\n            stride_h,\n            stride_w,\n            padding_h,\n            padding_w,\n            dilation_h,\n            dilation_w,\n            kernel_h,\n            kernel_w,\n            self.in_channels,\n            self.out_channels,\n            self.groups,\n            x.stride(0), x.stride(1), x.stride(2), x.stride(3),\n            self.weight.stride(0), self.weight.stride(1), self.weight.stride(2), self.weight.stride(3),\n            output.stride(0), output.stride(1), output.stride(2), output.stride(3),\n            BLOCK_H, BLOCK_W\n        )\n        return output\n\n# Test code\nbatch_size = 16\nin_channels = 32\nout_channels = 64\nkernel_size = (3, 5)\nheight_in = 16\nwidth_in = 32\n\ndef get_inputs():\n    x = torch.randn(batch_size, in_channels, height_in, width_in)\n    return [x]\n\ndef get_init_inputs():\n    return [in_channels, out_channels, kernel_size]\n# =================== EVOLVE-BLOCK-END ===================", "language": "python", "parent_id": "eb138a77-d713-4811-bc79-3bdd87e4f1c7", "generation": 3, "timestamp": 1754986293.9318626, "iteration_found": 15, "metrics": {"compiled": false, "correctness": false, "score": 1, "stage": "compile_error", "compile_log": "CUDA error: an illegal memory access was encountered\nCUDA kernel errors might be asynchronously reported at some other API call, so the stacktrace below might be incorrect.\nFor debugging consider passing CUDA_LAUNCH_BLOCKING=1\nCompile with `TORCH_USE_CUDA_DSA` to enable device-side assertions.\n\nTraceback (most recent call last):\n  File \"/cpfs01/shared/llm_kernel/hujiakai/KernelLLM/validation_api_server/evaluator.py\", line 173, in _verification_worker\n    result: KernelExecResult = eval_kernel_against_ref(\n  File \"/cpfs01/shared/llm_kernel/hujiakai/KernelLLM/validation_api_server/helpers/evaluations.py\", line 578, in eval_kernel_against_ref\n    graceful_eval_cleanup(context, device, tempfile)\n  File \"/cpfs01/shared/llm_kernel/hujiakai/KernelLLM/validation_api_server/helpers/evaluations.py\", line 230, in graceful_eval_cleanup\n    torch.cuda.empty_cache()\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/cuda/memory.py\", line 224, in empty_cache\n    torch._C._cuda_emptyCache()\ntorch.AcceleratorError: CUDA error: an illegal memory access was encountered\nCUDA kernel errors might be asynchronously reported at some other API call, so the stacktrace below might be incorrect.\nFor debugging consider passing CUDA_LAUNCH_BLOCKING=1\nCompile with `TORCH_USE_CUDA_DSA` to enable device-side assertions.\n\n", "exec_log": "[Child] \u7ed1\u5b9a GPU 7, torch sees 1 device(s)\n\n[Exception]\nTraceback (most recent call last):\n  File \"/cpfs01/shared/llm_kernel/hujiakai/KernelLLM/validation_api_server/code_executor.py\", line 71, in _exec_worker\n    exec(textwrap.dedent(code_src), mod.__dict__)\n  File \"<string>\", line 9, in <module>\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 844, in jit\n    return decorator(fn)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 832, in decorator\n    return JITFunction(\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 635, in __init__\n    self.starting_line_number = inspect.getsourcelines(fn)[1]\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/inspect.py\", line 1121, in getsourcelines\n    lines, lnum = findsource(object)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/inspect.py\", line 958, in findsource\n    raise OSError('could not get source code')\nOSError: could not get source code\n", "exit_code": "1"}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": false, "score": 20, "speed_up": 0.001, "runtime_ms": 30.7, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:7", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.0435, "speed_up": 0.001, "custom_timing": 30.7}}, "island": 0}, "artifacts_json": null, "artifact_dir": null}