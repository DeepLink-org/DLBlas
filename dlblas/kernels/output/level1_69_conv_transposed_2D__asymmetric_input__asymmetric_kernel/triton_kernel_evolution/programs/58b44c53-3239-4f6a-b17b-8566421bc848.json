{"id": "58b44c53-3239-4f6a-b17b-8566421bc848", "code": "# ================== EVOLVE-BLOCK-START ==================\nimport math\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_H': 16, 'BLOCK_W': 16}, num_warps=4),\n        triton.Config({'BLOCK_H': 16, 'BLOCK_W': 16}, num_warps=8),\n        triton.Config({'BLOCK_H': 32, 'BLOCK_W': 32}, num_warps=8),\n        triton.Config({'BLOCK_H': 32, 'BLOCK_W': 32}, num_warps=4),\n        triton.Config({'BLOCK_H': 64, 'BLOCK_W': 64}, num_warps=8),\n        triton.Config({'BLOCK_H': 64, 'BLOCK_W': 64}, num_warps=16),\n    ],\n    key=['H_out', 'W_out'],\n)\n@triton.jit\ndef conv_transpose2d_kernel(\n    input_ptr, weight_ptr, bias_ptr, output_ptr,\n    in_channels, out_channels, H_in, W_in, H_out, W_out,\n    stride_h, stride_w, padding_h, padding_w, dilation_h, dilation_w, groups,\n    kH, kW,\n    input_bs_stride, input_c_stride, input_h_stride, input_w_stride,\n    weight_ic_stride, weight_oc_stride, weight_h_stride, weight_w_stride,\n    output_bs_stride, output_c_stride, output_h_stride, output_w_stride,\n    BLOCK_H: tl.constexpr, BLOCK_W: tl.constexpr\n):\n    pid_nc = tl.program_id(0)\n    pid_h = tl.program_id(1)\n    pid_w = tl.program_id(2)\n    \n    n = pid_nc // out_channels\n    oc = pid_nc % out_channels\n    group_id = oc // (out_channels // groups)\n    oc_in_group = oc % (out_channels // groups)\n    in_channels_per_group = in_channels // groups\n    start_ic = group_id * in_channels_per_group\n    \n    h_start = pid_h * BLOCK_H\n    w_start = pid_w * BLOCK_W\n    h_offsets = h_start + tl.arange(0, BLOCK_H)\n    w_offsets = w_start + tl.arange(0, BLOCK_W)\n    h_mask = h_offsets < H_out\n    w_mask = w_offsets < W_out\n    spatial_mask = h_mask[:, None] & w_mask[None, :]\n    \n    output = tl.zeros((BLOCK_H, BLOCK_W), dtype=tl.float32)\n    \n    for kh in range(kH):\n        for kw in range(kW):\n            base_h = (h_offsets + padding_h - kh * dilation_h)\n            base_w = (w_offsets + padding_w - kw * dilation_w)\n            valid_base = (base_h[:, None] >= 0) & (base_w[None, :] >= 0)\n            ih = base_h // stride_h\n            iw = base_w // stride_w\n            valid_div = (base_h[:, None] % stride_h == 0) & (base_w[None, :] % stride_w == 0)\n            valid_bounds = (ih[:, None] < H_in) & (iw[None, :] < W_in)\n            valid = valid_base & valid_div & valid_bounds\n            \n            for ic in range(start_ic, start_ic + in_channels_per_group):\n                input_ptrs = (\n                    input_ptr + \n                    n * input_bs_stride + \n                    ic * input_c_stride + \n                    ih[:, None] * input_h_stride + \n                    iw[None, :] * input_w_stride\n                )\n                input_val = tl.load(input_ptrs, mask=valid, other=0.0)\n                \n                weight_val = tl.load(\n                    weight_ptr + \n                    ic * weight_ic_stride + \n                    oc_in_group * weight_oc_stride + \n                    kh * weight_h_stride + \n                    kw * weight_w_stride\n                )\n                output += input_val * weight_val\n    \n    if bias_ptr is not None:\n        bias_val = tl.load(bias_ptr + oc)\n        output += bias_val\n    \n    output_ptrs = (\n        output_ptr + \n        n * output_bs_stride + \n        oc * output_c_stride + \n        h_offsets[:, None] * output_h_stride + \n        w_offsets[None, :] * output_w_stride\n    )\n    tl.store(output_ptrs, output, mask=spatial_mask)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_channels: int, out_channels: int, kernel_size: tuple, \n                 stride: tuple = (1, \u67811), padding: tuple = (0, 0), \n                 output_padding: tuple = (0, 0), dilation: tuple = (1, 1), \n                 groups: int = 1, bias: bool = False):\n        super(ModelNew, self).__init__()\n        self.in_channels = in_channels\n        self.out_channels = out_channels\n        self.kernel_size = kernel_size\n        self.stride = stride\n        self.padding = padding\n        self.output_padding = output_padding\n        self.dilation = dilation\n        self.groups = groups\n        \n        self.weight = nn.Parameter(torch.empty(\n            in_channels, out_channels // groups, *kernel_size\n        ))\n        if bias:\n            self.bias = nn.Parameter(torch.empty(out_channels))\n        else:\n            self.register_parameter('bias', None)\n        \n        nn.init.kaiming_uniform_(self.weight, a=math.sqrt(5))\n        if self.bias is not None:\n            fan_in, _ = nn.init._calculate_fan_in_and_fan_out(self.weight)\n            bound = 1 / math.sqrt(fan_in) if fan_in > 0 else 0\n            nn.init.uniform_(self.bias, -bound, bound)\n    \n    def forward(self, x: torch.Tensor) -> torch.Tensor:\n        N, C, H_in, W_in = x.shape\n        kH, kW = self.kernel_size\n        stride_h, stride_w = self.stride\n        padding_h, padding_w = self.padding\n        dilation_h, dilation_w = self.dilation\n        output_padding_h, output_padding_w = self.output_padding\n        \n        H_out = (H_in - 1) * stride_h - 2 * padding_h + dilation_h * (kH - 1) + output_padding_h + 1\n        W_out = (W_in - 1) * stride_w - 2 * padding_w + dilation_w * (kW - 1) + output_padding_w + 1\n        \n        output = torch.empty((N, self.out_channels, H_out, W_out), \n                             device=x.device, dtype=x.dtype)\n        \n        x = x.contiguous()\n        weight = self.weight.contiguous()\n        \n        grid = lambda opt: (\n            N * self.out_channels,\n            triton.cdiv(H_out, opt['BLOCK_H']),\n            triton.cdiv(W_out, opt['BLOCK_W'])\n        )\n        \n        conv_transpose2d_kernel[grid](\n            x, weight, self.bias, output,\n            self.in_channels, self.out_channels, \n            H_in, W_in, H_out, W_out,\n            stride_h, stride_w, padding_h, padding_w, \n            dilation_h, dilation_w, self.groups,\n            kH, kW,\n            x.stride(0), x.stride(1), x.stride(2), x.stride(3),\n            weight.stride(0), weight.stride(1), weight.stride(2), weight.stride(3),\n            output.stride(0), output.stride(1), output.stride(2), output.stride(3),\n            BLOCK_H=opt['BLOCK_H'], BLOCK_W=opt['BLOCK_W']\n        )\n        return output\n\n# Test code\nbatch_size = 16\nin_channels = 32\nout_channels = 64\nkernel_size = (3, 5)\nheight_in = 16\nwidth_in = 32\n\ndef get_inputs():\n    x = torch.randn(batch_size, in_channels, height_in, width_in)\n    return [x]\n\ndef get_init_inputs():\n    return [in_channels, out_channels, kernel_size]\n# =================== EVOLVE-BLOCK-END ===================", "language": "python", "parent_id": "dc7752ca-e9cc-4c5f-ab00-627a16c07ad9", "generation": 6, "timestamp": 1754985409.6142802, "iteration_found": 12, "metrics": {"compiled": false, "correctness": false, "score": 1, "stage": "compile_error", "compile_log": "", "exec_log": "[Child] \u7ed1\u5b9a GPU 3, torch sees 1 device(s)\n\n[Exception]\nTraceback (most recent call last):\n  File \"/cpfs01/shared/llm_kernel/hujiakai/KernelLLM/validation_api_server/code_executor.py\", line 71, in _exec_worker\n    exec(textwrap.dedent(code_src), mod.__dict__)\n  File \"<string>\", line 20, in <module>\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 844, in jit\n    return decorator(fn)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 832, in decorator\n    return JITFunction(\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 635, in __init__\n    self.starting_line_number = inspect.getsourcelines(fn)[1]\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/inspect.py\", line 1121, in getsourcelines\n    lines, lnum = findsource(object)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/inspect.py\", line 958, in findsource\n    raise OSError('could not get source code')\nOSError: could not get source code\n", "exit_code": "1"}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": true, "correctness": false, "score": 10, "stage": "wrong_answer", "verify_payload": {"id": "level1_69_conv_transposed_2D__asymmetric_input__asymmetric_kernel", "result": {"compiled": true, "correctness": false, "metadata": {"hardware": "NVIDIA L20Y", "device": "cuda:1", "runtime_error": "Traceback (most recent call last):\n  File \"/cpfs01/shared/llm_kernel/hujiakai/KernelLLM/validation_api_server/helpers/evaluations.py\", line 720, in run_and_check_correctness\n    output_new = model_new(*inputs)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1773, in _wrapped_call_impl\n    return self._call_impl(*args, **kwargs)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1784, in _call_impl\n    return forward_call(*args, **kwargs)\n  File \"/tmp/tmpycqwzcye.py\", line 132, in forward\n    W_out = (W_in - \u67811) * stride_w - 2 * padding_w + dilation_w * (kW - 1) + output_padding_w + 1\nNameError: name '\u67811' is not defined\n", "runtime_error_name": "builtins.NameError", "reference_timing_ms": 0.0435, "speed_up": -1.0, "custom_timing": -1.0}, "runtime": -1.0, "runtime_stats": {}}}}, "island": 1}, "artifacts_json": null, "artifact_dir": null}