{"id": "c0b6c308-3e28-4920-b73e-b10dd366c673", "code": "# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef conv_transpose2d_kernel(\n    input_ptr, weight_ptr, bias_ptr, output_ptr,\n    in_channels, out_channels, kernel_h, kernel_w,\n    stride_h, stride_w, padding_h, padding_w,\n    dilation_h, dilation_w, groups,\n    output_height, output_width, height_in, width_in,\n    BLOCK_SIZE_IC: tl.constexpr, BLOCK_SIZE_KH: tl.constexpr, BLOCK_SIZE_KW: tl.constexpr,\n    HAS_BIAS: tl.constexpr,\n):\n    pid_b = tl.program_id(0)\n    pid_oc = tl.program_id(1)\n    pid_oh = tl.program_id(2)\n    pid_ow = tl.program_id(3)\n    \n    out_channels_per_group = out_channels // groups\n    in_channels_per_group = in_channels // groups\n    group_idx = pid_oc // out_channels_per_group\n    oc_in_group = pid_oc % out_channels_per_group\n    start_ic = group_idx * in_channels_per_group\n    \n    acc = 0.0\n    \n    for kh in range(0, kernel_h, BLOCK_SIZE_KH):\n        kh_offsets = kh + tl.arange(0, BLOCK_SIZE_KH)\n        kh_mask = kh_offsets < kernel_h\n        for kw in range(0, kernel_w, BLOCK_SIZE_KW):\n            kw_offsets = kw + tl.arange(0, BLOCK_SIZE_KW)\n            kw_mask = kw_offsets < kernel_w\n            for ic in range(0, in_channels_per_group, BLOCK_SIZE_IC):\n                ic_offsets = ic + tl.arange(0, BLOCK_SIZE_IC)\n                ic_mask = ic_offsets < in_channels_per_group\n                \n                w_offsets = (start_ic + ic_offsets)[:, None, None] * (out_channels_per_group * kernel_h * kernel_w) + \\\n                            oc_in_group * (kernel_h * kernel_w) + \\\n                            kh_offsets[None, :, None] * kernel_w + \\\n                            kw_offsets[None, None, :]\n                weights = tl.load(weight_ptr + w_offsets, mask=ic_mask[:, None, None] & kh_mask[None, :, None] & kw_mask[None, None, :], other=0.0)\n                \n                kh_dilated = kh_offsets[None, :, None] * dilation_h\n                kw_dilated = kw_offsets[None, None, :] * dilation_w\n                ih = (pid_oh + padding_h - kh_dilated) \n                iw = (pid_ow + padding_w - kw_dilated) \n                \n                ih_div = ih // stride_h\n                iw_div = iw // stride_w\n                ih_rem = ih % stride_h\n                iw_rem = iw % stride_w\n                \n                cond = (ih_rem == 0) & (iw_rem == 0) & (ih_div >= 0) & (ih_div < height_in) & (iw_div >= 0) & (iw_div < width_in)\n                \n                input_offsets = pid_b * (in_channels * height_in * width_in) + \\\n                                (start_ic + ic_offsets)[:, None, None] * (height_in * width_in) + \\\n                                ih_div * width_in + iw_div\n                inputs = tl.load(input_ptr + input_offsets, mask=cond & ic_mask[:, None, None] & kh_mask[None, :, None] & kw_mask[None, None, :], other=0.0)\n                \n                prod = inputs * weights\n                acc += tl.sum(prod, axis=[0, 1, 2])\n    \n    if HAS_BIAS:\n        bias_val = tl.load(bias_ptr + pid_oc)\n        acc += bias_val\n    \n    output_offset = pid_b * (out_channels * output_height * output_width) + \\\n                    pid_oc * (output_height * output_width) + \\\n                    pid_oh * output_width + pid_ow\n    tl.store(output_ptr + output_offset, acc)\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_channels: int, out_channels: int, kernel_size: tuple, stride: tuple = (1, 1), padding: tuple = (0, 0), output_padding: tuple = (0, 0), dilation: tuple = (1, 1), groups: int = 1, bias: bool = False):\n        super(ModelNew, self).__init__()\n        self.in_channels = in_channels\n        self.out_channels = out_channels\n        self.kernel_size = kernel_size\n        self.stride = stride\n        self.padding = padding\n        self.output_padding = output_padding\n        self.dilation = dilation\n        self.groups = groups\n        \n        self.weight = nn.Parameter(torch.empty(in_channels, out_channels // groups, kernel_size[0], kernel_size[1]))\n        if bias:\n            self.bias = nn.Parameter(torch.empty(out_channels))\n        else:\n            self.register_parameter('bias', None)\n        \n        nn.init.kaiming_uniform_(self.weight, a=math.sqrt(5))\n        if bias:\n            fan_in, _ = nn.init._calculate_fan_in_and_fan_out(self.weight)\n            bound = 1 / math.sqrt(fan_in)\n            nn.init.uniform_(self.bias, -bound, bound)\n    \n    def forward(self, x: torch.Tensor) -> torch.Tensor:\n        batch_size, in_channels, height_in, width_in = x.shape\n        kernel_h, kernel_w = self.kernel_size\n        stride_h, stride_w = self.stride\n        padding_h, padding_w = self.padding\n        dilation_h, dilation_w = self.dilation\n        \n        output_height = (height_in - 1) * stride_h - 2 * padding_h + dilation_h * (kernel_h - 1) + self.output_padding[0] + 1\n        output_width = (width_in - 1) * stride_w - 2 * padding_w + dilation_w * (kernel_w - 1) + self.output_padding[1] + 1\n        \n        output = torch.empty(batch_size, self.out_channels, output_height, output_width, device=x.device, dtype=x.dtype)\n        \n        grid = (batch_size, self.out_channels, output_height, output_width)\n        \n        has_bias = self.bias is not None\n        bias_ptr = self.bias.data_ptr() if has_bias else 0\n        \n        conv_transpose2d_kernel[grid](\n            x, self.weight, bias_ptr, output,\n            self.in_channels, self.out_channels, kernel_h, kernel_w,\n            stride_h, stride_w, padding_h, padding_w,\n            dilation_h, dilation_w, self.groups,\n            output_height, output_width, height_in, width_in,\n            BLOCK_SIZE_IC=16, BLOCK_SIZE_KH=4, BLOCK_SIZE_KW=4,\n            HAS_BIAS=has_bias\n        )\n        \n        return output\n\n# Test code\nbatch_size = 16\nin_channels = 32\nout_channels = 64\nkernel_size = (3, 5)\nheight_in = 16\nwidth_in = 32\n\ndef get_inputs():\n    x = torch.randn(batch_size, in_channels, height_in, width_in)\n    return [x]\n\ndef get_init_inputs():\n    return [in_channels, out_channels, kernel_size]\n# =================== EVOLVE-BLOCK-END ===================", "language": "python", "parent_id": "ae0a607e-a678-4135-915b-ef405bfcb4fb", "generation": 1, "timestamp": 1754646920.8642335, "iteration_found": 3, "metrics": {"compiled": false, "correctness": false, "score": 1, "stage": "compile_error", "compile_log": "name 'math' is not defined\nTraceback (most recent call last):\n  File \"/cpfs01/shared/llm_kernel/hujiakai/KernelLLM/validation_api_server/evaluator.py\", line 173, in _verification_worker\n    result: KernelExecResult = eval_kernel_against_ref(\n  File \"/cpfs01/shared/llm_kernel/hujiakai/KernelLLM/validation_api_server/helpers/evaluations.py\", line 484, in eval_kernel_against_ref\n    custom_model = ModelNew(*init_args, **init_kwargs)\n  File \"/tmp/tmpd5e9tuvb.py\", line 93, in __init__\n    nn.init.kaiming_uniform_(self.weight, a=math.sqrt(5))\nNameError: name 'math' is not defined\n", "exec_log": "[Child] \u7ed1\u5b9a GPU 3, torch sees 1 device(s)\n\n[Exception]\nTraceback (most recent call last):\n  File \"/cpfs01/shared/llm_kernel/hujiakai/KernelLLM/validation_api_server/code_executor.py\", line 71, in _exec_worker\n    exec(textwrap.dedent(code_src), mod.__dict__)\n  File \"<string>\", line 8, in <module>\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 844, in jit\n    return decorator(fn)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 832, in decorator\n    return JITFunction(\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 635, in __init__\n    self.starting_line_number = inspect.getsourcelines(fn)[1]\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/inspect.py\", line 1121, in getsourcelines\n    lines, lnum = findsource(object)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/inspect.py\", line 958, in findsource\n    raise OSError('could not get source code')\nOSError: could not get source code\n", "exit_code": "1"}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": true, "correctness": true, "stage": "reference code", "passed": false, "score": 0.0, "speed_up": 1.0, "runtime_ms": 0.0479, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:2", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.0435, "speed_up": 0.908, "custom_timing": 0.0479}}, "island": 1}, "artifacts_json": null, "artifact_dir": null}