{"id": "ac97f71e-7658-403c-a18d-1a608cad1700", "code": "# ================== EVOLVE-BLOCK-START ==================\nimport math\nimport torch\nimport triton\nimport triton.language as tl\nimport torch.nn as nn\n\n@triton.jit\ndef _linear_fused_kernel(\n    a_ptr, b_ptr, c_ptr, bias_ptr,\n    stride_am, stride_ak,\n    stride_bn, stride_bk,\n    stride_cm, stride_cn,\n    M, N, K,\n    scale_factor, clamp_min, clamp_max,\n    BLOCK_SIZE_M: tl.constexpr, BLOCK_SIZE_N: tl.constexpr, BLOCK_SIZE_K: tl.constexpr,\n):\n    pid = tl.program_id(0)\n    num_pid_n = tl.cdiv(N, BLOCK_SIZE_N)\n    pid_m = pid // num_pid_n\n    pid_n = pid % num_pid_n\n\n    offs_am = pid_m * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)\n    offs_bn = pid_n * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n    offs_k = tl.arange(0, BLOCK_SIZE_K)\n    a_ptrs = a_ptr + offs_am[:, None] * stride_am + offs_k[None, :] * stride_ak\n    b_ptrs = b_ptr + offs_k[:, None] * stride_bk + offs_bn[None, :] * stride_bn\n\n    acc = tl.zeros((BLOCK_SIZE_M, BLOCK_SIZE_N), dtype=tl.float32)\n    for k in range(0, tl.cdiv(K, BLOCK_SIZE_K)):\n        k_remaining = K - k * BLOCK_SIZE_K\n        k_mask = offs_k < k_remaining\n        a_mask = (offs_am[:, None] < M) & k_mask[None, :]\n        b_mask = k_mask[:, None] & (offs_bn[None, :] < N)\n        a = tl.load(a_ptrs, mask=a_mask, other=0.0)\n        b = tl.load(b_ptrs, mask=b_mask, other=0.0)\n        acc += tl.dot(a, b, allow_tf32=False)\n        a_ptrs += BLOCK_SIZE_K * stride_ak\n        b_ptrs += BLOCK_SIZE_K * stride_bk\n\n    if bias_ptr is not None:\n        bias_ptrs = bias_ptr + offs_bn\n        b_mask = offs_bn < N\n        bias = tl.load(bias_ptrs, mask=b_mask, other=0.0)\n        acc += bias[None, :]\n\n    acc = acc * scale_factor * 2.0\n    acc = tl.minimum(tl.maximum(acc, clamp_min), clamp_max)\n    \n    offs_cm = pid_m * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)\n    offs_cn = pid_n * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n    c_ptrs = c_ptr + offs_cm[:, None] * stride_cm + offs_cn[None, :] * stride_cn\n    c_mask = (offs_cm[:, None] < M) & (offs_cn[None, :] < N)\n    tl.store(c_ptrs, acc, mask=c_mask)\n\n@triton.jit\ndef _logsumexp_kernel(\n    x_ptr, output_ptr,\n    stride_xm, N,\n    BLOCK_SIZE: tl.constexpr\n):\n    pid = tl.program_id(0)\n    row_start = pid * stride_xm\n    offsets = tl.arange(0, BLOCK_SIZE)\n    mask = offsets < N\n    row = tl.load(x_ptr + row_start + offsets, mask=mask, other=-tl.float32(float('inf')))\n    row_max = tl.max(row, axis=0)\n    row_minus_max = tl.where(mask, row - row_max, -tl.float32(float('inf')))\n    exp_row = tl.exp(row_minus_max)\n    sum_exp = tl.sum(exp_row, axis=0)\n    log_sum_exp = tl.log(sum_exp) + row_max\n    tl.store(output_ptr + pid, log_sum_exp)\n\nclass ModelNew(nn.Module):\n    def __init__(self, input_size, hidden_size, scale_factor, clamp_min, clamp_max):\n        super(ModelNew, self).__init__()\n        self.weight = nn.Parameter(torch.Tensor(hidden_size, input_size))\n        self.bias = nn.Parameter(torch.Tensor(hidden_size))\n        self.scale_factor = scale_factor\n        self.clamp_min = clamp_min\n        self.clamp_max = clamp_max\n        self.hidden_size = hidden_size\n        self.input_size = input_size\n        \n        nn.init.kaiming_uniform_(self.weight, a=math.sqrt(5))\n        fan_in, _ = nn.init._calculate_fan_in_and_fan_out(self.weight)\n        bound = 1 / math.sqrt(fan_in) if fan_in > 0 else 0\n        nn.init.uniform_(self.bias, -bound, bound)\n\n    def forward(self, x):\n        M, K = x.shape\n        N = self.hidden_size\n        intermediate = torch.empty((M, N), device=x.device, dtype=x.dtype)\n        \n        grid = lambda META: (triton.cdiv(M, META['BLOCK_SIZE_M']) * triton.cdiv(N, META['BLOCK_SIZE_N']),)\n        \n        _linear_fused_kernel[grid](\n            x, self.weight, intermediate, self.bias,\n            x.stride(0), x.stride(1),\n            self.weight.stride(0), self.weight.stride(1),\n            intermediate.stride(0), intermediate.stride(1),\n            M, N, K,\n            self.scale_factor, self.clamp_min, self.clamp_max,\n            BLOCK_SIZE_M=16, BLOCK_SIZE_N=64, BLOCK_SIZE_K=32\n        )\n        \n        reduced = torch.empty(M, device=x.device, dtype=x.dtype)\n        BLOCK_SIZE = triton.next_power_of_2(N)\n        _logsumexp_kernel[(M,)](intermediate, reduced, intermediate.stride(0), N, BLOCK_SIZE=BLOCK_SIZE)\n        reduced = reduced.view(-1, 1)\n        out = reduced * torch.nn.functional.mish(reduced)\n        return out\n\nbatch_size = 128\ninput_size = 512\nhidden_size = 1024\nscale_factor = 2.0\nclamp_min = -10.0\nclamp_max = 10.0\n\ndef get_inputs():\n    return [torch.randn(batch_size, input_size)]\n\ndef get_init_inputs():\n    return [input_size, hidden_size, scale_factor, clamp_min, clamp_max]\n# =================== EVOLVE-BLOCK-END ===================", "language": "python", "parent_id": "f2a074f2-4d6e-4b6b-a4d7-5e50a8b56c8d", "generation": 2, "timestamp": 1754568228.2961402, "iteration_found": 12, "metrics": {"compiled": true, "correctness": false, "score": 10, "stage": "wrong_answer", "verify_payload": {"id": "level2_22_Matmul_Scale_ResidualAdd_Clamp_LogSumExp_Mish", "result": {"compiled": true, "correctness": false, "metadata": {"hardware": "NVIDIA L20Y", "device": "cuda:3", "runtime_error": "Traceback (most recent call last):\n  File \"/cpfs01/shared/llm_kernel/hujiakai/KernelLLM/validation_api_server/helpers/evaluations.py\", line 720, in run_and_check_correctness\n    output_new = model_new(*inputs)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1773, in _wrapped_call_impl\n    return self._call_impl(*args, **kwargs)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1784, in _call_impl\n    return forward_call(*args, **kwargs)\n  File \"/tmp/tmpcbvu90o6.py\", line 109, in forward\n    _logsumexp_kernel[(M,)](intermediate, reduced, intermediate.stride(0), N, BLOCK_SIZE=BLOCK_SIZE)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 390, in <lambda>\n    return lambda *args, **kwargs: self.run(grid=grid, warmup=False, *args, **kwargs)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 594, in run\n    kernel = self.compile(src, target=target, options=options.__dict__)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/compiler/compiler.py\", line 339, in compile\n    module = src.make_ir(options, codegen_fns, module_map, context)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/compiler/compiler.py\", line 83, in make_ir\n    return ast_to_ttir(self.fn, self, context=context, options=options, codegen_fns=codegen_fns,\ntriton.compiler.errors.CompilationError: at 10:65:\ndef _logsumexp_kernel(\n    x_ptr, output_ptr,\n    stride_xm, N,\n    BLOCK_SIZE: tl.constexpr\n):\n    pid = tl.program_id(0)\n    row_start = pid * stride_xm\n    offsets = tl.arange(0, BLOCK_SIZE)\n    mask = offsets < N\n    row = tl.load(x_ptr + row_start + offsets, mask=mask, other=-tl.float32(float('inf')))\n                                                                 ^\nTypeError(\"'dtype' object is not callable\")\n\n\nThe above exception was the direct cause of the following exception:\n\nTypeError: 'dtype' object is not callable\n", "runtime_error_name": "triton.compiler.errors.CompilationError", "reference_timing_ms": 0.137, "speed_up": -1.0, "custom_timing": -1.0}, "runtime": -1.0, "runtime_stats": {}}}}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": true, "correctness": false, "score": 10, "stage": "wrong_answer", "verify_payload": {"id": "level2_22_Matmul_Scale_ResidualAdd_Clamp_LogSumExp_Mish", "result": {"compiled": true, "correctness": false, "metadata": {"hardware": "NVIDIA L20Y", "device": "cuda:3", "runtime_error": "Traceback (most recent call last):\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/language/core.py\", line 42, in wrapper\n    return fn(*args, **kwargs)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/language/core.py\", line 2045, in dot\n    return _semantic.dot(input, other, acc, input_precision, max_num_imprecise_acc, out_dtype)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/language/semantic.py\", line 1498, in dot\n    assert lhs.shape[-1].value == rhs.shape[\nAssertionError: First input shape (['constexpr[16]', 'constexpr[32]']) and second input shape ['constexpr[64]', 'constexpr[32]'] are not compatible for matmul (second index of first shape (32) must be equal to first index of second shape (64)\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"/cpfs01/shared/llm_kernel/hujiakai/KernelLLM/validation_api_server/helpers/evaluations.py\", line 720, in run_and_check_correctness\n    output_new = model_new(*inputs)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1773, in _wrapped_call_impl\n    return self._call_impl(*args, **kwargs)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/torch/nn/modules/module.py\", line 1784, in _call_impl\n    return forward_call(*args, **kwargs)\n  File \"/tmp/tmpg7fyuwci.py\", line 97, in forward\n    _linear_fused_kernel[grid](\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 390, in <lambda>\n    return lambda *args, **kwargs: self.run(grid=grid, warmup=False, *args, **kwargs)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 594, in run\n    kernel = self.compile(src, target=target, options=options.__dict__)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/compiler/compiler.py\", line 339, in compile\n    module = src.make_ir(options, codegen_fns, module_map, context)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/compiler/compiler.py\", line 83, in make_ir\n    return ast_to_ttir(self.fn, self, context=context, options=options, codegen_fns=codegen_fns,\ntriton.compiler.errors.CompilationError: at 29:15:\n    a_ptrs = a_ptr + offs_am[:, None] * stride_am + offs_k[None, :] * stride_ak\n    b_ptrs = b_ptr + offs_bn[:, None] * stride_bn + offs_k[None, :] * stride_bk\n\n    acc = tl.zeros((BLOCK_SIZE_M, BLOCK_SIZE_N), dtype=tl.float32)\n    for k in range(0, tl.cdiv(K, BLOCK_SIZE_K)):\n        k_remaining = K - k * BLOCK_SIZE_K\n        k_mask = offs_k < k_remaining\n        a_mask = (offs_am[:, None] < M) & k_mask[None, :]\n        b_mask = (offs_bn[:, None] < N) & k_mask[None, :]\n        a = tl.load(a_ptrs, mask=a_mask, other=0.0)\n        b = tl.load(b_ptrs, mask=b_mask, other=0.0)\n        acc += tl.dot(a, b, allow_tf32=False)\n               ^\n\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/language/core.py\", line 42, in wrapper\n    return fn(*args, **kwargs)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/language/core.py\", line 2045, in dot\n    return _semantic.dot(input, other, acc, input_precision, max_num_imprecise_acc, out_dtype)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/language/semantic.py\", line 1498, in dot\n    assert lhs.shape[-1].value == rhs.shape[\nAssertionError: First input shape (['constexpr[16]', 'constexpr[32]']) and second input shape ['constexpr[64]', 'constexpr[32]'] are not compatible for matmul (second index of first shape (32) must be equal to first index of second shape (64)\n", "runtime_error_name": "triton.compiler.errors.CompilationError", "reference_timing_ms": 0.137, "speed_up": -1.0, "custom_timing": -1.0}, "runtime": -1.0, "runtime_stats": {}}}}, "island": 1}, "artifacts_json": null, "artifact_dir": null}