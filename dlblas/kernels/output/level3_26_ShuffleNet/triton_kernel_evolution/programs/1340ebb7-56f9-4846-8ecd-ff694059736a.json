{"id": "1340ebb7-56f9-4846-8ecd-ff694059736a", "code": "# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport triton\nimport triton.language as tl\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_SIZE_C': 64}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_C': 128}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_C': 256}, num_warps=8),\n        triton.Config({'BLOCK_SIZE_C': 512}, num_warps=8),\n    ],\n    key=['C'],\n)\n@triton.jit\ndef channel_shuffle_kernel(\n    input_ptr, output_ptr,\n    B, C, H, W, groups,\n    input_stride_b, input_stride_c, input_stride_h, input_stride_w,\n    output_stride_b, output_stride_c, output_stride_h, output_stride_w,\n    BLOCK_SIZE_C: tl.constexpr,\n):\n    pid_bhw = tl.program_id(0)\n    pid_c = tl.program_id(1)\n    \n    total_hw = H * W\n    b = pid_bhw // total_hw\n    hw = pid_bhw % total_hw\n    h = hw // W\n    w = hw % W\n    \n    c_offsets = pid_c * BLOCK_SIZE_C + tl.arange(0, BLOCK_SIZE_C)\n    mask = c_offsets < C\n    \n    channels_per_group = C // groups\n    group_idx = c_offsets // channels_per_group\n    index_in_group = c_offsets % channels_per_group\n    new_c = index_in_group * groups + group_idx\n    \n    input_offsets = b * input_stride_b + h * input_stride_h + w * input_stride_w + c_offsets * input_stride_c\n    output_offsets = b * output_stride_b + h * output_stride_h + w * output_stride_w + new_c * output_stride_c\n    \n    x = tl.load(input_ptr + input_offsets, mask=mask, eviction_policy='evict_first')\n    tl.store(output_ptr + output_offsets, x, mask=mask)\n\nclass ChannelShuffle(nn.Module):\n    def __init__(self, groups):\n        super(ChannelShuffle, self).__init__()\n        self.groups = groups\n    \n    def forward(self, x):\n        B, C, H, W = x.size()\n        assert C % self.groups == 0\n        \n        if x.numel() == 0:\n            return x\n\n        output = torch.empty_like(x)\n        grid = (B * H * W, triton.cdiv(C, 256))\n        channel_shuffle_kernel[grid](\n            x, output,\n            B, C, H, W, self.groups,\n            x.stride(0), x.stride(1), x.stride(2), x.stride(3),\n            output.stride(0), output.stride(1), output.stride(2), output.stride(3),\n            BLOCK_SIZE_C=256\n        )\n        return output\n\nclass ShuffleNetUnit(nn.Module):\n    def __init__(self, in_channels, out_channels, groups=3):\n        super(ShuffleNetUnit, self).__init__()\n        assert out_channels % 4 == 0\n        mid_channels = out_channels // 4\n        \n        self.conv1 = nn.Conv2d(in_channels, mid_channels, kernel_size=1, stride=1, padding=0, groups=groups, bias=False)\n        self.bn1 = nn.BatchNorm2d(mid_channels)\n        \n        self.conv2 = nn.Conv2d(mid_channels, mid_channels, kernel_size=3, stride=\u6781\u5ba2\u65f6\u95f4\n1, padding=1, groups=mid_channels, bias=False)\n        self.bn2 = nn.BatchNorm2d(mid_channels)\n        \n        self.conv3 = nn.Conv2d(mid_channels, out_channels, kernel_size=1, stride=1, padding=0, groups=groups, bias=False)\n        self.bn3 = nn.BatchNorm2d(out_channels)\n        \n        self.shuffle = ChannelShuffle(groups)\n        \n        if in_channels == out_channels:\n            self.shortcut = nn.Sequential()\n        else:\n            self.shortcut = nn.Sequential(\n                nn.Conv2d(in_channels, out_channels, kernel_size=1, stride=1, padding=0, bias=False),\n                nn.BatchNorm2d(out_channels)\n            )\n    \n    def forward(self, x):\n        out = F.relu(self.bn1(self.conv1(x)))\n        out = self.bn2(self.conv2(out))\n        out = self.shuffle(out)\n        out = F.relu(self.bn3(self.conv3(out)))\n        out += self.shortcut(x)\n        return out\n\nclass ModelNew(nn.Module):\n    def __init__(self, num_classes=1000, groups=3, stages_repeats=[3, 7, 3], stages_out_channels=[24, 240, 480, 960]):\n        super(ModelNew, self).__init__()\n        self.conv1 = nn.Conv2d(3, stages_out_channels[0], kernel_size=3, stride=2, padding=1, bias=False)\n        self.bn1 = nn.BatchNorm2d(stages_out_channels[0])\n        self.maxpool = nn.MaxPool2d(kernel_size=3, stride=2, padding=1)\n        \n        self.stage2 = self._make_stage(stages_out_channels[0], stages_out_channels[1], stages_repeats[0], groups)\n        self.stage3 = self._make_stage(stages_out_channels[1], stages_out_channels[2], stages_repeats[1], groups)\n        self.stage4 = self._make_stage(stages_out_channels[2], stages_out_channels[3], stages_repeats[2], groups)\n        \n        self.conv5 = nn.Conv2d(stages_out_channels[3], 1024, kernel_size=1, stride=1, padding=0, bias=False)\n        self.bn5 = nn.BatchNorm2d(1024)\n        self.f\u6781\u5ba2\u65f6\u95f4c = nn.Linear(1024, num_classes)\n    \n    def _make_stage(self, in_channels, out_channels, repeats, groups):\n        layers = []\n        layers.append(ShuffleNetUnit(in_channels, out_channels, groups))\n        for _ in range(1, repeats):\n            layers.append(ShuffleNetUnit(out_channels, out_channels, groups))\n        return nn.Sequential(*layers)\n    \n    def forward(self, x):\n        x = F.relu(self.bn1(self.conv1(x)))\n        x = self.maxpool(x)\n        x = self.stage2(x)\n        x = self.stage3(x)\n        x = self.stage4(x)\n        x = F.relu(self.bn5(self.conv5(x)))\n        x = F.adaptive_avg_pool2d(x, (1, 1))\n        x = x.view(x.size(0), -1)\n        x = self.fc(x)\n        return x\n\n# Test code\nbatch_size = 10\ninput_channels = 3\nheight = 224\nwidth = 224\nnum_classes = 1000\n\ndef get_inputs():\n    return [torch.randn(batch_size, input_channels, height, width)]\n\ndef get_init_inputs():\n    return [num_classes]\n# =================== EVOLVE-BLOCK-END ===================", "language": "python", "parent_id": "159bc33a-e7c9-41d6-af64-988f32653e8a", "generation": 3, "timestamp": 1754592385.2503085, "iteration_found": 25, "metrics": {"compiled": false, "correctness": false, "score": 1, "stage": "compile_error", "compile_log": "", "exec_log": "[Child] \u7ed1\u5b9a GPU 4, torch sees 1 device(s)\n\n[Exception]\nTraceback (most recent call last):\n  File \"/cpfs01/shared/llm_kernel/hujiakai/KernelLLM/validation_api_server/code_executor.py\", line 71, in _exec_worker\n    exec(textwrap.dedent(code_src), mod.__dict__)\n  File \"<string>\", line 80\n    self.conv2 = nn.Conv2d(mid_channels, mid_channels, kernel_size=3, stride=\u6781\u5ba2\u65f6\u95f4\n                                                                             \nSyntaxError: invalid syntax. Perhaps you forgot a comma?\n", "exit_code": "1"}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": false, "score": 20, "speed_up": 0.449, "runtime_ms": 8.58, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:1", "correctness_trials": "(5 / 5)", "reference_timing_ms": 3.85, "speed_up": 0.449, "custom_timing": 8.58}}, "island": 0}, "artifacts_json": null, "artifact_dir": null}