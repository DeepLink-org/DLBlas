{"id": "332af816-a9a4-4f7c-a86b-80763558e662", "code": "# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport triton\nimport triton.language as tl\nimport math\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_SIZE_C': 128}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_C': 256}, num_warps=4),\n        triton.Config({'BLOCK_SIZE_C': 64}, num_warps=8),\n        triton.Config({'BLOCK_SIZE_C': 128}, num_warps=8),\n    ],\n    key=['C']\n)\n@triton.jit\ndef channel_shuffle_kernel(\n    input_ptr, output_ptr,\n    B, C, H, W, groups,\n    stride_b, stride_c, stride_h, stride_w,\n    BLOCK_SIZE_C: tl.constexpr,\n):\n    pid0 = tl.program_id(0)  # Spatial index (H*W)\n    pid1 = tl.program_id(1)  # Batch index\n    pid2 = tl.program_id(2)  # Channel block index\n    \n    # Compute spatial coordinates\n    spatial_idx = pid0\n    w = spatial_idx % W\n    h = spatial_idx // W\n    b = pid1\n    \n    # Channel block processing\n    c_offsets = pid2 * BLOCK_SIZE_C + tl.arange(0, BLOCK_SIZE_C)\n    mask = c_offsets < C\n    \n    # Compute shuffled indices\n    channels_per_group = C // groups\n    group_idx = c_offsets // channels_per_group\n    index_in_group = c_offsets % channels_per_group\n    new_c = index_in_group * groups + group_idx\n    \n    # Compute base pointers\n    base_ptr = b * stride_b + h * stride_h + w * stride_w\n    input_ptr += base_ptr\n    output_ptr += base_ptr\n    \n    # Calculate offsets with explicit strides\n    input_offsets = new_c * stride_c\n    output_offsets = c_offsets * stride_c\n    \n    # Coalesced memory operations\n    x = tl.load(input_ptr + input_offsets, mask=mask, other=0)\n    tl.store(output_ptr + output_offsets, x, mask=mask)\n\nclass ChannelShuffle(nn.Module):\n    def __init__(self, groups):\n        super(ChannelShuffle, self).__init__()\n        self.groups = groups\n    \n    def forward(self, x):\n        batch_size, channels, height, width = x.size()\n        channels_per_group = channels // self.groups\n        \n        if self.groups == 1:\n            return x\n            \n        if x.is_cuda:\n            output = torch.empty_like(x)\n            grid = (height * width, batch_size, triton.cdiv(channels, 128))\n            channel_shuffle_kernel[grid](\n                x, output,\n                batch_size, channels, height, width, self.groups,\n                x.stride(0), x.stride(1), x.stride(2), x.stride(3)\n            )\n            return output\n        else:\n            x = x.view(batch_size, self.groups, channels_per_group, height, width)\n            x = x.transpose(1, 2).contiguous()\n            return x.view(batch_size, -1, height, width)\n\nclass ShuffleNetUnit(nn.Module):\n    def __init__(self, in_channels, out_channels, groups=3):\n        super(ShuffleNetUnit, self).__init__()\n        assert out_channels % 4 == 0\n        mid_channels = out_channels // 4\n        \n        self.conv1 = nn.Conv2d(in_channels, mid_channels, kernel_size=1, stride=1, padding=0, groups=groups, bias=False)\n        self.bn1 = nn.BatchNorm2d(mid_channels)\n        \n        self.conv2 = nn.Conv2d(mid_channels, mid_channels, kernel_size=3, stride=1, padding=1, groups=mid_channels, bias=False)\n        self.bn2 = nn.BatchNorm2d(mid_channels)\n        \n        self.conv3 = nn.Conv2d(mid_channels, out_channels, kernel_size=1, stride=1, padding=0, groups=groups, bias=False)\n        self.bn3 = nn.BatchNorm2d(out_channels)\n        \n        self.shuffle = ChannelShuffle(groups)\n        \n        if in_channels == out_channels:\n            self.shortcut = nn.Sequential()\n        else:\n            self.shortcut = nn.Sequential(\n                nn.Conv2d(in_channels, out_channels, kernel_size=1, stride=1, padding=0, bias=False),\n                nn.BatchNorm2d(out_channels)\n            )\n    \n    def forward(self, x):\n        out = F.relu(self.bn1(self.conv1(x)))\n        out = self.bn2(self.conv2(out))\n        out = self.shuffle(out)\n        out = F.relu(self.bn3(self.conv3(out)))\n        out += self.shortcut(x)\n        return out\n\nclass ModelNew(nn.Module):\n    def __init__(self, num_classes=1000, groups=3, stages_repeats=[3, 7, 3], stages_out_channels=[24, 240, 480, 960]):\n        super(ModelNew, self).__init__()\n        \n        self.conv1 = nn.Conv2d(3, stages_out_channels[0], kernel_size=3, stride=2, padding=1, bias=False)\n        self.bn1 = nn.BatchNorm2d(stages_out_channels[0])\n        self.maxpool = nn.MaxPool2d(kernel_size=3, stride=2, padding=1)\n        \n        self.stage2 = self._make_stage(stages_out_channels[0], stages_out_channels[1], stages_repeats[0], groups)\n        self.stage3 = self._make_stage(stages_out_channels[1], stages_out_channels[2], stages_repeats[1], groups)\n        self.stage4 = self._make_stage(stages_out_channels[2], stages_out_channels[3], stages_repeats[2], groups)\n        \n        self.conv5 = nn.Conv2d(stages_out_channels[\u6781], 1024, kernel_size=1, stride=1, padding=0, bias=False)\n        self.bn5 = nn.BatchNorm2d(1024)\n        \n        self.fc = nn.Linear(1024, num_classes)\n    \n    def _make_stage(self, in_channels, out_channels, repeats, groups):\n        layers = []\n        layers.append(ShuffleNetUnit(in_channels, out_channels, groups))\n        for _ in range(1, repeats):\n            layers.append(ShuffleNetUnit(out_channels, out_channels, groups))\n        return nn.Sequential(*layers)\n    \n    def forward(self, x):\n        x = F.relu(self.bn1(self.conv1(x)))\n        x = self.maxpool(x)\n        \n        x = self.stage2(x)\n        x = self.stage3(x)\n        x = self.stage4(x)\n        \n        x = F.relu(self.bn5(self.conv5(x)))\n        x = F.adaptive_avg_pool2d(x, (1, 1))\n        x = x.view(x.size(0), -1)\n        x = self.fc(x)\n        \n        return x\n\n# Test code\nbatch_size = 10\ninput_channels = 3\nheight = 224\nwidth = 224\nnum_classes = 1000\n\ndef get_inputs():\n    return [torch.randn(batch_size, input_channels, height, width)]\n\ndef get_init_inputs():\n    return [num_classes]\n# =================== EVOLVE-BLOCK-END ===================", "language": "python", "parent_id": "b2038d61-a6c0-4f39-924d-ebc48ec1e245", "generation": 2, "timestamp": 1754591988.6469176, "iteration_found": 21, "metrics": {"compiled": false, "correctness": false, "score": 1, "stage": "compile_error", "compile_log": "name '\u6781' is not defined\nTraceback (most recent call last):\n  File \"/cpfs01/shared/llm_kernel/hujiakai/KernelLLM/validation_api_server/evaluator.py\", line 173, in _verification_worker\n    result: KernelExecResult = eval_kernel_against_ref(\n  File \"/cpfs01/shared/llm_kernel/hujiakai/KernelLLM/validation_api_server/helpers/evaluations.py\", line 484, in eval_kernel_against_ref\n    custom_model = ModelNew(*init_args, **init_kwargs)\n  File \"/tmp/tmpjoxx93rs.py\", line 129, in __init__\n    self.conv5 = nn.Conv2d(stages_out_channels[\u6781], 1024, kernel_size=1, stride=1, padding=0, bias=False)\nNameError: name '\u6781' is not defined\n", "exec_log": "[Child] \u7ed1\u5b9a GPU 4, torch sees 1 device(s)\n\n[Exception]\nTraceback (most recent call last):\n  File \"/cpfs01/shared/llm_kernel/hujiakai/KernelLLM/validation_api_server/code_executor.py\", line 71, in _exec_worker\n    exec(textwrap.dedent(code_src), mod.__dict__)\n  File \"<string>\", line 19, in <module>\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 844, in jit\n    return decorator(fn)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 832, in decorator\n    return JITFunction(\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/site-packages/triton/runtime/jit.py\", line 635, in __init__\n    self.starting_line_number = inspect.getsourcelines(fn)[1]\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/inspect.py\", line 1121, in getsourcelines\n    lines, lnum = findsource(object)\n  File \"/home/lijiaxing/.conda/envs/api/lib/python3.10/inspect.py\", line 958, in findsource\n    raise OSError('could not get source code')\nOSError: could not get source code\n", "exit_code": "1"}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": false, "score": 20, "speed_up": 0.455, "runtime_ms": 8.46, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:4", "correctness_trials": "(5 / 5)", "reference_timing_ms": 3.85, "speed_up": 0.455, "custom_timing": 8.46}}, "island": 0}, "artifacts_json": null, "artifact_dir": null}