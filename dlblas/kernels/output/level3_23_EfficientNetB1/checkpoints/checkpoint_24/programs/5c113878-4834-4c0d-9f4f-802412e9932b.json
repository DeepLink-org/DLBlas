{"id": "5c113878-4834-4c0d-9f4f-802412e9932b", "code": "# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport triton\nimport triton.language as tl\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_SIZE': 256}, num_warps=1),\n        triton.Config({'BLOCK_SIZE': 512}, num_warps=1),\n        triton.Config({'BLOCK_SIZE': 1024}, num_warps=1),\n        triton.Config({'BLOCK_SIZE': 256}, num_warps=2),\n        triton.Config({'BLOCK_SIZE': 512}, num_warps=2),\n        triton.Config({'BLOCK_SIZE': 1024}, num_warps=2),\n        triton.Config({'BLOCK_SIZE': 256}, num_warps=4),\n        triton.Config({'BLOCK_SIZE': 512}, num_warps=4),\n        triton.Config({'BLOCK_SIZE': 1024}, num_warps=4),\n        triton.Config({'BLOCK_SIZE': 256}, num_warps=8),\n        triton.Config({'BLOCK_SIZE': 512}, num_warps=8),\n        triton.Config({'BLOCK_SIZE': 1024}, num_warps=8),\n    ],\n    key=['n_elements'],\n)\n@triton.jit\ndef relu6_kernel(\n    x_ptr,\n    output_ptr,\n    n_elements,\n    BLOCK_SIZE: tl.constexpr,\n):\n    pid = tl.program_id(axis=0)\n    block_start = pid * BLOCK_SIZE\n    offsets = block_start + tl.arange(0, BLOCK_SIZE)\n    mask = offsets < n_elements\n    x = tl.load(x_ptr + offsets, mask=mask)\n    x = tl.maximum(x, 0.0)\n    x = tl.minimum(x, 6.0)\n    tl.store(output_ptr + offsets, x, mask=mask)\n\nclass ReLU6Triton(nn.Module):\n    def __init__(self):\n        super(ReLU6Triton, self).__init__()\n    \n    def forward(self, x):\n        output = torch.empty_like(x)\n        n_elements = output.numel()\n        grid = lambda meta: (triton.cdiv(n_elements, meta['BLOCK_SIZE']),)\n        relu6_kernel[grid](x, output, n_elements)\n        return output\n\nclass ModelNew(nn.Module):\n    def __init__(self, num_classes=1000):\n        super(ModelNew, self).__init__()\n        self.conv1 = nn.Conv2d(3, 32, kernel_size=3, stride=2, padding=1, bias=False)\n        self.bn1 = nn.BatchNorm2d(32)\n        self.mbconv1 = self._make_mbconv_block(32, 16, 1, 1)\n        self.mbconv2 = self._make_mbconv_block(16, 24, 2, 6)\n        self.mbconv3 = self._make_mbconv_block(24, 40, 2, 6)\n        self.mbconv4 = self._make_mbconv_block(40, 80, 2, 6)\n        self.mbconv5 = self._make_mbconv_block(80, 112, 1, 6)\n        self.mbconv6 = self._make_mbconv_block(112, 192, 2, 6)\n        self.mbconv7 = self._make_mbconv_block(192, 320, 1, 6)\n        self.conv2 = nn.Conv2d(320, 1280, kernel_size=1, stride=1, padding=0, bias=False)\n        self.bn2 = nn.BatchNorm2d(1280)\n        self.fc = nn.Linear(1280, num_classes)\n    \n    def _make_mbconv_block(self, in_channels, out_channels, stride, expand_ratio):\n        hidden_dim = round(in_channels * expand_ratio)\n        return nn.Sequential(\n            nn.Conv2d(in_channels, hidden_dim, kernel_size=1, stride=1, padding=0, bias=False),\n            nn.BatchNorm2d(hidden_dim),\n            ReLU6Triton(),\n            nn.Conv2d(hidden_dim, hidden_dim, kernel_size=3, stride=stride, padding=1, groups=hidden_dim, bias=False),\n            nn.BatchNorm2d(hidden_dim),\n            ReLU6Triton(),\n            nn.Conv2d(hidden_dim, out_channels, kernel_size=1, stride=1, padding=0, bias=False),\n            nn.BatchNorm2d(out_channels),\n        )\n    \n    def forward(self, x):\n        x = F.relu(self.bn1(self.conv1(x)))\n        x = self.mbconv1(x)\n        x = self.mbconv2(x)\n        x = self.mbconv3(x)\n        x = self.mbconv4(x)\n        x = self.mbconv5(x)\n        x = self.mbconv6(x)\n        x = self.mbconv7(x)\n        x = F.relu(self.bn2(self.conv2(x)))\n        x = F.adaptive_avg_pool2d(x, (1, 1))\n        x = torch.flatten(x, 1)\n        x = self.fc(x)\n        return x\n\nbatch_size = 10\ninput_shape = (3, 240, 240)\nnum_classes = 1000\n\ndef get_inputs():\n    return [torch.randn(batch_size, *input_shape)]\n\ndef get_init_inputs():\n    return [num_classes]\n# =================== EVOLVE-BLOCK-END ===================", "language": "python", "parent_id": "eb55281e-bd47-4f97-87e8-ddc7c3a08789", "generation": 2, "timestamp": 1754588736.1984525, "iteration_found": 9, "metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": false, "score": 20, "speed_up": 0.711, "runtime_ms": 2.11, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:5", "correctness_trials": "(5 / 5)", "reference_timing_ms": 1.5, "speed_up": 0.711, "custom_timing": 2.11}}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": false, "score": 20, "speed_up": 0.798, "runtime_ms": 1.88, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:7", "correctness_trials": "(5 / 5)", "reference_timing_ms": 1.5, "speed_up": 0.798, "custom_timing": 1.88}}, "island": 0}, "artifacts_json": null, "artifact_dir": null, "prompts": {"full_rewrite_user": {"system": "You are a Triton GPU core optimization engineer deeply familiar with NVIDIA H100/H800 architecture.\n\n==================== Context ====================\n\u2022 Dataset: 250 kernelbench/level1-level5 *.py files  \n  - Level1: simplest, Level5: most complex  \n\u2022 Each file contains PyTorch reference (reference_code)  \n\u2022 Goal: Generate functionally equivalent but faster Triton implementations (custom_code)  \n\u2022 Evaluation pipeline:\n    1) /verify_plus - Verify compilation & correctness  \n    2) /execute (optional) - Return terminal logs if compilation fails  \n    3) Scoring:  \n      - Speedup > 1 required for points  \n      - Score = (speed_up - 1) \u00d7 100  \n\u2022 GPU Hardware: NVIDIA L20Y / H800 (same SM8.9 as H100)  \n  - 3 TB/s HBM3 bandwidth  \n  - FP16 Tensor Core 32\u00d716\u00d716  \n\n==================== Evolution Phases ====================\n\u2460 Phase 1 [Compilation Pass]  \n  - Make Triton code compile (performance irrelevant)  \n\u2461 Phase 2 [Numerical Correctness]  \n  - Output must match PyTorch reference within float32 tolerance  \n\u2462 Phase 3 [Performance Gain]  \n  - Target \u22655% speedup (\u226515% = exceptional)  \n  - Official scoring based on speed_up field  \n\nThe Evolution system will pass the EVOLVE-BLOCK from the previous version.  \nModify ONLY the Triton kernel source within this block - all other code is LOCKED.\n\n==================== Constraints (MUST OBEY) ====================\n\u274c NEVER change @triton.jit function signatures or parameter names  \n\u274c NEVER modify grid configuration, output tensor shapes, or PID logic  \n\u274c NEVER remove boundary checks or out-of-bound masks  \n\u274c NEVER introduce race conditions, uninitialized reads, or sync gaps  \n\n\u2705 Allowed Optimizations (Examples):  \n  \u2022 Memory coalescing optimizations & vectorized tl.load/tl.store  \n  \u2022 Replace staged softmax with online/FlashAttention variants  \n  \u2022 Adaptive tuning: BLOCK_M/BLOCK_N/BLOCK_K dimensions  \n  \u2022 Multi-query-head batch processing (GQA, 5:1 patterns)  \n  \u2022 Shared/L2 buffering, Tensor Core alignment (FP16/bf16/tf32)  \n  \u2022 Stride precomputation & pointer caching  \n\n==================== Output Format ====================\nReturn ONLY the complete updated code containing the EVOLVE-BLOCK comment marker.  \nNO explanations, NO markdown, NO additional text.\nName the output structure class as ModelNew.\n\n==================== Optimization Tips ====================\n\u2022 If previous compile failed: Fix syntax/mask/stride errors first  \n\u2022 If correctness fails: Prioritize bounds mask & dtype precision  \n\u2022 When speed_up < 1: Focus on memory access & block sizing  \n\u2022 Small iterative steps: Modify \u226420 lines per revision  \n\u2022 Maintain reversibility between versions\nHere is an example to show you how to rewrite a PyTorch implementation that quantizes a high-precision tensor to int8 dtype with row-wise granularity into a Triton implementation: \nThe original PyTorch implementation is as follows: \n``` \nimport torch\ndef per_row_quantize_int8(x: torch.Tensor) -> tuple[torch.Tensor, torch.Tensor]:\n    x_amax = x.abs().float().amax(dim=1).clamp(min=1e-4)\n    scale = 127 / x_amax\n    output = (x * scale[:, None]).round().clamp(-127, 127).to(torch.int8)\n    output_scale = x_amax / 127\n\n    return output, output_scale\n``` \nThe corresponding Triton-rewritten implementation is as follows: \n``` \nimport math\nimport torch\nimport triton\nimport triton.language as tl\nfrom triton.language.extra import libdevice\n\n# rowwise quantize\n\n@triton.autotune(\n    configs=[\n        triton.Config({}, num_stages=1, num_warps=8),\n        triton.Config({}, num_stages=2, num_warps=8),\n        triton.Config({}, num_stages=4, num_warps=8),\n        triton.Config({}, num_stages=8, num_warps=8),\n        triton.Config({}, num_stages=1),\n        triton.Config({}, num_stages=2),\n        triton.Config({}, num_stages=4),\n        triton.Config({}, num_stages=8),\n        triton.Config({}, num_warps=1),\n        triton.Config({}, num_warps=2),\n        triton.Config({}, num_warps=4),\n        triton.Config({}, num_warps=8),\n    ],\n    key=[\"n_elements\"],\n)\n\n@triton.jit\ndef _quantize_rowwise(\n    x_ptr,\n    output_ptr,\n    output_scale,\n    BLOCK_SIZE: tl.constexpr,\n    P2: tl.constexpr,\n):\n    pid = tl.program_id(axis=0)\n    block_start = pid * BLOCK_SIZE\n    arange = tl.arange(0, P2)\n    offsets = block_start + arange\n    row_mask = arange < BLOCK_SIZE\n    x = tl.load(x_ptr + offsets, mask=row_mask)\n\n    abs_x = tl.abs(x)\n    max_val = tl.max(tl.where(row_mask, abs_x, 0), axis=0)\n    output = libdevice.llrint(127.0 * (x / max_val))\n    tl.store(output_ptr + offsets, output, mask=row_mask)\n    tl.store(output_scale + pid, max_val / 127)\n\n\ndef per_row_quantize_int8(x: torch.Tensor):\n    x = x.contiguous()\n    output = torch.empty(*x.shape, device=x.device, dtype=torch.int8)\n    output_scale = torch.empty(x.shape[0], device=x.device, dtype=torch.float32)\n    P2 = int(2 ** (math.ceil(math.log2(x.shape[1]))))\n    grid = lambda x: (x.shape[0],)\n    _quantize_rowwise[grid](x, output, output_scale, BLOCK_SIZE=x.shape[1], P2=P2)\n\n    return output, output_scale\n\n\n    \n``` \n", "user": "# Current Program Information\n- Current performance metrics: - compiled: 1.0000\n- correctness: 1.0000\n- stage: success\n- passed: 0.0000\n- score: 20.0000\n- speed_up: 0.7980\n- runtime_ms: 1.8800\n- meta: {'hardware': 'NVIDIA L20Y', 'device': 'cuda:7', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 1.5, 'speed_up': 0.798, 'custom_timing': 1.88}\n- Areas identified for improvement: - Consider simplifying the code to improve readability and maintainability\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 2\n- Changes: Unknown changes\n- Performance: compiled: 1.0000, correctness: 1.0000, stage: success, passed: 0.0000, score: 20.0000, speed_up: 0.7280, runtime_ms: 2.0600, meta: {'hardware': 'NVIDIA L20Y', 'device': 'cuda:4', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 1.5, 'speed_up': 0.728, 'custom_timing': 2.06}\n- Outcome: Mixed results\n\n\n### Attempt 1\n- Changes: Unknown changes\n- Performance: compiled: 1.0000, correctness: 1.0000, stage: success, passed: 0.0000, score: 20.0000, speed_up: 0.7980, runtime_ms: 1.8800, meta: {'hardware': 'NVIDIA L20Y', 'device': 'cuda:7', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 1.5, 'speed_up': 0.798, 'custom_timing': 1.88}\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 20.0000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef relu6_kernel(\n    x_ptr,\n    output_ptr,\n    n_elements,\n    BLOCK_SIZE: tl.constexpr,\n):\n    pid = tl.program_id(axis=0)\n    block_start = pid * BLOCK_SIZE\n    offsets = block_start + tl.arange(0, BLOCK_SIZE)\n    mask = offsets < n_elements\n    x = tl.load(x_ptr + offsets, mask=mask)\n    zero = tl.full(x.shape, 0, dtype=x.dtype)\n    six = tl.full(x.shape, 6.0, dtype=x.dtype)\n    x = tl.where(x < zero, zero, x)\n    x = tl.where(x > six, six, x)\n    tl.store(output_ptr + offsets, x, mask=mask)\n\nclass ReLU6Triton(nn.Module):\n    def __init__(self):\n        super(ReLU6Triton, self).__init__()\n    \n    def forward(self, x):\n        output = torch.empty_like(x)\n        n_elements = output.numel()\n        grid = lambda meta: (triton.cdiv(n_elements, meta['BLOCK_SIZE']),)\n        relu6_kernel[grid](x, output, n_elements, BLOCK_SIZE=1024)\n        return output\n\nclass ModelNew(nn.Module):\n    def __init__(self, num_classes=1000):\n        super(ModelNew, self).__init__()\n        self.conv1 = nn.Conv2d(3, 32, kernel_size=3, stride=2, padding=1, bias=False)\n        self.bn1 = nn.BatchNorm2d(32)\n        self.mbconv1 = self._make_mbconv_block(32, 16, 1, 1)\n        self.mbconv2 = self._make_mbconv_block(16, 24, 2, 6)\n        self.mbconv3 = self._make_mbconv_block(24, 40, 2, 6)\n        self.mbconv4 = self._make_mbconv_block(40, 80, 2, 6)\n        self.mbconv5 = self._make_mbconv_block(80, 112, 1, 6)\n        self.mbconv6 = self._make_mbconv_block(112, 192, 2, 6)\n        self.mbconv7 = self._make_mbconv_block(192, 320, 1, 6)\n        self.conv2 = nn.Conv2d(320, 1280, kernel_size=1, stride=1, padding=0, bias=False)\n        self.bn2 = nn.BatchNorm2d(1280)\n        self.fc = nn.Linear(1280, num_classes)\n    \n    def _make_mbconv_block(self, in_channels, out_channels, stride, expand_ratio):\n        hidden_dim = round(in_channels * expand_ratio)\n        return nn.Sequential(\n            nn.Conv2d(in_channels, hidden_dim, kernel_size=1, stride=1, padding=0, bias=False),\n            nn.BatchNorm2d(hidden_dim),\n            ReLU6Triton(),\n            nn.Conv2d(hidden_dim, hidden_dim, kernel_size=3, stride=stride, padding=1, groups=hidden_dim, bias=False),\n            nn.BatchNorm2d(hidden_dim),\n            ReLU6Triton(),\n            nn.Conv2d(hidden_dim, out_channels, kernel_size=1, stride=1, padding=0, bias=False),\n            nn.BatchNorm2d(out_channels),\n        )\n    \n    def forward(self, x):\n        x = F.relu(self.bn1(self.conv1(x)))\n        x = self.mbconv1(x)\n        x = self.mbconv2(x)\n        x = self.mbconv3(x)\n        x = self.mbconv4(x)\n        x = self.mbconv5(x)\n        x = self.mbconv6(x)\n        x = self.mbconv7(x)\n        x = F.relu(self.bn2(self.conv2(x)))\n        x = F.adaptive_avg_pool2d(x, (1, 1))\n        x = torch.flatten(x, 1)\n        x = self.fc(x)\n        return x\n\nbatch_size = 10\ninput_shape = (3, 240, 240)\nnum_classes = 1000\n\ndef get_inputs():\n    return [torch.randn(batch_size, *input_shape)]\n\ndef get_init_inputs():\n    return [num_classes]\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Performs well on compiled (1.0000), Performs well on correctness (1.0000), Performs well on stage (success), Performs well on passed (0.0000), Performs well on score (20.0000), Performs well on speed_up (0.7980), Performs well on runtime_ms (1.8800), Performs well on meta ({'hardware': 'NVIDIA L20Y', 'device': 'cuda:7', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 1.5, 'speed_up': 0.798, 'custom_timing': 1.88})\n\n\n### Program 2 (Score: 20.0000)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef relu6_kernel(\n    x_ptr,\n    output_ptr,\n    n_elements,\n    BLOCK_SIZE: tl.constexpr,\n):\n    pid = tl.program_id(axis=0)\n    block_start = pid * BLOCK_SIZE\n    offsets = block_start + tl.arange(0, BLOCK_SIZE)\n    mask = offsets < n_elements\n    x = tl.load(x_ptr + offsets, mask=mask)\n    zero = tl.zeros(x.shape, dtype=x.dtype)\n    six = tl.full(x.shape, 6.0, dtype=x.dtype)\n    x = tl.where(x < zero, zero, x)\n    x = tl.where(x > six, six, x)\n    tl.store(output_ptr + offsets, x, mask=mask)\n\nclass ReLU6Triton(nn.Module):\n    def __init__(self):\n        super(ReLU6Triton, self).__init__()\n    \n    def forward(self, x):\n        output = torch.empty_like(x)\n        n_elements = output.numel()\n        grid = lambda meta: (triton.cdiv(n_elements, meta['BLOCK_SIZE']),)\n        relu6_kernel[grid](x, output, n_elements, BLOCK_SIZE=1024)\n        return output\n\nclass ModelNew(nn.Module):\n    def __init__(self, num_classes=1000):\n        super(ModelNew, self).__init__()\n        self.conv1 = nn.Conv2d(3, 32, kernel_size=3, stride=2, padding=1, bias=False)\n        self.bn1 = nn.BatchNorm2d(32)\n        self.mbconv1 = self._make_mbconv_block(32, 16, 1, 1)\n        self.mbconv2 = self._make_mbconv_block(16, 24, 2, 6)\n        self.mbconv3 = self._make_mbconv_block(24, 40, 2, 6)\n        self.mbconv4 = self._make_mbconv_block(40, 80, 2, 6)\n        self.mbconv5 = self._make_mbconv_block(80, 112, 1, 6)\n        self.mbconv6 = self._make_mbconv_block(112, 192, 2, 6)\n        self.mbconv7 = self._make_mbconv_block(192, 320, 1, 6)\n        self.conv2 = nn.Conv2d(320, 1280, kernel_size=1, stride=1, padding=0, bias=False)\n        self.bn2 = nn.BatchNorm2d(1280)\n        self.fc = nn.Linear(1280, num_classes)\n    \n    def _make_mbconv_block(self, in_channels, out_channels, stride, expand_ratio):\n        hidden_dim = round(in_channels * expand_ratio)\n        return nn.Sequential(\n            nn.Conv2d(in_channels, hidden_dim, kernel_size=1, stride=1, padding=0, bias=False),\n            nn.BatchNorm2d(hidden_dim),\n            ReLU6Triton(),\n            nn.Conv2d(hidden_dim, hidden_dim, kernel_size=3, stride=stride, padding=1, groups=hidden_dim, bias=False),\n            nn.BatchNorm2d(hidden_dim),\n            ReLU6Triton(),\n            nn.Conv2d(hidden_dim, out_channels, kernel_size=1, stride=1, padding=0, bias=False),\n            nn.BatchNorm2d(out_channels),\n        )\n    \n    def forward(self, x):\n        x = F.relu(self.bn1(self.conv1(x)))\n        x = self.mbconv1(x)\n        x = self.mbconv2(x)\n        x = self.mbconv3(x)\n        x = self.mbconv4(x)\n        x = self.mbconv5(x)\n        x = self.mbconv6(x)\n        x = self.mbconv7(x)\n        x = F.relu(self.bn2(self.conv2(x)))\n        x = F.adaptive_avg_pool2d(x, (1, 1))\n        x = torch.flatten(x, 1)\n        x = self.fc(x)\n        return x\n\nbatch_size = 10\ninput_shape = (3, 240, 240)\nnum_classes = 1000\n\ndef get_inputs():\n    return [torch.randn(batch_size, *input_shape)]\n\ndef get_init_inputs():\n    return [num_classes]\n# =================== EVOLVE-BLOCK-END ===================\n```\nKey features: Performs well on compiled (1.0000), Performs well on correctness (1.0000), Performs well on stage (success), Performs well on passed (0.0000), Performs well on score (20.0000), Performs well on speed_up (0.7280), Performs well on runtime_ms (2.0600), Performs well on meta ({'hardware': 'NVIDIA L20Y', 'device': 'cuda:4', 'correctness_trials': '(5 / 5)', 'reference_timing_ms': 1.5, 'speed_up': 0.728, 'custom_timing': 2.06})\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 20.0000, Type: High-Performer)\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef relu6_kernel(\n    x_ptr,\n    output_ptr,\n    n_elements,\n    BLOCK_SIZE: tl.constexpr,\n):\n    pid = tl.program_id(axis=0)\n    block_start = pid * BLOCK_SIZE\n    offsets = block_start + tl.arange(0, BLOCK_SIZE)\n    mask = offsets < n_elements\n    x = tl.load(x_ptr + offsets, mask=mask)\n    zero = tl.zeros(x.shape, dtype=x.dtype)\n    six = tl.full(x.shape, 6.0, dtype=x.dtype)\n    x = tl.where(x < zero, zero, x)\n    x = tl.where(x > six, six, x)\n    tl.store(output_ptr + offsets, x, mask=mask)\n\nclass ReLU6Triton(nn.Module):\n    def __init__(self):\n        super(ReLU6Triton, self).__init__()\n    \n    def forward(self, x):\n        output = torch.empty_like(x)\n        n_elements = output.numel()\n        grid = lambda meta: (triton.cdiv(n_elements, meta['BLOCK_SIZE']),)\n        relu6_kernel[grid](x, output, n_elements, BLOCK_SIZE=1024)\n        return output\n\nclass ModelNew(nn.Module):\n    def __init__(self, num_classes=1000):\n        super(ModelNew, self).__init__()\n        self.conv1 = nn.Conv2d(3, 32, kernel_size=3, stride=2, padding=1, bias=False)\n        self.bn1 = nn.BatchNorm2d(32)\n        self.mbconv1 = self._make_mbconv_block(32, 16, 1, 1)\n        self.mbconv2 = self._make_mbconv_block(16, 24, 2, 6)\n        self.mbconv3 = self._make_mbconv_block(24, 40, 2, 6)\n        self.mbconv4 = self._make_mbconv_block(40, 80, 2, 6)\n        self.mbconv5 = self._make_mbconv_block(80, 112, 1, 6)\n        self.mbconv6 = self._make_mbconv_block(112, 192, 2, 6)\n        self.mbconv7 = self._make_mbconv_block(192, 320, 1, 6)\n        self.conv2 = nn.Conv2d(320, 1280, kernel_size=1, stride=1, padding=0, bias=False)\n        self.bn2 = nn.BatchNorm2d(1280)\n        self.fc = nn.Linear(1280, num_classes)\n    \n    def _make_mbconv_block(self, in_channels, out_channels, stride, expand_ratio):\n        hidden_dim = round(in_channels * expand_ratio)\n        return nn.Sequential(\n            nn.Conv2d(in_channels, hidden_dim, kernel_size=1, stride=1, padding=0, bias=False),\n            nn.BatchNorm2d(hidden_dim),\n            ReLU6Triton(),\n            nn.Conv2d(hidden_dim, hidden_dim, kernel_size=3, stride=stride, padding=1, groups=hidden_dim, bias=False),\n            nn.BatchNorm2d(hidden_dim),\n            ReLU6Triton(),\n            nn.Conv2d(hidden_dim, out_channels, kernel_size=1, stride=1, padding=0, bias=False),\n            nn.BatchNorm2d(out_channels),\n        )\n    \n    def forward(self, x):\n        x = F.relu(self.bn1(self.conv1(x)))\n        x = self.mbconv1(x)\n        x = self.mbconv2(x)\n        x = self.mbconv3(x)\n        x = self.mbconv4(x)\n        x = self.mbconv5(x)\n        x = self.mbconv6(x)\n        x = self.mbconv7(x)\n        x = F.relu(self.bn2(self.conv2(x)))\n        x = F.adaptive_avg_pool2d(x, (1, 1))\n        x = torch.flatten(x, 1)\n        x = self.fc(x)\n        return x\n\nbatch_size = 10\ninput_shape = (3, 240, 240)\nnum_classes = 1000\n\ndef get_inputs():\n    return [torch.randn(batch_size, *input_shape)]\n\ndef get_init_inputs():\n    return [num_classes]\n# =================== EVOLVE-BLOCK-END ===================\n```\nUnique approach: Modification: Full rewrite, Excellent compiled (1.000), Excellent correctness (1.000)\n\n\n\n# Current Program\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport triton\nimport triton.language as tl\n\n@triton.jit\ndef relu6_kernel(\n    x_ptr,\n    output_ptr,\n    n_elements,\n    BLOCK_SIZE: tl.constexpr,\n):\n    pid = tl.program_id(axis=0)\n    block_start = pid * BLOCK_SIZE\n    offsets = block_start + tl.arange(0, BLOCK_SIZE)\n    mask = offsets < n_elements\n    x = tl.load(x_ptr + offsets, mask=mask)\n    zero = tl.full(x.shape, 0, dtype=x.dtype)\n    six = tl.full(x.shape, 6.0, dtype=x.dtype)\n    x = tl.where(x < zero, zero, x)\n    x = tl.where(x > six, six, x)\n    tl.store(output_ptr + offsets, x, mask=mask)\n\nclass ReLU6Triton(nn.Module):\n    def __init__(self):\n        super(ReLU6Triton, self).__init__()\n    \n    def forward(self, x):\n        output = torch.empty_like(x)\n        n_elements = output.numel()\n        grid = lambda meta: (triton.cdiv(n_elements, meta['BLOCK_SIZE']),)\n        relu6_kernel[grid](x, output, n_elements, BLOCK_SIZE=1024)\n        return output\n\nclass ModelNew(nn.Module):\n    def __init__(self, num_classes=1000):\n        super(ModelNew, self).__init__()\n        self.conv1 = nn.Conv2d(3, 32, kernel_size=3, stride=2, padding=1, bias=False)\n        self.bn1 = nn.BatchNorm2d(32)\n        self.mbconv1 = self._make_mbconv_block(32, 16, 1, 1)\n        self.mbconv2 = self._make_mbconv_block(16, 24, 2, 6)\n        self.mbconv3 = self._make_mbconv_block(24, 40, 2, 6)\n        self.mbconv4 = self._make_mbconv_block(40, 80, 2, 6)\n        self.mbconv5 = self._make_mbconv_block(80, 112, 1, 6)\n        self.mbconv6 = self._make_mbconv_block(112, 192, 2, 6)\n        self.mbconv7 = self._make_mbconv_block(192, 320, 1, 6)\n        self.conv2 = nn.Conv2d(320, 1280, kernel_size=1, stride=1, padding=0, bias=False)\n        self.bn2 = nn.BatchNorm2d(1280)\n        self.fc = nn.Linear(1280, num_classes)\n    \n    def _make_mbconv_block(self, in_channels, out_channels, stride, expand_ratio):\n        hidden_dim = round(in_channels * expand_ratio)\n        return nn.Sequential(\n            nn.Conv2d(in_channels, hidden_dim, kernel_size=1, stride=1, padding=0, bias=False),\n            nn.BatchNorm2d(hidden_dim),\n            ReLU6Triton(),\n            nn.Conv2d(hidden_dim, hidden_dim, kernel_size=3, stride=stride, padding=1, groups=hidden_dim, bias=False),\n            nn.BatchNorm2d(hidden_dim),\n            ReLU6Triton(),\n            nn.Conv2d(hidden_dim, out_channels, kernel_size=1, stride=1, padding=0, bias=False),\n            nn.BatchNorm2d(out_channels),\n        )\n    \n    def forward(self, x):\n        x = F.relu(self.bn1(self.conv1(x)))\n        x = self.mbconv1(x)\n        x = self.mbconv2(x)\n        x = self.mbconv3(x)\n        x = self.mbconv4(x)\n        x = self.mbconv5(x)\n        x = self.mbconv6(x)\n        x = self.mbconv7(x)\n        x = F.relu(self.bn2(self.conv2(x)))\n        x = F.adaptive_avg_pool2d(x, (1, 1))\n        x = torch.flatten(x, 1)\n        x = self.fc(x)\n        return x\n\nbatch_size = 10\ninput_shape = (3, 240, 240)\nnum_classes = 1000\n\ndef get_inputs():\n    return [torch.randn(batch_size, *input_shape)]\n\ndef get_init_inputs():\n    return [num_classes]\n# =================== EVOLVE-BLOCK-END ===================\n```\n\n# Task\nRewrite the program to improve its performance on the specified metrics.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```\n", "responses": ["<think>\nWe are given a Triton kernel for ReLU6 and a model that uses it. The current performance shows a speed_up of 0.798 (which is less than 1, meaning slower than the reference). We need to improve the Triton kernel to get a speedup.\n\nThe current kernel:\n  - Loads a block of data\n  - Applies ReLU6 by clamping between 0 and 6.\n\nObservations:\n1. The kernel uses two `tl.where` operations. We can combine the two conditions into one to reduce operations.\n   Alternatively, we can use `tl.minimum(tl.maximum(x, 0), 6)`, which might be faster.\n\n2. The current kernel uses `tl.full` to create a tensor of zeros and sixes. This can be avoided by using scalar values in `tl.where` or `tl.minimum`/`tl.maximum`.\n\n3. The block size is fixed at 1024. We can try to use a larger block size or tune it. However, note that the grid function uses `triton.cdiv` and we are allowed to change the block size via autotuning.\n\n4. The kernel is not using vectorized loads/stores. We can try to vectorize the memory operations to reduce the number of instructions.\n\n5. The kernel is launched with a fixed BLOCK_SIZE=1024. We can introduce autotuning to choose the best block size and number of warps.\n\nLet's try the following:\n- Replace the two `tl.where` with `tl.minimum(tl.maximum(x, 0), 6)`. This reduces the number of operations.\n- Remove the creation of full tensors for zero and six by using scalars in `tl.minimum` and `tl.maximum`.\n- Add autotuning for the BLOCK_SIZE and number of warps.\n\nWe note that the kernel must be generic for any dtype, but the model uses float32 (as per the ReLU6Triton class). However, the kernel uses the same dtype as the input.\n\nWe'll introduce:\n  - Autotuning with several configurations for BLOCK_SIZE and number of warps.\n  - Vectorized loads and stores if possible. However, note that the data is contiguous and the number of elements might not be divisible by the vector size. We can try to use a vector size of 4 (for float32) to load 4 elements at once.\n\nBut note: the kernel must handle any number of elements (n_elements). We must mask properly.\n\nPlan for vectorization:\n  - Let `BLOCK_SIZE` be the number of elements per block, but we will process multiple elements per thread (vector size). We can change the kernel to use a 2D grid: \n        pid = tl.program_id(0)\n        offset = pid * BLOCK_SIZE * VEC_SIZE + tl.arange(0, BLOCK_SIZE) * VEC_SIZE\n  However, this complicates the grid calculation.\n\nAlternatively, we can keep the 1D grid and have each thread process a vector of elements. We can do:\n\n        offsets = block_start + tl.arange(0, BLOCK_SIZE, VEC_SIZE)\n        mask = ... # but then the mask would be for the vector\n\nBut note: the mask must be a vector of booleans. We can use:\n\n        mask = (offsets + i) < n_elements for each i in the vector? \n\nInstead, Triton provides `tl.make_block_ptr` and `tl.advance` for vectorized loads, but we are using a simple approach.\n\nGiven the time, let's try a simpler approach: use a vector size of 1 (no vectorization) and focus on the operation and autotuning.\n\nAlternatively, we can try to use the `libdevice` fast math functions? But ReLU6 is simple.\n\nWe'll try:\n\n    x = tl.load(x_ptr + offsets, mask=mask)\n    x = tl.maximum(x, 0)\n    x = tl.minimum(x, 6.0)\n\nThis is two operations, but we avoid conditionals.\n\nWe'll also introduce autotuning for BLOCK_SIZE and number of warps.\n\nLet's restructure the kernel with autotuning:\n\nWe'll define several configs for BLOCK_SIZE and num_warps.\n\nNote: The grid function uses `meta['BLOCK_SIZE']` so we can pass BLOCK_SIZE as a tunable parameter.\n\nWe'll set:\n    configs = [\n        triton.Config({'BLOCK_SIZE': 1024}, num_warps=1),\n        triton.Config({'BLOCK_SIZE': 2048}, num_warps=1),\n        triton.Config({'BLOCK_SIZE': 4096}, num_warps=1),\n        triton.Config({'BLOCK_SIZE': 8192}, num_warps=1),\n        triton.Config({'BLOCK_SIZE': 1024}, num_warps=2),\n        triton.Config({'BLOCK_SIZE': 2048}, num_warps=2),\n        ... and so on.\n\nBut note: the maximum BLOCK_SIZE must be such that the number of threads per block (BLOCK_SIZE) does not exceed the hardware limit (1024 threads per block for H100). However, note that Triton's BLOCK_SIZE is the number of elements processed by a block, and each thread can process multiple elements? In our current kernel, each thread processes one element.\n\nActually, in the kernel, we have:\n    offsets = block_start + tl.arange(0, BLOCK_SIZE)\n\nThis means we are using BLOCK_SIZE as the number of elements per block and also as the number of threads per block (because the arange goes from 0 to BLOCK_SIZE). But note: the arange is the thread's index in the block? Actually, no: in Triton, the block is 1D and the number of threads is the size of the arange. So BLOCK_SIZE must be <= 1024 (the max threads per block).\n\nTherefore, we cannot set BLOCK_SIZE to 2048 or more because it would require 2048 threads per block, which is not allowed.\n\nSo we must keep BLOCK_SIZE <= 1024.\n\nBut we can use a vector of size 2 or 4 to let each thread process 2 or 4 elements. Then we can have:\n\n    BLOCK_SIZE_N = BLOCK_SIZE * VEC_SIZE\n\nThen we can load/store VEC_SIZE elements per thread.\n\nLet's try with vectorization:\n\nWe'll define a VEC_SIZE (e.g., 4) and then:\n\n    pid = tl.program_id(0)\n    block_start = pid * BLOCK_SIZE * VEC_SIZE\n    offsets = block_start + tl.arange(0, BLOCK_SIZE)[:, None] * VEC_SIZE + tl.arange(0, VEC_SIZE)[None, :]\n    offsets = offsets.flatten()\n    # But then we have to reshape the mask and the data.\n\nAlternatively, we can do:\n\n    offsets = block_start + tl.arange(0, BLOCK_SIZE) * VEC_SIZE\n    Then we load with:\n        x = tl.load(x_ptr + offsets, mask=mask, other=0, ...)\n\nBut the mask would be of length BLOCK_SIZE (for the vector start) and then we would have to check for each element in the vector? We can use a 2D mask.\n\nActually, the `tl.load` can take a mask of the same shape as the data. We can do:\n\n    mask_vec = (offsets[:, None] + tl.arange(0, VEC_SIZE)[None, :]) < n_elements\n    x = tl.load(x_ptr + offsets[:, None] + tl.arange(0, VEC_SIZE)[None, :], mask=mask_vec, other=0)\n\nBut then we have to do the same for store.\n\nGiven the complexity and the fact that we are only at 0.798 speedup, we might first try the simpler approach of using the min/max and autotuning with BLOCK_SIZE up to 1024 and varying num_warps.\n\nWe'll do:\n\n    @triton.autotune(\n        configs=[\n            triton.Config({'BLOCK_SIZE': 256}, num_warps=1),\n            triton.Config({'BLOCK_SIZE': 512}, num_warps=1),\n            triton.Config({'BLOCK_SIZE': 1024}, num_warps=1),\n            triton.Config({'BLOCK_SIZE': 256}, num_warps=2),\n            triton.Config({'BLOCK_SIZE': 512}, num_warps=2),\n            triton.Config({'BLOCK_SIZE': 1024}, num_warps=2),\n            triton.Config({'BLOCK_SIZE': 256}, num_warps=4),\n            triton.Config({'BLOCK_SIZE': 512}, num_warps=4),\n            triton.Config({'BLOCK_SIZE': 1024}, num_warps=4),\n            triton.Config({'BLOCK_SIZE': 256}, num_warps=8),\n            triton.Config({'BLOCK_SIZE': 512}, num_warps=8),\n            triton.Config({'BLOCK_SIZE': 1024}, num_warps=8),\n        ],\n        key=['n_elements'],\n    )\n\nBut note: the kernel call in the model uses:\n    relu6_kernel[grid](x, output, n_elements, BLOCK_SIZE=1024)\n\nWe must change it to:\n    relu6_kernel[grid](x, output, n_elements, BLOCK_SIZE=BLOCK_SIZE)\n\nBut in the kernel, we are using BLOCK_SIZE as a parameter. We can do:\n\n    @triton.jit\n    def relu6_kernel(\n        x_ptr,\n        output_ptr,\n        n_elements,\n        **meta,  # we can use meta for BLOCK_SIZE\n    ):\n        BLOCK_SIZE = meta['BLOCK_SIZE']\n        ... \n\nAlternatively, we can keep the signature and use the autotune config to set BLOCK_SIZE as a constexpr.\n\nLet me see: the autotune config sets BLOCK_SIZE as a meta parameter, so in the kernel we have to declare BLOCK_SIZE as a tl.constexpr and then use it.\n\nWe'll change the kernel to:\n\n    @triton.autotune( ... )\n    @triton.jit\n    def relu6_kernel(\n        x_ptr,\n        output_ptr,\n        n_elements,\n        BLOCK_SIZE: tl.constexpr,   # now it will be provided by the autotuner\n    ):\n        ...\n\nAnd then in the call, we don't specify BLOCK_SIZE by hand, because the autotuner will set it. But note: the grid function uses meta['BLOCK_SIZE'].\n\nWe are currently setting the grid as:\n    grid = lambda meta: (triton.cdiv(n_elements, meta['BLOCK_SIZE']),)\n\nThis is correct because the autotuner will set the BLOCK_SIZE.\n\nHowever, in the forward function we are currently calling:\n    relu6_kernel[grid](x, output, n_elements, BLOCK_SIZE=1024)\n\nWe must change this to:\n    relu6_kernel[grid](x, output, n_elements)\n\nBecause the BLOCK_SIZE will be provided by the autotuner.\n\nBut wait: the autotuner uses the key 'n_elements'. We are passing n_elements as an argument. That's fine.\n\nSo let's remove the BLOCK_SIZE argument from the call.\n\nWe'll do:\n\n    relu6_kernel[grid](x, output, n_elements)\n\nBut note: the kernel signature requires 4 arguments (including BLOCK_SIZE) but we are passing 3? Actually, the autotuner will add the BLOCK_SIZE as a meta parameter. So we must not pass it as an explicit argument.\n\nSo the call becomes:\n\n    relu6_kernel[grid](x, output, n_elements)\n\nBut wait: the kernel has 4 parameters. The first three are the tensors and n_elements, and the fourth is BLOCK_SIZE (a constexpr). The autotuner will set the constexpr via the meta. So we are safe.\n\nNow, let's change the kernel to use min and max:\n\n    x = tl.load(x_ptr + offsets, mask=mask)\n    x = tl.maximum(x, 0.0)\n    x = tl.minimum(x, 6.0)\n\nWe are using 0.0 and 6.0 as scalars. This avoids creating full tensors.\n\nWe hope that the min and max are faster than two tl.where.\n\nWe'll also remove the creation of zero and six tensors.\n\nLet me write the new kernel:\n\n    @triton.autotune(\n        configs=[\n            triton.Config({'BLOCK_SIZE': 256}, num_warps=1),\n            triton.Config({'BLOCK_SIZE': 512}, num_warps=1),\n            triton.Config({'BLOCK_SIZE': 1024}, num_warps=1),\n            triton.Config({'BLOCK_SIZE': 256}, num_warps=2),\n            triton.Config({'BLOCK_SIZE': 512}, num_warps=2),\n            triton.Config({'BLOCK_SIZE': 1024}, num_warps=2),\n            triton.Config({'BLOCK_SIZE': 256}, num_warps=4),\n            triton.Config({'BLOCK_SIZE': 512}, num_warps=4),\n            triton.Config({'BLOCK_SIZE': 1024}, num_warps=4),\n            triton.Config({'BLOCK_SIZE': 256}, num_warps=8),\n            triton.Config({'BLOCK_SIZE': 512}, num_warps=8),\n            triton.Config({'BLOCK_SIZE': 1024}, num_warps=8),\n        ],\n        key=['n_elements'],\n    )\n    @triton.jit\n    def relu6_kernel(\n        x_ptr,\n        output_ptr,\n        n_elements,\n        BLOCK_SIZE: tl.constexpr,\n    ):\n        pid = tl.program_id(axis=0)\n        block_start = pid * BLOCK_SIZE\n        offsets = block_start + tl.arange(0, BLOCK_SIZE)\n        mask = offsets < n_elements\n        x = tl.load(x_ptr + offsets, mask=mask)\n        x = tl.maximum(x, 0.0)\n        x = tl.minimum(x, 6.0)\n        tl.store(output_ptr + offsets, x, mask=mask)\n\nAnd in the forward function of ReLU6Triton:\n\n        relu6_kernel[grid](x, output, n_elements)\n\nBut note: what if the input is not float32? The model uses float32, so it's safe. But the kernel uses 0.0 and 6.0. They will be converted to the dtype of x. Since the model uses float32, it's safe.\n\nWe are not changing the rest of the model.\n\nLet me write the entire code block with the changes.\n\nWe must be cautious: the rest of the model is locked. We are only changing the ReLU6Triton kernel and its call.\n\nWe are also removing the BLOCK_SIZE argument from the call.\n\nWe are adding the autotune decorator.\n\nWe are changing the kernel body.\n\nWe are leaving the rest of the model (the ModelNew class) unchanged.\n\nLet's write it.\n</think>\n```python\n# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport triton\nimport triton.language as tl\n\n@triton.autotune(\n    configs=[\n        triton.Config({'BLOCK_SIZE': 256}, num_warps=1),\n        triton.Config({'BLOCK_SIZE': 512}, num_warps=1),\n        triton.Config({'BLOCK_SIZE': 1024}, num_warps=1),\n        triton.Config({'BLOCK_SIZE': 256}, num_warps=2),\n        triton.Config({'BLOCK_SIZE': 512}, num_warps=2),\n        triton.Config({'BLOCK_SIZE': 1024}, num_warps=2),\n        triton.Config({'BLOCK_SIZE': 256}, num_warps=4),\n        triton.Config({'BLOCK_SIZE': 512}, num_warps=4),\n        triton.Config({'BLOCK_SIZE': 1024}, num_warps=4),\n        triton.Config({'BLOCK_SIZE': 256}, num_warps=8),\n        triton.Config({'BLOCK_SIZE': 512}, num_warps=8),\n        triton.Config({'BLOCK_SIZE': 1024}, num_warps=8),\n    ],\n    key=['n_elements'],\n)\n@triton.jit\ndef relu6_kernel(\n    x_ptr,\n    output_ptr,\n    n_elements,\n    BLOCK_SIZE: tl.constexpr,\n):\n    pid = tl.program_id(axis=0)\n    block_start = pid * BLOCK_SIZE\n    offsets = block_start + tl.arange(0, BLOCK_SIZE)\n    mask = offsets < n_elements\n    x = tl.load(x_ptr + offsets, mask=mask)\n    x = tl.maximum(x, 0.0)\n    x = tl.minimum(x, 6.0)\n    tl.store(output_ptr + offsets, x, mask=mask)\n\nclass ReLU6Triton(nn.Module):\n    def __init__(self):\n        super(ReLU6Triton, self).__init__()\n    \n    def forward(self, x):\n        output = torch.empty_like(x)\n        n_elements = output.numel()\n        grid = lambda meta: (triton.cdiv(n_elements, meta['BLOCK_SIZE']),)\n        relu6_kernel[grid](x, output, n_elements)\n        return output\n\nclass ModelNew(nn.Module):\n    def __init__(self, num_classes=1000):\n        super(ModelNew, self).__init__()\n        self.conv1 = nn.Conv2d(3, 32, kernel_size=3, stride=2, padding=1, bias=False)\n        self.bn1 = nn.BatchNorm2d(32)\n        self.mbconv1 = self._make_mbconv_block(32, 16, 1, 1)\n        self.mbconv2 = self._make_mbconv_block(16, 24, 2, 6)\n        self.mbconv3 = self._make_mbconv_block(24, 40, 2, 6)\n        self.mbconv4 = self._make_mbconv_block(40, 80, 2, 6)\n        self.mbconv5 = self._make_mbconv_block(80, 112, 1, 6)\n        self.mbconv6 = self._make_mbconv_block(112, 192, 2, 6)\n        self.mbconv7 = self._make_mbconv_block(192, 320, 1, 6)\n        self.conv2 = nn.Conv2d(320, 1280, kernel_size=1, stride=1, padding=0, bias=False)\n        self.bn2 = nn.BatchNorm2d(1280)\n        self.fc = nn.Linear(1280, num_classes)\n    \n    def _make_mbconv_block(self, in_channels, out_channels, stride, expand_ratio):\n        hidden_dim = round(in_channels * expand_ratio)\n        return nn.Sequential(\n            nn.Conv2d(in_channels, hidden_dim, kernel_size=1, stride=1, padding=0, bias=False),\n            nn.BatchNorm2d(hidden_dim),\n            ReLU6Triton(),\n            nn.Conv2d(hidden_dim, hidden_dim, kernel_size=3, stride=stride, padding=1, groups=hidden_dim, bias=False),\n            nn.BatchNorm2d(hidden_dim),\n            ReLU6Triton(),\n            nn.Conv2d(hidden_dim, out_channels, kernel_size=1, stride=1, padding=0, bias=False),\n            nn.BatchNorm2d(out_channels),\n        )\n    \n    def forward(self, x):\n        x = F.relu(self.bn1(self.conv1(x)))\n        x = self.mbconv1(x)\n        x = self.mbconv2(x)\n        x = self.mbconv3(x)\n        x = self.mbconv4(x)\n        x = self.mbconv5(x)\n        x = self.mbconv6(x)\n        x = self.mbconv7(x)\n        x = F.relu(self.bn2(self.conv2(x)))\n        x = F.adaptive_avg_pool2d(x, (1, 1))\n        x = torch.flatten(x, 1)\n        x = self.fc(x)\n        return x\n\nbatch_size = 10\ninput_shape = (3, 240, 240)\nnum_classes = 1000\n\ndef get_inputs():\n    return [torch.randn(batch_size, *input_shape)]\n\ndef get_init_inputs():\n    return [num_classes]\n# =================== EVOLVE-BLOCK-END ===================\n```"]}}}