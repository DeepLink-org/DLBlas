{"id": "0690c9d4-24ef-4de1-8570-e0449d882c17", "code": "# ================== EVOLVE-BLOCK-START ==================\nimport torch\nimport torch.nn as nn\nimport triton\nimport triton.language as tl\nimport math\n\nclass ModelNew(nn.Module):\n    def __init__(self, in_channels: int, out_channels: int, kernel_size: int, \n                 stride: int = 1, padding: int = 0, dilation: int = 1, \n                 groups: int = 1, bias: bool = False):\n        super().__init__()\n        self.in_channels = in_channels\n        self.out_channels = out_channels\n        self.kernel_size = kernel_size\n        self.stride = stride\n        self.padding = padding\n        self.dilation = dilation\n        self.groups = groups\n        \n        self.weight = nn.Parameter(\n            torch.empty(out_channels, in_channels, kernel_size, kernel_size)\n        )\n        if bias:\n            self.bias = nn.Parameter(torch.empty(out_channels))\n        else:\n            self.bias = None\n            \n        # Initialize parameters\n        nn.init.kaiming_uniform_(self.weight, a=math.sqrt(5))\n        if self.bias is not None:\n            fan_in, _ = nn.init._calculate_fan_in_and_fan_out(self.weight)\n            bound = 1 / math.sqrt(fan_in) if fan_in > 0 else 0\n            nn.init.uniform_(self.bias, -bound, bound)\n\n    @staticmethod\n    @triton.autotune(\n        configs=[\n            triton.Config({'BLOCK_C': 32}, num_warps=4),\n            triton.Config({'BLOCK_C': 64}, num_warps=4),\n            triton.Config({'BLOCK_C': 128}, num_warps=4),\n            triton.Config({'BLOCK_C': 32}, num_warps=8),\n            triton.Config({'BLOCK_C': 64}, num_warps=8),\n            triton.Config({'BLOCK_C': 128}, num_warps=8),\n        ],\n        key=['C_in', 'H_out', 'W_out', 'kernel_size'],\n    )\n    @triton.jit\n    def _conv_forward_kernel(\n        # Tensors\n        x_ptr, weight_ptr, output_ptr,\n        # Input dimensions\n        B, C_in, H, W,\n        # Output dimensions\n        C_out, kernel_size, H_out, W_out,\n        # Strides\n        stride_xb, stride_xc, stride_xh, stride_xw,\n        stride_woc, stride_wic, stride_wh, stride_ww,\n        stride_ob, stride_oc, stride_oh, stride_ow,\n        # Convolution parameters\n        stride_h: tl.constexpr, stride_w: tl.constexpr,\n        padding_h: tl.constexpr, padding_w: tl.constexpr,\n        dilation_h: tl.constexpr, dilation_w: tl.constexpr,\n        # Blocking\n        BLOCK_C: tl.constexpr,\n    ):\n        # Program IDs\n        pid_b = tl.program_id(0)\n        pid_oc = tl.program_id(1)\n        pid_oh_ow = tl.program_id(2)\n        \n        oh = pid_oh_ow // W_out\n        ow = pid_oh_ow % W_out\n        \n        # Initialize accumulator\n        acc = 0.0\n        \n        # Loop over input channels in blocks\n        for ic0 in range(0, C_in, BLOCK_C):\n            ic_offsets = ic0 + tl.arange(0, BLOCK_C)\n            c_mask = ic_offsets < C_in\n            \n            # Loop over kernel positions\n            for kh in range(kernel_size):\n                for kw in range(kernel_size):\n                    # Calculate input position with dilation\n                    h_in = oh * stride_h - padding_h + kh * dilation_h\n                    w_in = ow * stride_w - padding_w + kw * dilation_w\n                    \n                    # Check input boundaries\n                    in_bounds = (h_in >= 0) & (h_in < H) & (w_in >= 0) & (w_in < W)\n                    \n                    # Load input block\n                    x_ptrs = (\n                        x_ptr + \n                        pid_b * stride_xb + \n                        ic_offsets * stride_xc + \n                        h_in * stride_xh + \n                        w_in * stride_xw\n                    )\n                    x_vals = tl.load(x_ptrs, mask=c_mask & in_bounds, other=0.0)\n                    \n                    # Load weight block\n                    w_ptrs = (\n                        weight_ptr + \n                        pid_oc * stride_woc + \n                        ic_offsets * stride_wic + \n                        kh * stride_wh + \n                        kw * stride_ww\n                    )\n                    w_vals = tl.load(w_ptrs, mask=c_mask, other=0.0)\n                    \n                    # Update accumulator\n                    acc += tl.sum(x_vals * w_vals)\n        \n        # Output pointer\n        out_ptr = (\n            output_ptr + \n            pid_b * stride_ob + \n            pid_oc * stride_oc + \n            oh * stride_oh + \n            ow * stride_ow\n        )\n        tl.store(out_ptr, acc)\n\n    def forward(self, x: torch.Tensor) -> torch.Tensor:\n        if self.groups != 1:\n            return nn.functional.conv2d(\n                x, self.weight, self.bias, self.stride, \n                self.padding, self.dilation, self.groups\n            )\n            \n        # Calculate output dimensions\n        B, C_in, H, W = x.shape\n        H_out = (H + 2 * self.padding - self.dilation * (self.kernel_size - 1) - 1\n                ) // self.stride + 1\n        W_out = (W + 2 * self.padding - self.dilation * (self.kernel_size - 1) - 1\n                ) // self.stride + 1\n        \n        # Prepare output\n        output = torch.empty(\n            (B, self.out_channels, H_out, W_out),\n            device=x.device, dtype=x.dtype\n        )\n        \n        # Launch kernel\n        grid = (B, self.out_channels, H_out * W_out)\n        self._conv_forward_kernel[grid](\n            x, self.weight, output,\n            B, C_in, H, W,\n            self.out_channels, self.kernel_size, H_out, W_out,\n            x.stride(0), x.stride(1), x.stride(2), x.stride(3),\n            self.weight.stride(0), self.weight.stride(1), \n            self.weight.stride(2), self.weight.stride(3),\n            output.stride(0), output.stride(1), \n            output.stride(2), output.stride(3),\n            self.stride, self.stride,\n            self.padding, self.padding,\n            self.dilation, self.dilation\n        )\n        \n        # Add bias if needed\n        if self.bias is not None:\n            output += self.bias.view(1, -1, 1, 1)\n            \n        return output\n\n# Test code\nbatch_size = 16\nin_channels = 3\nout_channels = 64\nkernel_size = 3\nwidth = 256\nheight = 128  # Asymmetric input\n\ndef get_inputs():\n    x = torch.randn(batch_size, in_channels, height, width)\n    return [x]\n\ndef get_init_inputs():\n    return [in_channels, out_channels, kernel_size]  # Provide in_channels, out_channels, kernel_size for initialization\n# =================== EVOLVE-BLOCK-END ===================", "language": "python", "parent_id": "afd63324-0d98-4f74-9a73-bdde40269d86", "generation": 2, "timestamp": 1754643680.9684231, "iteration_found": 25, "metrics": {"compiled": true, "correctness": true, "stage": "success", "passed": false, "score": 20, "speed_up": 0.001, "runtime_ms": 69.2, "meta": {"hardware": "NVIDIA L20Y", "device": "cuda:4", "correctness_trials": "(5 / 5)", "reference_timing_ms": 0.0354, "speed_up": 0.001, "custom_timing": 69.2}}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"compiled": true, "correctness": false, "score": 10, "stage": "wrong_answer", "verify_payload": {"id": "level1_55_conv_standard_2D__asymmetric_input__square_kernel", "result": {"compiled": true, "correctness": false, "metadata": {"hardware": "NVIDIA L20Y", "device": "cuda:5", "max_difference": ["34.754131", "32.355442", "35.493660", "37.068928", "35.211811"], "avg_difference": ["4.098666", "4.103528", "4.099865", "4.097117", "4.099372"], "correctness_issue": "Output mismatch", "correctness_trials": "(0 / 5)", "reference_timing_ms": 0.0354, "speed_up": -1.0, "custom_timing": -1.0}, "runtime": -1.0, "runtime_stats": {}}}}, "island": 1}, "artifacts_json": null, "artifact_dir": null}