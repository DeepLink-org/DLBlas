import torch
import torch.nn as nn
import triton
import triton.language as tl

@triton.jit
def _avg_pool1d_kernel(
    x_ptr,
    out_ptr,
    input_length,
    output_length,
    in_channels,
    stride: tl.constexpr,
    padding: tl.constexpr,
    kernel_size: tl.constexpr,
    BLOCK_SIZE_OUT: tl.constexpr
):
    pid_bc = tl.program_id(0)
    pid_out_block = tl.program_id(1)
    
    batch_idx = pid_bc // in_channels
    channel_idx = pid_bc % in_channels
    
    x_channel_ptr = x_ptr + batch_idx * in_channels * input_length + channel_idx * input_length
    out_channel_ptr = out_ptr + batch_idx * in_channels * output_length + channel_idx * output_length
    
    out_start_idx = pid_out_block * BLOCK_SIZE_OUT
    out_end_idx = min(out_start_idx + BLOCK_SIZE_OUT, output_length)
    
    for out_idx in range(out_start_idx, out_end_idx):
        start_idx = out_idx * stride - padding
        total = 0.0
        
        for j in range(0, kernel_size):
            idx = start_idx + j
            if idx >= 0 and idx < input_length:
                value = tl.load(x_channel_ptr + idx)
            else:
                value = 0.0
            total += value
        
        average = total / kernel_size
        tl.store(out_channel_ptr + out_idx, average)

def avg_pool1d_triton(x, kernel_size, stride, padding):
    batch_size, in_channels, input_length = x.shape
    output_length = (input_length + 2 * padding - kernel_size) // stride + 1
    output = torch.empty((batch_size, in_channels, output_length), device=x.device, dtype=x.dtype)
    
    if output.numel() == 0:
        return output
        
    grid_bc = batch_size * in_channels
    BLOCK_SIZE_OUT = 128
    grid_out_blocks = (output_length + BLOCK_SIZE_OUT - 1) // BLOCK_SIZE_OUT
    
    _avg_pool1d_kernel[(grid_bc, grid_out_blocks)](
        x, output,
        input_length, output_length,
        in_channels,
        stride=stride,
        padding=padding,
        kernel_size=kernel_size,
        BLOCK_SIZE_OUT=BLOCK_SIZE_OUT
    )
    return output

class ModelNew(nn.Module):
    def __init__(self, kernel_size: int, stride: int = 1, padding: int = 0):
        super(ModelNew, self).__init__()
        self.kernel_size = kernel_size
        self.stride = stride
        self.padding = padding

    def forward(self, x: torch.Tensor) -> torch.Tensor:
        return avg_pool1d_triton(x, self.kernel_size, self.stride, self.padding)

batch_size = 16
in_channels = 32
input_length = 128
kernel_size = 4
stride = 2
padding = 1

def get_inputs():
    x = torch.randn(batch_size, in_channels, input_length)
    return [x]

def get_init_inputs():
    return [kernel_size, stride, padding]
